<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>King哥</title>
  <subtitle>To know everything, no words don&#39;t talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kingge.top/"/>
  <updated>2017-08-16T02:35:53.838Z</updated>
  <id>http://kingge.top/</id>
  
  <author>
    <name>Jeremy Kinge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客迁移</title>
    <link href="http://kingge.top/2019/06/01/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    <id>http://kingge.top/2019/06/01/博客迁移/</id>
    <published>2019-06-01T04:58:04.666Z</published>
    <updated>2017-08-16T02:35:53.838Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天周一，天气炎热，调开空调。噼里啪啦的敲完今天的工作，因为今天本人决定再次迁移自己的PersonalBlog。个人一共换过很多个博客，前期使用过网易博客，后来访问量上不去(网易博客他并不是一个IT社区)，后来换到了博客园，感觉还行，但是好景不长，感觉本人有处女座的完美主义，很纠结，总感觉这个博客园UI设计不行。<br>      最后又换到了CSDN，今天又临时决定迁移到了本人的服务器上面，自由管理。<br>      我的性格知道的人应该知道，我是知无不言言无不尽，只要我会的有所感悟的都会分享出来。以后每天心情一更，工作方面一周一更。</p>
</blockquote>
<hr>
<blockquote>
<p>最后：人生需要面对,搞笑我是认真的。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天周一，天气炎热，调开空调。噼里啪啦的敲完今天的工作，因为今天本人决定再次迁移自己的PersonalBlog。个人一共换过很多个博客，前期使用过网易博客，后来访问量上不去(网易博客他并不是一个IT社区)，后来换到了博客园，感觉还行，但是好景不长，
    
    </summary>
    
      <category term="心情" scheme="http://kingge.top/categories/%E5%BF%83%E6%83%85/"/>
    
    
  </entry>
  
  <entry>
    <title>Hessian 多系统访问</title>
    <link href="http://kingge.top/2019/06/01/Hessian%20%E5%A4%9A%E7%B3%BB%E7%BB%9F%E8%AE%BF%E9%97%AE/"/>
    <id>http://kingge.top/2019/06/01/Hessian 多系统访问/</id>
    <published>2019-06-01T04:58:04.630Z</published>
    <updated>2017-08-31T09:44:24.038Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊分布式事务，再说说解决方案-cap</title>
    <link href="http://kingge.top/2017/10/18/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%86%8D%E8%AF%B4%E8%AF%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-cap/"/>
    <id>http://kingge.top/2017/10/18/聊聊分布式事务，再说说解决方案-cap/</id>
    <published>2017-10-18T09:57:58.000Z</published>
    <updated>2017-10-18T10:00:42.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><blockquote>
<p>在说分布式事务之前，我们先从数据库事务说起。 数据库事务可能大家都很熟悉，在开发过程中也会经常使用到。但是即使如此，可能对于一些细节问题，很多人仍然不清楚。比如很多人都知道数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation)和持久性(Durabilily)，简称就是ACID。但是再往下比如问到隔离性指的是什么的时候可能就不知道了，或者是知道隔离性是什么但是再问到数据库实现隔离的都有哪些级别，或者是每个级别他们有什么区别的时候可能就不知道了。</p>
</blockquote>
<p>本文并不打算介绍这些数据库事务的这些东西，有兴趣可以搜索一下相关资料。不过有一个知识点我们需要了解，就是假如数据库在提交事务的时候突然断电，那么它是怎么样恢复的呢？ 为什么要提到这个知识点呢？ 因为分布式系统的核心就是处理各种异常情况，这也是分布式系统复杂的地方，因为分布式的网络环境很复杂，这种“断电”故障要比单机多很多，所以我们在做分布式系统的时候，最先考虑的就是这种情况。这些异常可能有 机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的TCP、存储数据丢失、其他异常等等…</p>
<p>我们接着说本地事务数据库断电的这种情况，它是怎么保证数据一致性的呢？我们使用SQL Server来举例，我们知道我们在使用 SQL Server 数据库是由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。</p>
<p>接着，我们就说一下分布式事务。</p>
<h1 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h1><blockquote>
<p>当我们的单个数据库的性能产生瓶颈的时候，我们可能会对数据库进行分区，这里所说的分区指的是物理分区，分区之后可能不同的库就处于不同的服务器上了，这个时候单个数据库的ACID已经不能适应这种情况了，而在这种ACID的集群环境下，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，最为关键的是再很难扩展新的分区了，这个时候如果再追求集群的ACID会导致我们的系统变得很差，这时我们就需要引入一个新的理论原则来适应这种集群的情况，就是 CAP 原则或者叫CAP定理，那么CAP定理指的是什么呢？</p>
<p>CAP定理</p>
<blockquote>
<p>CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性：</p>
</blockquote>
</blockquote>
<ul>
<li>一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)</li>
<li>可用性(Availability) ： 每个操作都必须以可预期的响应结束</li>
<li>分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成</li>
<li>具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。</li>
</ul>
<blockquote>
<p>这个定理在迄今为止的分布式系统中都是适用的！ 为什么这么说呢？</p>
</blockquote>
<p>转载链接描述的很到位：<a href="http://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="external">http://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库事务&quot;&gt;&lt;a href=&quot;#数据库事务&quot; class=&quot;headerlink&quot; title=&quot;数据库事务&quot;&gt;&lt;/a&gt;数据库事务&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在说分布式事务之前，我们先从数据库事务说起。 数据库事务可能大家都很熟悉，在开发过程中也会
    
    </summary>
    
      <category term="分布式" scheme="http://kingge.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://kingge.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://kingge.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库中的undo和redo日志</title>
    <link href="http://kingge.top/2017/10/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84undo%E5%92%8Credo%E6%97%A5%E5%BF%97/"/>
    <id>http://kingge.top/2017/10/18/数据库中的undo和redo日志/</id>
    <published>2017-10-18T09:52:46.000Z</published>
    <updated>2017-10-18T09:55:01.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载好的博客解释1： <a href="http://blog.csdn.net/kobejayandy/article/details/50885693" target="_blank" rel="external">http://blog.csdn.net/kobejayandy/article/details/50885693</a> </p>
<p>转载好的博客解释2： <a href="http://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html" target="_blank" rel="external">http://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载好的博客解释1： &lt;a href=&quot;http://blog.csdn.net/kobejayandy/article/details/50885693&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.cs
    
    </summary>
    
      <category term="Mysql" scheme="http://kingge.top/categories/Mysql/"/>
    
    
      <category term="分布式" scheme="http://kingge.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://kingge.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>vSphere与Workstation虚拟机交互的几种方法</title>
    <link href="http://kingge.top/2017/10/18/vSphere%E4%B8%8EWorkstation%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://kingge.top/2017/10/18/vSphere与Workstation虚拟机交互的几种方法/</id>
    <published>2017-10-18T08:11:28.000Z</published>
    <updated>2017-10-18T08:14:18.402Z</updated>
    
    <content type="html"><![CDATA[<p>参见转载链接：  <a href="http://wangchunhai.blog.51cto.com/225186/1884052" target="_blank" rel="external">http://wangchunhai.blog.51cto.com/225186/1884052</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参见转载链接：  &lt;a href=&quot;http://wangchunhai.blog.51cto.com/225186/1884052&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wangchunhai.blog.51cto.com/2251
    
    </summary>
    
      <category term="Linux" scheme="http://kingge.top/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://kingge.top/tags/linux/"/>
    
      <category term="centos" scheme="http://kingge.top/tags/centos/"/>
    
      <category term="vmware" scheme="http://kingge.top/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>查看虚拟机里的Centos7的IP</title>
    <link href="http://kingge.top/2017/10/18/%E6%9F%A5%E7%9C%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%87%8C%E7%9A%84Centos7%E7%9A%84IP/"/>
    <id>http://kingge.top/2017/10/18/查看虚拟机里的Centos7的IP/</id>
    <published>2017-10-18T07:48:43.000Z</published>
    <updated>2017-10-18T08:09:04.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="登录虚拟机"><a href="#登录虚拟机" class="headerlink" title="登录虚拟机"></a>登录虚拟机</h1><p>   输入用户名和密码（用户名一般是root）</p>
<h1 id="查看ip-指令"><a href="#查看ip-指令" class="headerlink" title="查看ip 指令"></a>查看ip 指令</h1><blockquote>
<p>ip addr 指令：  查看当前虚拟机ip </p>
</blockquote>
<p><img src="/2017/10/18/查看虚拟机里的Centos7的IP/TIM截图20171018155302.png" alt=""></p>
<p>我们发现ens32 没有 inet 这个属性，没有出现ip，那么说明在设置的时候没有开启，需要先去设置。</p>
<blockquote>
<p>当前位置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[root@localhost ~]# pwd</div><div class="line">/root</div><div class="line">[root@localhost ~]#</div></pre></td></tr></table></figure></p>
<p>接着来查看ens32网卡的配置： vi /etc/sysconfig/network-scripts/ifcfg-ens32   注意vi后面加空格.  etc 文件夹的位置在于</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[root@localhost ~]# cd ..</div><div class="line">[root@localhost /]# ls</div><div class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</div><div class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</div></pre></td></tr></table></figure>
<blockquote>
<p>查看 ifcfg-ens32 的内容</p>
</blockquote>
<p><img src="/2017/10/18/查看虚拟机里的Centos7的IP/TIM截图20171018160037.png" alt=""></p>
<blockquote>
<p>从配置清单中可以发现 CentOS 7 默认是不启动网卡的（ONBOOT=no）。</p>
<blockquote>
<p>把这一项改为YES（ONBOOT=yes） – (按 i 进入编辑模式 ，修改完，按 esc退出编辑模式，然后 按 ctrl + shift + :  输入 wq 完成编辑)</p>
</blockquote>
<p>然后重启网络服务： sudo service network restart </p>
<p>然后我们再输入  ip addr 命令</p>
</blockquote>
<hr>
<p><img src="/2017/10/18/查看虚拟机里的Centos7的IP/TIM截图20171018160445.png" alt=""></p>
<hr>
<h1 id="使用第三方工具登录"><a href="#使用第三方工具登录" class="headerlink" title="使用第三方工具登录"></a>使用第三方工具登录</h1><blockquote>
<p>这里是用的是 xshell，你也可以用winscp（这个一般是用来传文件的）</p>
</blockquote>
<p><img src="/2017/10/18/查看虚拟机里的Centos7的IP/TIM截图20171018160611.png" alt=""></p>
<p>然后点击连接，输入用户名和密码，便可以进入命令界面</p>
<p><img src="/2017/10/18/查看虚拟机里的Centos7的IP/TIM截图20171018160844.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;登录虚拟机&quot;&gt;&lt;a href=&quot;#登录虚拟机&quot; class=&quot;headerlink&quot; title=&quot;登录虚拟机&quot;&gt;&lt;/a&gt;登录虚拟机&lt;/h1&gt;&lt;p&gt;   输入用户名和密码（用户名一般是root）&lt;/p&gt;
&lt;h1 id=&quot;查看ip-指令&quot;&gt;&lt;a href=&quot;#查看i
    
    </summary>
    
      <category term="Linux" scheme="http://kingge.top/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://kingge.top/tags/linux/"/>
    
      <category term="centos" scheme="http://kingge.top/tags/centos/"/>
    
      <category term="vmware" scheme="http://kingge.top/tags/vmware/"/>
    
  </entry>
  
  <entry>
    <title>activity工作流框架——数据库表结构说明</title>
    <link href="http://kingge.top/2017/10/12/activity%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E/"/>
    <id>http://kingge.top/2017/10/12/activity工作流框架——数据库表结构说明/</id>
    <published>2017-10-12T06:54:33.000Z</published>
    <updated>2017-10-12T07:08:08.890Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载于： <a href="http://www.jianshu.com/p/f9fd1cc02eae" target="_blank" rel="external">http://www.jianshu.com/p/f9fd1cc02eae</a></p>
<hr>
<p>activity一共23张表</p>
<p>   <img src="/2017/10/12/activity工作流框架——数据库表结构说明/4045508-3aa1b40649eeda13.png" alt="activity23张表" title="activity23张表"></p>
<hr>
<blockquote>
<p>表的命名第一部分都是以 ACT_开头的。</p>
<p>表的命名第二部分是一个两个字符用例表的标识</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">act_ge_*：</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>‘ge’代表general（一般）。普通数据，各种情况都使用的数据。</p>
</blockquote>
<ul>
<li><p>act_ge<em>bytearray：二进制数据表，用来保存部署文件的大文本数据<br>1.ID</em>:资源文件编号，自增长<br>2.REV<em>INT:版本号<br>3.NAME</em>:资源文件名称<br>4.DEPLOYMENT<em>ID</em>:来自于父表act_re<em>deployment的主键<br>5.BYTES</em>:大文本类型，存储文本字节流</p>
</li>
<li><p>act_ge<em>property：属性数据表，存储这整个流程引擎级别的数据。在初始化表结构时，会默认插入三条记录。<br>1.NAME</em>:属性名称<br>2.VALUE_:属性值<br>3.REV_INT:版本号</p>
</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">act_hi_*：</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>hi’代表 history（历史）。就是这些表包含着历史的相关数据，如结束的流程实例、变量、任务、等等。</p>
</blockquote>
<ul>
<li><p>act_hi<em>actinst：历史节点表<br>1.ID</em> : 标识<br>2.PROC_DEF<em>ID</em> :流程定义id<br>3.PROC_INST<em>ID</em> : 流程实例id<br>4.EXECUTION<em>ID</em> : 执行实例<br>5.ACT<em>ID</em> : 节点id<br>6.ACT<em>NAME</em> : 节点名称<br>7.ACT<em>TYPE</em> : 节点类型<br>8.ASSIGNEE_ : 节点任务分配人<br>9.START<em>TIME</em> : 开始时间<br>10.END<em>TIME</em> : 结束时间<br>11.DURATION : 经过时长</p>
</li>
<li><p>act_hi_attachment：历史附件表</p>
</li>
<li><p>act_hi<em>comment：历史意见表<br>1.ID</em> :标识<br>2.TYPE<em> : 意见记录类型 为comment 时 为处理意见<br>3.TIME</em> : 记录时间<br>4.USER<em>ID</em> :<br>5.TASK<em>ID</em> ： 对应任务的id<br>6.PROC_INST<em>ID</em> : 对应的流程实例的id<br>7.ACTION<em> ： 为AddComment 时为处理意见<br>8.MESSAGE</em> : 处理意见<br>9.FULL<em>MSG</em> :</p>
</li>
<li><p>act_hi<em>detail：历史详情表，启动流程或者在任务complete之后,记录历史流程变量<br>1.ID</em> : 标识<br>2.TYPE_ : variableUpdate 和 formProperty 两种值<br>3.PROC_INST<em>ID</em> : 对应流程实例id<br>4.EXECUTION<em>ID</em> : 对应执行实例id<br>5.TASK<em>ID</em> : 对应任务id<br>6.ACT_INST<em>ID : 对应节点id<br>7.NAME</em> : 历史流程变量名称，或者表单属性的名称<br>8.VAR<em>TYPE</em> : 定义类型<br>9.REV<em> : 版本<br>10.TIME</em> : 导入时间<br>11.BYTEARRAY<em>ID</em><br>12.DOUBLE<em> : 如果定义的变量或者表单属性的类型为double，他的值存在这里<br>13.LONG</em> : 如果定义的变量或者表单属性的类型为LONG ,他的值存在这里<br>14.TEXT<em> :　　如果定义的变量或者表单属性的类型为string，值存在这里<br>15.TEXT2</em>:</p>
</li>
<li><p>act_hi_identitylink：历史流程人员表</p>
</li>
<li><p>act_hi<em>procinst： 历史流程实例表<br>1.ID</em> : 唯一标识<br>2.PROC_INST<em>ID</em> : 流程ＩＤ<br>3.BUSINESS<em>KEY</em> : 业务编号<br>4.PROC_DEF<em>ID</em> ： 流程定义id<br>5.START<em>TIME</em> : 流程开始时间<br>6.ENT_<em>TIME : 结束时间<br>7.DURATION</em> : 流程经过时间<br>8.START_USER<em>ID</em> : 开启流程用户id<br>9.START_ACT<em>ID</em> : 开始节点<br>10.END_ACT<em>ID</em>： 结束节点<br>11.SUPER_PROCESS_INSTANCE<em>ID</em> : 父流程流程id<br>12.DELETE<em>REASON</em> : 从运行中任务表中删除原因</p>
</li>
<li><p>act_hi<em>taskinst： 历史任务实例表<br>1.ID</em> ： 标识<br>2.PROC_DEF<em>ID</em> ： 流程定义id<br>3.TASK_DEF<em>KEY</em> : 任务定义id<br>4.PROC_INST<em>ID</em> :　流程实例ｉｄ<br>5.EXECUTION<em>ID</em> : 执行实例id<br>6.PARENT_TASK<em>ID</em> : 父任务id<br>7.NAME<em> : 任务名称<br>8.DESCRIPTION</em> : 说明<br>9.OWNER<em> :　拥有人（发起人）<br>10.ASSIGNEE</em> : 分配到任务的人<br>11.START_<em>TIME</em> : 开始任务时间<br>12.END<em>TIME</em> : 结束任务时间<br>13.DURATION_ : 时长<br>14.DELETE<em>REASON</em> :从运行时任务表中删除的原因<br>15.PRIORITY_ : 紧急程度<br>16.DUE<em>DATE</em> :</p>
</li>
<li><p>act_hi_varinst：历史变量表</p>
</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">act_id_*：</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>id’代表 identity（身份）。这些表包含着标识的信息，如用户、用户组、等等。</p>
</blockquote>
<ul>
<li><p>act_id<em>group:用户组信息表，用来存储用户组信息。<br>1.ID</em>：用户组名<br>2.REV<em>INT:版本号<br>3.NAME</em>:用户组描述信息<br>4.TYPE_:用户组类型</p>
</li>
<li><p>act_id_info：用户扩展信息表</p>
</li>
<li><p>act_id_membership：用户与用户组对应信息表，用来保存用户的分组信息<br>1.USER<em>ID</em>:用户名<br>2.GROUP<em>ID</em>:用户组名</p>
</li>
<li><p>act_id<em>user：用户信息表<br>1.ID</em>:用户名<br>2.REV<em>INT:版本号<br>3.FIRST</em>:用户名称<br>4.LAST<em>:用户姓氏<br>5.EMAIL</em>:邮箱<br>6.PWD_:密码</p>
</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">act_re_*：</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>’re’代表 repository（仓库）。带此前缀的表包含的是静态信息，如，流程定义、流程的资源（图片、规则，等）。</p>
</blockquote>
<ul>
<li><p>act_re<em>deployment:部署信息表,用来存储部署时需要持久化保存下来的信息<br>1.ID</em>:部署编号，自增长<br>2.NAME_:部署包的名称<br>3.DEPLOY<em>TIME</em>:部署时间</p>
</li>
<li><p>act_re_model 流程设计模型部署表</p>
</li>
<li><p>act_re<em>procdef:业务流程定义数据表<br>1.ID</em>:流程ID，由“流程编号：流程版本号：自增长ID”组成<br>2.CATEGORY<em>:流程命名空间（该编号就是流程文件targetNamespace的属性值）<br>3.NAME</em>:流程名称（该编号就是流程文件process元素的name属性值）<br>4.KEY<em>:流程编号（该编号就是流程文件process元素的id属性值）<br>5.VERSION</em>:流程版本号（由程序控制，新增即为1，修改后依次加1来完成的）<br>6.DEPLOYMENT<em>ID</em>:部署编号<br>7.RESOURCE<em>NAME</em>:资源文件名称<br>8.DGRM_RESOURCE<em>NAME</em>:图片资源文件名称<br>9.HAS_START_FROM<em>KEY</em>:是否有Start From Key</p>
<blockquote>
<blockquote>
<p>注：此表和ACT_RE_DEPLOYMENT是多对一的关系，即，一个部署的bar包里可能包含多个流程定义文件，每个流程定义文件都会有一条记录在ACT_REPROCDEF表内，每个流程定义的数据，都会对于ACT_GE_BYTEARRAY表内的一个资源文件和PNG图片文件。和ACT_GE_BYTEARRAY的关联是通过程序用ACT_GE_BYTEARRAY.NAME与ACT_RE<em>PROCDEF.NAME</em>完成的，在数据库表结构中没有体现。</p>
</blockquote>
</blockquote>
</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">act_ru_*：</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>’ru’代表 runtime（运行时）。就是这个运行时的表存储着流程变量、用户任务、变量、作业，等中的运行时的数据。 activiti 只存储流程实例执行期间的运行时数据，当流程实例结束时，将删除这些记录。这就使这些运行时的表保持 的小且快。</p>
</blockquote>
<ul>
<li><p>act_ru_event_subscr</p>
</li>
<li><p>act_ru<em>execution：运行时流程执行实例表<br>1.ID</em>：主键，这个主键有可能和PROC_INST<em>ID</em>相同，相同的情况表示这条记录为主实例记录。<br>2.REV_：版本，表示数据库表更新次数。<br>3.PROC_INST<em>ID</em>：流程实例编号，一个流程实例不管有多少条分支实例，这个ID都是一致的。<br>4.BUSINESS<em>KEY</em>：业务编号，业务主键，主流程才会使用业务主键，另外这个业务主键字段在表中有唯一约束。<br>5.PARENT<em>ID</em>：找到该执行实例的父级，最终会找到整个流程的执行实例<br>6.PROC_DEF<em>ID</em>：流程定义ID<br>7.SUPER<em>EXEC</em>： 引用的执行模板，这个如果存在表示这个实例记录为一个外部子流程记录，对应主流程的主键ID。<br>8.ACT<em>ID</em>： 节点id，表示流程运行到哪个节点<br>9.IS<em>ACTIVE</em>： 是否活动流程实例<br>10.IS<em>CONCURRENT</em>：是否并发。上图同步节点后为并发，如果是并发多实例也是为1。<br>11.IS<em>SCOPE</em>： 主实例为1，子实例为0。<br>12.TENANT<em>ID</em> : 这个字段表示租户ID。可以应对多租户的设计。<br>13.IS_EVENT_SCOPE: 没有使用到事件的情况下，一般都为0。<br>14.SUSPENSION<em>STATE</em>：是否暂停。</p>
</li>
<li><p>act_ru<em>identitylink：运行时流程人员表，主要存储任务节点与参与者的相关信息<br>1.ID</em>： 标识<br>2.REV_： 版本<br>3.GROUP<em>ID</em>： 组织id<br>4.TYPE_： 类型<br>5.USER<em>ID</em>： 用户id<br>6.TASK<em>ID</em>： 任务id</p>
</li>
<li><p>act_ru_job</p>
</li>
<li><p>act_ru<em>task：运行时任务节点表<br>1.ID</em>：<br>2.REV_：<br>3.EXECUTION<em>ID</em>： 执行实例的id<br>4.PROC_INST<em>ID</em>： 流程实例的id<br>5.PROC_DEF<em>ID</em>： 流程定义的id,对应act_re<em>procdef 的id</em><br>6.NAME_： 任务名称，对应 task 的name<br>7.PARENT_TASK<em>ID</em> : 对应父任务<br>8.DESCRIPTION_：<br>9.TASK_DEF<em>KEY</em>： task 的id<br>10.OWNER<em> : 发起人<br>11.ASSIGNEE</em>： 分配到任务的人<br>12.DELEGATION<em> : 委托人<br>13.PRIORITY</em>： 紧急程度<br>14.CREATE<em>TIME</em>： 发起时间<br>15.DUE<em>TIME</em>：审批时长</p>
</li>
<li><p>act_ru<em>variable：运行时流程变量数据表<br>1.ID</em>：标识<br>2.REV<em>：版本号<br>3.TYPE</em>：数据类型<br>4.NAME_：变量名<br>5.EXECUTION<em>ID</em>： 执行实例id<br>6.PROC_INST<em>ID</em>： 流程实例id<br>7.TASK<em>ID</em>： 任务id<br>8.BYTEARRAY<em>ID</em>：<br>9.DOUBLE<em>：若数据类型为double ,保存数据在此列<br>10.LONG</em>： 若数据类型为Long保存数据到此列<br>11.TEXT<em>： string 保存到此列<br>12.TEXT2</em>：</p>
</li>
</ul>
<hr>
<blockquote>
<p>结论及总结:</p>
</blockquote>
<ol>
<li><p>流程文件部署主要涉及到3个表，分别是：ACT_GE_BYTEARRAY、ACT_RE_DEPLOYMENT、ACT_RE_PROCDEF。主要完成“部署包”–&gt;“流程定义文件”–&gt;“所有包内文件”的解析部署关系。从表结构中可以看出，流程定义的元素需要每次从数据库加载并解析，因为流程定义的元素没有转化成数据库表来完成，当然流程元素解析后是放在缓存中的，具体的还需要后面详细研究。</p>
</li>
<li><p>流程定义中的java类文件不保存在数据库里 。</p>
</li>
<li><p>组织机构的管理相对较弱，如果要纳入单点登录体系内还需要改造完成，具体改造方法有待研究。</p>
</li>
<li><p>运行时对象的执行与数据库记录之间的关系需要继续研究</p>
</li>
<li><p>历史数据的保存及作用需要继续研究。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载于： &lt;a href=&quot;http://www.jianshu.com/p/f9fd1cc02eae&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/f9fd1cc02eae&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

    
    </summary>
    
      <category term="activity" scheme="http://kingge.top/categories/activity/"/>
    
    
      <category term="activity" scheme="http://kingge.top/tags/activity/"/>
    
      <category term="工作流" scheme="http://kingge.top/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>关于web.xml中ServletContext、ServletContextListener、Filter、Servlet的执行顺序</title>
    <link href="http://kingge.top/2017/10/10/%E5%85%B3%E4%BA%8Eweb-xml%E4%B8%ADServletContext%E3%80%81ServletContextListener%E3%80%81Filter%E3%80%81Servlet%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://kingge.top/2017/10/10/关于web-xml中ServletContext、ServletContextListener、Filter、Servlet的执行顺序/</id>
    <published>2017-10-10T08:22:44.000Z</published>
    <updated>2017-10-10T09:25:05.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<blockquote>
<p>今天跑一个web项目，想做一些初始化工作，于是使用Filter来实现，但是发现ServletContextListener，Servlet也是能够实现的。但是肯定会有先后顺序执行的问题，那么接下来探讨这个问题。</p>
</blockquote>
<hr>
<blockquote>
<blockquote>
<p>作者规则：为了节省部分人的时间，先说结论。<strong><em>结论就是标题的顺序：ServletContext - ServletContextListener-  Filter、Servlet </em></strong></p>
</blockquote>
</blockquote>
<p><img src="/2017/10/10/关于web-xml中ServletContext、ServletContextListener、Filter、Servlet的执行顺序/TIM截图20171010164520.png" alt="web容器运行流程.png" title="web容器运行流程.png"></p>
<hr>
<h1 id="web加载"><a href="#web加载" class="headerlink" title="web加载"></a>web加载</h1><hr>
<p>启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml。</p>
<h2 id="加载产生Servlet上下文实例，ServletContext"><a href="#加载产生Servlet上下文实例，ServletContext" class="headerlink" title="加载产生Servlet上下文实例，ServletContext"></a>加载产生Servlet上下文实例，ServletContext</h2><hr>
<blockquote>
<p> 这个web项目的所有部分都将共享这个上下文。<br>容器将<context-param>转换为键值对，并交给servletContext。<br>L例如我们在使用spring的时候，会配置applicationContext.xml</context-param></p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;context-param&gt;</div><div class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</div><div class="line">  &lt;/context-param&gt;</div></pre></td></tr></table></figure>
<h2 id="依次加载Servlet的事件监听器-ServletContextListener"><a href="#依次加载Servlet的事件监听器-ServletContextListener" class="headerlink" title="依次加载Servlet的事件监听器 - ServletContextListener"></a>依次加载Servlet的事件监听器 - ServletContextListener</h2><hr>
<blockquote>
<p>并依次调用public void contextInitialized(ServletContextEvent sce)方法。<br>加载和调用多个Listener的顺序由在web.xml中配置的依次顺序决定的。</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;listener&gt;</div><div class="line">  &lt;listener-class&gt;com.wlx.core.application.ApplicaltionListener&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div><div class="line">&lt;listener&gt;</div><div class="line">  &lt;listener-class&gt;com.wlx.core.application.ApplicaltionListener2&lt;/listener-class&gt;</div><div class="line">&lt;/listener&gt;</div><div class="line">先执行 ApplicaltionListener的contextInitialized方法后执行ApplicaltionListener2的contextInitialized方法</div></pre></td></tr></table></figure>
<p>我们可以通过这个方法做一些初始化工作：例如初始化数据库连接池，初始化redis，启动定时器服务，启动线程池做一些socket通讯服务等等工作。 然后在contextDestroyed方法关闭这些服务即可。</p>
<hr>
<h2 id="依次加载Servlet的过滤器-Filter"><a href="#依次加载Servlet的过滤器-Filter" class="headerlink" title=".依次加载Servlet的过滤器-Filter"></a>.依次加载Servlet的过滤器-Filter</h2><blockquote>
<p>并依次调用public void init(FilterConfig filterConfig) throws ServletException;方法<br>加载和调用多个filter的顺序由在web.xml中配置的依次顺序决定的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">  &lt;filter-name&gt;appFilter&lt;/filter-name&gt;</div><div class="line">  &lt;filter-class&gt;com.wlx.core.application.AppFilter&lt;/filter-class&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;appFilter&lt;/filter-name&gt;</div><div class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<h2 id="依次加载Servlet"><a href="#依次加载Servlet" class="headerlink" title="依次加载Servlet"></a>依次加载Servlet</h2><blockquote>
<p>Load-on-startup元素在web应用启动的时候指定了servlet被加载的顺序，它的值必须是一个整数。如果它的值是一个负整数或是这个元素不存在，那么容器会在该servlet被调用的时候(例如下面代码访问-/servlet/UploadFile 为后缀的时候才会去初始化init，并不会在项目启动时候访问init)，加载这个servlet。如果值是正整数或零，容器在配置的时候就加载并初始化这个servlet，容器必须保证值小的先被加载。如果值相等，容器可以自动选择先加载谁。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">在servlet的配置当中，&lt;load-on-startup&gt;5&lt;/load-on-startup&gt;的含义是：</div><div class="line"></div><div class="line">标记容器是否在启动的时候就加载这个servlet。</div><div class="line">当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；</div><div class="line">当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。</div><div class="line">正数的值越小，启动该servlet的优先级越高。</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">项目启动时会去调用 UploadFile的init方法</div><div class="line">&lt;servlet&gt;</div><div class="line">    &lt;servlet-name&gt;UploadFile&lt;/servlet-name&gt;</div><div class="line">    &lt;servlet-class&gt;com.wlx.core.application.servlet.UploadFile&lt;/servlet-class&gt;</div><div class="line">    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;UploadFile&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/servlet/UploadFile&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div><div class="line">  </div><div class="line">项目启动时不会去调用 EServlet的init方法，访问匹配规则的网址时才会去调用init，而且只调用一次</div><div class="line">  &lt;servlet&gt;</div><div class="line">    &lt;servlet-name&gt;EServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;servlet-class&gt;com.wlx.core.application.servlet.EServlet&lt;/servlet-class&gt;</div><div class="line">  &lt;/servlet&gt;</div><div class="line">  &lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;EServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/servlet/EServlet&lt;/url-pattern&gt;</div><div class="line">  &lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>以上是Web容器在启动时加载的顺序，启动加载只会加载一次。<br>web.xml 的加载顺序是：ServletContext-&gt; context-param -&gt;listener -&gt; filter -&gt; servlet.</p>
</blockquote>
<hr>
<h1 id="扩展知识-请求执行循序"><a href="#扩展知识-请求执行循序" class="headerlink" title="扩展知识-请求执行循序"></a>扩展知识-请求执行循序</h1><hr>
<blockquote>
<p>在上面中我们总结web加载的执行顺序，那么一个请求的执行循序呢？<br>实际上就是一个责任链模式的问题</p>
</blockquote>
<hr>
<p><img src="/2017/10/10/关于web-xml中ServletContext、ServletContextListener、Filter、Servlet的执行顺序/TIM截图20171010171830.png" alt="web容器运行流程.png" title="请求过程"></p>
<hr>
<blockquote>
<ul>
<li>依次执行过滤器filter的方法public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain)，这个方法应用了责任链模式，当在该方法中使用chain.doFilter(request, response);则这个过滤器就调用下一个过滤器，直到过滤器链条完成调用，进入Servlet处理，这个时候doFilter并未执行完成，仅仅在servlet之前进行一连串的过滤处理。</li>
</ul>
<ul>
<li><p>进入相应Servlet并调用public void service(ServletRequest req, ServletResponse res)方法，或者说是GET和POST方法。public void doGet(HttpServletRequest request, HttpServletResponse respose)<br>进行请求响应的业务处理。</p>
</li>
<li><p>Servlet处理完成后，执行chain.doFilter(request, response);执行其他过滤器链条的后置过滤处理，然后执行自己的后置处理。</p>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>以上Filter和Servlet的执行顺序有点像Spring AOP 的前置通知和后置通知与业务方法关系。在Filter的doFilter方法中的chain.doFilter(request, response);之前做的业务逻辑就像前置通知，之后的逻辑像后置通知。业务方法是Sevlet中的public void service(ServletRequest req, ServletResponse res)方法。并且可以由多个有序的过滤链条进行Servlet的过滤。</p>
<blockquote>
<p>Filter的过滤请求的Servlet的范围与配置有关,Filter在每次访问Servlet时都会拦截过滤。</p>
</blockquote>
</blockquote>
<hr>
<p>代码例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class MyFilter implements Filter &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</div><div class="line">        System.out.println(&quot;执行MyFilter init&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void doFilter(ServletRequest request, ServletResponse response,</div><div class="line">            FilterChain chain) throws IOException, ServletException &#123;</div><div class="line">        System.out.println(&quot;执行MyFilter doFilter&quot;);</div><div class="line">        System.out.println(&quot;执行MyFilter doFilter before&quot;);</div><div class="line">        chain.doFilter(request, response);</div><div class="line">        System.out.println(&quot;执行MyFilter doFilter after&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void destroy() &#123;</div><div class="line">        System.out.println(&quot;执行MyFilter destroy&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">-------------------------------------------------------------</div><div class="line">public class MyFilter1 implements Filter &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</div><div class="line">        System.out.println(&quot;执行MyFilter1 init&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void doFilter(ServletRequest request, ServletResponse response,</div><div class="line">            FilterChain chain) throws IOException, ServletException &#123;</div><div class="line">        System.out.println(&quot;执行MyFilter1 doFilter &quot;);</div><div class="line">        System.out.println(&quot;执行MyFilter1 doFilter before&quot;);</div><div class="line">        chain.doFilter(request, response);</div><div class="line">        System.out.println(&quot;执行MyFilter1 doFilter after&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void destroy() &#123;</div><div class="line">        System.out.println(&quot;执行MyFilter1 destroy&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">------------------------------------------------------------------------</div><div class="line"></div><div class="line">public class MyServlet1 extends HttpServlet &#123;</div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">    public void init() throws ServletException &#123;</div><div class="line">        System.out.println(&quot;执行Servlet1 init()&quot;);</div><div class="line">    &#125;</div><div class="line">    public void destroy() &#123;</div><div class="line">        System.out.println(&quot;执行Servlet1 destroy()&quot;);</div><div class="line">    &#125;</div><div class="line">    public void doGet(HttpServletRequest request, HttpServletResponse respose)</div><div class="line">            throws ServletException, IOException &#123;</div><div class="line">        System.out.println(&quot;执行Servlet1 service&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>省略在web.xml中的配置</p>
<p>输出：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> 执行MyFilter doFilter</div><div class="line">执行MyFilter doFilter before</div><div class="line">执行MyFilter1 doFilter</div><div class="line">执行MyFilter1 doFilter before</div><div class="line">执行Servlet service</div><div class="line">执行MyFilter1 doFilter after</div><div class="line">执行MyFilter doFilter after</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;今天跑一个web项目，想做一些初始化工作，于是使用Filter来实现，但是发现ServletContex
    
    </summary>
    
      <category term="javaweb" scheme="http://kingge.top/categories/javaweb/"/>
    
    
      <category term="javaweb" scheme="http://kingge.top/tags/javaweb/"/>
    
      <category term="web.xml" scheme="http://kingge.top/tags/web-xml/"/>
    
  </entry>
  
  <entry>
    <title>软技能-代码之外的生存指南-把自己当做一个企业去思考</title>
    <link href="http://kingge.top/2017/10/09/%E8%BD%AF%E6%8A%80%E8%83%BD-%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97-%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%BD%93%E5%81%9A%E4%B8%80%E4%B8%AA%E4%BC%81%E4%B8%9A%E5%8E%BB%E6%80%9D%E8%80%83/"/>
    <id>http://kingge.top/2017/10/09/软技能-代码之外的生存指南-把自己当做一个企业去思考/</id>
    <published>2017-10-09T00:46:26.000Z</published>
    <updated>2017-10-09T00:51:47.087Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/b0aefa8f6a05" title="《软技能》—— 把自己当做一个企业去思考" target="_blank" rel="external">《软技能》—— 把自己当做一个企业去思考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/b0aefa8f6a05&quot; title=&quot;《软技能》—— 把自己当做一个企业去思考&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《软技能》—— 把自己当做一个企业去思考&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="读书系统" scheme="http://kingge.top/categories/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="软技能" scheme="http://kingge.top/tags/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
      <category term="代码之外的生存指南" scheme="http://kingge.top/tags/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>java到底是值传递还是引用传递</title>
    <link href="http://kingge.top/2017/09/26/java%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://kingge.top/2017/09/26/java到底是值传递还是引用传递/</id>
    <published>2017-09-26T07:13:17.000Z</published>
    <updated>2017-09-26T07:56:21.045Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><hr>
<blockquote>
<p>我们先给本文定下基调，java是<strong><em>值传递</em></strong></p>
</blockquote>
<hr>
<blockquote>
<p>有一种说法，引用传递实际上也就是值传递。这个说法很有意思，实际上这种说法也是有道理的，传递引用，这个引用实际上就是一个地址，也即是一个值。</p>
</blockquote>
<hr>
<h1 id="什么是值传递和引用传递"><a href="#什么是值传递和引用传递" class="headerlink" title="什么是值传递和引用传递"></a>什么是值传递和引用传递</h1><hr>
<blockquote>
<p>首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用含义。</p>
</blockquote>
<hr>
<h2 id="一：搞清楚-基本类型-和-引用类型的不同之处"><a href="#一：搞清楚-基本类型-和-引用类型的不同之处" class="headerlink" title="一：搞清楚 基本类型 和 引用类型的不同之处"></a>一：搞清楚 基本类型 和 引用类型的不同之处</h2><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int num = 10;</div><div class="line">String str = &quot;hello&quot;;</div></pre></td></tr></table></figure>
<p><img src="/2017/09/26/java到底是值传递还是引用传递/QQ截图20170926153341.png" alt="QQ截图20170926153341.png" title="QQ截图20170926153341.png"></p>
<blockquote>
<p>num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。</p>
</blockquote>
<hr>
<h2 id="二：搞清楚赋值运算符（-）的作用"><a href="#二：搞清楚赋值运算符（-）的作用" class="headerlink" title="二：搞清楚赋值运算符（=）的作用"></a>二：搞清楚赋值运算符（=）的作用</h2><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">num = 20;</div><div class="line">str = &quot;java&quot;;</div></pre></td></tr></table></figure>
<p><img src="/2017/09/26/java到底是值传递还是引用传递/QQ截图20170926153701.png" alt="QQ截图20170926153341.png" title="QQ截图20170926153701.png"></p>
<blockquote>
<p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。</p>
</blockquote>
<hr>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><hr>
<blockquote>
<p>参数传递基本上就是赋值操作</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">第一个例子：基本类型</div><div class="line">void foo(int value) &#123;</div><div class="line">    value = 100;</div><div class="line">&#125;</div><div class="line">foo(num); // num 没有被改变</div><div class="line"></div><div class="line">第二个例子：没有提供改变自身方法的引用类型</div><div class="line">void foo(String text) &#123;</div><div class="line">    text = &quot;windows&quot;;</div><div class="line">&#125;</div><div class="line">foo(str); // str 也没有被改变</div><div class="line"></div><div class="line">第三个例子：提供了改变自身方法的引用类型</div><div class="line">StringBuilder sb = new StringBuilder(&quot;iphone&quot;);</div><div class="line">void foo(StringBuilder builder) &#123;</div><div class="line">    builder.append(&quot;4&quot;);</div><div class="line">&#125;</div><div class="line">foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。</div><div class="line"></div><div class="line">第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</div><div class="line">StringBuilder sb = new StringBuilder(&quot;iphone&quot;);</div><div class="line">void foo(StringBuilder builder) &#123;</div><div class="line">    builder = new StringBuilder(&quot;ipad&quot;);</div><div class="line">&#125;</div><div class="line">foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>重点理解为什么，第三个例子和第四个例子结果不同？</p>
</blockquote>
<hr>
<p><img src="/2017/09/26/java到底是值传递还是引用传递/QQ截图20170926154128.png" alt="QQ截图20170926153341.png" title="QQ截图20170926154128.png"></p>
<p><img src="/2017/09/26/java到底是值传递还是引用传递/QQ截图20170926154232.png" alt="QQ截图20170926153341.png" title="QQ截图20170926154232.png"></p>
<hr>
<blockquote>
<p>例子5</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Employee &#123;</div><div class="line">	public int age;</div><div class="line">&#125;</div><div class="line">public class Main &#123;</div><div class="line">	public static void changeEmployee(Employee employee3)</div><div class="line">	&#123;</div><div class="line">		employee3 = new Employee(); // flag 1</div><div class="line">		employee3.age = 1000;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Employee employee = new Employee();</div><div class="line">		employee.age = 100;</div><div class="line">		changeEmployee(employee);</div><div class="line">		System.out.println(employee.age);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出： 100</div><div class="line"></div><div class="line"></div><div class="line">如果把  flag 1 位置代码注释，那么程序结果输出1000</div><div class="line"></div><div class="line">---原因同上</div></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<ul>
<li><p>= 号的理解是最重要的，他是一个动词，可能会引起左边变量值的改变</p>
</li>
<li><p>java中方法参数传递方式是按值传递。</p>
</li>
</ul>
<ul>
<li>如果参数是基本类型，传递的是基本类型的字面量值的拷贝。也就是你我没有半毛钱关系</li>
</ul>
<ul>
<li>如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。你我可能存在关系</li>
</ul>
<hr>
<ol>
<li><p>= 是赋值操作（任何包含=的如+=、-=、 /=等等，都内含了赋值操作）。不再是你以前理解的数学含义了，而+ - <em> /和 = 在java中更不是一个级别，换句话说， = 是一个动作，一个可以改变内存状态的操作，一个可以改变变量的符号，而+ - </em> /却不会。这里的赋值操作其实是包含了两个意思：1、放弃了原有的值或引用；2、得到了 = 右侧变量的值或引用。Java中对 = 的理解很重要啊！！可惜好多人忽略了，或者理解了却没深思过。</p>
</li>
<li><p>对于基本数据类型变量，= 操作是完整地复制了变量的值。换句话说，“=之后，你我已无关联”；至于基本数据类型，就不在这科普了。</p>
</li>
<li><p>对于非基本数据类型变量，= 操作是复制了变量的引用。换句话说，“嘿，= 左侧的变量，你丫别给我瞎动！咱俩现在是一根绳上的蚂蚱，除非你再被 = 一次放弃现有的引用！！上面说了 = 是一个动作，所以我把 = 当作动词用啦！！”。而非基本数据类型变量你基本上可以参数本身是变量</p>
</li>
<li><p>参数传递本质就是一种 = 操作。参数是变量，所有我们对变量的操作、变量能有的行为，参数都有。所以把C语言里参数是传值啊、传指针啊的那套理论全忘掉，参数传递就是 = 操作。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我们先给本文定下基调，java是&lt;strong&gt;&lt;em&gt;值传递&lt;/em&gt;&lt;/strong&gt;&lt;/
    
    </summary>
    
      <category term="java" scheme="http://kingge.top/categories/java/"/>
    
    
      <category term="java" scheme="http://kingge.top/tags/java/"/>
    
      <category term="java深入理解" scheme="http://kingge.top/tags/java%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>继承之上溯造型和下溯造型</title>
    <link href="http://kingge.top/2017/09/12/%E7%BB%A7%E6%89%BF%E4%B9%8B%E4%B8%8A%E6%BA%AF%E9%80%A0%E5%9E%8B%E5%92%8C%E4%B8%8B%E6%BA%AF%E9%80%A0%E5%9E%8B/"/>
    <id>http://kingge.top/2017/09/12/继承之上溯造型和下溯造型/</id>
    <published>2017-09-12T03:26:59.000Z</published>
    <updated>2017-09-12T07:01:12.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<blockquote>
<p>我们在平时的开发编码中，都会用到上溯造型和下溯造型，只是我们并不知道他的官方叫法而已，<strong><em> </em>上溯造型<em>跟</em>继承<em>和</em>多态<em>，以及</em>动态绑定<em>的关系很密切 </em></strong>，关于这几个概念后面会有涉及到他们的概念。</p>
</blockquote>
<hr>
<h2 id="继承和合成"><a href="#继承和合成" class="headerlink" title="继承和合成"></a>继承和合成</h2><blockquote>
<p>继承：<strong>它的本质就是为了使得代码复用</strong>（可以基于已经存在的类构造一个新类。继承已经存在的类就可以复用这些类的方法和域。在此基础上，可以添加新的方法和域，从而扩充了类的功能。）</p>
<p>合成：在新类里创建原有的对象称为合成。这种方式可以重复利用现有的代码而不更改它的形式。</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">-----继承</div><div class="line">关键字extends表明新类派生于一个已经存在的类。已存在的类称为父类或基类，新类称为子类或派生类。例如:</div><div class="line"></div><div class="line">class  Dog  extends  Animal  &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">类Dog继承了Animal，Animal类称为父类或基类，Dog类称为子类或派生类。</div><div class="line"></div><div class="line"></div><div class="line">---合成</div><div class="line">合成比较简单，就是在一个类中创建一个已经存在的类。</div><div class="line"></div><div class="line">class Dog &#123;</div><div class="line">    Animal animal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="上溯造型"><a href="#上溯造型" class="headerlink" title="上溯造型"></a>上溯造型</h1><blockquote>
<p>这个术语缘于继承关系图的传统画法：将基类至于顶部，而向下发展的就是派生类(子类)，发送给父类的消息亦可发给衍生类，父类包含子类。假设把子类赋值给父类，这个过程就称之为上溯造型— <strong><em>这个时候只能够调用父类父类的方法，子类特有的方法不能够调用，子类变窄</em></strong></p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">//父类</div><div class="line">abstract   class  Animal &#123;  </div><div class="line">    public   abstract   void  speak();  </div><div class="line">    public   void  eat()&#123;  </div><div class="line">   &#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">//子类特有方法</div><div class="line">interface  DoorGod &#123;  </div><div class="line">    void  guard();  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line">//Dog 子类和 Cat 子类</div><div class="line"></div><div class="line">class  Cat  extends  Animal &#123;  </div><div class="line">    </div><div class="line">    @Override  </div><div class="line">     public   void  eat() &#123;  </div><div class="line">         try  &#123;  </div><div class="line">            Thread.sleep( 1000 );  </div><div class="line">        &#125;  catch  (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        // super .eat();  </div><div class="line">         System.out.println(&quot;cat eat&quot;);</div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">     public   void  speak() &#123;  </div><div class="line">        System.out.println( &quot; 喵喵 &quot; );  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125; </div><div class="line"></div><div class="line">class  Dog  extends  Animal  implements  DoorGod&#123;  </div><div class="line">    </div><div class="line">    @Override  </div><div class="line">     public   void  speak() &#123;  </div><div class="line">        System.out.println( &quot; 汪汪 &quot; );  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">     public   void  guard() &#123;  </div><div class="line">         while ( true )&#123;  </div><div class="line">            System.out.println( &quot; 汪汪 &quot; );  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//测试方法</div><div class="line"></div><div class="line">public class TestShangSu</div><div class="line">&#123;</div><div class="line">    public static void upcasting(Animal animal)&#123;  </div><div class="line">        animal.speak();  </div><div class="line">        animal.eat();  </div><div class="line">    &#125; </div><div class="line">    </div><div class="line">        @Test</div><div class="line">       public void test1()&#123;</div><div class="line">            Animal dog1 = new Dog();  </div><div class="line">             upcasting(dog1);  </div><div class="line">             Animal cat  = new Cat();  </div><div class="line">             upcasting(cat);  </div><div class="line"></div><div class="line">       &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">//输出</div><div class="line"> 汪汪 </div><div class="line"> 喵喵 </div><div class="line">cat eat</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>这个时候为什么输出是：子类覆盖父类的方法，而不是父类的方法，这个涉及到<strong><em>动态绑定</em></strong>。后面再讲</p>
</blockquote>
<hr>
<blockquote>
<p>由于upcasting(Animal animal)方法的参数是 Animal类型的，因此如果传入的参数是 Animal的子类，传入的参数就会被转换成父类Animal类型，这样你创建的Dog对象能使用的方法只是Animal中的签名方法；也就是说，在上溯的过程中，Dog的接口变窄了，它本身的一些方法（例如实现了 DoorGod的guard方法）就不可见了。如果你想使用Dog中存在而Animal中不存在的方法（比如guard方法），编译时不能通过的。由此可见，上溯造型是安全的类型转换。</p>
<blockquote>
<p>如果Dog在上溯造型过程中想使用 DoorGod的guard方法，那么需要配合下溯造型和安全检查，来进行强制转换，讲Animal 下溯为 Dog类型。</p>
<blockquote>
<p>注意的是：下溯是不安全的，由父类转化为子类，所以需要加上判断。</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h1 id="下溯造型"><a href="#下溯造型" class="headerlink" title="下溯造型"></a>下溯造型</h1><blockquote>
<p>将基类转化为衍生类，不安全的操作，可能会引发ClassCastException。</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">上面的例子只需要加上这一层判断即可</div><div class="line"></div><div class="line">    public static void upcasting(Animal animal)&#123;  </div><div class="line">       if( animal instanceof Dog )&#123;//下溯造型判断</div><div class="line">            Dog dog = (Dog) animal;</div><div class="line">            dog.guard();</div><div class="line">        &#125;</div><div class="line">        animal.speak();  </div><div class="line">        animal.eat();  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p> 我们在使用<a href="/2017/09/06/注解实现请求方法的登录控制"><strong><em>注解实现请求方法的登录控制</em></strong></a>  登录拦截器里面有段关键代码使用的就是下溯造型</p>
</blockquote>
<p><img src="/2017/09/12/继承之上溯造型和下溯造型/下溯整形.png" alt="下溯整形.png" title="下溯整形.png"></p>
<hr>
<h1 id="为什么使用上溯和下溯造型"><a href="#为什么使用上溯和下溯造型" class="headerlink" title="为什么使用上溯和下溯造型"></a>为什么使用上溯和下溯造型</h1><blockquote>
<p>上面的例子我们发现，关键的代码是<strong><em>upcasting方法</em></strong>，为什么在调用upcasting方法时要有意忽略调用它的对象类型呢？如果让upcasting方法简单地获取Dog句柄似乎更加直观易懂，但是那样会使衍生自Animal类的每一个新类都要实现专属自己的upcasting方法：例如Cat会实现一个重复的upcasting(Cat cat )这样的方法。</p>
<blockquote>
<p>实现多态的好处和代码复利用。</p>
</blockquote>
</blockquote>
<hr>
<h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><blockquote>
<p>在上面的upcasting方法，测试例子输出的是子类的方法，而非是父类的方法，但是我们使用的是父类去调用这些方法，为什么输出不是父类的呢？</p>
<p>upcasting它接收的是Animal句柄，当执行speak和eat方法时时，它是如何知道Animal句柄指向的是一个Dog对象而不是Cat对象呢？编译器是无从得知的，这涉及到接下来要说明的绑定问题。</p>
</blockquote>
<hr>
<blockquote>
<p>Java实现了一种方法调用机制，可在运行期间判断对象的类型，然后调用相应的方法，这种在运行期间进行，以对象的类型为基础的绑定称为动态绑定。除非一个方法被声明为final，Java中的所有方法都是动态绑定的。</p>
</blockquote>
<h2 id="静态方法的绑定"><a href="#静态方法的绑定" class="headerlink" title="静态方法的绑定"></a>静态方法的绑定</h2><blockquote>
<p>他跟普通的方法不同，子类和父类方法都是静态的，子类如果去掉父类编译会错误</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package Test;</div><div class="line">class Person &#123;</div><div class="line">    static void eat() &#123;</div><div class="line">        System.out.println(&quot;Person.eat()&quot;);</div><div class="line">    &#125;</div><div class="line">    static void speak() &#123;</div><div class="line">        System.out.println(&quot;Person.speak()&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Boy extends Person &#123;</div><div class="line">    static void eat() &#123;</div><div class="line">        System.out.println(&quot;Boy.eat()&quot;);</div><div class="line">    &#125;</div><div class="line">    static void speak() &#123;</div><div class="line">        System.out.println(&quot;Boy.speak()&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Girl extends Person &#123;</div><div class="line">    static void eat() &#123;</div><div class="line">        System.out.println(&quot;Girl.eat()&quot;);</div><div class="line">    &#125;</div><div class="line">    static void speak() &#123;</div><div class="line">        System.out.println(&quot;Girl.speak()&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class Persons &#123;</div><div class="line">    public static Person randPerson() &#123;</div><div class="line">        switch ((int)(Math.random() * 2)) &#123;</div><div class="line">        default:</div><div class="line">        case 0:</div><div class="line">            return new Boy();</div><div class="line">        case 1:</div><div class="line">            return new Girl();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Person[] p = new Person[4];</div><div class="line">        for (int i = 0; i &lt; p.length; i++) &#123;</div><div class="line">            p[i] = randPerson();    // 随机生成Boy或Girl</div><div class="line">        &#125;</div><div class="line">        for (int i = 0; i &lt; p.length; i++) &#123;</div><div class="line">            p[i].eat();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//输出</div><div class="line">Person.eat()</div><div class="line">Person.eat()</div><div class="line">Person.eat()</div><div class="line">Person.eat()</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>对于静态方法而言，不管父类引用指向的什么子类对象，调用的都是父类的方法。</p>
</blockquote>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>上溯造型和动态绑定实际上就是多态的体现，下溯造型是为了解决因为上溯而导致衍生类功能变小的问题，继承则是上溯和下溯以及动态编译的基础。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我们在平时的开发编码中，都会用到上溯造型和下溯造型，只是我们并不知道他的官方叫法而已，&lt;strong&gt;&lt;
    
    </summary>
    
      <category term="Java" scheme="http://kingge.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://kingge.top/tags/java/"/>
    
      <category term="继承" scheme="http://kingge.top/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="多态" scheme="http://kingge.top/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>注解实现请求方法的登录控制</title>
    <link href="http://kingge.top/2017/09/06/%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%9A%84%E7%99%BB%E5%BD%95%E6%8E%A7%E5%88%B6/"/>
    <id>http://kingge.top/2017/09/06/注解实现请求方法的登录控制/</id>
    <published>2017-09-06T02:37:08.000Z</published>
    <updated>2017-09-06T03:56:00.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>之前一直使用的是，拦截器来统一验证当前用户是否登录，通过验证cookie或者session里面的是否存在已经登录标识来完成登录逻辑判断。但是会发现，这个很麻烦，而且有很多配置需要配置，例如免验证URL等等配置，无法实现可拔插式方法级别的控制。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class RequestInterceptor extends HandlerInterceptorAdapter &#123;  </div><div class="line"></div><div class="line">      </div><div class="line">    public String[] allowUrls;//配置不拦截的资源，所以在代码里面来排除.</div><div class="line">      </div><div class="line">    public void setAllowUrls(String[] allowUrls) &#123;    </div><div class="line">        this.allowUrls = allowUrls;    </div><div class="line">    &#125;    </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    public void postHandle(HttpServletRequest request,  </div><div class="line">            HttpServletResponse response, Object handler,  </div><div class="line">            ModelAndView modelAndView) throws Exception &#123;  </div><div class="line">        // TODO Auto-generated method stub  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public boolean preHandle(HttpServletRequest request,  </div><div class="line">            HttpServletResponse response, Object handler) throws Exception &#123;  </div><div class="line">          </div><div class="line">          </div><div class="line">        // TODO Auto-generated method stub  </div><div class="line">        request.setCharacterEncoding(&quot;UTF8&quot;);  </div><div class="line">        HttpSession session=request.getSession();//获取登录的SESSION   </div><div class="line">          </div><div class="line">          </div><div class="line">        String sessionid=request.getSession().getId();//获取登录的SESSIONID  </div><div class="line">        String requestPath=request.getServletPath();//获取客户请求页面  </div><div class="line">          </div><div class="line">          </div><div class="line">         //先过滤掉不需要判断SESSION的请求  </div><div class="line">        for(String url : allowUrls) &#123;     </div><div class="line">            if(requestPath.contains(url)) &#123;      </div><div class="line">                return true;      </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">     Object attribute = request.getSession().getAttribute(&quot;sys_user&quot;);</div><div class="line">                if( attribute == null )&#123;</div><div class="line">                    response.sendRedirect(&quot;/index.jsp&quot;);</div><div class="line">                &#125;</div><div class="line">				</div><div class="line">            return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>大体上是这样的，<strong>通过allowUrls来控制免登录url</strong>（上面的代码其实可以使用配置文件的方式来配置allowUrls的值，可以不通过setAllowUrls的方式来赋值，但是为了方面扩展就加入了。）</p>
<blockquote>
<p>这里会面临一个问题，那就是如果网站网页多的话，那么allowUrls的值会变得很庞大，可能会缺漏。所以下面讲解本人用到的解决方式—-<strong><em>注解</em></strong> 和 <strong><em>spring配置方式</em></strong>（跟数组形式没有什么区别）</p>
</blockquote>
</blockquote>
<h1 id="spring-配置方式"><a href="#spring-配置方式" class="headerlink" title="spring 配置方式"></a>spring 配置方式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">path 对所有的请求拦截使用/**，对某个模块下的请求拦截使用：/myPath/*</div><div class="line">&lt;mvc:interceptor&gt;</div><div class="line">	&lt;mvc:mapping path=&quot;/**&quot; /&gt;</div><div class="line">	&lt;bean class=&quot;com.kingge.oa.user.LoginInterceptor&quot; /&gt;</div><div class="line">&lt;/mvc:interceptor&gt;</div><div class="line"></div><div class="line"></div><div class="line">    或者</div><div class="line">       &lt;!--       拦截是否登录</div><div class="line">      &lt;mvc:interceptor&gt;</div><div class="line">		   需拦截的地址  </div><div class="line">                      二级目录  </div><div class="line">	            &lt;mvc:mapping path=&quot;/*/*&quot;/&gt; </div><div class="line"> &lt;bean class=&quot;com.jk.ssm.interceptor.RequestInterceptor&quot; &gt;</div><div class="line">		 &lt;property name=&quot;allowUrls&quot;&gt;   //回去调用拦截器的 setAllowUrls 方法</div><div class="line">	            &lt;list&gt;  </div><div class="line">	              如果请求中包含以下路径，则不进行拦截  </div><div class="line">	              &lt;value&gt;/account/login.html&lt;/value&gt;  </div><div class="line">	              &lt;value&gt;/captcha/image.html&lt;/value&gt;  </div><div class="line">	          	  &lt;value&gt;/register/register.html&lt;/value&gt; </div><div class="line">	          	  &lt;value&gt;/error/400.html&lt;/value&gt; </div><div class="line">	          	  &lt;value&gt;/error/404.html&lt;/value&gt; </div><div class="line">	          	  &lt;value&gt;/error/500.html&lt;/value&gt; </div><div class="line">	            &lt;/list&gt;  </div><div class="line">        		&lt;/property&gt;</div><div class="line">        &lt;/bean&gt;</div><div class="line">&lt;/mvc:interceptor&gt;</div></pre></td></tr></table></figure>
<hr>
<h1 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h1><h2 id="关于注解"><a href="#关于注解" class="headerlink" title="关于注解"></a>关于注解</h2><blockquote>
<p>官方说辞：JDK5开始，java增加了对元数据(MetaData)的支持，怎么支持？答：通过Annotation(注解）来实现。Annotation提供了为程序元素设置元数据的方法。元数据：描述数据的数据。</p>
</blockquote>
<hr>
<blockquote>
<p>个人理解：首先什么是元数据，元数据就是对一类事物的统称，他不仅限于某个事物的描述。例如我们有ABC三个系统，分别使用oracle，mysql，db2，都有登录功能，他们的用户表字段名称是不一样的。那么有个需求，我想把A系统的用户数据pour到B系统中，那么进行映射操作？这个时候就需要一个描述用户数据的一个统一标识（元数据）这样我们就可以先把，A系统数据映射到元数据，然后再从元数据取数据映射到B系统中。</p>
</blockquote>
<hr>
<blockquote>
<p>粗俗的理解，元数据就是一个类的属性，但是他所具备的职能的而应用范围，跟真正意义上类的属性数不一样的。传统的类的属性他只描述这个类，元数据可以描述多个具有共性的类。</p>
</blockquote>
<hr>
<blockquote>
<p>再举个例子，我们现在常用的数据中心（DC）就是使用了元数据来作为数据传输的媒介。</p>
</blockquote>
<p><img src="/2017/09/06/注解实现请求方法的登录控制/DC流程.png" alt="DC流程.png" title="DC流程.png"></p>
<hr>
<blockquote>
<p>元数据作用：：Annotation就像代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。读取到了程序元素的元数据，就可以执行相应的处理。通过注解，程序开发人员可以在不改变原有逻辑的情况下，在源代码文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过解析这些注解获取到这些补充信息，从而进行验证或者进行部署等。</p>
</blockquote>
<hr>
<h2 id="到java8为止一共提供了五个-注解"><a href="#到java8为止一共提供了五个-注解" class="headerlink" title="到java8为止一共提供了五个  注解"></a>到java8为止一共提供了五个  <strong><em>注解</em></strong></h2><hr>
<p><img src="/2017/09/06/注解实现请求方法的登录控制/五个基本原数据.png" alt="五个基本原数据.png" title="五个基本原数据.png"></p>
<hr>
<blockquote>
<ul>
<li>unchecked异常：运行时异常。是RuntimeException的子类，不需要在代码中显式地捕获unchecked异常做处理。Java异常</li>
</ul>
</blockquote>
<ul>
<li>@SafeVarargs (java7新增）：java7的“堆污染”警告与@SafeVarargs<br>堆污染：把一个不带泛型的对象赋给一个带泛型的变量是，就会发生堆污染。<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">例如：下面代码引起堆污染，会给出警告</div><div class="line">List l2 = new ArrayList&lt;Number&gt;();</div><div class="line">List&lt;String&gt; ls = l2;</div><div class="line">3中方式去掉这个警告</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>3种方式去掉这个警告：<br>使用注解@SafeVarargs修饰引发该警告的方法或构造器。<br>使用@SuppressWarnings(“unchecked”) 修饰。<br>使用编译器参数命令：-Xlint:varargs</p>
</blockquote>
<ul>
<li>@Functionlnterface （java8新增）：修饰函数式接口<br>使用该注解修饰的接口必须是函数式接口，不然编译会出错。那么什么是函数式接口？答：如果接口中只有一个抽象方法（可以包含多个默认方法或static方法），就是函数式接口。</li>
</ul>
<hr>
<h2 id="五个基本元注解"><a href="#五个基本元注解" class="headerlink" title="五个基本元注解"></a>五个基本元注解</h2><blockquote>
<p>元注解：描述注解的注解（概念跟元数据类似）。</p>
<blockquote>
<p>java提供了6个元注解（Meta Annotation)，在java.lang.annotation中。其中5个用于修饰其他的Annonation定义。而@Repeatable专门用于定义Java8新增的重复注解。所以要定义注解必须使用到5个元注解来定义( 五个注解用法 详情百度 )</p>
<ul>
<li>@Inherited</li>
<li>@Documented</li>
<li>@Retention（英文：保留）</li>
<li>@Target ( 目标)</li>
</ul>
</blockquote>
</blockquote>
<hr>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><blockquote>
<p>参见下面，例子或者白度，具体就不阐述了。</p>
</blockquote>
<h2 id="使用注解解决登录问题"><a href="#使用注解解决登录问题" class="headerlink" title="使用注解解决登录问题"></a>使用注解解决登录问题</h2><h3 id="定义一个枚举类"><a href="#定义一个枚举类" class="headerlink" title="定义一个枚举类"></a>定义一个枚举类</h3><blockquote>
<p>作用： 是否进行验证权限（因为后期可能会增加权限判断注解，而且是否登录也可以说是权限判断的一种，所以这里的枚举类的作用就是保存是否进行权限判断信息）</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public enum Action</div><div class="line">&#123;</div><div class="line">    Normal(&quot;0&quot;,&quot;执行权限验证&quot;), Skip(&quot;1&quot;, &quot;跳过权限验证&quot;);</div><div class="line">    private final  String key;</div><div class="line">    private final  String desc;</div><div class="line">    private Action(String key, String desc)</div><div class="line">    &#123;</div><div class="line">        this.key = key;</div><div class="line">        this.desc = desc;</div><div class="line">    &#125;</div><div class="line"> //省略get set方法</div></pre></td></tr></table></figure>
<hr>
<h3 id="定义登录和权限注解"><a href="#定义登录和权限注解" class="headerlink" title="定义登录和权限注解"></a>定义登录和权限注解</h3><blockquote>
<p>Login属性是action ，属性类型是Action（上面的枚举类）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Target(ElementType.METHOD)</div><div class="line">@Documented</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">public @interface Login</div><div class="line">&#123;</div><div class="line">      Action action() default Action.Normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Target(&#123;java.lang.annotation.ElementType.METHOD&#125;)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface Permission</div><div class="line">&#123;</div><div class="line">  String value() default &quot;&quot;; // 这里我是保存一个权限代码，例如赋值为4000，表示当前用户的必须具备4000的权限才能够访问方法</div><div class="line">  </div><div class="line">  Action action() default Action.Normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class LoginInterceptor extends HandlerInterceptorAdapter</div><div class="line">&#123;</div><div class="line">    @Override</div><div class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception&#123;</div><div class="line">        if(handler instanceof HandlerMethod)&#123;  //是否为请求方法</div><div class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;  </div><div class="line">            Login login = handlerMethod.getMethodAnnotation(Login.class);//当前请求方法是否添加了Login注解</div><div class="line">            if(  login != null &amp;&amp; &quot;0&quot;.equals(login.action().getKey()) )&#123;//判断属性的值是否是0-表示需要进行登录验证</div><div class="line">    </div><div class="line">                Object attribute = request.getSession().getAttribute(&quot;sys_user&quot;);</div><div class="line">                if( attribute == null )&#123;</div><div class="line">                    response.sendRedirect(&quot;/index.jsp&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在spring中配置拦截器"><a href="#在spring中配置拦截器" class="headerlink" title="在spring中配置拦截器"></a>在spring中配置拦截器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;mvc:interceptors&gt;</div><div class="line">&lt;bean class=&quot;com.kingge.oa.user.LoginInterceptor&quot;&gt;&lt;/bean&gt;</div><div class="line">&lt;/mvc:interceptors&gt;</div></pre></td></tr></table></figure>
<h3 id="给请求方法添加权限控制"><a href="#给请求方法添加权限控制" class="headerlink" title="给请求方法添加权限控制"></a>给请求方法添加权限控制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> @Login(action=Action.Skip) //不需要进行登录校验</div><div class="line"> @Permission(value=&quot;4000&quot;,action=Action.normal)//需要进行权限号为4000的权限校验</div><div class="line"> @RequestMapping(&quot;/list&quot;)</div><div class="line"> public String list(Model model,HttpServletRequest request)</div><div class="line"> &#123;</div><div class="line">     request.getSession().setAttribute(&quot;sys_user&quot;, &quot;denglule&quot;);</div><div class="line">	 List&lt;User&gt; userList = userService.findAllObjects();</div><div class="line">	 System.out.println( userList );</div><div class="line">	   model.addAttribute(&quot;userList&quot;,userList );</div><div class="line">	  return &quot;list&quot;;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">@Login(action=Action.Normal)//添加操作，需要校验是否登录</div><div class="line"> @RequestMapping(value=&quot;/add&quot;, method=RequestMethod.POST)</div><div class="line"> public  String add( User user )</div><div class="line"> &#123;</div><div class="line">	 </div><div class="line">	 System.out.println( user );</div><div class="line">	 </div><div class="line">	 userService.insert(user);</div><div class="line">	 </div><div class="line">	 return &quot;forward:/user/list&quot;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;之前一直使用的是，拦截器来统一验证当前用户是否登录，通过验证cookie或者session里面的是否存在已经登录标
    
    </summary>
    
      <category term="java" scheme="http://kingge.top/categories/java/"/>
    
    
      <category term="java" scheme="http://kingge.top/tags/java/"/>
    
      <category term="java注解" scheme="http://kingge.top/tags/java%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="登录控制" scheme="http://kingge.top/tags/%E7%99%BB%E5%BD%95%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>java8新特性</title>
    <link href="http://kingge.top/2017/08/29/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://kingge.top/2017/08/29/java8新特性/</id>
    <published>2017-08-29T04:27:16.000Z</published>
    <updated>2017-09-01T02:08:20.226Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8可谓是自Java 5以来最具革命性的版本了，她在语言、编译器、类库、开发工具以及Java虚拟机等方面都带来了不少新特性。<br>我们来一一回顾一下这些特性。</p>
<p><img src="/2017/08/29/java8新特性/java8特性简介.png" alt="java8新特性"></p>
<h1 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h1><blockquote>
<p>Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。Lambda  是一个匿名函数。</p>
</blockquote>
<p>一个Lambda表达式可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。例如：</p>
<h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><blockquote>
<p>需求：  比较TreeSet<integer>中数据，按小到大输出</integer></p>
</blockquote>
<h3 id="使用匿名内部类实现一个排序功能"><a href="#使用匿名内部类实现一个排序功能" class="headerlink" title="使用匿名内部类实现一个排序功能"></a><strong>使用匿名内部类实现一个排序功能</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">      <span class="comment">//采用匿名内部类的方式-实现比较器</span></div><div class="line">      Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;()</div><div class="line">      &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span></div><div class="line"><span class="function">          </span>&#123;</div><div class="line">              <span class="keyword">return</span> Integer.compare(o1, o2);<span class="comment">//关键代码</span></div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line"><span class="comment">//传入比较器</span></div><div class="line">    TreeSet&lt;Integer&gt; tree2 = <span class="keyword">new</span> TreeSet&lt;&gt;(comparator );</div><div class="line">      tree2.add(<span class="number">12</span>);</div><div class="line">      tree2.add(-<span class="number">12</span>);</div><div class="line">      tree2.add(<span class="number">100</span>);</div><div class="line">System.out.println(tree2)</div><div class="line"></div><div class="line">    <span class="comment">//输出</span></div><div class="line"> -<span class="number">12</span></div><div class="line">  <span class="number">12</span></div><div class="line">  <span class="number">100</span></div></pre></td></tr></table></figure>
<p>我们不难发现上面的代码存在一个问题：其实关键代码只有第七行，其他代码都是冗余的</p>
<h3 id="使用Lambda表达式实现同样功能"><a href="#使用Lambda表达式实现同样功能" class="headerlink" title="使用Lambda表达式实现同样功能"></a><strong>使用Lambda表达式实现同样功能</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="comment">//使用Lambda表达式，抽取关键代码，减少代码量</span></div><div class="line">Comparator&lt;Integer&gt; comparator2 = (x, y) -&gt; Integer.compare(x, y); <span class="comment">//关键代码</span></div><div class="line">  TreeSet&lt;Integer&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;(comparator2 );</div><div class="line">  tree.add(<span class="number">12</span>);</div><div class="line">  tree.add(-<span class="number">12</span>);</div><div class="line">  tree.add(<span class="number">100</span>);</div><div class="line">  tree.forEach(System.out::println);<span class="comment">//代替System.out.println</span></div></pre></td></tr></table></figure>
<p>代码瞬间就变得很简短，你可能觉得这个有什么，没什么感觉。那么我们在进入第二个例子</p>
<h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><blockquote>
<p>需求：<br>1.获取公司中年龄小于 35 的员工信息<br>2.获取公司中工资大于 5000 的员工信息<br>。。。。。。</p>
</blockquote>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>实现一个Employee类,有四个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private int id;</div><div class="line">private String name;</div><div class="line">private int age;</div><div class="line">private double salary;</div><div class="line"></div><div class="line">忽略get/set方法和构造器</div></pre></td></tr></table></figure>
<p>初始化一个List：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">List&lt;Employee&gt; emps = Arrays.asList(</div><div class="line">		new Employee(101, &quot;张三&quot;, 18, 9999.99),</div><div class="line">		new Employee(102, &quot;李四&quot;, 59, 6666.66),</div><div class="line">		new Employee(103, &quot;王五&quot;, 28, 3333.33),</div><div class="line">		new Employee(104, &quot;赵六&quot;, 8, 7777.77),</div><div class="line">		new Employee(105, &quot;田七&quot;, 38, 5555.55)</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="常规方法实现"><a href="#常规方法实现" class="headerlink" title="常规方法实现"></a><strong>常规方法实现</strong></h3><p>实现两个方法，然后传入需要过滤的源数据，返回过滤后的结果集<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">     	<span class="comment">//需求：获取公司中年龄小于 35 的员工信息</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployeeAge</span><span class="params">(List&lt;Employee&gt; emps)</span></span>&#123;</div><div class="line">	List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (Employee emp : emps) &#123;</div><div class="line">		<span class="keyword">if</span>(emp.getAge() &lt;= <span class="number">35</span>)&#123;<span class="comment">//比较代码</span></div><div class="line">			list.add(emp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//需求：获取公司中工资大于 5000 的员工信息</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployeeSalary</span><span class="params">(List&lt;Employee&gt; emps)</span></span>&#123;</div><div class="line">	List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (Employee emp : emps) &#123;</div><div class="line">		<span class="keyword">if</span>(emp.getSalary() &gt;= <span class="number">5000</span>)&#123;<span class="comment">//比较代码</span></div><div class="line">			list.add(emp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们不难发现上面的代码存在一个问题：那就是两个方法除了比较部分不同，其他逻辑是一样的，存在大量冗余，假设有新的需求（例如求得求得名字姓王的员工）那么就需要再创建一个 filterEmployee<em>**</em>方法对应新的需求。</p>
<h3 id="使用策略设计模式实现"><a href="#使用策略设计模式实现" class="headerlink" title="使用策略设计模式实现"></a><strong>使用策略设计模式实现</strong></h3><blockquote>
<p>提供父借口 和 两个 实现类（两个需求对应的逻辑实现类）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 父接口</span></div><div class="line">   <span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyPredicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//需求1 实现类-年龄小于35</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeForAge</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee t)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> t.getAge() &lt;= <span class="number">35</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//需求1 实现类-工资大于5000</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeForSalary</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee t)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> t.getSalary() &gt;= <span class="number">5000</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>测试代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 通用过滤方法</div><div class="line">	public List&lt;Employee&gt; filterEmployee(List&lt;Employee&gt; emps, MyPredicate&lt;Employee&gt; mp)&#123;</div><div class="line">		List&lt;Employee&gt; list = new ArrayList&lt;&gt;();</div><div class="line">		</div><div class="line">		for (Employee employee : emps) &#123;</div><div class="line">			if(mp.test(employee))&#123;</div><div class="line">				list.add(employee);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Test</div><div class="line">	public void test4()&#123;</div><div class="line">        //传入实现年龄过滤的实现类</div><div class="line">		List&lt;Employee&gt; list = </div><div class="line">filterEmployee(emps, new FilterEmployeeForAge());</div><div class="line">		for (Employee employee : list) &#123;</div><div class="line">			System.out.println(employee);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(&quot;------------------------------------------&quot;);</div><div class="line">		</div><div class="line">		List&lt;Employee&gt; list2 = filterEmployee(emps, new FilterEmployeeForSalary());</div><div class="line">		for (Employee employee : list2) &#123;</div><div class="line">			System.out.println(employee);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>使用策略模式比上一个的好处是：代码很清晰，便于维护，新的需求我们只需要再实现对应的需求实现类即可，然后传入<figure class="highlight plain"><figcaption><span>MyPredicate<t>```接口即可。</t></span></figcaption><table><tr><td class="code"><pre><div class="line"></div><div class="line">缺点是：需要实现对应的需求类然后实现``` MyPredicate&lt;T&gt;```接口</div><div class="line"></div><div class="line"></div><div class="line">###   **匿名内部类**</div><div class="line">这种方法类似于例子1中的 Comparator这个接口的实现</div><div class="line"></div><div class="line"></div><div class="line">```JAVA</div><div class="line">//直接使用 MyPredicate&lt;Employee&gt;接口，不去实现对应的需求类（上面的FilterEmployeeForSalary 和 FilterEmployeeForAge ）</div><div class="line">   @Test</div><div class="line">	public void test5()&#123;</div><div class="line">		List&lt;Employee&gt; list = filterEmployee(emps, new MyPredicate&lt;Employee&gt;() &#123;</div><div class="line">			@Override</div><div class="line">			public boolean test(Employee t) &#123;</div><div class="line">				return t.getId() &lt;= 103;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		for (Employee employee : list) &#123;</div><div class="line">			System.out.println(employee);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>我们不难发现上面的代码存在一个问题：跟例子1一样，存在大量的冗余。</p>
<h3 id="Lambda-表达式实现"><a href="#Lambda-表达式实现" class="headerlink" title="Lambda 表达式实现"></a><strong>Lambda 表达式实现</strong></h3><h4 id="前期准备-1"><a href="#前期准备-1" class="headerlink" title="前期准备"></a>前期准备</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public List&lt;Employee&gt; filterEmployee(List&lt;Employee&gt; emps, MyPredicate&lt;Employee&gt; mp)&#123;</div><div class="line">	List&lt;Employee&gt; list = new ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	for (Employee employee : emps) &#123;</div><div class="line">		if(mp.test(employee))&#123;</div><div class="line">			list.add(employee);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</div><div class="line">	List&lt;Employee&gt; list = filterEmployee(emps, (e) -&gt; e.getAge() &lt;= <span class="number">35</span>);</div><div class="line">	list.forEach(System.out::println);</div><div class="line">	System.out.println(<span class="string">"------------------------------------------"</span>);</div><div class="line">	</div><div class="line">	List&lt;Employee&gt; list2 = filterEmployee(emps, (e) -&gt; e.getSalary() &gt;= <span class="number">5000</span>);</div><div class="line">	list2.forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们不难发现上面的代码存在一个问题：这个代码，是不是已经非常简短了，感觉已经是终极的最简代码。但是实际上还有更简短的代码（使用stream api）<br><strong>缺点</strong>：太过依赖  MyPredicate<t> 这个接口，假设这个接口不存在，该怎么办呢？（我们这里仅仅是做个假设）</t></p>
<h3 id="终极实现方式：Stream-API"><a href="#终极实现方式：Stream-API" class="headerlink" title="终极实现方式：Stream API"></a><strong>终极实现方式：Stream API</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Test</div><div class="line">public void test7()&#123;</div><div class="line">	emps.stream()</div><div class="line">		.filter((e) -&gt; e.getAge() &lt;= 35)</div><div class="line">		.forEach(System.out::println);</div><div class="line">	</div><div class="line">	System.out.println(&quot;----------------------------------------------&quot;);</div><div class="line">      emps.stream()</div><div class="line">         .filter((e) -&gt; e.getSalary() &gt;= 5000)</div><div class="line">         .forEach(System.out::println);</div><div class="line">	</div><div class="line">      System.out.println(&quot;----------------------------------------------&quot;);</div><div class="line">	  </div><div class="line">        // 可以使用map 指定输出那个属性的值，代替普通的便利输出</div><div class="line">	emps.stream()</div><div class="line">		.map(Employee::getName)</div><div class="line">		.limit(3)// 输出前三个</div><div class="line">		.sorted()//排序</div><div class="line">		.forEach(System.out::println);</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>输出</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Employee [id=101, name=张三, age=18, salary=9999.99]</div><div class="line">Employee [id=103, name=王五, age=28, salary=3333.33]</div><div class="line">Employee [id=104, name=赵六, age=8, salary=7777.77]</div><div class="line">----------------------------------------------</div><div class="line">Employee [id=101, name=张三, age=18, salary=9999.99]</div><div class="line">Employee [id=102, name=李四, age=59, salary=6666.66]</div><div class="line">Employee [id=104, name=赵六, age=8, salary=7777.77]</div><div class="line">Employee [id=105, name=田七, age=38, salary=5555.55]</div><div class="line">----------------------------------------------</div><div class="line">张三</div><div class="line">李四</div><div class="line">王五</div></pre></td></tr></table></figure>
<p>我们不难发现上面的代码存在一个问题：这个代码，是非常潇洒，舒服的，不依赖我们上面所说的接口。</p>
<hr>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><blockquote>
<p>为了使现有函数更好的支持Lambda表达式，Java 8引入了函数式接口的概念。函数式接口就是<strong>只有一个方法的普通接口</strong>。java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的例子。为此，Java 8增加了一种特殊的注解@FunctionalInterface：</p>
</blockquote>
<p><strong><em>–也就是说：这个接口里面只能够存在一个接口方法，多个就会报错</em></strong></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Functional &#123;</div><div class="line">    void method();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="认识Lambda表达式"><a href="#认识Lambda表达式" class="headerlink" title="认识Lambda表达式"></a>认识Lambda表达式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>  一、Lambda 表达式的基础语法：Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符<br>                              箭头操作符将 Lambda 表达式拆分成两部分：</p>
<p>  左侧：Lambda 表达式的参数列表<br>  右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体</p>
<blockquote>
<p>上面的例子：List<employee> list = filterEmployee(emps, (e) -&gt; e.getAge() &lt;= 35);</employee></p>
<p>第二个参数他会去找 <code>MyPredicate&lt;T&gt;</code> 接口里面的  public boolean test(T t);<br>test方法，lambda表达式左边的(e) 对应的是test方法的入参, ambda表达式右边的e.getAge() &lt;= 35 对应得是test方法的实现</p>
</blockquote>
<p><strong>那么你可能会有疑问，假设MyPredicate接口里面有很多个接口方法，那么他会去调用那个呢？他怎么知道去找test方法呢？</strong> 引入了：@FunctionalInterface这个函数式接口的概念，解决了这个问题。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> * 语法格式一：无参数，无返回值</div><div class="line"> * 		() -&gt; System.out.println(&quot;Hello Lambda!&quot;);</div><div class="line"> </div><div class="line"></div><div class="line">&gt; 例如 Runnable接口的 run方法就是无参数无返回值：</div><div class="line"></div><div class="line">	@Test</div><div class="line">	public void test1()&#123;</div><div class="line">		int num = 0;//jdk 1.7 前，我们知道匿名内部引用局部变量必须声明为final</div><div class="line">		//但jdk1.8，它默认给我们添加了final，不用显示声明。</div><div class="line">		</div><div class="line">		Runnable r = new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;Hello World!&quot; + num);</div><div class="line">				          //这里如果改为 num++是会报错的，因为他本质上是一个final</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		</div><div class="line">		r.run();</div><div class="line">		</div><div class="line">		System.out.println(&quot;-------------------------------&quot;);</div><div class="line">		</div><div class="line">		Runnable r1 = () -&gt; System.out.println(&quot;Hello Lambda!&quot;);</div><div class="line">		r1.run();</div><div class="line">	&#125;</div><div class="line">这两个是等效的</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* </div><div class="line">* 语法格式二：有一个参数，并且无返回值</div><div class="line">* 		(x) -&gt; System.out.println(x)</div><div class="line">* </div><div class="line">例子：</div><div class="line">Consumer这个类jdk自带--有参数无返回值</div><div class="line">@Test</div><div class="line">public void test2()&#123;</div><div class="line">	Consumer&lt;String&gt; con = x -&gt; System.out.println(x);</div><div class="line">	con.accept(&quot;我是你泽精哥！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* 语法格式三：若只有一个参数，小括号可以省略不写</div><div class="line">* 		x -&gt; System.out.println(x)</div><div class="line">*</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* 语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句</div><div class="line">*		Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;</div><div class="line">*			System.out.println(&quot;函数式接口&quot;);</div><div class="line">*			return Integer.compare(x, y);</div><div class="line">*		&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* 语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写</div><div class="line">* 		Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</div><div class="line">*</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* 语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”</div><div class="line">* 		(Integer x, Integer y) -&gt; Integer.compare(x, y);</div></pre></td></tr></table></figure>
<blockquote>
<p><strong><em>类型推断</em></strong> : jdk1.8后，添加了这个功能<br>String[] strs = {“aaa”, “bbb”, “ccc”} ;  它自动会转换里面的数据为String类型的数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">改为： </div><div class="line">String[] strs;</div><div class="line">strs = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;</div><div class="line">//会报错--因为这样无法进行类型推断</div></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p><strong>类型推断例子2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">	public void show(Map&lt;String, Integer&gt; map)&#123;&#125;//方法</div><div class="line">		show(new HashMap&lt;&gt;());//调用方法</div><div class="line">我们发现在调用方法的时候入参我们并没有明确声明类型，但是在jdk1.8中是可以编译通过的。这里也是运用了类型推断（注意：jdk1.7中编译会失败）</div></pre></td></tr></table></figure>
<hr>
<h3 id="热身例子一"><a href="#热身例子一" class="headerlink" title="热身例子一"></a>热身例子一</h3><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//函数是接口</div><div class="line">@FunctionalInterface</div><div class="line">public interface MyFun &#123;</div><div class="line">	public Integer getValue(Integer num);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试</div><div class="line"></div><div class="line">	//需求：对一个数进行运算</div><div class="line">	@Test</div><div class="line">	public void test6()&#123;</div><div class="line">		Integer num = operation(100, (x) -&gt; x * x);</div><div class="line">		System.out.println(num);</div><div class="line">		</div><div class="line">		System.out.println(operation(200, (y) -&gt; y + 200));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Integer operation(Integer num, MyFun mf)&#123;</div><div class="line">		return mf.getValue(num);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="热身例子二"><a href="#热身例子二" class="headerlink" title="热身例子二"></a>热身例子二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//函数接口 </div><div class="line">@FunctionalInterface //约束当前接口只能有一个方法</div><div class="line">public interface CalcLong&lt;K,T&gt;</div><div class="line">&#123;</div><div class="line">      // public K getMultiply(T t, T tt);</div><div class="line">        K getMultiply(T t, T tt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//需求：求得两个数的和</div><div class="line">        String result = getMuyl(10L,10L,(e,ee)-&gt;&#123;</div><div class="line">            System.out.println(e+ &quot;  &quot; + ee);</div><div class="line">            return e+ee+&quot;&quot;;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(result);</div><div class="line"> </div><div class="line">    </div><div class="line">    public String getMuyl(Long l,Long ll,CalcLong&lt;String,Long&gt; mf)&#123;</div><div class="line">        return mf.getMultiply(l, ll);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>看到这里可能会有疑惑？我靠，使用lambda表达式还得声明一个函数接口，这么麻烦。实际上，java内部已经帮我们实现了很多个接口供我们使用，不需要重新自己定义，除非有特别操作。</p>
</blockquote>
<hr>
<h3 id="java8内置四大函数式接口"><a href="#java8内置四大函数式接口" class="headerlink" title="java8内置四大函数式接口"></a>java8内置四大函数式接口</h3><blockquote>
<p> 为了解决接口需要自定义问题</p>
</blockquote>
<p><img src="/2017/08/29/java8新特性/内置四大函数接口.png" alt="内置四大函数接口.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*</div><div class="line"> * Java8 内置的四大核心函数式接口</div><div class="line"> * </div><div class="line"> * Consumer&lt;T&gt; : 消费型接口</div><div class="line"> * 		void accept(T t);</div><div class="line"> * </div><div class="line"> * Supplier&lt;T&gt; : 供给型接口</div><div class="line"> * 		T get(); </div><div class="line"> * </div><div class="line"> * Function&lt;T, R&gt; : 函数型接口</div><div class="line"> * 		R apply(T t);</div><div class="line"> * </div><div class="line"> * Predicate&lt;T&gt; : 断言型接口</div><div class="line"> * 		boolean test(T t);</div><div class="line"> * </div><div class="line"> */</div></pre></td></tr></table></figure>
<hr>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="消费型接口"><a href="#消费型接口" class="headerlink" title="消费型接口"></a>消费型接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Consumer&lt;T&gt; 消费型接口 :</div><div class="line">@Test</div><div class="line">public void test1()&#123;</div><div class="line">    String p;</div><div class="line">	happy(10000, (m) -&gt; System.out.println(&quot;桑拿，每次消费：&quot; + m + &quot;元&quot;));</div><div class="line">&#125; </div><div class="line"></div><div class="line">public void happy(double money, Consumer&lt;Double&gt; con)&#123;</div><div class="line">	con.accept(money);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h5 id="Supplier-供给型接口"><a href="#Supplier-供给型接口" class="headerlink" title="Supplier 供给型接口"></a>Supplier 供给型接口</h5><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Supplier&lt;T&gt; 供给型接口 :</div><div class="line">@Test</div><div class="line">public void test2()&#123;</div><div class="line">	List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100));</div><div class="line">	</div><div class="line">	for (Integer num : numList) &#123;</div><div class="line">		System.out.println(num);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//需求：产生指定个数的整数，并放入集合中</div><div class="line">public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123;</div><div class="line">	List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	for (int i = 0; i &lt; num; i++) &#123;</div><div class="line">		Integer n = sup.get();</div><div class="line">		list.add(n);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h5 id="Function-函数型接口"><a href="#Function-函数型接口" class="headerlink" title="Function 函数型接口"></a>Function 函数型接口</h5><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Function&lt;T, R&gt; 函数型接口：</div><div class="line">@Test</div><div class="line">public void test3()&#123;</div><div class="line">	String newStr = strHandler(&quot;\t\t\t 去除前后空格   &quot;, (str) -&gt; str.trim());</div><div class="line">	System.out.println(newStr);</div><div class="line">	</div><div class="line">	String subStr = strHandler(&quot;截取字符串你知不知道&quot;, (str) -&gt; str.substring(2, 5));</div><div class="line">	System.out.println(subStr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//需求：用于处理字符串</div><div class="line">public String strHandler(String str, Function&lt;String, String&gt; fun)&#123;</div><div class="line">	return fun.apply(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h5 id="Predicate-断言型接口"><a href="#Predicate-断言型接口" class="headerlink" title="Predicate 断言型接口"></a>Predicate 断言型接口</h5><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Predicate&lt;T&gt; 断言型接口：</div><div class="line">@Test</div><div class="line">public void test4()&#123;</div><div class="line">	List&lt;String&gt; list = Arrays.asList(&quot;Hello&quot;, &quot;atguigu&quot;, &quot;Lambda&quot;, &quot;www&quot;, &quot;ok&quot;);</div><div class="line">	List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; 3);</div><div class="line">	</div><div class="line">	for (String str : strList) &#123;</div><div class="line">		System.out.println(str);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//需求：将满足条件的字符串，放入集合中</div><div class="line">public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123;</div><div class="line">	List&lt;String&gt; strList = new ArrayList&lt;&gt;();</div><div class="line">	for (String str : list) &#123;</div><div class="line">		if(pre.test(str))&#123;</div><div class="line">			strList.add(str);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return strList;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="四大内置函数衍生的子函数"><a href="#四大内置函数衍生的子函数" class="headerlink" title="四大内置函数衍生的子函数"></a>四大内置函数衍生的子函数</h4><p><img src="/2017/08/29/java8新特性/四大内置函数接口的子接口.png" alt="四大内置函数接口的子接口.png"></p>
<hr>
<h1 id="二、接口的默认方法与静态方法"><a href="#二、接口的默认方法与静态方法" class="headerlink" title="二、接口的默认方法与静态方法"></a>二、接口的默认方法与静态方法</h1><blockquote>
<p>我们可以在接口中定义默认方法，使用default关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface DefaultFunctionInterface &#123;</div><div class="line">    default String defaultFunction() &#123;</div><div class="line">        return &quot;default function&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p>我们还可以在接口中定义静态方法，使用static关键字，也可以提供实现。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface StaticFunctionInterface &#123;</div><div class="line">    static String staticFunction() &#123;</div><div class="line">        return &quot;static function&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口的默认方法和静态方法的引入，其实可以认为引入了C＋＋中抽象类的理念，以后我们再也不用在每个实现类中都写重复的代码了。</p>
<hr>
<h1 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h1><blockquote>
<p>通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。一般有四种不同的方法引用：</p>
</blockquote>
<h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><hr>
<ul>
<li>构造器引用。语法是Class::new，构造器的参数列表，需要与函数式接口中参数列表保持一致！<strong><em>也就是说，决定Class::new调用那一个构造器得是：接口函数的方法的参数 </em></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//构造器引用</div><div class="line">@Test</div><div class="line">public void test7()&#123;</div><div class="line">    //  Supplier 的接口方法  T get(); --所以调用无参构造器</div><div class="line">    Supplier&lt;Employee&gt; fun0 = Employee::new;</div><div class="line">    //Function 的接口方法  R apply(T t);-调用一个参数构造器</div><div class="line">	Function&lt;String, Employee&gt; fun = Employee::new;</div><div class="line">	//BiFunction 的接口方法 R apply(T t, U u); -调用二参构造器</div><div class="line">	BiFunction&lt;String, Integer, Employee&gt; fun2 = Employee::new;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象静态方法引用（类名-静态方法）"><a href="#对象静态方法引用（类名-静态方法）" class="headerlink" title="对象静态方法引用（类名::静态方法）"></a>对象静态方法引用（类名::静态方法）</h2><hr>
<blockquote>
<ul>
<li>静态方法引用。语法是Class::static_method，要求接受一个Class类型的参数；</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//类名 :: 静态方法名</div><div class="line">//max和compare 都是静态方法</div><div class="line">@Test</div><div class="line">public void test4()&#123;</div><div class="line">	Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</div><div class="line">	System.out.println(&quot;-------------------------------------&quot;);</div><div class="line">	Comparator&lt;Integer&gt; com2 = Integer::compare;</div><div class="line">	</div><div class="line"></div><div class="line"></div><div class="line">	BiFunction&lt;Double, Double, Double&gt; fun = (x, y) -&gt; Math.max(x, y);</div><div class="line">	System.out.println(fun.apply(1.5, 22.2));</div><div class="line">	</div><div class="line">	System.out.println(&quot;------------------------------------&quot;);</div><div class="line">	</div><div class="line">	BiFunction&lt;Double, Double, Double&gt; fun2 = Math::max;</div><div class="line">	System.out.println(fun2.apply(1.2, 1.5));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="对象实例方法引用（对象引用-实例方法名）"><a href="#对象实例方法引用（对象引用-实例方法名）" class="headerlink" title="对象实例方法引用（对象引用::实例方法名）"></a>对象实例方法引用（对象引用::实例方法名）</h2><hr>
<blockquote>
<ul>
<li>特定类的任意对象方法引用。它的语法是Class::method。要求方法是没有参数的；</li>
</ul>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//对象的引用 :: 实例方法名</div><div class="line">@Test</div><div class="line">public void test2()&#123;</div><div class="line">	Employee emp = new Employee(101, &quot;张三&quot;, 18, 9999.99);</div><div class="line">	</div><div class="line">	Supplier&lt;String&gt; sup = () -&gt; emp.getName();</div><div class="line">	System.out.println(sup.get());</div><div class="line">	</div><div class="line">	System.out.println(&quot;----------------------------------&quot;);</div><div class="line">	</div><div class="line">	Supplier&lt;String&gt; sup2 = emp::getName;</div><div class="line">	System.out.println(sup2.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类名实例方法引用-类名-实例方法名"><a href="#类名实例方法引用-类名-实例方法名" class="headerlink" title="类名实例方法引用(类名::实例方法名)"></a>类名实例方法引用(类名::实例方法名)</h2><hr>
<blockquote>
<ul>
<li>我们知道一般是有对象才能够引用实例方法，但是有种特殊情况是可以直接使用类名引用实例方法<br>若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName</li>
</ul>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//类名 :: 实例方法名</div><div class="line">//按照常规是String st = new String(&quot;123&quot;); st::equals,</div><div class="line">//对象调用实例方法，但是下面因为符合第四种引用的规则，</div><div class="line">//所以可以使用类名调用实例方法</div><div class="line">@Test</div><div class="line">public void test5()&#123;</div><div class="line">//第一个参数为实例方法调用者，第二个参数为为实例方法参数</div><div class="line">	BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);</div><div class="line">	System.out.println(bp.test(&quot;abcde&quot;, &quot;abcde&quot;));</div><div class="line">	System.out.println(&quot;-------------------------------------&quot;);</div><div class="line">	</div><div class="line">BiPredicate&lt;String, String&gt; bp2 = String::equals;</div><div class="line">System.out.println(bp2.test(&quot;abc&quot;, &quot;abc&quot;));</div><div class="line">	</div><div class="line">System.out.println(&quot;---------------------------------------&quot;);</div><div class="line">	</div><div class="line">	//第一个参数为实例方法调用者，第二个参数为空</div><div class="line">Function&lt;Employee, String&gt; fun = (e) -&gt; e.show();</div><div class="line">System.out.println(fun.apply(new Employee()));</div><div class="line">System.out.println(&quot;--------------------------------------&quot;);</div><div class="line">	</div><div class="line">	Function&lt;Employee, String&gt; fun2 = Employee::show;</div><div class="line">	System.out.println(fun2.apply(new Employee()));</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 注意：</p>
<blockquote>
<p> ①方法体所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！</p>
<p>  ②若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式：ClassName::MethodName  (<strong><em>针对于第四种方法引用</em></strong>)</p>
</blockquote>
<hr>
<h2 id="数组引用（类型-new）"><a href="#数组引用（类型-new）" class="headerlink" title="数组引用（类型[] :: new）"></a>数组引用（类型[] :: new）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//数组引用</div><div class="line">@Test</div><div class="line">public void test8()&#123;</div><div class="line">	Function&lt;Integer, String[]&gt; fun = (args) -&gt; new String[args];</div><div class="line">	String[] strs = fun.apply(10);</div><div class="line">	System.out.println(strs.length);</div><div class="line">	</div><div class="line">	System.out.println(&quot;--------------------------&quot;);</div><div class="line">	</div><div class="line">	Function&lt;Integer, Employee[]&gt; fun2 = Employee[] :: new;</div><div class="line">	Employee[] emps = fun2.apply(20);</div><div class="line">	System.out.println(emps.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="四、重复注解"><a href="#四、重复注解" class="headerlink" title="四、重复注解"></a>四、重复注解</h1><p>在Java 5中使用注解有一个限制，即相同的注解在同一位置只能声明一次。Java 8引入重复注解，这样相同的注解在同一地方也可以声明多次。重复注解机制本身需要用@Repeatable注解。Java 8在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。</p>
<h1 id="五、扩展注解的支持"><a href="#五、扩展注解的支持" class="headerlink" title="五、扩展注解的支持"></a>五、扩展注解的支持</h1><p>Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。</p>
<h1 id="六、Optional"><a href="#六、Optional" class="headerlink" title="六、Optional"></a>六、Optional</h1><p>Java 8引入Optional类来防止空指针异常，Optional类最先是由Google的Guava项目引入的。Optional类实际上是个容器：它可以保存类型T的值，或者保存null。使用Optional类我们就不用显式进行空指针检查了。</p>
<h1 id="七、Stream"><a href="#七、Stream" class="headerlink" title="七、Stream"></a>七、Stream</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Stream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce，当然Google的MapReduce的灵感也是来自函数式编程。她其实是一连串支持连续、并行聚集操作的元素。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！</p>
</blockquote>
<hr>
<p><img src="/2017/08/29/java8新特性/stream前言.png" alt="stream前言.png"></p>
<hr>
<p><img src="/2017/08/29/java8新特性/stream概念一.png" alt="stream概念一.png"></p>
<hr>
<p><img src="/2017/08/29/java8新特性/stream概念二.png" alt="stream概念二.png"></p>
<hr>
<h1 id="八、Date-Time-API-JSR-310"><a href="#八、Date-Time-API-JSR-310" class="headerlink" title="八、Date/Time API (JSR 310)"></a>八、Date/Time API (JSR 310)</h1><p>Java 8新的Date-Time API (JSR 310)受Joda-Time的影响，提供了新的java.time包，可以用来替代 java.util.Date和java.util.Calendar。一般会用到Clock、LocaleDate、LocalTime、LocaleDateTime、ZonedDateTime、Duration这些类，对于时间日期的改进还是非常不错的。</p>
<h1 id="九、JavaScript引擎Nashorn"><a href="#九、JavaScript引擎Nashorn" class="headerlink" title="九、JavaScript引擎Nashorn"></a>九、JavaScript引擎Nashorn</h1><p>Nashorn允许在JVM上开发运行JavaScript应用，允许Java与JavaScript相互调用。</p>
<h1 id="十、Base64"><a href="#十、Base64" class="headerlink" title="十、Base64"></a>十、Base64</h1><p>在Java 8中，Base64编码成为了Java类库的标准。Base64类同时还提供了对URL、MIME友好的编码器与解码器。</p>
<p>除了这十大新特性之外，还有另外的一些新特性：</p>
<ul>
<li><p>更好的类型推测机制：Java 8在类型推测方面有了很大的提高，这就使代码更整洁，不需要太多的强制类型转换了。</p>
</li>
<li><p>编译器优化：Java 8将方法的参数名加入了字节码中，这样在运行时通过反射就能获取到参数名，只需要在编译时使用-parameters参数。</p>
</li>
<li><p>并行（parallel）数组：支持对数组进行并行处理，主要是parallelSort()方法，它可以在多核机器上极大提高数组排序的速度。</p>
</li>
<li><p>并发（Concurrency）：在新增Stream机制与Lambda的基础之上，加入了一些新方法来支持聚集操作。</p>
</li>
<li><p>Nashorn引擎jjs：基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。</p>
</li>
<li><p>类依赖分析器jdeps：可以显示Java类的包级别或类级别的依赖。</p>
</li>
<li><p>JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122），元空间直接采用的是物理空间，也即是我们电脑的内存，电脑内存多大，元空间就有多大。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8可谓是自Java 5以来最具革命性的版本了，她在语言、编译器、类库、开发工具以及Java虚拟机等方面都带来了不少新特性。&lt;br&gt;我们来一一回顾一下这些特性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/08/29/java8新特性/java8特性简介.png&quot;
    
    </summary>
    
      <category term="Java8" scheme="http://kingge.top/categories/Java8/"/>
    
    
      <category term="java" scheme="http://kingge.top/tags/java/"/>
    
      <category term="java8" scheme="http://kingge.top/tags/java8/"/>
    
      <category term="java8新特性" scheme="http://kingge.top/tags/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>哈希表冲突解决方式之开放地址法和链地址法</title>
    <link href="http://kingge.top/2017/08/29/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E5%92%8C%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95/"/>
    <id>http://kingge.top/2017/08/29/哈希表冲突解决方式之开放地址法和链地址法/</id>
    <published>2017-08-29T03:07:51.000Z</published>
    <updated>2017-08-29T03:56:03.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>基本定义</p>
<p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字key对应一个存储位置f(key)。<br> 这种对应关系f称为<strong><em>散列或哈希函数</em></strong></p>
<p>采用上述思想将数据存储在一块连续的存储空间中，这块连续的存储空间<strong><em>称为散列或哈希表</em></strong></p>
<p>关键字对应的存储位置称为<strong><em>散列地址</em></strong></p>
<p>如果碰到两个不同的关键字key1≠key2，但却有相同的f(key1)=f(key2)，这种现象称为<strong><em>冲突</em></strong>，<br> 并把key1和key2 称为这个散列函数的同义词（synonym）</p>
</blockquote>
<h1 id="散列函数构造方法"><a href="#散列函数构造方法" class="headerlink" title="散列函数构造方法"></a>散列函数构造方法</h1><p>好的散列函数参考如下两个原则：</p>
<ul>
<li>计算简单</li>
<li>散列地址分布均匀</li>
</ul>
<p>最常用的方法是除留余数法，对于散列表长度为m的散列函数是 f(key)=key mod p (p≤m)</p>
<h1 id="处理散列冲突"><a href="#处理散列冲突" class="headerlink" title="处理散列冲突"></a>处理散列冲突</h1><ul>
<li><p>开放地址法</p>
<blockquote>
<p>开放地址法就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列表总能找到，并存入。<br>开放地址法又分为线性探测法，二次探测法和随机探测法。 </p>
</blockquote>
</li>
<li><p>链地址法</p>
<blockquote>
<p>将所有同义词的关键字存储在同一个单链表中，称这个单链表为同义词子表，在散列表中只存储同义词子表的头指针。<br>只要有冲突，就在同义词的子表中增加结点。(java中的HashMap就是采用这种方法)</p>
</blockquote>
</li>
</ul>
<h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本定义&lt;/p&gt;
&lt;p&gt;散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字key对应一个存储位置f(key)。&lt;br&gt; 这种对应关系f称为&lt;strong&gt;&lt;em&gt;散列或哈希函数&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="数据结构" scheme="http://kingge.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="java" scheme="http://kingge.top/tags/java/"/>
    
      <category term="数据结构" scheme="http://kingge.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="http://kingge.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="哈希解决冲突" scheme="http://kingge.top/tags/%E5%93%88%E5%B8%8C%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/"/>
    
  </entry>
  
  <entry>
    <title>java8之Hashmap</title>
    <link href="http://kingge.top/2017/08/28/java8%E4%B9%8BHashmap/"/>
    <id>http://kingge.top/2017/08/28/java8之Hashmap/</id>
    <published>2017-08-28T14:27:16.000Z</published>
    <updated>2017-08-29T08:08:38.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java8-HashMap变化"><a href="#Java8-HashMap变化" class="headerlink" title="Java8-HashMap变化"></a>Java8-HashMap变化</h1><blockquote>
<p>数据的存储结构从：<strong><strong>数组+链表</strong></strong>  演变为了 <strong><strong>数组+链表+红黑树</strong></strong></p>
</blockquote>
<h1 id="Map-家庭族谱"><a href="#Map-家庭族谱" class="headerlink" title="Map 家庭族谱"></a>Map 家庭族谱</h1><p><img src="/2017/08/28/java8之Hashmap/java.util.map类图.png" alt="Map" title="HashMap"></p>
<ul>
<li><p>HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap<strong>非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果<strong>需要满足线程安全</strong>，可以用<strong> Collections的synchronizedMap方法使HashMap具有线程安全的能力</strong>，或者使用<strong>ConcurrentHashMap</strong>。</p>
</li>
<li><p>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
</li>
<li><p>LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
</li>
<li><p>TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<p>通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><blockquote>
<p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>我们知道HashMap的数据存储结构就是：数组加上链表。通过对于key的值做hash运算，获得对应的值找到对应的数组下标，然后再存储值。存储值的过程中可能当前数组已经存在值（这个称之为冲突） 然后再生成一个链表存储冲突的值。</p>
<blockquote>
<p>HashCode() 和 Hash() 方法实现得足够好，能够尽可能地减少冲突的产生，那么对 HashMap 的操作几乎等价于对数组的随机访问操作，具有很好的性能。但是，如果 HashCode() 或者 Hash() 方法实现较差，在大量冲突产生的情况下，HashMap 事实上就退化为几个链表，对 HashMap 的操作等价于遍历链表，此时性能很差。</p>
</blockquote>
</blockquote>
<p>解决冲突的方法：<a href="/2017/08/29/哈希表冲突解决方式之开放地址法和链地址法"><strong><em>开放地址法和链地址法</em></strong></a></p>
<h1 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h1><ul>
<li>允许null为key</li>
<li><p>输出无序</p>
<blockquote>
<p>如果想要输出有序，那以使用继承他的LinkedHashMap，<strong>元素输出顺序跟输入顺序一致</strong>,他提供了一个节点保存输入的元素的顺序。<br>想要对<strong>元素的值进行排序</strong> 推荐TreeMap（因为他继承了SortedMap)</p>
</blockquote>
</li>
<li><p>非线程安全</p>
</li>
<li><p>数组+链表存储方式<br><img src="/2017/08/28/java8之Hashmap/2012122409394770.png" alt="hashMap内存结构图" title="HashMap"></p>
</li>
</ul>
<h1 id="Java8特性"><a href="#Java8特性" class="headerlink" title="Java8特性"></a>Java8特性</h1><blockquote>
<p>HashMap是数组+链表+红黑树</p>
</blockquote>
<p><img src="/2017/08/28/java8之Hashmap/hashMap内存结构图.png" alt="hashMap内存结构图" title="HashMap"></p>
<blockquote>
<p>存储算法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">map.put(&quot;kingge&quot;,&quot;shuai&quot;)</div><div class="line"></div><div class="line">系统将调用kingge”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</div></pre></td></tr></table></figure>
<p><img src="/2017/08/28/java8之Hashmap/QQ截图20170829143321.png" alt="高位运算和取模运算" title="HashMap"></p>
<blockquote>
<p><strong><strong>好的hash算法和扩容机制是解决冲突和高效存取的命题</strong></strong></p>
</blockquote>
<h2 id="HashMap-重要的几个属性"><a href="#HashMap-重要的几个属性" class="headerlink" title="HashMap 重要的几个属性"></a>HashMap 重要的几个属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int threshold;             // 所能容纳的key-value对极限 </div><div class="line">final float loadFactor;    // 负载因子</div><div class="line">int modCount;  </div><div class="line">int size;</div></pre></td></tr></table></figure>
<blockquote>
<p>Node[] table(Hash桶)始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
</blockquote>
<hr>
<blockquote>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
</blockquote>
<hr>
<blockquote>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p>
</blockquote>
<h2 id="分析HashMap的put方法"><a href="#分析HashMap的put方法" class="headerlink" title="分析HashMap的put方法"></a>分析HashMap的put方法</h2><p>put方法图解，详情可以去看源码</p>
<p><img src="/2017/08/28/java8之Hashmap/hashMapput方法执行流程图.png" alt="hashMapput方法执行流程图" title="HashMap"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">      // 对key的hashCode()做hash</div><div class="line">      return putVal(hash(key), key, value, false, true);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">                 boolean evict) &#123;</div><div class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">      // 步骤①：tab为空则创建</div><div class="line">     if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">         n = (tab = resize()).length;</div><div class="line">     // 步骤②：计算index，并对null做处理 </div><div class="line">     if ((p = tab[i = (n - 1) &amp; hash]) == null) </div><div class="line">         tab[i] = newNode(hash, key, value, null);</div><div class="line">     else &#123;</div><div class="line">         Node&lt;K,V&gt; e; K k;</div><div class="line">         // 步骤③：节点key存在，直接覆盖value</div><div class="line">         if (p.hash == hash &amp;&amp;</div><div class="line">             ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">             e = p;</div><div class="line">         // 步骤④：判断该链为红黑树</div><div class="line">         else if (p instanceof TreeNode)</div><div class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div class="line">         // 步骤⑤：该链为链表</div><div class="line">         else &#123;</div><div class="line">             for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                 if ((e = p.next) == null) &#123;</div><div class="line">                     p.next = newNode(hash, key,value,null);</div><div class="line">                        //链表长度大于8转换为红黑树进行处理</div><div class="line">                     if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  </div><div class="line">                         treeifyBin(tab, hash);</div><div class="line">                     break;</div><div class="line">                 &#125;</div><div class="line">                    // key已经存在直接覆盖value</div><div class="line">                 if (e.hash == hash &amp;&amp;</div><div class="line">                     ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                                            break;</div><div class="line">                 p = e;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">        </div><div class="line">         if (e != null) &#123; // existing mapping for key</div><div class="line">             V oldValue = e.value;</div><div class="line">             if (!onlyIfAbsent || oldValue == null)</div><div class="line">                 e.value = value;</div><div class="line">             afterNodeAccess(e);</div><div class="line">             return oldValue;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     ++modCount;</div><div class="line">     // 步骤⑥：超过最大容量 就扩容</div><div class="line">     if (++size &gt; threshold)</div><div class="line">         resize();</div><div class="line">     afterNodeInsertion(evict);</div><div class="line">     return null;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="为什么说HashMap是线程不安全的"><a href="#为什么说HashMap是线程不安全的" class="headerlink" title="为什么说HashMap是线程不安全的"></a>为什么说HashMap是线程不安全的</h2><blockquote>
<p>个人觉得有两个表现，如果还有其他的希望大家补充，或者以后等楼主源码研究透了再补充</p>
</blockquote>
<h3 id="表现一"><a href="#表现一" class="headerlink" title="表现一"></a>表现一</h3><blockquote>
<p>我们知道当插入数据超过了threshold(threshold=length * Load factor),那么就会扩容，扩容会去调用resize和transfer方法，这个时候原先hash桶里面的所有数据都会重新计算，对应的位置–称之为rehash，这个成本很大</p>
</blockquote>
<hr>
<blockquote>
<p>最根本的原因是出现时死循环-也就是在死锁问题出现在了transfer方法上面,而且是因为在扩容转换的过程中采用的是链表的头插法的形式<br>进行插入数据。例如原来在数组arr[0]的位置又链表1–&gt;2–&gt;3 那么扩容后，采用头插法就变成了arr[0]：3–&gt;2–&gt;1</p>
<p>为什么采用头插法，因为时间复杂度为O(1)，想象一下尾插法，那么需要遍历找到最尾元素然后插入时间复杂度是O(n)</p>
</blockquote>
<hr>
<p>具体源码分析参见：<a href="http://www.importnew.com/22011.html" target="_blank" rel="external">http://www.importnew.com/22011.html</a></p>
<h3 id="表现二"><a href="#表现二" class="headerlink" title="表现二"></a>表现二</h3><p>多个线程同时操作一个hashmap就可能出现不安全的情况：<br>比如A B两个线程(A线程获数据 B线程存数据) 同时操作myHashMap<br>1.B线程执行存放数据<br>modelHashMap.put(“1”,”2”);<br>2.A线程执行get获取数据<br>modelHashMap.get(“1”)<br>A线程获取的值本来应该是2，但是如果A线程在刚到达获取的动作还没执行的时候，<br>线程执行的机会又跳到线程B，此时线程B又对modelHashMap赋值 如：modelHashMap.put(“1”,”3”);<br>然后线程虚拟机又执行线程A，A取到的值为3，这样map中第一个存放的值 就会丢失。。。。。<br>—原子性</p>
<h2 id="解决HashMap非线程安全"><a href="#解决HashMap非线程安全" class="headerlink" title="解决HashMap非线程安全"></a>解决HashMap非线程安全</h2><p>其实上面我已经有提过了：</p>
<p> 三个方法：</p>
<ul>
<li><p>Hashtable替换HashMap</p>
</li>
<li><p>Collections.synchronizedMap将HashMap包装起来</p>
</li>
</ul>
<blockquote>
<p>private Map map = Collections.synchronizedMap(new HashMap());<br>替换<br>private HashMap map = new HashMap();</p>
</blockquote>
<ul>
<li>ConcurrentHashMap替换HashMap</li>
</ul>
<blockquote>
<p>private ConcurrentHashMap map = new ConcurrentHashMap();<br>替换<br>private HashMap map = new HashMap();</p>
</blockquote>
<h1 id="好的博文"><a href="#好的博文" class="headerlink" title="好的博文"></a>好的博文</h1><p><a href="http://blog.csdn.net/lyg468088/article/details/49464121" target="_blank" rel="external">http://blog.csdn.net/lyg468088/article/details/49464121</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java8-HashMap变化&quot;&gt;&lt;a href=&quot;#Java8-HashMap变化&quot; class=&quot;headerlink&quot; title=&quot;Java8-HashMap变化&quot;&gt;&lt;/a&gt;Java8-HashMap变化&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;数据的存储
    
    </summary>
    
      <category term="Java8" scheme="http://kingge.top/categories/Java8/"/>
    
    
      <category term="java" scheme="http://kingge.top/tags/java/"/>
    
      <category term="java8" scheme="http://kingge.top/tags/java8/"/>
    
      <category term="java8新特性" scheme="http://kingge.top/tags/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>程序员未来规划</title>
    <link href="http://kingge.top/2017/08/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92/"/>
    <id>http://kingge.top/2017/08/28/程序员未来规划/</id>
    <published>2017-08-28T02:00:36.000Z</published>
    <updated>2017-08-28T02:06:13.437Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/9d29a441ee17?utm_source=desktop&amp;utm_medium=timeline" target="_blank" rel="external">http://www.jianshu.com/p/9d29a441ee17?utm_source=desktop&amp;utm_medium=timeline</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/9d29a441ee17?utm_source=desktop&amp;amp;utm_medium=timeline&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jian
    
    </summary>
    
      <category term="心情" scheme="http://kingge.top/categories/%E5%BF%83%E6%83%85/"/>
    
    
      <category term="心情" scheme="http://kingge.top/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="大龄程序员" scheme="http://kingge.top/tags/%E5%A4%A7%E9%BE%84%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="规划" scheme="http://kingge.top/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>java之ClassLoader源码分析</title>
    <link href="http://kingge.top/2017/08/24/java%E4%B9%8BClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://kingge.top/2017/08/24/java之ClassLoader源码分析/</id>
    <published>2017-08-24T06:36:35.000Z</published>
    <updated>2017-08-24T08:36:55.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载器ClassLoader的含义"><a href="#类加载器ClassLoader的含义" class="headerlink" title="类加载器ClassLoader的含义"></a>类加载器ClassLoader的含义</h1><blockquote>
<p>不论多么简单的java程序，都是由一个或者多个java文件组成，java内部实现了程序所需要的功能逻辑，类之间可能还存在着依赖关系。当程序运行的时候，类加载器会把<strong>一部分</strong>类编译为class后加载到内存中，这样程序才能够调用里面的方法并运行。</p>
</blockquote>
<hr>
<blockquote>
<p>类之间如果存在依赖关系，那么类加载会去帮你加载相关的类到内存中，这样才能够完成调用。如果找不到相关的类，那么他就会抛出我们在开发经常见到的异常：<strong><em>ClassNotFoundException</em></strong></p>
</blockquote>
<hr>
<blockquote>
<p>Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，JVM在加载类的时候，都是通过ClassLoader的loadClass（）方法来加载class的,<strong><em>与此同时在loadClass中存在着三种加载策略</em></strong>，loadClass使用<strong>双亲委派模式</strong>。</p>
</blockquote>
<hr>
<blockquote>
<p><strong><em>所以Classloader就是用来动态加载Class文件到内存当中用的。</em></strong></p>
</blockquote>
<h1 id="Java默认提供的三个ClassLoader"><a href="#Java默认提供的三个ClassLoader" class="headerlink" title="Java默认提供的三个ClassLoader"></a>Java默认提供的三个ClassLoader</h1><h2 id="1-Bootstrap-ClassLoader"><a href="#1-Bootstrap-ClassLoader" class="headerlink" title="1.Bootstrap ClassLoader"></a><strong>1.Bootstrap ClassLoader</strong></h2><blockquote>
<p>称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，预设上它负责搜寻JRE所在目录的classes或lib目录下（实际上是由系统参数sun.boot.class.path指定）。如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;  </div><div class="line">        System.out.println(urls[i].toExternalForm());  </div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&gt; 这两种输出的内容都是一样的。</div><div class="line">    System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">file:/F:/JDK/jdk1.8/jre/lib/resources.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/rt.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/sunrsasign.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/jsse.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/jce.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/charsets.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/jfr.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/classes</div><div class="line"></div><div class="line">F:\JDK\jdk1.8\jre\lib\resources.jar;F:\JDK\jdk1.8\jre\lib\rt.jar;F:\JDK\jdk1.8\jre\lib\sunrsasign.jar;F:\JDK\jdk1.8\jre\lib\jsse.jar;F:\JDK\jdk1.8\jre\lib\jce.jar;F:\JDK\jdk1.8\jre\lib\charsets.jar;F:\JDK\jdk1.8\jre\lib\jfr.jar;F:\JDK\jdk1.8\jre\classes</div></pre></td></tr></table></figure>
<h2 id="2-Extension-ClassLoader"><a href="#2-Extension-ClassLoader" class="headerlink" title="2.Extension ClassLoader"></a><strong>2.Extension ClassLoader</strong></h2><blockquote>
<p>称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar（实际上是由系统参数java.ext.dirs指定）</p>
</blockquote>
<h2 id="3-App-ClassLoader"><a href="#3-App-ClassLoader" class="headerlink" title="3.App ClassLoader"></a><strong>3.App ClassLoader</strong></h2><blockquote>
<p>称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件（由系统参数java.class.path指定）</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote>
<p>Extension ClassLoader和App ClassLoader 这两个类加载器实际上都是继承了ClassLoader类，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器，也就是说：</p>
<blockquote>
<blockquote>
<p>Bootstrap Loader会在JVM启动之后载入，之后它会载入ExtClassLoader并将ExtClassLoader的parent设为Bootstrap Loader，然后BootstrapLoader再加载AppClassLoader，并将AppClassLoader的<strong>parent</strong>设定为 ExtClassLoader。</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="ClassLoader加载类的原理"><a href="#ClassLoader加载类的原理" class="headerlink" title="ClassLoader加载类的原理"></a><strong>ClassLoader加载类的原理</strong></h1><h2 id="双亲委托加载模式"><a href="#双亲委托加载模式" class="headerlink" title="双亲委托加载模式"></a><strong>双亲委托加载模式</strong></h2><blockquote>
<p>我们知道除了顶级的 Bootstrap Loader他的parent属性为null之外，其他的两个或者自定义的类加载器都是存在parent 的。</p>
</blockquote>
<hr>
<blockquote>
<p>当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，<strong>先把</strong>这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象<br><img src="/2017/08/24/java之ClassLoader源码分析/1807893f814129fdbae5ad6.png" alt="类加载顺序" title="类加载顺序"></p>
</blockquote>
<h2 id="为什么要使用双亲委托这种模型呢"><a href="#为什么要使用双亲委托这种模型呢" class="headerlink" title="为什么要使用双亲委托这种模型呢"></a><strong>为什么要使用双亲委托这种模型呢</strong></h2><blockquote>
<p>java是一门具有很高的安全性的语言，使用这种加载策略的目的是为了：防止重载，父类如果已经找到了需要的类并加载到了内存，那么子类加载器就不需要再去加载该类。安全性问题。两个原因</p>
</blockquote>
<h2 id="JVM在搜索类的时候，又是如何判定两个class是相同的"><a href="#JVM在搜索类的时候，又是如何判定两个class是相同的" class="headerlink" title="JVM在搜索类的时候，又是如何判定两个class是相同的"></a><strong>JVM在搜索类的时候，又是如何判定两个class是相同的</strong></h2><ul>
<li>类名是否相同</li>
<li>否由同一个类加载器实例加载</li>
</ul>
<h2 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a><strong>看一个例子</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoader</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">       </div><div class="line">        ClassLoader loader = TestClassLoader.class.getClassLoader();    <span class="comment">//获得加载ClassLoaderTest.class这个类的类加载器  </span></div><div class="line">        <span class="keyword">while</span>(loader != <span class="keyword">null</span>) &#123;  </div><div class="line">            System.out.println(loader);  </div><div class="line">            loader = loader.getParent();    <span class="comment">//获得父类加载器的引用  </span></div><div class="line">        &#125;  </div><div class="line">        System.out.println(loader);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@2a139a55</div><div class="line">sun.misc.Launcher$ExtClassLoader@7852e922</div><div class="line">null</div></pre></td></tr></table></figure>
<p>结论</p>
<blockquote>
<p>第一行结果说明：ClassLoaderTest的类加载器是AppClassLoader。</p>
<p>第二行结果说明：AppClassLoader的类加器是ExtClassLoader，即parent=ExtClassLoader。</p>
<p>第三行结果说明：ExtClassLoader的类加器是Bootstrap ClassLoader，因为Bootstrap ClassLoader不是一个普通的Java类，所以ExtClassLoader的parent=null，所以第三行的打印结果为null就是这个原因。</p>
</blockquote>
<p>测试2</p>
<blockquote>
<p>将ClassLoaderTest.class打包成ClassLoaderTest.jar，放到Extension ClassLoader的加载目录下（JAVA_HOME/jre/lib/ext），然后重新运行这个程序，得到的结果会是什么样呢？</p>
</blockquote>
<hr>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sun.misc.Launcher$ExtClassLoader@7852e922</div><div class="line">null</div></pre></td></tr></table></figure>
<p>结果分析：</p>
<blockquote>
<p>为什么第一行的结果是ExtClassLoader呢？</p>
<p>因为ClassLoader的委托模型机制，当我们要用ClassLoaderTest.class这个类的时候，AppClassLoader在试图加载之前，先委托给Bootstrcp ClassLoader，Bootstracp ClassLoader发现自己没找到，它就告诉ExtClassLoader，兄弟，我这里没有这个类，你去加载看看，然后Extension ClassLoader拿着这个类去它指定的类路径（JAVA_HOME/jre/lib/ext）试图加载，唉，它发现在ClassLoaderTest.jar这样一个文件中包含ClassLoaderTest.class这样的一个文件，然后它把找到的这个类加载到内存当中，并生成这个类的Class实例对象，最后把这个实例返回。所以ClassLoaderTest.class的类加载器是ExtClassLoader。</p>
<p>第二行的结果为null，是因为ExtClassLoader的父类加载器是Bootstrap ClassLoader。</p>
</blockquote>
<p>测试3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">用Bootstrcp ClassLoader来加载ClassLoaderTest.class，有两种方式：</div><div class="line"></div><div class="line">1、在jvm中添加-Xbootclasspath参数，指定Bootstrcp ClassLoader加载类的路径，并追加我们自已的jar（ClassTestLoader.jar）</div><div class="line"></div><div class="line">2、将class文件放到JAVA_HOME/jre/classes/目录下（上面有提到）(将ClassLoaderTest.jar解压后，放到JAVA_HOME/jre/classes目录下，如下图所示：)</div><div class="line">提示：jre目录下默认没有classes目录，需要自己手动创建一个</div><div class="line"></div><div class="line"></div><div class="line">提供者：Java团长</div></pre></td></tr></table></figure>
<p><img src="/2017/08/24/java之ClassLoader源码分析/1807893-362b2865ac4badae.jpg" alt=""></p>
<h1 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a><strong>自定义ClassLoader</strong></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><blockquote>
<p>实现自定义类加载的目的是，假设我们的类他不是存在特定的位置，可能是某个磁盘或者某个远程服务器上面，那么我们就需要自定义类加载器去加载这些类。</p>
</blockquote>
<ul>
<li><p>继承继承java.lang.ClassLoader</p>
</li>
<li><p>重写父类的findClass方法</p>
</li>
<li><p>在findClass()方法中调用defineClass()。</p>
</li>
</ul>
<p>这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常</p>
<p>注意： 一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。</p>
<blockquote>
<p>为什么不去重定义loadClass方法呢？其实也可以，但是loadClass方法内部已经实现了搜索类的策略。除非你是非常熟悉否则还是不建议这样去做。这里建议重载findClass方法，因为在loadClass中最后会去调用findClass方法去加载类。而且这个方法内部默认是空的。</p>
</blockquote>
<h2 id="分析loadClass方法"><a href="#分析loadClass方法" class="headerlink" title="分析loadClass方法"></a><strong>分析loadClass方法</strong></h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"></div><div class="line"></div><div class="line">*</div><div class="line"> A class loader is an object that is responsible for loading classes. The</div><div class="line"> class ClassLoader is an abstract class.  Given the binary name of a class, a class loader should attempt to</div><div class="line"> locate or generate data that constitutes a definition for the class.  A</div><div class="line"> typical strategy is to transform the name into a file name and then read a</div><div class="line"> &quot;class file&quot; of that name from a file system.</div><div class="line">**/</div></pre></td></tr></table></figure>
<p>大致意思如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class loader是一个负责加载classes的对象，ClassLoader类是一个抽象类，需要给出类的二进制名称，class loader尝试定位或者产生一个class的数据，一个典型的策略是把二进制名字转换成文件名然后到文件系统中找到该文件。</div></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">protected synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException&#123;  </div><div class="line">         // 首先检查该name指定的class是否有被加载  </div><div class="line">         Class c = findLoadedClass(name);  </div><div class="line">         if (c == null) &#123;  </div><div class="line">             try &#123;  </div><div class="line">                 if (parent != null) &#123;  </div><div class="line">                     //如果parent不为null，则调用parent的loadClass进行加载  </div><div class="line">                     c = parent.loadClass(name, false);  </div><div class="line">                 &#125;else&#123;  </div><div class="line">                     //parent为null，则调用BootstrapClassLoader进行加载  </div><div class="line">                     c = findBootstrapClass0(name);  </div><div class="line">                 &#125;  </div><div class="line">             &#125;catch(ClassNotFoundException e) &#123;  </div><div class="line">                 //如果仍然无法加载成功，则调用自身的findClass进行加载              </div><div class="line">                 c = findClass(name);  //</div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">         if (resolve) &#123;  </div><div class="line">             resolveClass(c);  </div><div class="line">         &#125;  </div><div class="line">         return c;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.com;</div><div class="line"></div><div class="line">import java.io.ByteArrayOutputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">public class PersonalClassLoader extends ClassLoader&#123;</div><div class="line">    private String rootUrl;  </div><div class="line"></div><div class="line">    public PersonalClassLoader(String rootUrl) &#123;  </div><div class="line">        this.rootUrl = rootUrl;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </div><div class="line">        Class clazz = null;//this.findLoadedClass(name); // 父类已加载     </div><div class="line">        //if (clazz == null) &#123;  //检查该类是否已被加载过  </div><div class="line">            byte[] classData = getClassData(name);  //根据类的二进制名称,获得该class文件的字节码数组  </div><div class="line">            if (classData == null) &#123;  </div><div class="line">                throw new ClassNotFoundException();  </div><div class="line">            &#125;  </div><div class="line">            clazz = defineClass(name, classData, 0, classData.length);  //将class的字节码数组转换成Class类的实例  </div><div class="line">          //ClassLoader内置方法</div><div class="line">             /*        * Converts an array of bytes into an instance of class </div><div class="line">        * Before the &lt;tt&gt;Class&lt;/tt&gt; can be used it must be resolved.*/</div><div class="line">        //&#125;   </div><div class="line">        return clazz;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    private byte[] getClassData(String name) &#123;  </div><div class="line">        InputStream is = null;  </div><div class="line">        try &#123;  </div><div class="line">            String path = classNameToPath(name);  </div><div class="line">            URL url = new URL(path);  </div><div class="line">            byte[] buff = new byte[1024*4];  </div><div class="line">            int len = -1;  </div><div class="line">            is = url.openStream();  </div><div class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();  </div><div class="line">            while((len = is.read(buff)) != -1) &#123;  </div><div class="line">                baos.write(buff,0,len);  </div><div class="line">            &#125;  </div><div class="line">            return baos.toByteArray();  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            if (is != null) &#123;  </div><div class="line">               try &#123;  </div><div class="line">                  is.close();  </div><div class="line">               &#125; catch(IOException e) &#123;  </div><div class="line">                  e.printStackTrace();  </div><div class="line">               &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return null;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    private String classNameToPath(String name) &#123;  </div><div class="line">        return rootUrl + &quot;/&quot; + name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.com;</div><div class="line"></div><div class="line">public class ClassLoaderTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        try &#123;  </div><div class="line">            /*ClassLoader loader = ClassLoaderTest.class.getClassLoader();  //获得ClassLoaderTest这个类的类加载器 </div><div class="line">            while(loader != null) &#123; </div><div class="line">                System.out.println(loader); </div><div class="line">                loader = loader.getParent();    //获得父加载器的引用 </div><div class="line">            &#125; </div><div class="line">            System.out.println(loader);*/  </div><div class="line"></div><div class="line">            String rootUrl = &quot;http://localhost:8080/console/res&quot;;  </div><div class="line">            PersonalClassLoader networkClassLoader = new PersonalClassLoader(rootUrl);  </div><div class="line">            String classname = &quot;HelloWorld&quot;;  </div><div class="line">            Class clazz = networkClassLoader.loadClass(classname);  </div><div class="line">            System.out.println(clazz.getClassLoader());  </div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>com.kingge.com.PersonalClassLoader@65b54208</p>
</blockquote>
<p>其中HelloWorld.class文件的位置在于：<br><img src="/2017/08/24/java之ClassLoader源码分析/HelloWorld类的位置.png" alt="HelloWorld类" title="HelloWorld类"></p>
<h3 id="其实很多服务器都自定义了类加载器"><a href="#其实很多服务器都自定义了类加载器" class="headerlink" title="其实很多服务器都自定义了类加载器"></a><strong>其实很多服务器都自定义了类加载器</strong></h3><blockquote>
<p>用于加载web应用指定目录下的类库（jar或class），如：Weblogic、Jboss、tomcat等，下面我以Tomcat为例，展示该web容器都定义了哪些个类加载器：</p>
</blockquote>
<p>下面以tomcat为例子</p>
<ul>
<li>1、新建一个web工程httpweb</li>
<li>2、新建一个ClassLoaderServletTest，用于打印web容器中的ClassLoader层次结构</li>
</ul>
<p>一下代码来自网上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.io.IOException;  </div><div class="line">import java.io.PrintWriter;  </div><div class="line"></div><div class="line">import javax.servlet.ServletException;  </div><div class="line">import javax.servlet.http.HttpServlet;  </div><div class="line">import javax.servlet.http.HttpServletRequest;  </div><div class="line">import javax.servlet.http.HttpServletResponse;  </div><div class="line"></div><div class="line">public class ClassLoaderServletTest extends HttpServlet &#123;  </div><div class="line"></div><div class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response)  </div><div class="line">            throws ServletException, IOException &#123;  </div><div class="line"></div><div class="line">        response.setContentType(&quot;text/html&quot;);  </div><div class="line">        PrintWriter out = response.getWriter();  </div><div class="line">        ClassLoader loader = this.getClass().getClassLoader();  </div><div class="line">        while(loader != null) &#123;  </div><div class="line">            out.write(loader.getClass().getName()+&quot;&lt;br/&gt;&quot;);  </div><div class="line">            loader = loader.getParent();  </div><div class="line">        &#125;  </div><div class="line">        out.write(String.valueOf(loader));  </div><div class="line">        out.flush();  </div><div class="line">        out.close();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response)  </div><div class="line">            throws ServletException, IOException &#123;  </div><div class="line">        this.doGet(request, response);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<ul>
<li>3、配置Servlet，并启动服务</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </div><div class="line">&lt;web-app version=&quot;2.4&quot;   </div><div class="line">    xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;   </div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   </div><div class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee   </div><div class="line"></div><div class="line">http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;</div><div class="line"></div><div class="line">  &lt;servlet&gt;  </div><div class="line">    &lt;servlet-name&gt;ClassLoaderServletTest&lt;/servlet-name&gt;  </div><div class="line">    &lt;servlet-class&gt;ClassLoaderServletTest&lt;/servlet-class&gt;  </div><div class="line">  &lt;/servlet&gt;  </div><div class="line"></div><div class="line">  &lt;servlet-mapping&gt;  </div><div class="line">    &lt;servlet-name&gt;ClassLoaderServletTest&lt;/servlet-name&gt;  </div><div class="line">    &lt;url-pattern&gt;/servlet/ClassLoaderServletTest&lt;/url-pattern&gt;  </div><div class="line">  &lt;/servlet-mapping&gt;  </div><div class="line">  &lt;welcome-file-list&gt;  </div><div class="line">    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;  </div><div class="line">  &lt;/welcome-file-list&gt;  </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>运行截图：</p>
<p><img src="/2017/08/24/java之ClassLoader源码分析/1807893-a84849c93b9df9e0.jpg" alt="运行结果图" title="运行结果图"></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h1><blockquote>
<p>这种自定义的方式目的就是为了，能够控制类的加载流程，那么这种远程加载类的方式类似于我们常用的Hessian 来访问多个系统获取类</p>
</blockquote>
<h1 id="好的网站"><a href="#好的网站" class="headerlink" title="好的网站"></a><strong>好的网站</strong></h1><p><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="external">http://blog.csdn.net/briblue/article/details/54973413</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类加载器ClassLoader的含义&quot;&gt;&lt;a href=&quot;#类加载器ClassLoader的含义&quot; class=&quot;headerlink&quot; title=&quot;类加载器ClassLoader的含义&quot;&gt;&lt;/a&gt;类加载器ClassLoader的含义&lt;/h1&gt;&lt;blockquo
    
    </summary>
    
      <category term="java深入理解" scheme="http://kingge.top/categories/java%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="Java" scheme="http://kingge.top/tags/Java/"/>
    
      <category term="ClassLoader" scheme="http://kingge.top/tags/ClassLoader/"/>
    
      <category term="类加载器" scheme="http://kingge.top/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
      <category term="自定义类加载器" scheme="http://kingge.top/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
      <category term="类加载器源码分析" scheme="http://kingge.top/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>为什么毕业后选择留在小城市</title>
    <link href="http://kingge.top/2017/08/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%95%E4%B8%9A%E5%90%8E%E9%80%89%E6%8B%A9%E7%95%99%E5%9C%A8%E5%B0%8F%E5%9F%8E%E5%B8%82/"/>
    <id>http://kingge.top/2017/08/21/为什么毕业后选择留在小城市/</id>
    <published>2017-08-21T06:13:44.000Z</published>
    <updated>2017-08-23T01:12:42.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong><em>前言</em></strong></h1><p>经常看到大学要毕业的学生，会有一种纠结感。越是临近毕业，这种感觉就越是强烈<br>这种感觉实际上就是一种选择恐惧症，又或者说是<strong><em>小城综合征</em></strong>。他们对于毕业后究竟是选择去一线城市就业还是去二三线城市就业，产生了很大的选择恐惧。</p>
<h1 id="为什么会产生这种心理"><a href="#为什么会产生这种心理" class="headerlink" title="为什么会产生这种心理"></a><strong><em>为什么会产生这种心理</em></strong></h1><p>大致的原因有那么几个：</p>
<ul>
<li>身边的认识的人，都是选择回到自己的家乡进行就业，自己收到了影响。</li>
<li>大城市的生活节奏会比小城市更加的紧凑，你会很忙。</li>
<li>父母希望自己回去，离家近的地方工作。</li>
<li>恋人不跟随自己，她或他选择了回到了故乡就业，自己左右为难。</li>
<li>有些人已经在大城市实习过，对于大城市已经厌倦。</li>
</ul>
<h1 id="作者的选择"><a href="#作者的选择" class="headerlink" title="作者的选择"></a><strong><em>作者的选择</em></strong></h1><blockquote>
<p>本人就是属于最后一种，大三的时候去的深圳实习，在一家IT互联网公司上班，加班很多，虽然加班这种现象在深圳是一种常态。但是每天加班到晚上一点多，也是很累，所以毕业后也就选择回到了自己的家乡就业。</p>
</blockquote>
<hr>
<blockquote>
<p>回到了</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;前言&lt;/em&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;经常看到大学要毕业的学生，会有一种纠结感。越是临近毕业，这种感觉就越是强烈&lt;br&gt;这种感
    
    </summary>
    
      <category term="心情" scheme="http://kingge.top/categories/%E5%BF%83%E6%83%85/"/>
    
    
      <category term="心情" scheme="http://kingge.top/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="总结" scheme="http://kingge.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="有感" scheme="http://kingge.top/tags/%E6%9C%89%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>max-allowed-packet的问题</title>
    <link href="http://kingge.top/2017/08/17/max-allowed-packet%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://kingge.top/2017/08/17/max-allowed-packet的问题/</id>
    <published>2017-08-17T02:37:15.000Z</published>
    <updated>2017-08-17T09:44:39.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p> 近期，因启动项目有个批量插入的sql结果太大，超过了mysql自带的缓存，报了这个错误</p>
</blockquote>
<hr>
<blockquote>
<p>修改： 定位到mysql的安装目录下面，然后修改my.ini 的max_allowed_packet = 8M<br>默认是1M </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 近期，因启动项目有个批量插入的sql结果太大，超过了mysql自带的缓存，报了这个错误&lt;/p&gt;
&lt;/blockq
    
    </summary>
    
      <category term="Mysql" scheme="http://kingge.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://kingge.top/tags/Mysql/"/>
    
      <category term="异常" scheme="http://kingge.top/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="sql异常" scheme="http://kingge.top/tags/sql%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>YUM仓库配置</title>
    <link href="http://kingge.top/2017/08/06/YUM%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
    <id>http://kingge.top/2017/08/06/YUM仓库配置/</id>
    <published>2017-08-06T14:12:30.000Z</published>
    <updated>2019-06-02T06:17:59.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。-<strong>需要联网</strong></p>
<h2 id="1-2-为什么要制作本地YUM源"><a href="#1-2-为什么要制作本地YUM源" class="headerlink" title="1.2 为什么要制作本地YUM源"></a>1.2 为什么要制作本地YUM源</h2><p>YUM源虽然可以简化我们在Linux上安装软件的过程，但是生产环境通常无法上网，不能连接外网的YUM源，说以就无法使用yum命令安装软件了。为了在内网中也可以使用yum安装相关的软件，就要配置yum源。</p>
<p>YUM源其实就是一个保存了多个RPM包的服务器，可以通过http的方式来检索、下载并安装相关的RPM包。</p>
<p><img src="/2017/08/06/YUM仓库配置/clip_image002.png" alt="img"></p>
<h2 id="1-3-yum的常用命令"><a href="#1-3-yum的常用命令" class="headerlink" title="1.3 yum的常用命令"></a>1.3 yum的常用命令</h2><p>1）基本语法：</p>
<p>yum install -y rpm软件包               （功能描述：安装httpd并确认安装）</p>
<p>yum list                                              （功能描述：列出所有可用的package和package组）</p>
<p>yum clean all                                     （功能描述：清除所有缓冲数据）</p>
<p>yum deplist rpm软件包                  （功能描述：列出一个包所有依赖的包）</p>
<p>yum remove rpm软件包                 （功能描述：删除httpd）</p>
<p>2）案例实操</p>
<p>​         yum install -y tree  //安装文档树结构展示插件</p>
<h2 id="1-4-关联网络yum源"><a href="#1-4-关联网络yum源" class="headerlink" title="1.4 关联网络yum源"></a>1.4 关联网络yum源</h2><p>1）前期文件准备</p>
<p>（1）前提条件linux系统必须可以联网</p>
<p>（2）在Linux环境中访问该网络地址：<a href="http://mirrors.163.com/.help/centos.html" target="_blank" rel="external">http://mirrors.163.com/.help/centos.html</a>，在使用说明中点击CentOS6-&gt;再点击保存</p>
<p><img src="/2017/08/06/YUM仓库配置/clip_image004.jpg" alt="img"></p>
<p>（3）查看文件保存的位置</p>
<p><img src="/2017/08/06/YUM仓库配置/clip_image006.jpg" alt="img"> <img src="/2017/08/06/YUM仓库配置/clip_image008.jpg" alt="img"></p>
<p>在打开的终端中输入如下命令，就可以找到文件的保存位置。</p>
<p>[kingge@hadoop101 下载]$ pwd</p>
<p>/home/kingge/下载</p>
<p>2）替换本地yum文件</p>
<p>​         （1）把下载的文件移动到/etc/yum.repos.d/目录</p>
<p>[root@hadoop101 下载]# mv CentOS6-Base-163.repo /etc/yum.repos.d/  </p>
<p>​     （2）进入到/etc/yum.repos.d/目录</p>
<p>[root@hadoop101 yum.repos.d]# pwd</p>
<p>/etc/yum.repos.d</p>
<p>​     （3）用CentOS6-Base-163.repo替换CentOS-Base.rep</p>
<p>[root@hadoop101 yum.repos.d]# mv CentOS6-Base-163.repo  CentOS-Base.rep</p>
<p>3）安装命令</p>
<p>​         （1）[root@hadoop101 yum.repos.d]#yum clean all</p>
<p>​     （2）[root@hadoop101 yum.repos.d]#yum makecache</p>
<p>​     （3）[root@hadoop101 yum.repos.d]# yum install -y createrepo</p>
<p>（4）[root@hadoop101 yum.repos.d]#yum install -y httpd</p>
<h2 id="1-5-制作本地yum源"><a href="#1-5-制作本地yum源" class="headerlink" title="1.5 制作本地yum源"></a>1.5 制作本地yum源</h2><h3 id="1-5-1-制作只有本机能访问的本地YUM源"><a href="#1-5-1-制作只有本机能访问的本地YUM源" class="headerlink" title="1.5.1 制作只有本机能访问的本地YUM源"></a>1.5.1 制作只有本机能访问的本地YUM源</h3><p>（1）准备一台Linux服务器，版本CentOS-6.8-x86_64-bin-DVD1.iso</p>
<p>（2）配置好这台服务器的IP地址</p>
<p>（3）将CentOS-6.8-x86_64-bin-DVD1.iso镜像挂载到/mnt/cdrom目录</p>
<p>[root@hadoop101 /]# mkdir /mnt/cdrom</p>
<p> [root@hadoop101 /]# mount -t iso9660 /dev/cdrom /mnt/cdrom</p>
<p>（4）安装相应的软件</p>
<p>[root@hadoop101 yum.repos.d]#yum install -y httpd</p>
<p>​         （5）启动httpd服务</p>
<p>[root@hadoop101 yum.repos.d]#service httpd start</p>
<p>（6）使用浏览器访问<a href="http://192.168.1.101:80" target="_blank" rel="external">http://192.168.1.101:80</a>（如果访问不通，检查防火墙是否开启了80端口或关闭防火墙），测试网络是否畅通</p>
<p>（7）将YUM源配置到httpd（Apache Server）中</p>
<p>[root@hadoop101 html]# mkdir Packages</p>
<p>[root@hadoop101 html]# chown kingge:kingge Packages/</p>
<p>[root@hadoop101 html]# cp -r /mnt/cdrom/Packages/* /var/www/html/Packages/</p>
<p>（8）执行创建仓库命令：createrepo 路径</p>
<p>[root@hadoop101 Packages]# createrepo ./</p>
<p>（9）修改本机上的YUM源配置文件，将源指向自己</p>
<p>备份原有的YUM源的配置文件</p>
<p>[root@hadoop101 /]# cd /etc/yum.repos.d/</p>
<p>[root@hadoop101 yum.repos.d]# cp CentOS-Base.repo  CentOS-Base.repo.bak</p>
<p>​                 编辑CentOS-Base.repo文件</p>
<p>[root@hadoop101 yum.repos.d]# vi CentOS-Base.repo</p>
<p>   [base]   name=CentOS-Local   baseurl=file:///var/www/html/Packages   gpgcheck=0   enabled=1   #增加改行，使能   gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6   </p>
<p>添加上面内容保存退出</p>
<p>（10）清除YUM缓存</p>
<p>[root@hadoop101 yum.repos.d]# yum clean all</p>
<p>（11）列出可用的YUM仓库</p>
<p>[root@hadoop101 yum.repos.d]# yum repolist</p>
<p>（12）安装相应的软件</p>
<p>[root@hadoop101 yum.repos.d]# yum install -y tree</p>
<p>[root@hadoop101 Packages]# yum install -y firefox-45.0.1-1.el6.centos.x86_64.rpm</p>
<h3 id="1-5-2-制作其他主机通过网络能访问的本地YUM源"><a href="#1-5-2-制作其他主机通过网络能访问的本地YUM源" class="headerlink" title="1.5.2 制作其他主机通过网络能访问的本地YUM源"></a>1.5.2 制作其他主机通过网络能访问的本地YUM源</h3><p>前期准备：检查yum源服务器的httpd服务是否启动：</p>
<p>​    Ps aux | grep httpd –查看该进程是否存在</p>
<p>   或者 netstat –anp | grep 80 直接查看是否监听80端口</p>
<p>​    启动 httpd服务： service httpd start/restart</p>
<p>启动后，可能使用yum源的服务器访问不到yum仓库（例如下面的101服务器访问不到102服务器的yum），那么有可能是101服务器防火墙屏蔽了80端口，应该设置一下防火墙规则 </p>
<p><img src="/2017/08/06/YUM仓库配置/clip_image009.png" alt="img"></p>
<p>（1）让其他需要安装RPM包的服务器指向这个YUM源，准备一台新的服务器，备份或删除原有的YUM源配置文件</p>
<p>备份原有的YUM源的配置文件</p>
<p>[root@hadoop102 /]#cd /etc/yum.repos.d/</p>
<p>[root@hadoop102 yum.repos.d]# cp CentOS-Base.repo  CentOS-Base.repo.bak</p>
<p>​                 编辑CentOS-Base.repo文件</p>
<p>[root@hadoop102 yum.repos.d]# vi CentOS-Base.repo</p>
<p>   [base]   name=CentOS-hadoop101   baseurl=<a href="http://192.168.1.101/Packages" target="_blank" rel="external">http://192.168.1.101/Packages</a>   gpgcheck=1   gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6   </p>
<p>添加上面内容保存退出</p>
<p>（2）在这台新的服务器上执行YUM的命令</p>
<p>[root@hadoop102 yum.repos.d]# yum clean all</p>
<p>[root@hadoop102 yum.repos.d]# yum repolist</p>
<p>（3）安装软件</p>
<p>[root@hadoop102 yum.repos.d]# yum install -y httpd</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概述&quot;&gt;&lt;/a&gt;1.1 概述&lt;/h2&gt;&lt;p&gt;YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat
    
    </summary>
    
      <category term="Linux" scheme="http://kingge.top/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://kingge.top/tags/linux/"/>
    
      <category term="hadoop" scheme="http://kingge.top/tags/hadoop/"/>
    
  </entry>
  
</feed>
