<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>King哥</title>
  <subtitle>To know everything, no words don&#39;t talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kingge.top/"/>
  <updated>2017-09-01T02:08:20.226Z</updated>
  <id>http://kingge.top/</id>
  
  <author>
    <name>Jeremy Kinge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java8新特性</title>
    <link href="http://kingge.top/2017/08/29/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://kingge.top/2017/08/29/java8新特性/</id>
    <published>2017-08-29T04:27:16.000Z</published>
    <updated>2017-09-01T02:08:20.226Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8可谓是自Java 5以来最具革命性的版本了，她在语言、编译器、类库、开发工具以及Java虚拟机等方面都带来了不少新特性。<br>我们来一一回顾一下这些特性。</p>
<p><img src="/2017/08/29/java8新特性/java8特性简介.png" alt="java8新特性"></p>
<h1 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h1><blockquote>
<p>Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。Lambda  是一个匿名函数。</p>
</blockquote>
<p>一个Lambda表达式可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。例如：</p>
<h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><blockquote>
<p>需求：  比较TreeSet<integer>中数据，按小到大输出</integer></p>
</blockquote>
<h3 id="使用匿名内部类实现一个排序功能"><a href="#使用匿名内部类实现一个排序功能" class="headerlink" title="使用匿名内部类实现一个排序功能"></a><strong>使用匿名内部类实现一个排序功能</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">      <span class="comment">//采用匿名内部类的方式-实现比较器</span></div><div class="line">      Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;()</div><div class="line">      &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span></div><div class="line"><span class="function">          </span>&#123;</div><div class="line">              <span class="keyword">return</span> Integer.compare(o1, o2);<span class="comment">//关键代码</span></div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line"><span class="comment">//传入比较器</span></div><div class="line">    TreeSet&lt;Integer&gt; tree2 = <span class="keyword">new</span> TreeSet&lt;&gt;(comparator );</div><div class="line">      tree2.add(<span class="number">12</span>);</div><div class="line">      tree2.add(-<span class="number">12</span>);</div><div class="line">      tree2.add(<span class="number">100</span>);</div><div class="line">System.out.println(tree2)</div><div class="line"></div><div class="line">    <span class="comment">//输出</span></div><div class="line"> -<span class="number">12</span></div><div class="line">  <span class="number">12</span></div><div class="line">  <span class="number">100</span></div></pre></td></tr></table></figure>
<p>我们不难发现上面的代码存在一个问题：其实关键代码只有第七行，其他代码都是冗余的</p>
<h3 id="使用Lambda表达式实现同样功能"><a href="#使用Lambda表达式实现同样功能" class="headerlink" title="使用Lambda表达式实现同样功能"></a><strong>使用Lambda表达式实现同样功能</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="comment">//使用Lambda表达式，抽取关键代码，减少代码量</span></div><div class="line">Comparator&lt;Integer&gt; comparator2 = (x, y) -&gt; Integer.compare(x, y); <span class="comment">//关键代码</span></div><div class="line">  TreeSet&lt;Integer&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;(comparator2 );</div><div class="line">  tree.add(<span class="number">12</span>);</div><div class="line">  tree.add(-<span class="number">12</span>);</div><div class="line">  tree.add(<span class="number">100</span>);</div><div class="line">  tree.forEach(System.out::println);<span class="comment">//代替System.out.println</span></div></pre></td></tr></table></figure>
<p>代码瞬间就变得很简短，你可能觉得这个有什么，没什么感觉。那么我们在进入第二个例子</p>
<h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><blockquote>
<p>需求：<br>1.获取公司中年龄小于 35 的员工信息<br>2.获取公司中工资大于 5000 的员工信息<br>。。。。。。</p>
</blockquote>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>实现一个Employee类,有四个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private int id;</div><div class="line">private String name;</div><div class="line">private int age;</div><div class="line">private double salary;</div><div class="line"></div><div class="line">忽略get/set方法和构造器</div></pre></td></tr></table></figure>
<p>初始化一个List：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">List&lt;Employee&gt; emps = Arrays.asList(</div><div class="line">		new Employee(101, &quot;张三&quot;, 18, 9999.99),</div><div class="line">		new Employee(102, &quot;李四&quot;, 59, 6666.66),</div><div class="line">		new Employee(103, &quot;王五&quot;, 28, 3333.33),</div><div class="line">		new Employee(104, &quot;赵六&quot;, 8, 7777.77),</div><div class="line">		new Employee(105, &quot;田七&quot;, 38, 5555.55)</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="常规方法实现"><a href="#常规方法实现" class="headerlink" title="常规方法实现"></a><strong>常规方法实现</strong></h3><p>实现两个方法，然后传入需要过滤的源数据，返回过滤后的结果集<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">     	<span class="comment">//需求：获取公司中年龄小于 35 的员工信息</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployeeAge</span><span class="params">(List&lt;Employee&gt; emps)</span></span>&#123;</div><div class="line">	List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (Employee emp : emps) &#123;</div><div class="line">		<span class="keyword">if</span>(emp.getAge() &lt;= <span class="number">35</span>)&#123;<span class="comment">//比较代码</span></div><div class="line">			list.add(emp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//需求：获取公司中工资大于 5000 的员工信息</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployeeSalary</span><span class="params">(List&lt;Employee&gt; emps)</span></span>&#123;</div><div class="line">	List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (Employee emp : emps) &#123;</div><div class="line">		<span class="keyword">if</span>(emp.getSalary() &gt;= <span class="number">5000</span>)&#123;<span class="comment">//比较代码</span></div><div class="line">			list.add(emp);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们不难发现上面的代码存在一个问题：那就是两个方法除了比较部分不同，其他逻辑是一样的，存在大量冗余，假设有新的需求（例如求得求得名字姓王的员工）那么就需要再创建一个 filterEmployee<em>**</em>方法对应新的需求。</p>
<h3 id="使用策略设计模式实现"><a href="#使用策略设计模式实现" class="headerlink" title="使用策略设计模式实现"></a><strong>使用策略设计模式实现</strong></h3><blockquote>
<p>提供父借口 和 两个 实现类（两个需求对应的逻辑实现类）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 父接口</span></div><div class="line">   <span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyPredicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//需求1 实现类-年龄小于35</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeForAge</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee t)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> t.getAge() &lt;= <span class="number">35</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//需求1 实现类-工资大于5000</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeForSalary</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee t)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> t.getSalary() &gt;= <span class="number">5000</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>测试代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 通用过滤方法</div><div class="line">	public List&lt;Employee&gt; filterEmployee(List&lt;Employee&gt; emps, MyPredicate&lt;Employee&gt; mp)&#123;</div><div class="line">		List&lt;Employee&gt; list = new ArrayList&lt;&gt;();</div><div class="line">		</div><div class="line">		for (Employee employee : emps) &#123;</div><div class="line">			if(mp.test(employee))&#123;</div><div class="line">				list.add(employee);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Test</div><div class="line">	public void test4()&#123;</div><div class="line">        //传入实现年龄过滤的实现类</div><div class="line">		List&lt;Employee&gt; list = </div><div class="line">filterEmployee(emps, new FilterEmployeeForAge());</div><div class="line">		for (Employee employee : list) &#123;</div><div class="line">			System.out.println(employee);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(&quot;------------------------------------------&quot;);</div><div class="line">		</div><div class="line">		List&lt;Employee&gt; list2 = filterEmployee(emps, new FilterEmployeeForSalary());</div><div class="line">		for (Employee employee : list2) &#123;</div><div class="line">			System.out.println(employee);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>使用策略模式比上一个的好处是：代码很清晰，便于维护，新的需求我们只需要再实现对应的需求实现类即可，然后传入<figure class="highlight plain"><figcaption><span>MyPredicate<t>```接口即可。</t></span></figcaption><table><tr><td class="code"><pre><div class="line"></div><div class="line">缺点是：需要实现对应的需求类然后实现``` MyPredicate&lt;T&gt;```接口</div><div class="line"></div><div class="line"></div><div class="line">###   **匿名内部类**</div><div class="line">这种方法类似于例子1中的 Comparator这个接口的实现</div><div class="line"></div><div class="line"></div><div class="line">```JAVA</div><div class="line">//直接使用 MyPredicate&lt;Employee&gt;接口，不去实现对应的需求类（上面的FilterEmployeeForSalary 和 FilterEmployeeForAge ）</div><div class="line">   @Test</div><div class="line">	public void test5()&#123;</div><div class="line">		List&lt;Employee&gt; list = filterEmployee(emps, new MyPredicate&lt;Employee&gt;() &#123;</div><div class="line">			@Override</div><div class="line">			public boolean test(Employee t) &#123;</div><div class="line">				return t.getId() &lt;= 103;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		for (Employee employee : list) &#123;</div><div class="line">			System.out.println(employee);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>我们不难发现上面的代码存在一个问题：跟例子1一样，存在大量的冗余。</p>
<h3 id="Lambda-表达式实现"><a href="#Lambda-表达式实现" class="headerlink" title="Lambda 表达式实现"></a><strong>Lambda 表达式实现</strong></h3><h4 id="前期准备-1"><a href="#前期准备-1" class="headerlink" title="前期准备"></a>前期准备</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public List&lt;Employee&gt; filterEmployee(List&lt;Employee&gt; emps, MyPredicate&lt;Employee&gt; mp)&#123;</div><div class="line">	List&lt;Employee&gt; list = new ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	for (Employee employee : emps) &#123;</div><div class="line">		if(mp.test(employee))&#123;</div><div class="line">			list.add(employee);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</div><div class="line">	List&lt;Employee&gt; list = filterEmployee(emps, (e) -&gt; e.getAge() &lt;= <span class="number">35</span>);</div><div class="line">	list.forEach(System.out::println);</div><div class="line">	System.out.println(<span class="string">"------------------------------------------"</span>);</div><div class="line">	</div><div class="line">	List&lt;Employee&gt; list2 = filterEmployee(emps, (e) -&gt; e.getSalary() &gt;= <span class="number">5000</span>);</div><div class="line">	list2.forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们不难发现上面的代码存在一个问题：这个代码，是不是已经非常简短了，感觉已经是终极的最简代码。但是实际上还有更简短的代码（使用stream api）<br><strong>缺点</strong>：太过依赖  MyPredicate<t> 这个接口，假设这个接口不存在，该怎么办呢？（我们这里仅仅是做个假设）</t></p>
<h3 id="终极实现方式：Stream-API"><a href="#终极实现方式：Stream-API" class="headerlink" title="终极实现方式：Stream API"></a><strong>终极实现方式：Stream API</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Test</div><div class="line">public void test7()&#123;</div><div class="line">	emps.stream()</div><div class="line">		.filter((e) -&gt; e.getAge() &lt;= 35)</div><div class="line">		.forEach(System.out::println);</div><div class="line">	</div><div class="line">	System.out.println(&quot;----------------------------------------------&quot;);</div><div class="line">      emps.stream()</div><div class="line">         .filter((e) -&gt; e.getSalary() &gt;= 5000)</div><div class="line">         .forEach(System.out::println);</div><div class="line">	</div><div class="line">      System.out.println(&quot;----------------------------------------------&quot;);</div><div class="line">	  </div><div class="line">        // 可以使用map 指定输出那个属性的值，代替普通的便利输出</div><div class="line">	emps.stream()</div><div class="line">		.map(Employee::getName)</div><div class="line">		.limit(3)// 输出前三个</div><div class="line">		.sorted()//排序</div><div class="line">		.forEach(System.out::println);</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>输出</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Employee [id=101, name=张三, age=18, salary=9999.99]</div><div class="line">Employee [id=103, name=王五, age=28, salary=3333.33]</div><div class="line">Employee [id=104, name=赵六, age=8, salary=7777.77]</div><div class="line">----------------------------------------------</div><div class="line">Employee [id=101, name=张三, age=18, salary=9999.99]</div><div class="line">Employee [id=102, name=李四, age=59, salary=6666.66]</div><div class="line">Employee [id=104, name=赵六, age=8, salary=7777.77]</div><div class="line">Employee [id=105, name=田七, age=38, salary=5555.55]</div><div class="line">----------------------------------------------</div><div class="line">张三</div><div class="line">李四</div><div class="line">王五</div></pre></td></tr></table></figure>
<p>我们不难发现上面的代码存在一个问题：这个代码，是非常潇洒，舒服的，不依赖我们上面所说的接口。</p>
<hr>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><blockquote>
<p>为了使现有函数更好的支持Lambda表达式，Java 8引入了函数式接口的概念。函数式接口就是<strong>只有一个方法的普通接口</strong>。java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的例子。为此，Java 8增加了一种特殊的注解@FunctionalInterface：</p>
</blockquote>
<p><strong><em>–也就是说：这个接口里面只能够存在一个接口方法，多个就会报错</em></strong></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Functional &#123;</div><div class="line">    void method();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="认识Lambda表达式"><a href="#认识Lambda表达式" class="headerlink" title="认识Lambda表达式"></a>认识Lambda表达式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>  一、Lambda 表达式的基础语法：Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符<br>                              箭头操作符将 Lambda 表达式拆分成两部分：</p>
<p>  左侧：Lambda 表达式的参数列表<br>  右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体</p>
<blockquote>
<p>上面的例子：List<employee> list = filterEmployee(emps, (e) -&gt; e.getAge() &lt;= 35);</employee></p>
<p>第二个参数他会去找 <code>MyPredicate&lt;T&gt;</code> 接口里面的  public boolean test(T t);<br>test方法，lambda表达式左边的(e) 对应的是test方法的入参, ambda表达式右边的e.getAge() &lt;= 35 对应得是test方法的实现</p>
</blockquote>
<p><strong>那么你可能会有疑问，假设MyPredicate接口里面有很多个接口方法，那么他会去调用那个呢？他怎么知道去找test方法呢？</strong> 引入了：@FunctionalInterface这个函数式接口的概念，解决了这个问题。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> * 语法格式一：无参数，无返回值</div><div class="line"> * 		() -&gt; System.out.println(&quot;Hello Lambda!&quot;);</div><div class="line"> </div><div class="line"></div><div class="line">&gt; 例如 Runnable接口的 run方法就是无参数无返回值：</div><div class="line"></div><div class="line">	@Test</div><div class="line">	public void test1()&#123;</div><div class="line">		int num = 0;//jdk 1.7 前，我们知道匿名内部引用局部变量必须声明为final</div><div class="line">		//但jdk1.8，它默认给我们添加了final，不用显示声明。</div><div class="line">		</div><div class="line">		Runnable r = new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println(&quot;Hello World!&quot; + num);</div><div class="line">				          //这里如果改为 num++是会报错的，因为他本质上是一个final</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		</div><div class="line">		r.run();</div><div class="line">		</div><div class="line">		System.out.println(&quot;-------------------------------&quot;);</div><div class="line">		</div><div class="line">		Runnable r1 = () -&gt; System.out.println(&quot;Hello Lambda!&quot;);</div><div class="line">		r1.run();</div><div class="line">	&#125;</div><div class="line">这两个是等效的</div></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* </div><div class="line">* 语法格式二：有一个参数，并且无返回值</div><div class="line">* 		(x) -&gt; System.out.println(x)</div><div class="line">* </div><div class="line">例子：</div><div class="line">Consumer这个类jdk自带--有参数无返回值</div><div class="line">@Test</div><div class="line">public void test2()&#123;</div><div class="line">	Consumer&lt;String&gt; con = x -&gt; System.out.println(x);</div><div class="line">	con.accept(&quot;我是你泽精哥！&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* 语法格式三：若只有一个参数，小括号可以省略不写</div><div class="line">* 		x -&gt; System.out.println(x)</div><div class="line">*</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* 语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句</div><div class="line">*		Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;</div><div class="line">*			System.out.println(&quot;函数式接口&quot;);</div><div class="line">*			return Integer.compare(x, y);</div><div class="line">*		&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* 语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写</div><div class="line">* 		Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</div><div class="line">*</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* 语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”</div><div class="line">* 		(Integer x, Integer y) -&gt; Integer.compare(x, y);</div></pre></td></tr></table></figure>
<blockquote>
<p><strong><em>类型推断</em></strong> : jdk1.8后，添加了这个功能<br>String[] strs = {“aaa”, “bbb”, “ccc”} ;  它自动会转换里面的数据为String类型的数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">改为： </div><div class="line">String[] strs;</div><div class="line">strs = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;</div><div class="line">//会报错--因为这样无法进行类型推断</div></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p><strong>类型推断例子2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">	public void show(Map&lt;String, Integer&gt; map)&#123;&#125;//方法</div><div class="line">		show(new HashMap&lt;&gt;());//调用方法</div><div class="line">我们发现在调用方法的时候入参我们并没有明确声明类型，但是在jdk1.8中是可以编译通过的。这里也是运用了类型推断（注意：jdk1.7中编译会失败）</div></pre></td></tr></table></figure>
<hr>
<h3 id="热身例子一"><a href="#热身例子一" class="headerlink" title="热身例子一"></a>热身例子一</h3><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//函数是接口</div><div class="line">@FunctionalInterface</div><div class="line">public interface MyFun &#123;</div><div class="line">	public Integer getValue(Integer num);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试</div><div class="line"></div><div class="line">	//需求：对一个数进行运算</div><div class="line">	@Test</div><div class="line">	public void test6()&#123;</div><div class="line">		Integer num = operation(100, (x) -&gt; x * x);</div><div class="line">		System.out.println(num);</div><div class="line">		</div><div class="line">		System.out.println(operation(200, (y) -&gt; y + 200));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Integer operation(Integer num, MyFun mf)&#123;</div><div class="line">		return mf.getValue(num);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="热身例子二"><a href="#热身例子二" class="headerlink" title="热身例子二"></a>热身例子二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//函数接口 </div><div class="line">@FunctionalInterface //约束当前接口只能有一个方法</div><div class="line">public interface CalcLong&lt;K,T&gt;</div><div class="line">&#123;</div><div class="line">      // public K getMultiply(T t, T tt);</div><div class="line">        K getMultiply(T t, T tt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//需求：求得两个数的和</div><div class="line">        String result = getMuyl(10L,10L,(e,ee)-&gt;&#123;</div><div class="line">            System.out.println(e+ &quot;  &quot; + ee);</div><div class="line">            return e+ee+&quot;&quot;;</div><div class="line">        &#125;);</div><div class="line">        System.out.println(result);</div><div class="line"> </div><div class="line">    </div><div class="line">    public String getMuyl(Long l,Long ll,CalcLong&lt;String,Long&gt; mf)&#123;</div><div class="line">        return mf.getMultiply(l, ll);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>看到这里可能会有疑惑？我靠，使用lambda表达式还得声明一个函数接口，这么麻烦。实际上，java内部已经帮我们实现了很多个接口供我们使用，不需要重新自己定义，除非有特别操作。</p>
</blockquote>
<hr>
<h3 id="java8内置四大函数式接口"><a href="#java8内置四大函数式接口" class="headerlink" title="java8内置四大函数式接口"></a>java8内置四大函数式接口</h3><blockquote>
<p> 为了解决接口需要自定义问题</p>
</blockquote>
<p><img src="/2017/08/29/java8新特性/内置四大函数接口.png" alt="内置四大函数接口.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*</div><div class="line"> * Java8 内置的四大核心函数式接口</div><div class="line"> * </div><div class="line"> * Consumer&lt;T&gt; : 消费型接口</div><div class="line"> * 		void accept(T t);</div><div class="line"> * </div><div class="line"> * Supplier&lt;T&gt; : 供给型接口</div><div class="line"> * 		T get(); </div><div class="line"> * </div><div class="line"> * Function&lt;T, R&gt; : 函数型接口</div><div class="line"> * 		R apply(T t);</div><div class="line"> * </div><div class="line"> * Predicate&lt;T&gt; : 断言型接口</div><div class="line"> * 		boolean test(T t);</div><div class="line"> * </div><div class="line"> */</div></pre></td></tr></table></figure>
<hr>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="消费型接口"><a href="#消费型接口" class="headerlink" title="消费型接口"></a>消费型接口</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Consumer&lt;T&gt; 消费型接口 :</div><div class="line">@Test</div><div class="line">public void test1()&#123;</div><div class="line">    String p;</div><div class="line">	happy(10000, (m) -&gt; System.out.println(&quot;桑拿，每次消费：&quot; + m + &quot;元&quot;));</div><div class="line">&#125; </div><div class="line"></div><div class="line">public void happy(double money, Consumer&lt;Double&gt; con)&#123;</div><div class="line">	con.accept(money);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h5 id="Supplier-供给型接口"><a href="#Supplier-供给型接口" class="headerlink" title="Supplier 供给型接口"></a>Supplier 供给型接口</h5><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Supplier&lt;T&gt; 供给型接口 :</div><div class="line">@Test</div><div class="line">public void test2()&#123;</div><div class="line">	List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100));</div><div class="line">	</div><div class="line">	for (Integer num : numList) &#123;</div><div class="line">		System.out.println(num);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//需求：产生指定个数的整数，并放入集合中</div><div class="line">public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123;</div><div class="line">	List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</div><div class="line">	</div><div class="line">	for (int i = 0; i &lt; num; i++) &#123;</div><div class="line">		Integer n = sup.get();</div><div class="line">		list.add(n);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h5 id="Function-函数型接口"><a href="#Function-函数型接口" class="headerlink" title="Function 函数型接口"></a>Function 函数型接口</h5><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Function&lt;T, R&gt; 函数型接口：</div><div class="line">@Test</div><div class="line">public void test3()&#123;</div><div class="line">	String newStr = strHandler(&quot;\t\t\t 去除前后空格   &quot;, (str) -&gt; str.trim());</div><div class="line">	System.out.println(newStr);</div><div class="line">	</div><div class="line">	String subStr = strHandler(&quot;截取字符串你知不知道&quot;, (str) -&gt; str.substring(2, 5));</div><div class="line">	System.out.println(subStr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//需求：用于处理字符串</div><div class="line">public String strHandler(String str, Function&lt;String, String&gt; fun)&#123;</div><div class="line">	return fun.apply(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h5 id="Predicate-断言型接口"><a href="#Predicate-断言型接口" class="headerlink" title="Predicate 断言型接口"></a>Predicate 断言型接口</h5><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Predicate&lt;T&gt; 断言型接口：</div><div class="line">@Test</div><div class="line">public void test4()&#123;</div><div class="line">	List&lt;String&gt; list = Arrays.asList(&quot;Hello&quot;, &quot;atguigu&quot;, &quot;Lambda&quot;, &quot;www&quot;, &quot;ok&quot;);</div><div class="line">	List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; 3);</div><div class="line">	</div><div class="line">	for (String str : strList) &#123;</div><div class="line">		System.out.println(str);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//需求：将满足条件的字符串，放入集合中</div><div class="line">public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123;</div><div class="line">	List&lt;String&gt; strList = new ArrayList&lt;&gt;();</div><div class="line">	for (String str : list) &#123;</div><div class="line">		if(pre.test(str))&#123;</div><div class="line">			strList.add(str);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return strList;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="四大内置函数衍生的子函数"><a href="#四大内置函数衍生的子函数" class="headerlink" title="四大内置函数衍生的子函数"></a>四大内置函数衍生的子函数</h4><p><img src="/2017/08/29/java8新特性/四大内置函数接口的子接口.png" alt="四大内置函数接口的子接口.png"></p>
<hr>
<h1 id="二、接口的默认方法与静态方法"><a href="#二、接口的默认方法与静态方法" class="headerlink" title="二、接口的默认方法与静态方法"></a>二、接口的默认方法与静态方法</h1><blockquote>
<p>我们可以在接口中定义默认方法，使用default关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface DefaultFunctionInterface &#123;</div><div class="line">    default String defaultFunction() &#123;</div><div class="line">        return &quot;default function&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p>我们还可以在接口中定义静态方法，使用static关键字，也可以提供实现。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface StaticFunctionInterface &#123;</div><div class="line">    static String staticFunction() &#123;</div><div class="line">        return &quot;static function&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口的默认方法和静态方法的引入，其实可以认为引入了C＋＋中抽象类的理念，以后我们再也不用在每个实现类中都写重复的代码了。</p>
<hr>
<h1 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h1><blockquote>
<p>通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。一般有四种不同的方法引用：</p>
</blockquote>
<h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><hr>
<ul>
<li>构造器引用。语法是Class::new，构造器的参数列表，需要与函数式接口中参数列表保持一致！<strong><em>也就是说，决定Class::new调用那一个构造器得是：接口函数的方法的参数 </em></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//构造器引用</div><div class="line">@Test</div><div class="line">public void test7()&#123;</div><div class="line">    //  Supplier 的接口方法  T get(); --所以调用无参构造器</div><div class="line">    Supplier&lt;Employee&gt; fun0 = Employee::new;</div><div class="line">    //Function 的接口方法  R apply(T t);-调用一个参数构造器</div><div class="line">	Function&lt;String, Employee&gt; fun = Employee::new;</div><div class="line">	//BiFunction 的接口方法 R apply(T t, U u); -调用二参构造器</div><div class="line">	BiFunction&lt;String, Integer, Employee&gt; fun2 = Employee::new;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象静态方法引用（类名-静态方法）"><a href="#对象静态方法引用（类名-静态方法）" class="headerlink" title="对象静态方法引用（类名::静态方法）"></a>对象静态方法引用（类名::静态方法）</h2><hr>
<blockquote>
<ul>
<li>静态方法引用。语法是Class::static_method，要求接受一个Class类型的参数；</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//类名 :: 静态方法名</div><div class="line">//max和compare 都是静态方法</div><div class="line">@Test</div><div class="line">public void test4()&#123;</div><div class="line">	Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</div><div class="line">	System.out.println(&quot;-------------------------------------&quot;);</div><div class="line">	Comparator&lt;Integer&gt; com2 = Integer::compare;</div><div class="line">	</div><div class="line"></div><div class="line"></div><div class="line">	BiFunction&lt;Double, Double, Double&gt; fun = (x, y) -&gt; Math.max(x, y);</div><div class="line">	System.out.println(fun.apply(1.5, 22.2));</div><div class="line">	</div><div class="line">	System.out.println(&quot;------------------------------------&quot;);</div><div class="line">	</div><div class="line">	BiFunction&lt;Double, Double, Double&gt; fun2 = Math::max;</div><div class="line">	System.out.println(fun2.apply(1.2, 1.5));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="对象实例方法引用（对象引用-实例方法名）"><a href="#对象实例方法引用（对象引用-实例方法名）" class="headerlink" title="对象实例方法引用（对象引用::实例方法名）"></a>对象实例方法引用（对象引用::实例方法名）</h2><hr>
<blockquote>
<ul>
<li>特定类的任意对象方法引用。它的语法是Class::method。要求方法是没有参数的；</li>
</ul>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//对象的引用 :: 实例方法名</div><div class="line">@Test</div><div class="line">public void test2()&#123;</div><div class="line">	Employee emp = new Employee(101, &quot;张三&quot;, 18, 9999.99);</div><div class="line">	</div><div class="line">	Supplier&lt;String&gt; sup = () -&gt; emp.getName();</div><div class="line">	System.out.println(sup.get());</div><div class="line">	</div><div class="line">	System.out.println(&quot;----------------------------------&quot;);</div><div class="line">	</div><div class="line">	Supplier&lt;String&gt; sup2 = emp::getName;</div><div class="line">	System.out.println(sup2.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类名实例方法引用-类名-实例方法名"><a href="#类名实例方法引用-类名-实例方法名" class="headerlink" title="类名实例方法引用(类名::实例方法名)"></a>类名实例方法引用(类名::实例方法名)</h2><hr>
<blockquote>
<ul>
<li>我们知道一般是有对象才能够引用实例方法，但是有种特殊情况是可以直接使用类名引用实例方法<br>若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName</li>
</ul>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//类名 :: 实例方法名</div><div class="line">//按照常规是String st = new String(&quot;123&quot;); st::equals,</div><div class="line">//对象调用实例方法，但是下面因为符合第四种引用的规则，</div><div class="line">//所以可以使用类名调用实例方法</div><div class="line">@Test</div><div class="line">public void test5()&#123;</div><div class="line">//第一个参数为实例方法调用者，第二个参数为为实例方法参数</div><div class="line">	BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);</div><div class="line">	System.out.println(bp.test(&quot;abcde&quot;, &quot;abcde&quot;));</div><div class="line">	System.out.println(&quot;-------------------------------------&quot;);</div><div class="line">	</div><div class="line">BiPredicate&lt;String, String&gt; bp2 = String::equals;</div><div class="line">System.out.println(bp2.test(&quot;abc&quot;, &quot;abc&quot;));</div><div class="line">	</div><div class="line">System.out.println(&quot;---------------------------------------&quot;);</div><div class="line">	</div><div class="line">	//第一个参数为实例方法调用者，第二个参数为空</div><div class="line">Function&lt;Employee, String&gt; fun = (e) -&gt; e.show();</div><div class="line">System.out.println(fun.apply(new Employee()));</div><div class="line">System.out.println(&quot;--------------------------------------&quot;);</div><div class="line">	</div><div class="line">	Function&lt;Employee, String&gt; fun2 = Employee::show;</div><div class="line">	System.out.println(fun2.apply(new Employee()));</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 注意：</p>
<blockquote>
<p> ①方法体所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！</p>
<p>  ②若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式：ClassName::MethodName  (<strong><em>针对于第四种方法引用</em></strong>)</p>
</blockquote>
<hr>
<h2 id="数组引用（类型-new）"><a href="#数组引用（类型-new）" class="headerlink" title="数组引用（类型[] :: new）"></a>数组引用（类型[] :: new）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//数组引用</div><div class="line">@Test</div><div class="line">public void test8()&#123;</div><div class="line">	Function&lt;Integer, String[]&gt; fun = (args) -&gt; new String[args];</div><div class="line">	String[] strs = fun.apply(10);</div><div class="line">	System.out.println(strs.length);</div><div class="line">	</div><div class="line">	System.out.println(&quot;--------------------------&quot;);</div><div class="line">	</div><div class="line">	Function&lt;Integer, Employee[]&gt; fun2 = Employee[] :: new;</div><div class="line">	Employee[] emps = fun2.apply(20);</div><div class="line">	System.out.println(emps.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="四、重复注解"><a href="#四、重复注解" class="headerlink" title="四、重复注解"></a>四、重复注解</h1><p>在Java 5中使用注解有一个限制，即相同的注解在同一位置只能声明一次。Java 8引入重复注解，这样相同的注解在同一地方也可以声明多次。重复注解机制本身需要用@Repeatable注解。Java 8在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。</p>
<h1 id="五、扩展注解的支持"><a href="#五、扩展注解的支持" class="headerlink" title="五、扩展注解的支持"></a>五、扩展注解的支持</h1><p>Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。</p>
<h1 id="六、Optional"><a href="#六、Optional" class="headerlink" title="六、Optional"></a>六、Optional</h1><p>Java 8引入Optional类来防止空指针异常，Optional类最先是由Google的Guava项目引入的。Optional类实际上是个容器：它可以保存类型T的值，或者保存null。使用Optional类我们就不用显式进行空指针检查了。</p>
<h1 id="七、Stream"><a href="#七、Stream" class="headerlink" title="七、Stream"></a>七、Stream</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Stream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce，当然Google的MapReduce的灵感也是来自函数式编程。她其实是一连串支持连续、并行聚集操作的元素。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！</p>
</blockquote>
<hr>
<p><img src="/2017/08/29/java8新特性/stream前言.png" alt="stream前言.png"></p>
<hr>
<p><img src="/2017/08/29/java8新特性/stream概念一.png" alt="stream概念一.png"></p>
<hr>
<p><img src="/2017/08/29/java8新特性/stream概念二.png" alt="stream概念二.png"></p>
<hr>
<h1 id="八、Date-Time-API-JSR-310"><a href="#八、Date-Time-API-JSR-310" class="headerlink" title="八、Date/Time API (JSR 310)"></a>八、Date/Time API (JSR 310)</h1><p>Java 8新的Date-Time API (JSR 310)受Joda-Time的影响，提供了新的java.time包，可以用来替代 java.util.Date和java.util.Calendar。一般会用到Clock、LocaleDate、LocalTime、LocaleDateTime、ZonedDateTime、Duration这些类，对于时间日期的改进还是非常不错的。</p>
<h1 id="九、JavaScript引擎Nashorn"><a href="#九、JavaScript引擎Nashorn" class="headerlink" title="九、JavaScript引擎Nashorn"></a>九、JavaScript引擎Nashorn</h1><p>Nashorn允许在JVM上开发运行JavaScript应用，允许Java与JavaScript相互调用。</p>
<h1 id="十、Base64"><a href="#十、Base64" class="headerlink" title="十、Base64"></a>十、Base64</h1><p>在Java 8中，Base64编码成为了Java类库的标准。Base64类同时还提供了对URL、MIME友好的编码器与解码器。</p>
<p>除了这十大新特性之外，还有另外的一些新特性：</p>
<ul>
<li><p>更好的类型推测机制：Java 8在类型推测方面有了很大的提高，这就使代码更整洁，不需要太多的强制类型转换了。</p>
</li>
<li><p>编译器优化：Java 8将方法的参数名加入了字节码中，这样在运行时通过反射就能获取到参数名，只需要在编译时使用-parameters参数。</p>
</li>
<li><p>并行（parallel）数组：支持对数组进行并行处理，主要是parallelSort()方法，它可以在多核机器上极大提高数组排序的速度。</p>
</li>
<li><p>并发（Concurrency）：在新增Stream机制与Lambda的基础之上，加入了一些新方法来支持聚集操作。</p>
</li>
<li><p>Nashorn引擎jjs：基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。</p>
</li>
<li><p>类依赖分析器jdeps：可以显示Java类的包级别或类级别的依赖。</p>
</li>
<li><p>JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122），元空间直接采用的是物理空间，也即是我们电脑的内存，电脑内存多大，元空间就有多大。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8可谓是自Java 5以来最具革命性的版本了，她在语言、编译器、类库、开发工具以及Java虚拟机等方面都带来了不少新特性。&lt;br&gt;我们来一一回顾一下这些特性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/08/29/java8新特性/java8特性简介.png&quot;
    
    </summary>
    
      <category term="Java8" scheme="http://kingge.top/categories/Java8/"/>
    
    
      <category term="java" scheme="http://kingge.top/tags/java/"/>
    
      <category term="java8" scheme="http://kingge.top/tags/java8/"/>
    
      <category term="java8新特性" scheme="http://kingge.top/tags/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>哈希表冲突解决方式之开放地址法和链地址法</title>
    <link href="http://kingge.top/2017/08/29/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E5%92%8C%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95/"/>
    <id>http://kingge.top/2017/08/29/哈希表冲突解决方式之开放地址法和链地址法/</id>
    <published>2017-08-29T03:07:51.000Z</published>
    <updated>2017-08-29T03:56:03.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>基本定义</p>
<p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字key对应一个存储位置f(key)。<br> 这种对应关系f称为<strong><em>散列或哈希函数</em></strong></p>
<p>采用上述思想将数据存储在一块连续的存储空间中，这块连续的存储空间<strong><em>称为散列或哈希表</em></strong></p>
<p>关键字对应的存储位置称为<strong><em>散列地址</em></strong></p>
<p>如果碰到两个不同的关键字key1≠key2，但却有相同的f(key1)=f(key2)，这种现象称为<strong><em>冲突</em></strong>，<br> 并把key1和key2 称为这个散列函数的同义词（synonym）</p>
</blockquote>
<h1 id="散列函数构造方法"><a href="#散列函数构造方法" class="headerlink" title="散列函数构造方法"></a>散列函数构造方法</h1><p>好的散列函数参考如下两个原则：</p>
<ul>
<li>计算简单</li>
<li>散列地址分布均匀</li>
</ul>
<p>最常用的方法是除留余数法，对于散列表长度为m的散列函数是 f(key)=key mod p (p≤m)</p>
<h1 id="处理散列冲突"><a href="#处理散列冲突" class="headerlink" title="处理散列冲突"></a>处理散列冲突</h1><ul>
<li><p>开放地址法</p>
<blockquote>
<p>开放地址法就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列表总能找到，并存入。<br>开放地址法又分为线性探测法，二次探测法和随机探测法。 </p>
</blockquote>
</li>
<li><p>链地址法</p>
<blockquote>
<p>将所有同义词的关键字存储在同一个单链表中，称这个单链表为同义词子表，在散列表中只存储同义词子表的头指针。<br>只要有冲突，就在同义词的子表中增加结点。(java中的HashMap就是采用这种方法)</p>
</blockquote>
</li>
</ul>
<h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本定义&lt;/p&gt;
&lt;p&gt;散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字key对应一个存储位置f(key)。&lt;br&gt; 这种对应关系f称为&lt;strong&gt;&lt;em&gt;散列或哈希函数&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="数据结构" scheme="http://kingge.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="java" scheme="http://kingge.top/tags/java/"/>
    
      <category term="数据结构" scheme="http://kingge.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="http://kingge.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="哈希解决冲突" scheme="http://kingge.top/tags/%E5%93%88%E5%B8%8C%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/"/>
    
  </entry>
  
  <entry>
    <title>java8之Hashmap</title>
    <link href="http://kingge.top/2017/08/28/java8%E4%B9%8BHashmap/"/>
    <id>http://kingge.top/2017/08/28/java8之Hashmap/</id>
    <published>2017-08-28T14:27:16.000Z</published>
    <updated>2017-08-29T08:08:38.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java8-HashMap变化"><a href="#Java8-HashMap变化" class="headerlink" title="Java8-HashMap变化"></a>Java8-HashMap变化</h1><blockquote>
<p>数据的存储结构从：<strong><strong>数组+链表</strong></strong>  演变为了 <strong><strong>数组+链表+红黑树</strong></strong></p>
</blockquote>
<h1 id="Map-家庭族谱"><a href="#Map-家庭族谱" class="headerlink" title="Map 家庭族谱"></a>Map 家庭族谱</h1><p><img src="/2017/08/28/java8之Hashmap/java.util.map类图.png" alt="Map" title="HashMap"></p>
<ul>
<li><p>HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap<strong>非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果<strong>需要满足线程安全</strong>，可以用<strong> Collections的synchronizedMap方法使HashMap具有线程安全的能力</strong>，或者使用<strong>ConcurrentHashMap</strong>。</p>
</li>
<li><p>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
</li>
<li><p>LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
</li>
<li><p>TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<p>通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><blockquote>
<p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>我们知道HashMap的数据存储结构就是：数组加上链表。通过对于key的值做hash运算，获得对应的值找到对应的数组下标，然后再存储值。存储值的过程中可能当前数组已经存在值（这个称之为冲突） 然后再生成一个链表存储冲突的值。</p>
<blockquote>
<p>HashCode() 和 Hash() 方法实现得足够好，能够尽可能地减少冲突的产生，那么对 HashMap 的操作几乎等价于对数组的随机访问操作，具有很好的性能。但是，如果 HashCode() 或者 Hash() 方法实现较差，在大量冲突产生的情况下，HashMap 事实上就退化为几个链表，对 HashMap 的操作等价于遍历链表，此时性能很差。</p>
</blockquote>
</blockquote>
<p>解决冲突的方法：<a href="/2017/08/29/哈希表冲突解决方式之开放地址法和链地址法"><strong><em>开放地址法和链地址法</em></strong></a></p>
<h1 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h1><ul>
<li>允许null为key</li>
<li><p>输出无序</p>
<blockquote>
<p>如果想要输出有序，那以使用继承他的LinkedHashMap，<strong>元素输出顺序跟输入顺序一致</strong>,他提供了一个节点保存输入的元素的顺序。<br>想要对<strong>元素的值进行排序</strong> 推荐TreeMap（因为他继承了SortedMap)</p>
</blockquote>
</li>
<li><p>非线程安全</p>
</li>
<li><p>数组+链表存储方式<br><img src="/2017/08/28/java8之Hashmap/2012122409394770.png" alt="hashMap内存结构图" title="HashMap"></p>
</li>
</ul>
<h1 id="Java8特性"><a href="#Java8特性" class="headerlink" title="Java8特性"></a>Java8特性</h1><blockquote>
<p>HashMap是数组+链表+红黑树</p>
</blockquote>
<p><img src="/2017/08/28/java8之Hashmap/hashMap内存结构图.png" alt="hashMap内存结构图" title="HashMap"></p>
<blockquote>
<p>存储算法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">map.put(&quot;kingge&quot;,&quot;shuai&quot;)</div><div class="line"></div><div class="line">系统将调用kingge”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</div></pre></td></tr></table></figure>
<p><img src="/2017/08/28/java8之Hashmap/QQ截图20170829143321.png" alt="高位运算和取模运算" title="HashMap"></p>
<blockquote>
<p><strong><strong>好的hash算法和扩容机制是解决冲突和高效存取的命题</strong></strong></p>
</blockquote>
<h2 id="HashMap-重要的几个属性"><a href="#HashMap-重要的几个属性" class="headerlink" title="HashMap 重要的几个属性"></a>HashMap 重要的几个属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int threshold;             // 所能容纳的key-value对极限 </div><div class="line">final float loadFactor;    // 负载因子</div><div class="line">int modCount;  </div><div class="line">int size;</div></pre></td></tr></table></figure>
<blockquote>
<p>Node[] table(Hash桶)始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
</blockquote>
<hr>
<blockquote>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
</blockquote>
<hr>
<blockquote>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p>
</blockquote>
<h2 id="分析HashMap的put方法"><a href="#分析HashMap的put方法" class="headerlink" title="分析HashMap的put方法"></a>分析HashMap的put方法</h2><p>put方法图解，详情可以去看源码</p>
<p><img src="/2017/08/28/java8之Hashmap/hashMapput方法执行流程图.png" alt="hashMapput方法执行流程图" title="HashMap"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">      // 对key的hashCode()做hash</div><div class="line">      return putVal(hash(key), key, value, false, true);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">                 boolean evict) &#123;</div><div class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">      // 步骤①：tab为空则创建</div><div class="line">     if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">         n = (tab = resize()).length;</div><div class="line">     // 步骤②：计算index，并对null做处理 </div><div class="line">     if ((p = tab[i = (n - 1) &amp; hash]) == null) </div><div class="line">         tab[i] = newNode(hash, key, value, null);</div><div class="line">     else &#123;</div><div class="line">         Node&lt;K,V&gt; e; K k;</div><div class="line">         // 步骤③：节点key存在，直接覆盖value</div><div class="line">         if (p.hash == hash &amp;&amp;</div><div class="line">             ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">             e = p;</div><div class="line">         // 步骤④：判断该链为红黑树</div><div class="line">         else if (p instanceof TreeNode)</div><div class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div class="line">         // 步骤⑤：该链为链表</div><div class="line">         else &#123;</div><div class="line">             for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                 if ((e = p.next) == null) &#123;</div><div class="line">                     p.next = newNode(hash, key,value,null);</div><div class="line">                        //链表长度大于8转换为红黑树进行处理</div><div class="line">                     if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  </div><div class="line">                         treeifyBin(tab, hash);</div><div class="line">                     break;</div><div class="line">                 &#125;</div><div class="line">                    // key已经存在直接覆盖value</div><div class="line">                 if (e.hash == hash &amp;&amp;</div><div class="line">                     ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                                            break;</div><div class="line">                 p = e;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">        </div><div class="line">         if (e != null) &#123; // existing mapping for key</div><div class="line">             V oldValue = e.value;</div><div class="line">             if (!onlyIfAbsent || oldValue == null)</div><div class="line">                 e.value = value;</div><div class="line">             afterNodeAccess(e);</div><div class="line">             return oldValue;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     ++modCount;</div><div class="line">     // 步骤⑥：超过最大容量 就扩容</div><div class="line">     if (++size &gt; threshold)</div><div class="line">         resize();</div><div class="line">     afterNodeInsertion(evict);</div><div class="line">     return null;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="为什么说HashMap是线程不安全的"><a href="#为什么说HashMap是线程不安全的" class="headerlink" title="为什么说HashMap是线程不安全的"></a>为什么说HashMap是线程不安全的</h2><blockquote>
<p>个人觉得有两个表现，如果还有其他的希望大家补充，或者以后等楼主源码研究透了再补充</p>
</blockquote>
<h3 id="表现一"><a href="#表现一" class="headerlink" title="表现一"></a>表现一</h3><blockquote>
<p>我们知道当插入数据超过了threshold(threshold=length * Load factor),那么就会扩容，扩容会去调用resize和transfer方法，这个时候原先hash桶里面的所有数据都会重新计算，对应的位置–称之为rehash，这个成本很大</p>
</blockquote>
<hr>
<blockquote>
<p>最根本的原因是出现时死循环-也就是在死锁问题出现在了transfer方法上面,而且是因为在扩容转换的过程中采用的是链表的头插法的形式<br>进行插入数据。例如原来在数组arr[0]的位置又链表1–&gt;2–&gt;3 那么扩容后，采用头插法就变成了arr[0]：3–&gt;2–&gt;1</p>
<p>为什么采用头插法，因为时间复杂度为O(1)，想象一下尾插法，那么需要遍历找到最尾元素然后插入时间复杂度是O(n)</p>
</blockquote>
<hr>
<p>具体源码分析参见：<a href="http://www.importnew.com/22011.html" target="_blank" rel="external">http://www.importnew.com/22011.html</a></p>
<h3 id="表现二"><a href="#表现二" class="headerlink" title="表现二"></a>表现二</h3><p>多个线程同时操作一个hashmap就可能出现不安全的情况：<br>比如A B两个线程(A线程获数据 B线程存数据) 同时操作myHashMap<br>1.B线程执行存放数据<br>modelHashMap.put(“1”,”2”);<br>2.A线程执行get获取数据<br>modelHashMap.get(“1”)<br>A线程获取的值本来应该是2，但是如果A线程在刚到达获取的动作还没执行的时候，<br>线程执行的机会又跳到线程B，此时线程B又对modelHashMap赋值 如：modelHashMap.put(“1”,”3”);<br>然后线程虚拟机又执行线程A，A取到的值为3，这样map中第一个存放的值 就会丢失。。。。。<br>—原子性</p>
<h2 id="解决HashMap非线程安全"><a href="#解决HashMap非线程安全" class="headerlink" title="解决HashMap非线程安全"></a>解决HashMap非线程安全</h2><p>其实上面我已经有提过了：</p>
<p> 三个方法：</p>
<ul>
<li><p>Hashtable替换HashMap</p>
</li>
<li><p>Collections.synchronizedMap将HashMap包装起来</p>
</li>
</ul>
<blockquote>
<p>private Map map = Collections.synchronizedMap(new HashMap());<br>替换<br>private HashMap map = new HashMap();</p>
</blockquote>
<ul>
<li>ConcurrentHashMap替换HashMap</li>
</ul>
<blockquote>
<p>private ConcurrentHashMap map = new ConcurrentHashMap();<br>替换<br>private HashMap map = new HashMap();</p>
</blockquote>
<h1 id="好的博文"><a href="#好的博文" class="headerlink" title="好的博文"></a>好的博文</h1><p><a href="http://blog.csdn.net/lyg468088/article/details/49464121" target="_blank" rel="external">http://blog.csdn.net/lyg468088/article/details/49464121</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java8-HashMap变化&quot;&gt;&lt;a href=&quot;#Java8-HashMap变化&quot; class=&quot;headerlink&quot; title=&quot;Java8-HashMap变化&quot;&gt;&lt;/a&gt;Java8-HashMap变化&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;数据的存储
    
    </summary>
    
      <category term="Java8" scheme="http://kingge.top/categories/Java8/"/>
    
    
      <category term="java" scheme="http://kingge.top/tags/java/"/>
    
      <category term="java8" scheme="http://kingge.top/tags/java8/"/>
    
      <category term="java8新特性" scheme="http://kingge.top/tags/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>程序员未来规划</title>
    <link href="http://kingge.top/2017/08/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92/"/>
    <id>http://kingge.top/2017/08/28/程序员未来规划/</id>
    <published>2017-08-28T02:00:36.000Z</published>
    <updated>2017-08-28T02:06:13.437Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/9d29a441ee17?utm_source=desktop&amp;utm_medium=timeline" target="_blank" rel="external">http://www.jianshu.com/p/9d29a441ee17?utm_source=desktop&amp;utm_medium=timeline</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/9d29a441ee17?utm_source=desktop&amp;amp;utm_medium=timeline&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jian
    
    </summary>
    
      <category term="心情" scheme="http://kingge.top/categories/%E5%BF%83%E6%83%85/"/>
    
    
      <category term="心情" scheme="http://kingge.top/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="大龄程序员" scheme="http://kingge.top/tags/%E5%A4%A7%E9%BE%84%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="规划" scheme="http://kingge.top/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>java之ClassLoader源码分析</title>
    <link href="http://kingge.top/2017/08/24/java%E4%B9%8BClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://kingge.top/2017/08/24/java之ClassLoader源码分析/</id>
    <published>2017-08-24T06:36:35.000Z</published>
    <updated>2017-08-24T08:36:55.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载器ClassLoader的含义"><a href="#类加载器ClassLoader的含义" class="headerlink" title="类加载器ClassLoader的含义"></a>类加载器ClassLoader的含义</h1><blockquote>
<p>不论多么简单的java程序，都是由一个或者多个java文件组成，java内部实现了程序所需要的功能逻辑，类之间可能还存在着依赖关系。当程序运行的时候，类加载器会把<strong>一部分</strong>类编译为class后加载到内存中，这样程序才能够调用里面的方法并运行。</p>
</blockquote>
<hr>
<blockquote>
<p>类之间如果存在依赖关系，那么类加载会去帮你加载相关的类到内存中，这样才能够完成调用。如果找不到相关的类，那么他就会抛出我们在开发经常见到的异常：<strong><em>ClassNotFoundException</em></strong></p>
</blockquote>
<hr>
<blockquote>
<p>Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，JVM在加载类的时候，都是通过ClassLoader的loadClass（）方法来加载class的,<strong><em>与此同时在loadClass中存在着三种加载策略</em></strong>，loadClass使用<strong>双亲委派模式</strong>。</p>
</blockquote>
<hr>
<blockquote>
<p><strong><em>所以Classloader就是用来动态加载Class文件到内存当中用的。</em></strong></p>
</blockquote>
<h1 id="Java默认提供的三个ClassLoader"><a href="#Java默认提供的三个ClassLoader" class="headerlink" title="Java默认提供的三个ClassLoader"></a>Java默认提供的三个ClassLoader</h1><h2 id="1-Bootstrap-ClassLoader"><a href="#1-Bootstrap-ClassLoader" class="headerlink" title="1.Bootstrap ClassLoader"></a><strong>1.Bootstrap ClassLoader</strong></h2><blockquote>
<p>称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，预设上它负责搜寻JRE所在目录的classes或lib目录下（实际上是由系统参数sun.boot.class.path指定）。如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;  </div><div class="line">        System.out.println(urls[i].toExternalForm());  </div><div class="line">    &#125;</div><div class="line">	</div><div class="line">&gt; 这两种输出的内容都是一样的。</div><div class="line">    System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">file:/F:/JDK/jdk1.8/jre/lib/resources.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/rt.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/sunrsasign.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/jsse.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/jce.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/charsets.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/lib/jfr.jar</div><div class="line">file:/F:/JDK/jdk1.8/jre/classes</div><div class="line"></div><div class="line">F:\JDK\jdk1.8\jre\lib\resources.jar;F:\JDK\jdk1.8\jre\lib\rt.jar;F:\JDK\jdk1.8\jre\lib\sunrsasign.jar;F:\JDK\jdk1.8\jre\lib\jsse.jar;F:\JDK\jdk1.8\jre\lib\jce.jar;F:\JDK\jdk1.8\jre\lib\charsets.jar;F:\JDK\jdk1.8\jre\lib\jfr.jar;F:\JDK\jdk1.8\jre\classes</div></pre></td></tr></table></figure>
<h2 id="2-Extension-ClassLoader"><a href="#2-Extension-ClassLoader" class="headerlink" title="2.Extension ClassLoader"></a><strong>2.Extension ClassLoader</strong></h2><blockquote>
<p>称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar（实际上是由系统参数java.ext.dirs指定）</p>
</blockquote>
<h2 id="3-App-ClassLoader"><a href="#3-App-ClassLoader" class="headerlink" title="3.App ClassLoader"></a><strong>3.App ClassLoader</strong></h2><blockquote>
<p>称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件（由系统参数java.class.path指定）</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote>
<p>Extension ClassLoader和App ClassLoader 这两个类加载器实际上都是继承了ClassLoader类，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器，也就是说：</p>
<blockquote>
<blockquote>
<p>Bootstrap Loader会在JVM启动之后载入，之后它会载入ExtClassLoader并将ExtClassLoader的parent设为Bootstrap Loader，然后BootstrapLoader再加载AppClassLoader，并将AppClassLoader的<strong>parent</strong>设定为 ExtClassLoader。</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="ClassLoader加载类的原理"><a href="#ClassLoader加载类的原理" class="headerlink" title="ClassLoader加载类的原理"></a><strong>ClassLoader加载类的原理</strong></h1><h2 id="双亲委托加载模式"><a href="#双亲委托加载模式" class="headerlink" title="双亲委托加载模式"></a><strong>双亲委托加载模式</strong></h2><blockquote>
<p>我们知道除了顶级的 Bootstrap Loader他的parent属性为null之外，其他的两个或者自定义的类加载器都是存在parent 的。</p>
</blockquote>
<hr>
<blockquote>
<p>当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，<strong>先把</strong>这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象<br><img src="/2017/08/24/java之ClassLoader源码分析/1807893f814129fdbae5ad6.png" alt="类加载顺序" title="类加载顺序"></p>
</blockquote>
<h2 id="为什么要使用双亲委托这种模型呢"><a href="#为什么要使用双亲委托这种模型呢" class="headerlink" title="为什么要使用双亲委托这种模型呢"></a><strong>为什么要使用双亲委托这种模型呢</strong></h2><blockquote>
<p>java是一门具有很高的安全性的语言，使用这种加载策略的目的是为了：防止重载，父类如果已经找到了需要的类并加载到了内存，那么子类加载器就不需要再去加载该类。安全性问题。两个原因</p>
</blockquote>
<h2 id="JVM在搜索类的时候，又是如何判定两个class是相同的"><a href="#JVM在搜索类的时候，又是如何判定两个class是相同的" class="headerlink" title="JVM在搜索类的时候，又是如何判定两个class是相同的"></a><strong>JVM在搜索类的时候，又是如何判定两个class是相同的</strong></h2><ul>
<li>类名是否相同</li>
<li>否由同一个类加载器实例加载</li>
</ul>
<h2 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a><strong>看一个例子</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoader</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">       </div><div class="line">        ClassLoader loader = TestClassLoader.class.getClassLoader();    <span class="comment">//获得加载ClassLoaderTest.class这个类的类加载器  </span></div><div class="line">        <span class="keyword">while</span>(loader != <span class="keyword">null</span>) &#123;  </div><div class="line">            System.out.println(loader);  </div><div class="line">            loader = loader.getParent();    <span class="comment">//获得父类加载器的引用  </span></div><div class="line">        &#125;  </div><div class="line">        System.out.println(loader);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@2a139a55</div><div class="line">sun.misc.Launcher$ExtClassLoader@7852e922</div><div class="line">null</div></pre></td></tr></table></figure>
<p>结论</p>
<blockquote>
<p>第一行结果说明：ClassLoaderTest的类加载器是AppClassLoader。</p>
<p>第二行结果说明：AppClassLoader的类加器是ExtClassLoader，即parent=ExtClassLoader。</p>
<p>第三行结果说明：ExtClassLoader的类加器是Bootstrap ClassLoader，因为Bootstrap ClassLoader不是一个普通的Java类，所以ExtClassLoader的parent=null，所以第三行的打印结果为null就是这个原因。</p>
</blockquote>
<p>测试2</p>
<blockquote>
<p>将ClassLoaderTest.class打包成ClassLoaderTest.jar，放到Extension ClassLoader的加载目录下（JAVA_HOME/jre/lib/ext），然后重新运行这个程序，得到的结果会是什么样呢？</p>
</blockquote>
<hr>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sun.misc.Launcher$ExtClassLoader@7852e922</div><div class="line">null</div></pre></td></tr></table></figure>
<p>结果分析：</p>
<blockquote>
<p>为什么第一行的结果是ExtClassLoader呢？</p>
<p>因为ClassLoader的委托模型机制，当我们要用ClassLoaderTest.class这个类的时候，AppClassLoader在试图加载之前，先委托给Bootstrcp ClassLoader，Bootstracp ClassLoader发现自己没找到，它就告诉ExtClassLoader，兄弟，我这里没有这个类，你去加载看看，然后Extension ClassLoader拿着这个类去它指定的类路径（JAVA_HOME/jre/lib/ext）试图加载，唉，它发现在ClassLoaderTest.jar这样一个文件中包含ClassLoaderTest.class这样的一个文件，然后它把找到的这个类加载到内存当中，并生成这个类的Class实例对象，最后把这个实例返回。所以ClassLoaderTest.class的类加载器是ExtClassLoader。</p>
<p>第二行的结果为null，是因为ExtClassLoader的父类加载器是Bootstrap ClassLoader。</p>
</blockquote>
<p>测试3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">用Bootstrcp ClassLoader来加载ClassLoaderTest.class，有两种方式：</div><div class="line"></div><div class="line">1、在jvm中添加-Xbootclasspath参数，指定Bootstrcp ClassLoader加载类的路径，并追加我们自已的jar（ClassTestLoader.jar）</div><div class="line"></div><div class="line">2、将class文件放到JAVA_HOME/jre/classes/目录下（上面有提到）(将ClassLoaderTest.jar解压后，放到JAVA_HOME/jre/classes目录下，如下图所示：)</div><div class="line">提示：jre目录下默认没有classes目录，需要自己手动创建一个</div><div class="line"></div><div class="line"></div><div class="line">提供者：Java团长</div></pre></td></tr></table></figure>
<p><img src="/2017/08/24/java之ClassLoader源码分析/1807893-362b2865ac4badae.jpg" alt=""></p>
<h1 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a><strong>自定义ClassLoader</strong></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><blockquote>
<p>实现自定义类加载的目的是，假设我们的类他不是存在特定的位置，可能是某个磁盘或者某个远程服务器上面，那么我们就需要自定义类加载器去加载这些类。</p>
</blockquote>
<ul>
<li><p>继承继承java.lang.ClassLoader</p>
</li>
<li><p>重写父类的findClass方法</p>
</li>
<li><p>在findClass()方法中调用defineClass()。</p>
</li>
</ul>
<p>这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常</p>
<p>注意： 一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。</p>
<blockquote>
<p>为什么不去重定义loadClass方法呢？其实也可以，但是loadClass方法内部已经实现了搜索类的策略。除非你是非常熟悉否则还是不建议这样去做。这里建议重载findClass方法，因为在loadClass中最后会去调用findClass方法去加载类。而且这个方法内部默认是空的。</p>
</blockquote>
<h2 id="分析loadClass方法"><a href="#分析loadClass方法" class="headerlink" title="分析loadClass方法"></a><strong>分析loadClass方法</strong></h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"></div><div class="line"></div><div class="line">*</div><div class="line"> A class loader is an object that is responsible for loading classes. The</div><div class="line"> class ClassLoader is an abstract class.  Given the binary name of a class, a class loader should attempt to</div><div class="line"> locate or generate data that constitutes a definition for the class.  A</div><div class="line"> typical strategy is to transform the name into a file name and then read a</div><div class="line"> &quot;class file&quot; of that name from a file system.</div><div class="line">**/</div></pre></td></tr></table></figure>
<p>大致意思如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class loader是一个负责加载classes的对象，ClassLoader类是一个抽象类，需要给出类的二进制名称，class loader尝试定位或者产生一个class的数据，一个典型的策略是把二进制名字转换成文件名然后到文件系统中找到该文件。</div></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">protected synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException&#123;  </div><div class="line">         // 首先检查该name指定的class是否有被加载  </div><div class="line">         Class c = findLoadedClass(name);  </div><div class="line">         if (c == null) &#123;  </div><div class="line">             try &#123;  </div><div class="line">                 if (parent != null) &#123;  </div><div class="line">                     //如果parent不为null，则调用parent的loadClass进行加载  </div><div class="line">                     c = parent.loadClass(name, false);  </div><div class="line">                 &#125;else&#123;  </div><div class="line">                     //parent为null，则调用BootstrapClassLoader进行加载  </div><div class="line">                     c = findBootstrapClass0(name);  </div><div class="line">                 &#125;  </div><div class="line">             &#125;catch(ClassNotFoundException e) &#123;  </div><div class="line">                 //如果仍然无法加载成功，则调用自身的findClass进行加载              </div><div class="line">                 c = findClass(name);  //</div><div class="line">             &#125;  </div><div class="line">         &#125;  </div><div class="line">         if (resolve) &#123;  </div><div class="line">             resolveClass(c);  </div><div class="line">         &#125;  </div><div class="line">         return c;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.com;</div><div class="line"></div><div class="line">import java.io.ByteArrayOutputStream;</div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">public class PersonalClassLoader extends ClassLoader&#123;</div><div class="line">    private String rootUrl;  </div><div class="line"></div><div class="line">    public PersonalClassLoader(String rootUrl) &#123;  </div><div class="line">        this.rootUrl = rootUrl;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;  </div><div class="line">        Class clazz = null;//this.findLoadedClass(name); // 父类已加载     </div><div class="line">        //if (clazz == null) &#123;  //检查该类是否已被加载过  </div><div class="line">            byte[] classData = getClassData(name);  //根据类的二进制名称,获得该class文件的字节码数组  </div><div class="line">            if (classData == null) &#123;  </div><div class="line">                throw new ClassNotFoundException();  </div><div class="line">            &#125;  </div><div class="line">            clazz = defineClass(name, classData, 0, classData.length);  //将class的字节码数组转换成Class类的实例  </div><div class="line">          //ClassLoader内置方法</div><div class="line">             /*        * Converts an array of bytes into an instance of class </div><div class="line">        * Before the &lt;tt&gt;Class&lt;/tt&gt; can be used it must be resolved.*/</div><div class="line">        //&#125;   </div><div class="line">        return clazz;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    private byte[] getClassData(String name) &#123;  </div><div class="line">        InputStream is = null;  </div><div class="line">        try &#123;  </div><div class="line">            String path = classNameToPath(name);  </div><div class="line">            URL url = new URL(path);  </div><div class="line">            byte[] buff = new byte[1024*4];  </div><div class="line">            int len = -1;  </div><div class="line">            is = url.openStream();  </div><div class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();  </div><div class="line">            while((len = is.read(buff)) != -1) &#123;  </div><div class="line">                baos.write(buff,0,len);  </div><div class="line">            &#125;  </div><div class="line">            return baos.toByteArray();  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            if (is != null) &#123;  </div><div class="line">               try &#123;  </div><div class="line">                  is.close();  </div><div class="line">               &#125; catch(IOException e) &#123;  </div><div class="line">                  e.printStackTrace();  </div><div class="line">               &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return null;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    private String classNameToPath(String name) &#123;  </div><div class="line">        return rootUrl + &quot;/&quot; + name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.com;</div><div class="line"></div><div class="line">public class ClassLoaderTest</div><div class="line">&#123;</div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        try &#123;  </div><div class="line">            /*ClassLoader loader = ClassLoaderTest.class.getClassLoader();  //获得ClassLoaderTest这个类的类加载器 </div><div class="line">            while(loader != null) &#123; </div><div class="line">                System.out.println(loader); </div><div class="line">                loader = loader.getParent();    //获得父加载器的引用 </div><div class="line">            &#125; </div><div class="line">            System.out.println(loader);*/  </div><div class="line"></div><div class="line">            String rootUrl = &quot;http://localhost:8080/console/res&quot;;  </div><div class="line">            PersonalClassLoader networkClassLoader = new PersonalClassLoader(rootUrl);  </div><div class="line">            String classname = &quot;HelloWorld&quot;;  </div><div class="line">            Class clazz = networkClassLoader.loadClass(classname);  </div><div class="line">            System.out.println(clazz.getClassLoader());  </div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>com.kingge.com.PersonalClassLoader@65b54208</p>
</blockquote>
<p>其中HelloWorld.class文件的位置在于：<br><img src="/2017/08/24/java之ClassLoader源码分析/HelloWorld类的位置.png" alt="HelloWorld类" title="HelloWorld类"></p>
<h3 id="其实很多服务器都自定义了类加载器"><a href="#其实很多服务器都自定义了类加载器" class="headerlink" title="其实很多服务器都自定义了类加载器"></a><strong>其实很多服务器都自定义了类加载器</strong></h3><blockquote>
<p>用于加载web应用指定目录下的类库（jar或class），如：Weblogic、Jboss、tomcat等，下面我以Tomcat为例，展示该web容器都定义了哪些个类加载器：</p>
</blockquote>
<p>下面以tomcat为例子</p>
<ul>
<li>1、新建一个web工程httpweb</li>
<li>2、新建一个ClassLoaderServletTest，用于打印web容器中的ClassLoader层次结构</li>
</ul>
<p>一下代码来自网上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.io.IOException;  </div><div class="line">import java.io.PrintWriter;  </div><div class="line"></div><div class="line">import javax.servlet.ServletException;  </div><div class="line">import javax.servlet.http.HttpServlet;  </div><div class="line">import javax.servlet.http.HttpServletRequest;  </div><div class="line">import javax.servlet.http.HttpServletResponse;  </div><div class="line"></div><div class="line">public class ClassLoaderServletTest extends HttpServlet &#123;  </div><div class="line"></div><div class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response)  </div><div class="line">            throws ServletException, IOException &#123;  </div><div class="line"></div><div class="line">        response.setContentType(&quot;text/html&quot;);  </div><div class="line">        PrintWriter out = response.getWriter();  </div><div class="line">        ClassLoader loader = this.getClass().getClassLoader();  </div><div class="line">        while(loader != null) &#123;  </div><div class="line">            out.write(loader.getClass().getName()+&quot;&lt;br/&gt;&quot;);  </div><div class="line">            loader = loader.getParent();  </div><div class="line">        &#125;  </div><div class="line">        out.write(String.valueOf(loader));  </div><div class="line">        out.flush();  </div><div class="line">        out.close();  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response)  </div><div class="line">            throws ServletException, IOException &#123;  </div><div class="line">        this.doGet(request, response);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<ul>
<li>3、配置Servlet，并启动服务</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </div><div class="line">&lt;web-app version=&quot;2.4&quot;   </div><div class="line">    xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;   </div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   </div><div class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee   </div><div class="line"></div><div class="line">http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;</div><div class="line"></div><div class="line">  &lt;servlet&gt;  </div><div class="line">    &lt;servlet-name&gt;ClassLoaderServletTest&lt;/servlet-name&gt;  </div><div class="line">    &lt;servlet-class&gt;ClassLoaderServletTest&lt;/servlet-class&gt;  </div><div class="line">  &lt;/servlet&gt;  </div><div class="line"></div><div class="line">  &lt;servlet-mapping&gt;  </div><div class="line">    &lt;servlet-name&gt;ClassLoaderServletTest&lt;/servlet-name&gt;  </div><div class="line">    &lt;url-pattern&gt;/servlet/ClassLoaderServletTest&lt;/url-pattern&gt;  </div><div class="line">  &lt;/servlet-mapping&gt;  </div><div class="line">  &lt;welcome-file-list&gt;  </div><div class="line">    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;  </div><div class="line">  &lt;/welcome-file-list&gt;  </div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>运行截图：</p>
<p><img src="/2017/08/24/java之ClassLoader源码分析/1807893-a84849c93b9df9e0.jpg" alt="运行结果图" title="运行结果图"></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h1><blockquote>
<p>这种自定义的方式目的就是为了，能够控制类的加载流程，那么这种远程加载类的方式类似于我们常用的Hessian 来访问多个系统获取类</p>
</blockquote>
<h1 id="好的网站"><a href="#好的网站" class="headerlink" title="好的网站"></a><strong>好的网站</strong></h1><p><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="external">http://blog.csdn.net/briblue/article/details/54973413</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类加载器ClassLoader的含义&quot;&gt;&lt;a href=&quot;#类加载器ClassLoader的含义&quot; class=&quot;headerlink&quot; title=&quot;类加载器ClassLoader的含义&quot;&gt;&lt;/a&gt;类加载器ClassLoader的含义&lt;/h1&gt;&lt;blockquo
    
    </summary>
    
      <category term="java深入理解" scheme="http://kingge.top/categories/java%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="Java" scheme="http://kingge.top/tags/Java/"/>
    
      <category term="ClassLoader" scheme="http://kingge.top/tags/ClassLoader/"/>
    
      <category term="类加载器" scheme="http://kingge.top/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
      <category term="自定义类加载器" scheme="http://kingge.top/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
      <category term="类加载器源码分析" scheme="http://kingge.top/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>为什么毕业后选择留在小城市</title>
    <link href="http://kingge.top/2017/08/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%95%E4%B8%9A%E5%90%8E%E9%80%89%E6%8B%A9%E7%95%99%E5%9C%A8%E5%B0%8F%E5%9F%8E%E5%B8%82/"/>
    <id>http://kingge.top/2017/08/21/为什么毕业后选择留在小城市/</id>
    <published>2017-08-21T06:13:44.000Z</published>
    <updated>2017-08-23T01:12:42.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong><em>前言</em></strong></h1><p>经常看到大学要毕业的学生，会有一种纠结感。越是临近毕业，这种感觉就越是强烈<br>这种感觉实际上就是一种选择恐惧症，又或者说是<strong><em>小城综合征</em></strong>。他们对于毕业后究竟是选择去一线城市就业还是去二三线城市就业，产生了很大的选择恐惧。</p>
<h1 id="为什么会产生这种心理"><a href="#为什么会产生这种心理" class="headerlink" title="为什么会产生这种心理"></a><strong><em>为什么会产生这种心理</em></strong></h1><p>大致的原因有那么几个：</p>
<ul>
<li>身边的认识的人，都是选择回到自己的家乡进行就业，自己收到了影响。</li>
<li>大城市的生活节奏会比小城市更加的紧凑，你会很忙。</li>
<li>父母希望自己回去，离家近的地方工作。</li>
<li>恋人不跟随自己，她或他选择了回到了故乡就业，自己左右为难。</li>
<li>有些人已经在大城市实习过，对于大城市已经厌倦。</li>
</ul>
<h1 id="作者的选择"><a href="#作者的选择" class="headerlink" title="作者的选择"></a><strong><em>作者的选择</em></strong></h1><blockquote>
<p>本人就是属于最后一种，大三的时候去的深圳实习，在一家IT互联网公司上班，加班很多，虽然加班这种现象在深圳是一种常态。但是每天加班到晚上一点多，也是很累，所以毕业后也就选择回到了自己的家乡就业。</p>
</blockquote>
<hr>
<blockquote>
<p>回到了</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;前言&lt;/em&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;经常看到大学要毕业的学生，会有一种纠结感。越是临近毕业，这种感觉就越是强烈&lt;br&gt;这种感
    
    </summary>
    
      <category term="心情" scheme="http://kingge.top/categories/%E5%BF%83%E6%83%85/"/>
    
    
      <category term="心情" scheme="http://kingge.top/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="总结" scheme="http://kingge.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="有感" scheme="http://kingge.top/tags/%E6%9C%89%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>max-allowed-packet的问题</title>
    <link href="http://kingge.top/2017/08/17/max-allowed-packet%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://kingge.top/2017/08/17/max-allowed-packet的问题/</id>
    <published>2017-08-17T02:37:15.000Z</published>
    <updated>2017-08-17T09:44:39.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p> 近期，因启动项目有个批量插入的sql结果太大，超过了mysql自带的缓存，报了这个错误</p>
</blockquote>
<hr>
<blockquote>
<p>修改： 定位到mysql的安装目录下面，然后修改my.ini 的max_allowed_packet = 8M<br>默认是1M </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 近期，因启动项目有个批量插入的sql结果太大，超过了mysql自带的缓存，报了这个错误&lt;/p&gt;
&lt;/blockq
    
    </summary>
    
      <category term="Mysql" scheme="http://kingge.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://kingge.top/tags/Mysql/"/>
    
      <category term="异常" scheme="http://kingge.top/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="sql异常" scheme="http://kingge.top/tags/sql%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移</title>
    <link href="http://kingge.top/2017/08/14/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    <id>http://kingge.top/2017/08/14/博客迁移/</id>
    <published>2017-08-14T02:26:07.157Z</published>
    <updated>2017-08-16T02:35:53.838Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天周一，天气炎热，调开空调。噼里啪啦的敲完今天的工作，因为今天本人决定再次迁移自己的PersonalBlog。个人一共换过很多个博客，前期使用过网易博客，后来访问量上不去(网易博客他并不是一个IT社区)，后来换到了博客园，感觉还行，但是好景不长，感觉本人有处女座的完美主义，很纠结，总感觉这个博客园UI设计不行。<br>      最后又换到了CSDN，今天又临时决定迁移到了本人的服务器上面，自由管理。<br>      我的性格知道的人应该知道，我是知无不言言无不尽，只要我会的有所感悟的都会分享出来。以后每天心情一更，工作方面一周一更。</p>
</blockquote>
<hr>
<blockquote>
<p>最后：人生需要面对,搞笑我是认真的。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天周一，天气炎热，调开空调。噼里啪啦的敲完今天的工作，因为今天本人决定再次迁移自己的PersonalBlog。个人一共换过很多个博客，前期使用过网易博客，后来访问量上不去(网易博客他并不是一个IT社区)，后来换到了博客园，感觉还行，但是好景不长，
    
    </summary>
    
      <category term="心情" scheme="http://kingge.top/categories/%E5%BF%83%E6%83%85/"/>
    
    
  </entry>
  
  <entry>
    <title>Hessian 多系统访问</title>
    <link href="http://kingge.top/2017/08/14/Hessian%20%E5%A4%9A%E7%B3%BB%E7%BB%9F%E8%AE%BF%E9%97%AE/"/>
    <id>http://kingge.top/2017/08/14/Hessian 多系统访问/</id>
    <published>2017-08-14T01:31:13.972Z</published>
    <updated>2017-08-31T09:44:24.038Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>实现多数据量的导入数据库</title>
    <link href="http://kingge.top/2017/08/01/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://kingge.top/2017/08/01/实现多数据量的导入数据库/</id>
    <published>2017-08-01T06:37:15.000Z</published>
    <updated>2017-08-17T08:21:15.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>在做一个项目的时候，涉及到需要从一个表格中获取百万条数据然后插入到数据库中，最后采用JDBC的executeBantch方法实现这个功能。</p>
</blockquote>
<hr>
<h2 id="采取的策略"><a href="#采取的策略" class="headerlink" title="采取的策略"></a>采取的策略</h2><ul>
<li><p>尽量关闭字段<a href="/2016/08/01/Mysql索引详解"><strong><em>索引</em></strong></a>（因为再插入数据的时候还是需要维护索引的，在创建索引和维护索引 会耗费时间,随着数据量的增加而增加，可以在插入数据后再去为字段创建索引）</p>
<blockquote>
<p>虽然索引可以提高查询速度但是，插入数据的时候会导致索性的更新。索性越多，插入会越慢。可以看文档描述:<br>Although it can be tempting to create an indexes for every possible column used in a query, unnecessary indexes waste space and waste time for MySQL to determine which indexes to use. Indexes also add to the cost of inserts, updates, and deletes because each index must be updated. You must find the right balance to achieve fast queries using the optimal set of indexes.</p>
</blockquote>
</li>
<li><p>分批次提交数据</p>
</li>
<li><p>在分布式条件下，还可以考虑在不同的数据库结点提交，有底层的消息系统完成数据扩展</p>
</li>
<li>过滤预处理数据<blockquote>
<p>预处理数据的场景：为了避免插入的数据（假设ListA）跟数据库中某些数据重复，那么我们会把要插入的数据去数据库中查询是否已经存在，获得返回的已经存在数据（ListB）。然后在插入数据的时候判断当前数据是否在ListB中，那么当前数据不能够插入数据库。过滤出来，最后得到一个可以插入数据库的ListC</p>
</blockquote>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*数据分析结束*/</span></div><div class="line">     <span class="comment">/*往数据库写数据开始*/</span></div><div class="line">     Connection conn=<span class="keyword">null</span>;</div><div class="line">     PreparedStatement idsUserAdd=<span class="keyword">null</span>;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>) ;</div><div class="line">         conn = DriverManager.getConnection(ConfigTool.getProperty(<span class="string">"jdbc.url"</span>).toString() , ConfigTool.getProperty(<span class="string">"jdbc.username"</span>).toString() , ConfigTool.getProperty(<span class="string">"jdbc.password"</span>).toString());</div><div class="line">         conn.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">         <span class="comment">//构造预处理statement</span></div><div class="line">         idsUserAdd = conn.prepareStatement(<span class="string">"INSERT INTO dc_matedata ("</span>+</div><div class="line">       		  <span class="string">" ID,`NAME`, DATATYPE,`CODE`,TYPE_ID,`LENGTH`, "</span>+</div><div class="line">       		  <span class="string">" DATANAME, VALUEAREA,`RESTRICT`, REMARK,MD_DATE)"</span>+</div><div class="line">       		  <span class="string">" values(?,?,?,?,?,?,?,?,?,?,now())"</span>);</div><div class="line">        <span class="comment">//最大列表的数目当做循环次数</span></div><div class="line">         <span class="keyword">int</span> xhcs=addMetadataList.size();<span class="comment">//addMetadataList需要插入的数据</span></div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xhcs;i++)&#123;</div><div class="line">                 idsUserAdd.setString(<span class="number">1</span>,addMetadataList.get(i).get(<span class="string">"id"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">2</span>,addMetadataList.get(i).get(<span class="string">"name"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">3</span>,addMetadataList.get(i).get(<span class="string">"dataType"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">4</span>,addMetadataList.get(i).get(<span class="string">"code"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">5</span>,addMetadataList.get(i).get(<span class="string">"typeId"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">6</span>,addMetadataList.get(i).get(<span class="string">"dataLength"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">7</span>,addMetadataList.get(i).get(<span class="string">"dataName"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">8</span>,addMetadataList.get(i).get(<span class="string">"valueArea"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">9</span>,addMetadataList.get(i).get(<span class="string">"dataRestrict"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">10</span>,addMetadataList.get(i).get(<span class="string">"dataRemark"</span>).toString());</div><div class="line">                 idsUserAdd.addBatch();</div><div class="line">                 </div><div class="line">             <span class="comment">//每10000次提交一次</span></div><div class="line">             <span class="keyword">if</span>(i%<span class="number">10000</span>==<span class="number">0</span>||i==xhcs-<span class="number">1</span>)&#123;<span class="comment">//可以设置不同的大小；如50，100，500，1000等等 i==xhcs-1（最后一次）</span></div><div class="line">                 idsUserAdd.executeBatch();</div><div class="line">                 conn.commit();</div><div class="line">                 idsUserAdd.clearBatch();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">         <span class="keyword">throw</span>  e;</div><div class="line">     &#125;<span class="keyword">finally</span> &#123;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             <span class="keyword">if</span>(idsUserAdd!=<span class="keyword">null</span>)</div><div class="line">                 idsUserAdd.close();</div><div class="line">             <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</div><div class="line">                 conn.close();</div><div class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">             e.printStackTrace();</div><div class="line">             <span class="keyword">throw</span>  e;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div><div class="line">     <span class="comment">/*往数据库写数据结束*/</span></div></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">   * 校验需要导入的元数据信息，封装错误信息并批量插入数据库</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; saveDCMetadataBatch(List&lt;Map&lt;String, Object&gt;&gt; list,  <span class="keyword">boolean</span> valid,</div><div class="line">          <span class="keyword">boolean</span> addError) <span class="keyword">throws</span> Exception&#123;</div><div class="line">      </div><div class="line">      List&lt;Map&lt;String,Object&gt;&gt; errorList=<span class="keyword">new</span> ArrayList&lt;Map&lt;String,Object&gt;&gt;();<span class="comment">//获得不能够添加成功的数据</span></div><div class="line">      Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;String,Object&gt;();<span class="comment">//查询条件</span></div><div class="line">      Map&lt;String,String&gt; codeMap=<span class="keyword">new</span> HashMap&lt;String,String&gt;();<span class="comment">//每个分类对应的元数据的编号最大值</span></div><div class="line">      Map&lt;String,Object&gt; metaName=<span class="keyword">new</span> HashMap&lt;String,Object&gt;();<span class="comment">//查询数据库中是否存在相同的数据（这里校验的是：元数据的中文简称）</span></div><div class="line">      Map&lt;String,Object&gt; metaDataName=<span class="keyword">new</span> HashMap&lt;String,Object&gt;();<span class="comment">//查询数据库中是否存在相同的数据（这里校验的是：元数据的数据项名称）</span></div><div class="line">      </div><div class="line">      map.put(<span class="string">"metaName"</span>,list);<span class="comment">//需要查询的元数据中文名称</span></div><div class="line">      map.put(<span class="string">"metaDataTypeId"</span>,list);<span class="comment">//导入的元数据的编号</span></div><div class="line">      List&lt;Map&lt;String, Object&gt;&gt; metaExistList = dCMatedataDao.getDCMetadata(map);<span class="comment">//根据元数据名称查询当前分类下是否存在同样元数据</span></div><div class="line">      map.put(<span class="string">"metaName"</span>,<span class="keyword">null</span>);<span class="comment">//置空</span></div><div class="line">      </div><div class="line">      map.put(<span class="string">"metaDataName"</span>,list);</div><div class="line">      List&lt;Map&lt;String, Object&gt;&gt; metaExistListTwo = dCMatedataDao.getDCMetadata(map);<span class="comment">//根据元数据数据项名称查询存在的元数据</span></div><div class="line">      </div><div class="line">      <span class="comment">//保存重复的信息</span></div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;metaExistList.size();i++)</div><div class="line">          metaName.put(metaExistList.get(i).get(<span class="string">"name"</span>).toString()+metaExistList.get(i).get(<span class="string">"code"</span>).toString()</div><div class="line">                  ,metaExistList.get(i).get(<span class="string">"id"</span>));<span class="comment">//添加父类的编号为后缀-唯一性保证</span></div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;metaExistListTwo.size();i++)</div><div class="line">          metaDataName.put(metaExistListTwo.get(i).get(<span class="string">"dataname"</span>).toString()+metaExistListTwo.get(i).get(<span class="string">"code"</span>).toString(),</div><div class="line">                  metaExistListTwo.get(i).get(<span class="string">"id"</span>));</div><div class="line">      </div><div class="line">      </div><div class="line">      <span class="comment">/*整理出来的数据-开始*/</span></div><div class="line">      List&lt;Map&lt;String,Object&gt;&gt; addMetadataList=<span class="keyword">new</span> ArrayList&lt;Map&lt;String,Object&gt;&gt;();</div><div class="line">      </div><div class="line">      <span class="comment">/*整理出来的数据-结束*/</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">          Map&lt;String, Object&gt; MetadataObj = list.get(i);</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">              String metadatId = StringUtil.getUUID();<span class="comment">//元数据id</span></div><div class="line">                  <span class="comment">/*校验开始*/</span></div><div class="line">              <span class="keyword">if</span> (valid)&#123;</div><div class="line">                  <span class="keyword">if</span>(validUser(MetadataObj,<span class="string">"name"</span>,addError)!=<span class="keyword">null</span>)&#123;<span class="comment">//验证输入的数据是否符合格式和必填。</span></div><div class="line">                      errorList.add(MetadataObj);</div><div class="line">                      <span class="keyword">continue</span>;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              <span class="comment">/*前端校验结束*/</span></div><div class="line">              <span class="comment">/*校验是否存在同名的元数据*/</span></div><div class="line">              String dataCodeCheck = MetadataObj.get(<span class="string">"dataCode"</span>).toString().trim();      <span class="comment">//元数据父分类编号</span></div><div class="line">              String name = MetadataObj.get(<span class="string">"name"</span>).toString().trim();<span class="comment">//元数据中文简称</span></div><div class="line">                  <span class="keyword">if</span> (metaName.containsKey(name+dataCodeCheck)) &#123;</div><div class="line"></div><div class="line">                      <span class="keyword">if</span> (addError) &#123;</div><div class="line">                          MetadataObj.put(<span class="string">"errInfo"</span>, <span class="string">"中文简称已存在"</span>);</div><div class="line">                      &#125;</div><div class="line">                      errorList.add(MetadataObj);</div><div class="line">                      <span class="keyword">continue</span>;</div><div class="line">                  &#125;</div><div class="line">                  <span class="comment">/*校验是否存在相同数据项的元数据*/</span></div><div class="line">                  String dataName = MetadataObj.get(<span class="string">"dataName"</span>).toString().trim();<span class="comment">//数据项名</span></div><div class="line">                  <span class="keyword">if</span> (metaDataName.containsKey(dataName+dataCodeCheck)) &#123;</div><div class="line">                      </div><div class="line">                      <span class="keyword">if</span> (addError) &#123;</div><div class="line">                          MetadataObj.put(<span class="string">"errInfo"</span>, <span class="string">"数据项名已存在"</span>);</div><div class="line">                      &#125;</div><div class="line">                      errorList.add(MetadataObj);</div><div class="line">                      <span class="keyword">continue</span>;</div><div class="line">                  &#125;</div><div class="line">                  </div><div class="line">                  String dataCode = MetadataObj.get(<span class="string">"dataCode"</span>).toString().trim();      <span class="comment">//元数据父分类编号</span></div><div class="line">                  List&lt;Map&lt;String, Object&gt;&gt; footCount = dCMatedataDao.getFootCount(dataCode);</div><div class="line">                  <span class="keyword">if</span>( footCount.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">                      <span class="keyword">if</span> (addError) &#123;</div><div class="line">                          MetadataObj.put(<span class="string">"errInfo"</span>, <span class="string">"分类编码不是最后一级分类"</span>);</div><div class="line">                      &#125;</div><div class="line">                      errorList.add(MetadataObj);</div><div class="line">                      <span class="keyword">continue</span>;</div><div class="line">                  &#125;</div><div class="line">                   Map&lt;String, Object&gt; typeByCode = dCMatedataDao.getMetadataTypeByCode(dataCode);</div><div class="line">                  <span class="keyword">if</span>( typeByCode == <span class="keyword">null</span> || typeByCode.size() &lt; <span class="number">1</span>)&#123;</div><div class="line">                      <span class="keyword">if</span> (addError) &#123;</div><div class="line">                          MetadataObj.put(<span class="string">"errInfo"</span>, <span class="string">"分类编码不存在，请先添加分类"</span>);</div><div class="line">                      &#125;</div><div class="line">                      errorList.add(MetadataObj);</div><div class="line">                      <span class="keyword">continue</span>;</div><div class="line">                  &#125;</div><div class="line">                  <span class="comment">//校验是在添加的List中是否存在相同的数据项名或者中文简称</span></div><div class="line">                  <span class="comment">//校验导入文件中是否存在一样的中文简称或者数据项名</span></div><div class="line">                  <span class="keyword">boolean</span> nameExist = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">boolean</span> dataNameExist = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; addMetadataList.size(); j++)&#123;</div><div class="line">                      Map&lt;String, Object&gt; map2 = addMetadataList.get(j);</div><div class="line">                      String typeId = map2.get(<span class="string">"typeId"</span>).toString();</div><div class="line">                      String nameE = map2.get(<span class="string">"name"</span>).toString();</div><div class="line">                      String dataNameE = map2.get(<span class="string">"dataName"</span>).toString();</div><div class="line">                      <span class="keyword">if</span>( typeId.equals(typeByCode.get(<span class="string">"id"</span>).toString()) &amp;&amp; nameE.equals(name))&#123;</div><div class="line">                          nameExist=<span class="keyword">true</span>;</div><div class="line">                          <span class="keyword">break</span>;</div><div class="line">                      &#125;</div><div class="line">                      <span class="keyword">if</span>( typeId.equals(typeByCode.get(<span class="string">"id"</span>).toString()) &amp;&amp; dataNameE.equals(dataName))&#123;</div><div class="line">                          dataNameExist=<span class="keyword">true</span>;</div><div class="line">                          <span class="keyword">break</span>;</div><div class="line">                      &#125;</div><div class="line">                   </div><div class="line">               &#125;</div><div class="line">                  <span class="keyword">if</span>( nameExist )&#123;</div><div class="line">                      <span class="keyword">if</span> (addError) &#123;</div><div class="line">                          MetadataObj.put(<span class="string">"errInfo"</span>, <span class="string">"中文简称已存在"</span>);</div><div class="line">                      &#125;</div><div class="line">                      errorList.add(MetadataObj);</div><div class="line">                      <span class="keyword">continue</span>;</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">if</span>( dataNameExist )&#123;</div><div class="line">                      <span class="keyword">if</span> (addError) &#123;</div><div class="line">                          MetadataObj.put(<span class="string">"errInfo"</span>, <span class="string">"数据项名已存在"</span>);</div><div class="line">                      &#125;</div><div class="line">                      errorList.add(MetadataObj);</div><div class="line">                      <span class="keyword">continue</span>;</div><div class="line">                  &#125;</div><div class="line">                  </div><div class="line">                 <span class="comment">//进入这里说明校验结束，开始填充添加的数据</span></div><div class="line">                  String type_id = typeByCode.get(<span class="string">"id"</span>).toString();<span class="comment">//元数据所属分类id</span></div><div class="line">                  String dataType =  MetadataObj.get(<span class="string">"dataType"</span>).toString().trim();      <span class="comment">//元数据类型</span></div><div class="line">                  String dataLength =  MetadataObj.get(<span class="string">"dataLength"</span>).toString().trim();      <span class="comment">//元数据长度</span></div><div class="line">                  String code  = <span class="string">""</span>;</div><div class="line">                  <span class="comment">////</span></div><div class="line">                  <span class="keyword">if</span>( codeMap.get(dataCode) == <span class="keyword">null</span>||StringUtil.isEmpty(codeMap.get(dataCode)) )&#123;<span class="comment">//表示当前分类不存在已经添加的元数据--因为编码map中不存在对应分类的最大编码</span></div><div class="line">                      </div><div class="line">                      Map maxCodeByPid = <span class="keyword">this</span>.selectMetadataMaxCode(type_id);</div><div class="line">                      <span class="keyword">if</span>( maxCodeByPid == <span class="keyword">null</span> )&#123;<span class="comment">//表示当前分类下不存在任何子分类</span></div><div class="line">                          code =  StringUtil.getCode(<span class="string">"0"</span>, dataCode);<span class="comment">//则从01开始编号</span></div><div class="line">                          codeMap.put(dataCode, <span class="string">"01"</span>);<span class="comment">//保存当前分类下元数据编号最大值</span></div><div class="line">                      &#125;<span class="keyword">else</span>&#123;</div><div class="line">                          String object = (String) maxCodeByPid.get(<span class="string">"codeNum"</span>);<span class="comment">//当前分类节点下的元数据的编号最大值。</span></div><div class="line">                          <span class="keyword">int</span> pSituation = object.indexOf(dataCode);</div><div class="line">                          <span class="keyword">int</span> pLength =   pSituation+dataCode.length() ;</div><div class="line">                          String substring = object.substring(pLength); <span class="comment">//截取出最大编号值得最大值</span></div><div class="line">                          code = StringUtil.getCode(substring, dataCode);</div><div class="line">                          </div><div class="line">                          <span class="keyword">int</span> temp = Integer.parseInt(substring);<span class="comment">//保存当前分类下元数据编号最大值</span></div><div class="line">                          temp+=<span class="number">1</span>;</div><div class="line">                          codeMap.put(dataCode, temp+<span class="string">""</span>);</div><div class="line">                      &#125;</div><div class="line">                  &#125;<span class="keyword">else</span>&#123;</div><div class="line">                      String maxCode = codeMap.get(dataCode);</div><div class="line">                      code = StringUtil.getCode(maxCode, dataCode);</div><div class="line">                      <span class="comment">//保存当前分类下元数据编号最大值</span></div><div class="line">                      <span class="keyword">int</span> temp = Integer.parseInt(maxCode);</div><div class="line">                      temp+=<span class="number">1</span>;</div><div class="line">                      codeMap.put(dataCode, temp+<span class="string">""</span>);</div><div class="line">                  &#125;</div><div class="line">                      </div><div class="line">                  <span class="comment">///</span></div><div class="line">                  Map&lt;String, Object&gt; metadatList = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</div><div class="line">                  metadatList.put(<span class="string">"id"</span>, metadatId);</div><div class="line">                  metadatList.put(<span class="string">"name"</span>,name);</div><div class="line">                  metadatList.put(<span class="string">"dataType"</span>,dataType);</div><div class="line">                  metadatList.put(<span class="string">"code"</span>,code);</div><div class="line">                  metadatList.put(<span class="string">"typeId"</span>,type_id);</div><div class="line">                  metadatList.put(<span class="string">"dataLength"</span>,dataLength);</div><div class="line">                  metadatList.put(<span class="string">"dataName"</span>,dataName);</div><div class="line">                  metadatList.put(<span class="string">"valueArea"</span>, MetadataObj.get(<span class="string">"valueArea"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:MetadataObj.get(<span class="string">"valueArea"</span>) );</div><div class="line">                  metadatList.put(<span class="string">"dataRestrict"</span>,MetadataObj.get(<span class="string">"dataRestrict"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:MetadataObj.get(<span class="string">"dataRestrict"</span>));</div><div class="line">                  metadatList.put(<span class="string">"dataRemark"</span>,MetadataObj.get(<span class="string">"dataRemark"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:MetadataObj.get(<span class="string">"dataRemark"</span>));</div><div class="line">                  metadatList.put(<span class="string">"mdDate"</span>,<span class="keyword">new</span> Date());</div><div class="line">                  </div><div class="line">                  addMetadataList.add(metadatList);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">              <span class="keyword">if</span>(addError) &#123;</div><div class="line">                  MetadataObj.put(<span class="string">"errInfo"</span>, e.getMessage());</div><div class="line">              &#125;</div><div class="line">              errorList.add(MetadataObj);</div><div class="line"></div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">/*数据分析结束*/</span></div><div class="line">     <span class="comment">/*往数据库写数据开始*/</span></div><div class="line">     Connection conn=<span class="keyword">null</span>;</div><div class="line">     PreparedStatement idsUserAdd=<span class="keyword">null</span>;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>) ;</div><div class="line">         conn = DriverManager.getConnection(ConfigTool.getProperty(<span class="string">"jdbc.url"</span>).toString() , ConfigTool.getProperty(<span class="string">"jdbc.username"</span>).toString() , ConfigTool.getProperty(<span class="string">"jdbc.password"</span>).toString());</div><div class="line">         conn.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">         <span class="comment">//构造预处理statement</span></div><div class="line">         idsUserAdd = conn.prepareStatement(<span class="string">"INSERT INTO dc_matedata ("</span>+</div><div class="line">       		  <span class="string">" ID,`NAME`, DATATYPE,`CODE`,TYPE_ID,`LENGTH`, "</span>+</div><div class="line">       		  <span class="string">" DATANAME, VALUEAREA,`RESTRICT`, REMARK,MD_DATE)"</span>+</div><div class="line">       		  <span class="string">" values(?,?,?,?,?,?,?,?,?,?,now())"</span>);</div><div class="line">        <span class="comment">//最大列表的数目当做循环次数</span></div><div class="line">         <span class="keyword">int</span> xhcs=addMetadataList.size();</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xhcs;i++)&#123;</div><div class="line">                 idsUserAdd.setString(<span class="number">1</span>,addMetadataList.get(i).get(<span class="string">"id"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">2</span>,addMetadataList.get(i).get(<span class="string">"name"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">3</span>,addMetadataList.get(i).get(<span class="string">"dataType"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">4</span>,addMetadataList.get(i).get(<span class="string">"code"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">5</span>,addMetadataList.get(i).get(<span class="string">"typeId"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">6</span>,addMetadataList.get(i).get(<span class="string">"dataLength"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">7</span>,addMetadataList.get(i).get(<span class="string">"dataName"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">8</span>,addMetadataList.get(i).get(<span class="string">"valueArea"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">9</span>,addMetadataList.get(i).get(<span class="string">"dataRestrict"</span>).toString());</div><div class="line">                 idsUserAdd.setString(<span class="number">10</span>,addMetadataList.get(i).get(<span class="string">"dataRemark"</span>).toString());</div><div class="line">                 idsUserAdd.addBatch();</div><div class="line">                 </div><div class="line">             <span class="comment">//每10000次提交一次</span></div><div class="line">             <span class="keyword">if</span>(i%<span class="number">10000</span>==<span class="number">0</span>||i==xhcs-<span class="number">1</span>)&#123;<span class="comment">//可以设置不同的大小；如50，100，500，1000等等</span></div><div class="line">                 idsUserAdd.executeBatch();</div><div class="line">                 conn.commit();</div><div class="line">                 idsUserAdd.clearBatch();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">         <span class="keyword">throw</span>  e;</div><div class="line">     &#125;<span class="keyword">finally</span> &#123;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             <span class="keyword">if</span>(idsUserAdd!=<span class="keyword">null</span>)</div><div class="line">                 idsUserAdd.close();</div><div class="line">             <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</div><div class="line">                 conn.close();</div><div class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">             e.printStackTrace();</div><div class="line">             <span class="keyword">throw</span>  e;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div><div class="line">     <span class="comment">/*往数据库写数据结束*/</span></div><div class="line"></div><div class="line">      </div><div class="line">   <span class="keyword">return</span> errorList;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>有些网友发现使用StringBuffer 来拼接入参，不通过prepareStatement的预处理，虽然前者速度很快，但是使用prepareStatement可以防止SQL注入</p>
</blockquote>
<hr>
<blockquote>
<p>有的好的建议大家都可以提出来</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在做一个项目的时候，涉及到需要从一个表格中获取百万条数据然后插入到数据库中，最后采用JDBC的executeBan
    
    </summary>
    
      <category term="JDBC" scheme="http://kingge.top/categories/JDBC/"/>
    
    
      <category term="Mysql" scheme="http://kingge.top/tags/Mysql/"/>
    
      <category term="JDBC" scheme="http://kingge.top/tags/JDBC/"/>
    
      <category term="批量导入" scheme="http://kingge.top/tags/%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5/"/>
    
      <category term="SSM" scheme="http://kingge.top/tags/SSM/"/>
    
      <category term="项目经验" scheme="http://kingge.top/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Java工程师书单（初级、中级、高级）</title>
    <link href="http://kingge.top/2017/06/21/Java%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B9%A6%E5%8D%95%EF%BC%88%E5%88%9D%E7%BA%A7%E3%80%81%E4%B8%AD%E7%BA%A7%E3%80%81%E9%AB%98%E7%BA%A7%EF%BC%89/"/>
    <id>http://kingge.top/2017/06/21/Java工程师书单（初级、中级、高级）/</id>
    <published>2017-06-21T06:13:44.000Z</published>
    <updated>2017-08-24T07:33:21.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>当你的能力承受不住你的欲望，你就应该静下心来读书</p>
</blockquote>
<h1 id="初级书籍"><a href="#初级书籍" class="headerlink" title="初级书籍"></a><strong>初级书籍</strong></h1><h2 id="《编写高质量代码——改善Java程序的151个建议》"><a href="#《编写高质量代码——改善Java程序的151个建议》" class="headerlink" title="《编写高质量代码——改善Java程序的151个建议》"></a>《编写高质量代码——改善Java程序的151个建议》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-3a0479a82ae73108.jpg" alt="编写高质量代码——改善Java程序的151个建议"></p>
<blockquote>
<p>这是一本值得入门java的人放在床头的书。此书内容广泛、要点翔实。大多数优秀程序设计书籍都需要看老外写的，但是这本讲述提高java编程水平的书还是不错的，适合具有基本java编程能力的人。<br>对于程序猿而言，工作久了，就感觉编程习惯对一个人很重要。习惯好，不仅工作效率告，而且bug少。这本书对提高个人的好的编程习惯很有帮助。</p>
</blockquote>
<h2 id="《Java程序员修炼之道》"><a href="#《Java程序员修炼之道》" class="headerlink" title="《Java程序员修炼之道》"></a>《Java程序员修炼之道》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-dc1266b4d179ca93.jpg" alt="Java程序员修炼之道"></p>
<blockquote>
<p>此书涵盖了Java7的新特性和Java开发的关键技术，对当前大量开源技术并存，多核处理器、并发以及海量数据给Java开发带来的挑战作出了精辟的分析，提供了实践前沿的深刻洞见，涉及依赖注入、现代并发、类与字节码、性能调优等底层概念的剖析。<em>**</em><br>书中的道理很浅显，可是对于菜鸟却是至理名言。基本为你勾勒了一个成熟软件程序员专家所需要的所有特性。。</p>
</blockquote>
<h2 id="《Java8实战》"><a href="#《Java8实战》" class="headerlink" title="《Java8实战》"></a>《Java8实战》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-7522c1eda632f594.jpg" alt="Java8实战"></p>
<blockquote>
<p>没看过。嘻嘻嘻</p>
</blockquote>
<h2 id="《有效的单元测试》"><a href="#《有效的单元测试》" class="headerlink" title="《有效的单元测试》"></a>《有效的单元测试》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-43a284b4c090ae7a.jpg" alt="有效的单元测试"></p>
<blockquote>
<p>此书由敏捷技术实践专家撰写，系统且深入地阐释单元测试用于软件设计的工具、方法、原则和佳实践；深入剖析各种测试常见问题，包含大量实践案例，可操作性强，能为用户高效编写测试提供系统实践指南。<em>**</em><br>介绍了单元测试的各个方面，TDD、test double、测试的坏味道、可测试的设计等等，每个主题需要深入的话，还需要配合其它书籍和实践，非常适合入门单元测试。书中例子非常全面，看完对使用 Junit 进行单元测试会有一个大的长进，而且用java语言编写，内容很新</p>
</blockquote>
<h2 id="《Java核心技术：卷1》"><a href="#《Java核心技术：卷1》" class="headerlink" title="《Java核心技术：卷1》"></a>《Java核心技术：卷1》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/juanyi.jpg" alt="《Java核心技术：卷1 》"></p>
<blockquote>
<p>不推荐卷2，因为这个作为初级书单来讲，太难了。</p>
</blockquote>
<h2 id="《代码整洁之道》"><a href="#《代码整洁之道》" class="headerlink" title="《代码整洁之道》"></a>《代码整洁之道》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-af77e6efc29482be.jpg" alt="《代码整洁之道》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<h2 id="《数据结构与算法分析-Java语言描述》"><a href="#《数据结构与算法分析-Java语言描述》" class="headerlink" title="《数据结构与算法分析-Java语言描述》"></a>《数据结构与算法分析-Java语言描述》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-1c4bce389fcc0232.jpg" alt="《数据结构与算法分析-Java语言描述》"></p>
<blockquote>
<p>本书是java数据结构与算法方面的三宝之一，除了这三本其他的已经没有意义了。这三宝分别是:<em>**</em><br>黑宝书《数据结构与算法分析java语言描述》mark allen weiss<br>蓝宝书《java数据结构和算法》robert lafore<br>红宝书《算法》robert sedgewick<br>黑宝书胜在公式推理和证明以及算法的简洁和精炼，此外习题较多。蓝宝书胜在对算法的深入浅出的讲解，演示和举例，让艰涩的理论变得很容易理解。红宝书胜在系出名门斯坦福，演示通俗易懂，内容丰富。有了这三宝，算法不用愁，学完以后再看《算法导论》就容易多了。<br>本书从讲解什么是数据结构开始，延伸至高级数据结构和算法分析，强调数据结构和问题求解技术。本书的目的是从抽象思维和问题求解的观点提供对数据结构的实用介绍，试图包含有关数据结构、算法分析及其Java实现的所有重要的细节</p>
</blockquote>
<hr>
<h1 id="中级书单"><a href="#中级书单" class="headerlink" title="中级书单"></a><strong>中级书单</strong></h1><h2 id="《重构：改善既有代码的设计》"><a href="#《重构：改善既有代码的设计》" class="headerlink" title="《重构：改善既有代码的设计》"></a>《重构：改善既有代码的设计》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-ab38bf45a4a7b0e1.png" alt="《重构：改善既有代码的设计》"></p>
<blockquote>
<p>重构，绝对是写程序过程中最重要的事之一。在写程序之前我们不可能事先了解所有的需求，设计肯定会有考虑不周的地方，而且随着项目需求的修改，也有可能原来的设计已经被改得面目全非了。更何况，我们很少有机会从头到尾完成一个项目，基本上都是接手别人的代码，我们要做的是重构，从小范围的重构开始。<em>**</em><br>重构是设计,设计是art,重构也是art. 一个函数三行只是语不惊人死不休的说法,是对成百上千行代码的矫枉过正。 更一个般的看法是一个函数应该写在一页纸内。</p>
</blockquote>
<hr>
<h2 id="《Effective-Java》"><a href="#《Effective-Java》" class="headerlink" title="《Effective Java》"></a>《Effective Java》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-d9337d4b531ffb2b.jpg" alt="《Effective Java》"></p>
<blockquote>
<p>必读</p>
</blockquote>
<hr>
<h2 id="《Java并发编程实战》"><a href="#《Java并发编程实战》" class="headerlink" title="《Java并发编程实战》"></a>《Java并发编程实战》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-b008cd9c0915d0c0.png" alt="《Java并发编程实战》"></p>
<blockquote>
<p>没看过：</p>
<p>本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量。<em>**</em><br>java进阶必看，多线程的最佳书籍。</p>
</blockquote>
<hr>
<h2 id="实战Java高并发程序设计》"><a href="#实战Java高并发程序设计》" class="headerlink" title="实战Java高并发程序设计》"></a>实战Java高并发程序设计》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-a660ebcb96759c63.jpg" alt="实战Java高并发程序设计》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<hr>
<h2 id="《算法》"><a href="#《算法》" class="headerlink" title="《算法》"></a>《算法》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-a617f3102707d2a8.png" alt="《算法》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<hr>
<h2 id="《Head-First-设计模式》"><a href="#《Head-First-设计模式》" class="headerlink" title="《Head First 设计模式》"></a>《Head First 设计模式》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-ff7a658fe4ee1218.png" alt="《Head First 设计模式》"></p>
<blockquote>
<p>这是我看过最幽默最搞笑最亲切同时又让我收获巨大的技术书籍！ 森森的膜拜Freeman(s)！Amen！ 深入浅出，娓娓道来，有的地方能笑死你！写得很有趣，图文并茂，比起四人帮的那本，好懂了不知道多少倍。计算机世界的head first系列基本都是经典。不过只看书学明白设计模式是不可能的，这些只是前人的总结，我们唯有实践实践再实践了。<em>**</em><br>读这本书不仅仅是学习知识，而是在学习一种思考的方法，学习一种认知的技巧，学习一种成长的阶梯。 总之，用你闲暇的时间来读这本书，并不亚于你专注的工作或学习。笔者强烈推荐此书，要成长为一名高级程序员，设计模式已经是必备技能了。</p>
</blockquote>
<hr>
<h2 id="《Java编程思想》"><a href="#《Java编程思想》" class="headerlink" title="《Java编程思想》"></a>《Java编程思想》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-8d6811d9766232e5.png" alt="《代码整洁之道》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<h1 id="高级书单"><a href="#高级书单" class="headerlink" title="高级书单"></a><strong>高级书单</strong></h1><hr>
<h2 id="《深入理解Java虚拟机》"><a href="#《深入理解Java虚拟机》" class="headerlink" title="《深入理解Java虚拟机》"></a>《深入理解Java虚拟机》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-9b11d03c4bee5e71.png" alt="《深入理解Java虚拟机》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<hr>
<h2 id="《Java性能权威指南》"><a href="#《Java性能权威指南》" class="headerlink" title="《Java性能权威指南》"></a>《Java性能权威指南》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-4626892e666e33df.png" alt="《Java性能权威指南》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<hr>
<h2 id="《深入分析Java-Web技术内幕》"><a href="#《深入分析Java-Web技术内幕》" class="headerlink" title="《深入分析Java Web技术内幕》"></a>《深入分析Java Web技术内幕》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-8e52313d3a94ae3e.png" alt="《深入分析Java Web技术内幕》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<hr>
<h2 id="《大型网站系统与Java中间件实践》"><a href="#《大型网站系统与Java中间件实践》" class="headerlink" title="《大型网站系统与Java中间件实践》"></a>《大型网站系统与Java中间件实践》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-ea0ddb7a2a705a6f.png" alt="《大型网站系统与Java中间件实践》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<hr>
<h2 id="《大型网站技术架构：核心原理与案例分析》"><a href="#《大型网站技术架构：核心原理与案例分析》" class="headerlink" title="《大型网站技术架构：核心原理与案例分析》"></a>《大型网站技术架构：核心原理与案例分析》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-a3b611f69e8f6afc.png" alt="《大型网站技术架构：核心原理与案例分析》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<hr>
<h2 id="《企业应用架构模式》"><a href="#《企业应用架构模式》" class="headerlink" title="《企业应用架构模式》"></a>《企业应用架构模式》</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/1807893-999499ccc43cb6b6.png" alt="《企业应用架构模式》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<hr>
<h2 id="Spring3-x企业应用开发实战"><a href="#Spring3-x企业应用开发实战" class="headerlink" title="Spring3.x企业应用开发实战"></a>Spring3.x企业应用开发实战</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/avatar.png" alt="Spring3.x企业应用开发实战"></p>
<blockquote>
<p>这本书适合初学者看或者当做一本参考书。对于提高者而言，略看就行</p>
</blockquote>
<hr>
<h2 id="Spring揭秘"><a href="#Spring揭秘" class="headerlink" title="Spring揭秘"></a>Spring揭秘</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/avatar.png" alt="《Spring揭秘》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<hr>
<h2 id="Java程序性能优化-让你的Java程序更快、更稳定"><a href="#Java程序性能优化-让你的Java程序更快、更稳定" class="headerlink" title="Java程序性能优化:让你的Java程序更快、更稳定"></a>Java程序性能优化:让你的Java程序更快、更稳定</h2><p><img src="/2017/06/21/Java工程师书单（初级、中级、高级）/avatar.png" alt="《Java程序性能优化:让你的Java程序更快、更稳定》"></p>
<blockquote>
<p>没看过</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>talk is less show me your code，希望大家有好的书籍也可以推荐</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当你的能力承受不住你的欲望，你就应该静下心来读书&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;初级书籍&quot;&gt;&lt;a href=&quot;#初级书籍&quot; class=&quot;headerlink&quot; title=&quot;初级书籍&quot;&gt;&lt;/a&gt;&lt;strong&gt;初级书籍&lt;/s
    
    </summary>
    
      <category term="读书系统" scheme="http://kingge.top/categories/%E8%AF%BB%E4%B9%A6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Java" scheme="http://kingge.top/tags/Java/"/>
    
      <category term="书籍推荐" scheme="http://kingge.top/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引详解</title>
    <link href="http://kingge.top/2016/08/01/Mysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://kingge.top/2016/08/01/Mysql索引详解/</id>
    <published>2016-08-01T02:37:15.000Z</published>
    <updated>2017-08-17T09:35:34.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。考虑如下情况，假设数据库中一个表有10^6条记录，DBMS的页面大小为4K，并存储100条记录。如果没有索引，查询将对整个表进行扫描，最坏的情况下，如果所有数据页都不在内存，需要读取10^4个页面，如果这10^4个页面在磁盘上随机分布，需要进行10^4次I/O，假设磁盘每次I/O时间为10ms(忽略数据传输时间)，则总共需要100s(但实际上要好很多很多)。如果对之建立B-Tree索引，则只需要进行log100(10^6)=3次页面读取，最坏情况下耗时30ms。这就是索引带来的效果，很多时候，当你的应用程序进行SQL查询速度很慢时，应该想想是否可以建索引。进入正题：</p>
</blockquote>
<hr>
<blockquote>
<p>有些硬啃的干货还是得了解的，下面先了解索引的基本知识</p>
</blockquote>
<h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><ul>
<li>单列索引<ul>
<li>主键索引</li>
<li>唯一索引</li>
<li>普通索引</li>
</ul>
</li>
<li>组合索引<h3 id="用到的表"><a href="#用到的表" class="headerlink" title="用到的表"></a>用到的表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`award`</span> (</div><div class="line">   <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</div><div class="line">   <span class="string">`aty_id`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'活动场景id'</span>,</div><div class="line">   <span class="string">`nickname`</span> <span class="built_in">varchar</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'用户昵称'</span>,</div><div class="line">   <span class="string">`is_awarded`</span> tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'用户是否领奖'</span>,</div><div class="line">   <span class="string">`award_time`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'领奖时间'</span>,</div><div class="line">   <span class="string">`account`</span> <span class="built_in">varchar</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'帐号'</span>,</div><div class="line">   <span class="string">`password`</span> <span class="built_in">char</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</div><div class="line">   <span class="string">`message`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'获奖信息'</span>,</div><div class="line">   <span class="string">`created_time`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</div><div class="line">   <span class="string">`updated_time`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</div><div class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line"> ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'获奖信息表'</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h2><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><blockquote>
<p>这个是最基本的索引</p>
</blockquote>
<hr>
<blockquote>
<p>创建语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">其sql格式是：</div><div class="line">   第一种方式 :</div><div class="line">     CREATE INDEX IndexName ON `TableName`(`字段名`(length))</div><div class="line">   第二种方式 :</div><div class="line">	 ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length))</div></pre></td></tr></table></figure></p>
<p>创建例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">第一种方式 :</div><div class="line">  CREATE INDEX account_Index ON `award`(`account`);</div><div class="line">第二种方式:</div><div class="line">  ALTER TABLE award ADD INDEX account_Index(`account`)</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><blockquote>
<p>与普通索引类似,但是不同的是唯一索引要求所有的类的值是唯一的,这一点和主键索引一样.但是他允许有空值</p>
</blockquote>
<hr>
<blockquote>
<p>创建语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">其sql格式是：</div><div class="line">   第一种方式 :</div><div class="line">    CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));</div><div class="line">   第二种方式 :</div><div class="line">	ALTER TABLE TableName ADD UNIQUE (column_list)</div></pre></td></tr></table></figure></p>
<p>创建例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE UNIQUE INDEX account_UNIQUE_Index ON `award`(`account`);</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><blockquote>
<p>他与唯一索引的不同在于不允许有空值(在B+TREE中的InnoDB引擎中,主键索引起到了至关重要的地位)</p>
</blockquote>
<hr>
<blockquote>
<p>创建语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">其sql格式是：</div><div class="line">   第一种方式 :</div><div class="line">    CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length));</div><div class="line">   第二种方式 :</div><div class="line">	ALTER TABLE TableName ADD UNIQUE (column_list)</div></pre></td></tr></table></figure></p>
<p>创建例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE UNIQUE INDEX account_UNIQUE_Index ON `award`(`account`);</div></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h3 id="单列索引的总结"><a href="#单列索引的总结" class="headerlink" title="单列索引的总结"></a>单列索引的总结</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">mysql&gt;SELECT ｀uid｀ FROM people WHERE lname｀='Liu'  AND ｀fname｀='Zhiqun' AND ｀age｀=26</div><div class="line">因为我们不想扫描整表，故考虑用索引。</div><div class="line"></div><div class="line">单列索引：</div><div class="line"><span class="function">ALTER TABLE people ADD INDEX <span class="title">lname</span> <span class="params">(lname)</span></span>;</div><div class="line">将lname列建索引，这样就把范围限制在lname='Liu'的结果集1上，之后扫描结果集1，产生满足fname='Zhiqun'的结果集2，再扫描结果集2，找到 age=26的结果集3，即最终结果。</div><div class="line"></div><div class="line">由 于建立了lname列的索引，与执行表的完全扫描相比，效率提高了很多，但我们要求扫描的记录数量仍旧远远超过了实际所需 要的。虽然我们可以删除lname列上的索引，再创建fname或者age 列的索引，但是，不论在哪个列上创建索引搜索效率仍旧相似。</div><div class="line"></div><div class="line">&gt; 所以就需要组合索引</div></pre></td></tr></table></figure>
<hr>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><blockquote>
<p>一个表中含有多个单列索引不代表是组合索引,通俗一点讲 组合索引是:包含多个字段但是只有索引名称</p>
</blockquote>
<hr>
<blockquote>
<p>创建语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">其sql格式是：</div><div class="line"> CREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...);</div></pre></td></tr></table></figure></p>
<p>创建例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE INDEX nickname_account_createdTime_Index ON `award`(`nickname`, `account`, `created_time`);</div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>如果你建立了 <strong><em>组合索引</em></strong>(nickname_account_createdTime_Index)<strong> 那么他实际包含的是3个索引 (nickname) (nickname,account)(nickname,account,created_time)</strong></p>
</blockquote>
</blockquote>
<hr>
<h3 id="组合索引的最左前缀"><a href="#组合索引的最左前缀" class="headerlink" title="组合索引的最左前缀"></a>组合索引的最左前缀</h3><blockquote>
<p>上面的例子中给nickname,account,created_time 这三个字段建立索引他会去创建<strong>三个索引</strong>，但是在执行查询的时候只会用其中一个索引去查询，mysql会选择一个最严格(获得结果集记录数最少)的索引，所以where子句中使用最频繁的一列放在最左边。所谓最左前缀原则就是先要看第一列，在第一列满足的条件下再看左边第二列</p>
</blockquote>
<hr>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">文本字段上(text)如果建立的是普通索引,那么只有对文本的字段内容前面的字符进行索引,其字符大小根据索引建立索引时申明的大小来规定.</div><div class="line"></div><div class="line">如果文本中出现多个一样的字符,而且需要查找的话,那么其条件只能是 where column lick &apos;%xxxx%&apos; 这样做会让索引失效</div><div class="line"></div><div class="line">.这个时候全文索引就祈祷了作用了</div><div class="line"></div><div class="line">ALTER TABLE tablename ADD FULLTEXT(column1, column2)</div><div class="line">有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。</div><div class="line"></div><div class="line">ELECT * FROM tablename</div><div class="line">WHERE MATCH(column1, column2) AGAINST(‘xxx′, ‘sss′, ‘ddd′)</div><div class="line">这条命令将把column1和column2字段里有xxx、sss和ddd的数据记录全部查询出来。</div></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="使用索引的优点"><a href="#使用索引的优点" class="headerlink" title="使用索引的优点"></a>使用索引的优点</h2><ol>
<li>可以通过建立唯一索引或者主键索引,保证数据库表中每一行数据的唯一性.</li>
<li>建立索引可以大大提高检索的数据,以及减少表的检索行数</li>
<li>在表连接的连接条件 可以加速表与表直接的相连 </li>
<li>在分组和排序字句进行数据检索,可以减少查询时间中 分组 和 排序时所消耗的时间(数据库的记录会重新排序)</li>
<li>建立索引,在查询中使用索引 可以提高性能</li>
</ol>
<h2 id="使用索引的缺点"><a href="#使用索引的缺点" class="headerlink" title="使用索引的缺点"></a>使用索引的缺点</h2><ol>
<li>在创建索引和维护索引 会耗费时间,随着数据量的增加而增加</li>
<li>索引文件会占用物理空间,除了数据表需要占用物理空间之外,每一个索引还会占用一定的物理空间</li>
<li>当对表的数据进行 INSERT,UPDATE,DELETE 的时候,索引也要动态的维护,这样就会降低数据的维护速度,(建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)。</li>
</ol>
<h2 id="使用索引需要注意的地方"><a href="#使用索引需要注意的地方" class="headerlink" title="使用索引需要注意的地方"></a>使用索引需要注意的地方</h2><ol>
<li><p>在经常需要搜索的列上,可以加快索引的速度</p>
</li>
<li><p>主键列上可以确保列的唯一性</p>
</li>
<li><p>在表与表的而连接条件上加上索引,可以加快连接查询的速度</p>
</li>
<li><p>在经常需要排序(order by),分组(group by)和的distinct 列上加索引 可以加快排序查询的时间,  (单独order by 用不了索引，索引考虑加where 或加limit)</p>
</li>
<li><p>在一些where 之后的 &lt; &lt;= &gt; &gt;= BETWEEN IN 以及某个情况下的like 建立字段的索引(B-TREE)</p>
</li>
<li><p>like语句的 如果你对nickname字段建立了一个索引.当查询的时候的语句是 nickname lick ‘%ABC%’ 那么这个索引讲不会起到作用.而nickname lick ‘ABC%’ 那么将可以用到索引</p>
</li>
<li><p>索引不会包含NULL列,如果列中包含NULL值都将不会被包含在索引中,复合索引中如果有一列含有NULL值那么这个组合索引都将失效,一般需要给默认值0或者 ‘ ‘字符串</p>
</li>
<li><p>使用短索引,如果你的一个字段是Char(32)或者int(32),在创建索引的时候指定前缀长度 比如前10个字符 (前提是多数值是唯一的..)那么短索引可以提高查询速度,并且可以减少磁盘的空间,也可以减少I/0操作.</p>
</li>
<li><p>不要在列上进行运算,这样会使得mysql索引失效,也会进行全表扫描</p>
</li>
<li><p>选择越小的数据类型越好,因为通常越小的数据类型通常在磁盘,内存,cpu,缓存中 占用的空间很少,处理起来更快</p>
</li>
</ol>
<h2 id="什么情况下不建立索引"><a href="#什么情况下不建立索引" class="headerlink" title="什么情况下不建立索引"></a>什么情况下不建立索引</h2><ol>
<li><p>查询中很少使用到的列 不应该创建索引,如果建立了索引然而还会降低mysql的性能和增大了空间需求.</p>
</li>
<li><p>很少数据的列也不应该建立索引,比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql需要扫描的行数很多,增加索引,并不能提高效率</p>
</li>
<li><p>定义为text和image和bit数据类型的列不应该增加索引</p>
</li>
<li><p>当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系</p>
</li>
</ol>
<h1 id="好的文章"><a href="#好的文章" class="headerlink" title="好的文章"></a>好的文章</h1><p><a href="http://blog.csdn.net/zly9923218/article/details/51007554" target="_blank" rel="external">转：SQL优化</a><br><a href="http://blog.jobbole.com/86594/" target="_blank" rel="external">转：MySQL索引原理及慢查询优化</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。考虑如下情况，假设数据库中一个表有10^
    
    </summary>
    
      <category term="Mysql" scheme="http://kingge.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://kingge.top/tags/Mysql/"/>
    
      <category term="索引" scheme="http://kingge.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>C++文件流操作的读与写</title>
    <link href="http://kingge.top/2014/11/08/C-%E6%96%87%E4%BB%B6%E6%B5%81%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%BB%E4%B8%8E%E5%86%99/"/>
    <id>http://kingge.top/2014/11/08/C-文件流操作的读与写/</id>
    <published>2014-11-08T13:04:00.000Z</published>
    <updated>2017-08-17T06:33:56.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对文件的写入"><a href="#对文件的写入" class="headerlink" title="对文件的写入"></a>对文件的写入</h1><h2 id="put和-lt-lt-写入方式"><a href="#put和-lt-lt-写入方式" class="headerlink" title="put和&lt;&lt; 写入方式"></a>put和&lt;&lt; 写入方式</h2><ul>
<li>put的操作：是对文件进行写入的操作，写入一个字符（可以使字母也可以是asci码值）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">file.put(<span class="string">'   A'</span>);</div><div class="line">file.put(<span class="string">'\n'</span>);</div><div class="line">file &lt;&lt; <span class="string">"xiezejing1994"</span>;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>输出： &nbsp;&nbsp;&nbsp;&nbsp;A// 注意到A这里有几个空格 但是不影响左对齐<br>xiezejing1994// 也就是说A的前面不会有空格</p>
</blockquote>
<p>##操作和&lt;&lt; 读写方式区别</p>
<blockquote>
<p>put操作和 file &lt;&lt;‘A’这个基本上是一样的，但是有个区别就是他不可以这样file &lt;&lt;’  A’;（A的前面有空格）因为他是格式化输入 所以中间不能有”空格“<br>但是这样file &lt;&lt;”‘       A”;（也就是以字符串的格式输入则会有空格）</p>
</blockquote>
<hr>
<h1 id="文件的读操作"><a href="#文件的读操作" class="headerlink" title="文件的读操作"></a>文件的读操作</h1><h2 id="1-getline（）"><a href="#1-getline（）" class="headerlink" title="1.getline（）"></a>1.getline（）</h2><blockquote>
<p>getline（ cin ，string类型 ）<br> getline( cin, z );<br>  file1 &lt;&lt; z;  （file1 为文件流对象）</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">例子：</div><div class="line"> char c[100];</div><div class="line"></div><div class="line"> while ( !file.eof() )</div><div class="line"> &#123;</div><div class="line">  file.getline( c,100 );</div><div class="line">  cout &lt;&lt; c;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">假设文件1.txt内有'       A</div><div class="line">                 xiezejing1994  这样文本</div><div class="line"></div><div class="line">它的输出：'       Axiezejing1994  也就是说他没有读到换行的功能</div><div class="line"> 不会输出'       A</div><div class="line">         xiezejing1994（原因就是getlibe其实里面有三个参数，第三个参数默认为<span class="string">'\n'</span>）</div></pre></td></tr></table></figure>
<h2 id="2-getline（-fstream，string-）"><a href="#2-getline（-fstream，string-）" class="headerlink" title="2.getline（ fstream，string ）"></a>2.getline（ fstream，string ）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> ( getline( file,z ) )</div><div class="line">&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; z;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-get（）"><a href="#3-get（）" class="headerlink" title="3.get（）"></a>3.get（）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">char</span> c[<span class="number">100</span>];</div><div class="line"></div><div class="line"> <span class="keyword">while</span> ( !file.eof() )</div><div class="line"> &#123;</div><div class="line">  <span class="comment">//file.getline( c,100 ,'\0');</span></div><div class="line">  file.get( c,<span class="number">100</span> ,<span class="string">'\0'</span>);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; c;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">输出同getline一样</div><div class="line">----必须要写三个参数 否则只会输出一行（第三个参数为<span class="string">'\n'</span>也是只会输出一行）。非常严格的输出。</div></pre></td></tr></table></figure>
<h2 id="4-get操作"><a href="#4-get操作" class="headerlink" title="4.get操作"></a>4.get操作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">char</span> c;</div><div class="line"> file.get(c);</div><div class="line"> <span class="keyword">while</span> ( !file.eof() )</div><div class="line"> &#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; c;</div><div class="line">  file.get(c);</div><div class="line">  </div><div class="line"> &#125;</div><div class="line">-----和getline的区别在于 他是读取单个字符的，所以会读取到结束符号</div><div class="line">故会输出</div><div class="line">'       A</div><div class="line">xiezejing1994</div></pre></td></tr></table></figure>
<h1 id="对文件是否读到末尾的判断"><a href="#对文件是否读到末尾的判断" class="headerlink" title="对文件是否读到末尾的判断"></a>对文件是否读到末尾的判断</h1><h1 id="1-feof（）"><a href="#1-feof（）" class="headerlink" title="1.feof（）"></a>1.feof（）</h1><blockquote>
<p>该函数只有“已经读取了”结束标志时 feof（）才会返回非零值  也就是说当文件读取到文件结束标志位时他的返回值不是非零还是零 故还要在进行一次读.</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">例子 假设在<span class="number">1.</span>txt中只有abc三个字符</div><div class="line">在进行 </div><div class="line"><span class="keyword">while</span>（！feof(fp)）</div><div class="line"> &#123;</div><div class="line">   ch = getc(fp);</div><div class="line">   <span class="built_in">putchar</span>(ch);</div><div class="line">  </div><div class="line"> &#125;<span class="comment">//实际上输出的是四个字符</span></div><div class="line"></div><div class="line">改为</div><div class="line">ch = getc（fp）；</div><div class="line"><span class="keyword">while</span> （ ！feof（fp））</div><div class="line">&#123;</div><div class="line">   <span class="built_in">putchar</span>（ch）；</div><div class="line">   ch = getc（fp）；</div><div class="line">&#125;<span class="comment">// 这样就可以正常运行</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">3.</span> 可以不调用函数eof 直接就是 </div><div class="line"><span class="keyword">while</span> （ file ） <span class="comment">// file 就是文件流的对象</span></div><div class="line">&#123;</div><div class="line"> 。。。。操作</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="number">4.</span></div><div class="line"><span class="keyword">char</span> c[<span class="number">100</span>];</div><div class="line"></div><div class="line"> <span class="keyword">while</span> ( !file.eof() )</div><div class="line"> &#123;</div><div class="line">  file.getline( c,<span class="number">100</span> ,<span class="string">'\0'</span>);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; c;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">这个 和</div><div class="line"><span class="keyword">char</span> c[<span class="number">100</span>];</div><div class="line"></div><div class="line"> <span class="keyword">while</span> ( !file.eof() )</div><div class="line"> &#123;</div><div class="line">  file.getline( c,<span class="number">100</span> ,<span class="string">'\n'</span>);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; c;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">假设文本为上面的。</div><div class="line">输出分别为'       A</div><div class="line">          xiezejing1994</div><div class="line"></div><div class="line"></div><div class="line">'       Axiezejing1994</div></pre></td></tr></table></figure>
<h1 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h1><h2 id="1-read-数组名，接收的个数"><a href="#1-read-数组名，接收的个数" class="headerlink" title="1.read( 数组名，接收的个数 )"></a>1.read( 数组名，接收的个数 )</h2><h2 id="2-write-数组名，gcount函数"><a href="#2-write-数组名，gcount函数" class="headerlink" title="2.write( 数组名，gcount函数  )"></a>2.write( 数组名，gcount函数  )</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"> <span class="function">ifstream <span class="title">file</span><span class="params">( <span class="string">"D:\\jjj.txt"</span>)</span></span>;</div><div class="line"> <span class="function">ofstream <span class="title">file1</span><span class="params">( <span class="string">"D:\\j.txt"</span> , ios::app)</span></span>;</div><div class="line"> <span class="built_in">string</span> z;</div><div class="line"></div><div class="line"> <span class="keyword">if</span> ( !file )</div><div class="line"> &#123;</div><div class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">" 无法打开\n "</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="keyword">char</span> c[<span class="number">100</span>];</div><div class="line"> </div><div class="line"> </div><div class="line"> <span class="keyword">while</span> ( !file.eof() )</div><div class="line"> &#123;</div><div class="line">  file.read( c,<span class="number">100</span>  );</div><div class="line">  file1.write( c, file.gcount() );</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"></div><div class="line"> file.close();</div><div class="line"> file.close();</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>判断打开是否正确<strong><strong><strong>**</strong></strong></strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="keyword">if</span>( !file )</div><div class="line"><span class="number">2.</span><span class="keyword">if</span> ( !file.good() )</div><div class="line"> &#123;</div><div class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">" 无法打开\n "</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="number">3.</span></div><div class="line"> <span class="keyword">if</span> ( !file.is_open() )</div><div class="line"> &#123;</div><div class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">" 无法打开\n "</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="number">4.</span> <span class="keyword">if</span> ( file.fail() )</div><div class="line"> &#123;</div><div class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">" 无法打开\n "</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对文件的写入&quot;&gt;&lt;a href=&quot;#对文件的写入&quot; class=&quot;headerlink&quot; title=&quot;对文件的写入&quot;&gt;&lt;/a&gt;对文件的写入&lt;/h1&gt;&lt;h2 id=&quot;put和-lt-lt-写入方式&quot;&gt;&lt;a href=&quot;#put和-lt-lt-写入方式&quot; class
    
    </summary>
    
      <category term="c++" scheme="http://kingge.top/categories/c/"/>
    
    
      <category term="文件" scheme="http://kingge.top/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="C++" scheme="http://kingge.top/tags/C/"/>
    
      <category term="文件读写" scheme="http://kingge.top/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>文章例子</title>
    <link href="http://kingge.top/2013/12/02/ceshi/"/>
    <id>http://kingge.top/2013/12/02/ceshi/</id>
    <published>2013-12-02T07:30:16.000Z</published>
    <updated>2017-08-16T02:36:44.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>
</ol>
<a id="more"></a>
<ol>
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
<li>等等；</li>
</ol>
]]></content>
    
    <summary type="html">
    
      附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面
    
    </summary>
    
      <category term="默认分类" scheme="http://kingge.top/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="tag1" scheme="http://kingge.top/tags/tag1/"/>
    
      <category term="tag2" scheme="http://kingge.top/tags/tag2/"/>
    
      <category term="tag3" scheme="http://kingge.top/tags/tag3/"/>
    
  </entry>
  
</feed>
