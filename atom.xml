<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>King哥</title>
  <subtitle>To know everything, no words don&#39;t talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kingge.top/"/>
  <updated>2017-08-31T09:44:24.038Z</updated>
  <id>http://kingge.top/</id>
  
  <author>
    <name>Jeremy Kinge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hessian 多系统访问</title>
    <link href="http://kingge.top/2020/05/06/Hessian%20%E5%A4%9A%E7%B3%BB%E7%BB%9F%E8%AE%BF%E9%97%AE/"/>
    <id>http://kingge.top/2020/05/06/Hessian 多系统访问/</id>
    <published>2020-05-06T13:26:31.834Z</published>
    <updated>2017-08-31T09:44:24.038Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>下个开源项目的计划</title>
    <link href="http://kingge.top/2020/04/28/%E4%B8%8B%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AE%A1%E5%88%92/"/>
    <id>http://kingge.top/2020/04/28/下个开源项目的计划/</id>
    <published>2020-04-28T12:59:59.000Z</published>
    <updated>2020-05-04T08:28:49.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-已经做的事"><a href="#1-已经做的事" class="headerlink" title="1.已经做的事"></a>1.已经做的事</h1><p>​    首先我们不会重复造轮子，因为如果市面上已经存在很好很优秀的框架或者解决方案，那么我建议使用那些成熟的解决方案。</p>
<p>​    那么比如说，我之前实现的<strong>可靠消息最终一致性方案（rtm）</strong>，就是利用了<strong>其他mq没有事务消息这个特征(Rocketmq独有)</strong>，但是又想在<strong>不改用mq</strong>的前提下，那么<strong>又想保证数据最终一致性</strong>，那么就可以<strong>使用rtm系统</strong>来作为<code>中间商</code> <strong>协调上下游系统的事务处理</strong>，保证了数据的最终一致性。</p>
<p>​        话句话说，<strong>RTM实际上是基于本地消息表这种解决方案来实现的</strong>。 而且实际上rtm的理念其实就是跟rocketmq的事务消息类似，但是rtm更加全面。</p>
<p>​    </p>
<h2 id="rocketmq事务消息的弊端"><a href="#rocketmq事务消息的弊端" class="headerlink" title="rocketmq事务消息的弊端"></a>rocketmq事务消息的弊端</h2><p>​    我们知道， <code>事务消息</code> 仅仅只是保证本地事务和MQ消息发送形成整体的 <code>原子性</code>，而投递到MQ服务器后，并无法保证消费者一定能消费成功！<strong>也就是下游系统可能会发送失败</strong>。</p>
<p>​    如果 <strong>消费端消费失败</strong> 后的处理方式，建议是记录异常信息然后 <strong>人工处理</strong>，并不建议回滚上游服务的数据(因为两者是 <strong>解耦</strong> 的，而且 <strong>回滚复杂度</strong> 太高) </p>
<p>​    <strong>那么如果使用事务消息怎么解决下游系统消费失败的问题呢？</strong></p>
<p><strong>常见两个解决方案：</strong></p>
<p>  我们可以利用 <code>MQ</code> 的两个特性 <code>重试</code> 和 <code>死信队列</code> 来协助消费端处理：</p>
<ol>
<li><p>消费失败后mq进行<strong>一定次数</strong>的 <code>重试</code></p>
</li>
<li><p>重试后也失败的话该消息丢进 <code>死信队列</code> 里</p>
</li>
<li><p>另外起一个线程监听消费 <code>死信队列</code> 里的消息，记录日志并且预警！</p>
<p>因为有 <code>重试</code> 所以消费者需要实现 <code>幂等性</code></p>
</li>
</ol>
<h2 id="RTM系统优点-广告一波"><a href="#RTM系统优点-广告一波" class="headerlink" title="RTM系统优点 - 广告一波"></a>RTM系统优点 - 广告一波</h2><p>​    在兼有rocketmq事务消息的同时，能够<strong>保证下游系统一定能消费消息（提供消费失败一定次数和时间间隔重试以及记录超过重试次数的消息）</strong>，从而保证了数据的最终一致性，同时提供管理界面，管理已经超过重发次数上限的消息，重新发送。</p>
<p>​    所以说，当你的项目架构在最初的技术选型时，并没有使用rocketmq，那么又想保证数据最终一致性，那么就可以引入rtm系统，非常方便快捷。</p>
<h1 id="2-分布式事务选型"><a href="#2-分布式事务选型" class="headerlink" title="2.分布式事务选型"></a>2.分布式事务选型</h1><p>分布式解决方案，一般有如下几种：</p>
<ul>
<li>XA分布式协议<ul>
<li>2pc    - 一般不适用</li>
<li>3pc</li>
</ul>
</li>
</ul>
<ul>
<li><p>TCC</p>
<ul>
<li><p>Try、Confirm、Cancel，实际上用到了补偿的概念</p>
</li>
<li><p>这种方案说实话几乎很少用人使用，我问过得人，用的也比较少，但是也有使用的场景。因为这个事务回滚实际上是<strong>严重依赖于你自己写代码来回滚和补偿</strong>，会造成补偿代码巨大，非常之恶心。</p>
<p>​    <strong>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用TCC，严格严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，在资金上出现问题。</strong></p>
<ul>
<li><strong>阿里开源的seata</strong>，但是阿里的seata并不是纯正的tcc框架，因为 纯正的tcc框架，很麻烦，需要你手动把各种接口实现出来3个接口，try，confirm，cancel。bytetcc框架，就是一个纯的tcc框架，可以了解一下。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>可靠消息最终一致性</p>
<ul>
<li><strong>推荐使用</strong></li>
</ul>
</li>
<li><p>本地消息表</p>
</li>
<li><p>最大努力通知方案</p>
<ul>
<li><p>这个方案的大致意思就是：</p>
<p>1）系统A本地事务执行完之后，发送个消息到MQ</p>
<p>2）这里会有个专门消费MQ的<strong>最大努力通知服务</strong>，这个服务会消费MQ然后<strong>写入数据库中记录下来</strong>，或者是放入个<strong>内存队列（DelayQueue）</strong>也可以，接着调用系统B的接口</p>
<p>3）要是系统B执行成功就ok了；要是系统B执行失败了，那么最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行就放弃。</p>
</li>
</ul>
</li>
</ul>
<p><strong>实际上rtm系统，已经实现了可靠消息最终一致性和本地消息表这两种方案。</strong></p>
<h1 id="3-自我实现最大努力通知方案"><a href="#3-自我实现最大努力通知方案" class="headerlink" title="3.自我实现最大努力通知方案"></a>3.自我实现最大努力通知方案</h1><p><strong>最大努力通知与可靠消息一致性有什么不同</strong></p>
<p>1、解决方案思想不同</p>
<p>​    可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知 方来保证。</p>
<p>​    最大努力通知，发起通知方尽最大的努力将业务处理结果通知给接收通知方，但是可能消息接收不到，此时需要接收通知方<strong>主动调用发起通知方的接口查询业务处理结果</strong>，通知的可靠性关键在接收通知方。</p>
<p>2、两者的业务应用场景不同</p>
<p>​    可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。</p>
<p>​    最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。</p>
<p>3、技术解决方向不同</p>
<p>​    可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。</p>
<p>​    最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，最大努力的将消 息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）。</p>
<p>也就是我们<strong>要实现的最大通知服务关注</strong>的是<strong>跟下游服务之间的可靠性通信</strong>，而可靠消息一致性中可靠消息服务（rtm）关注的是跟上游的数据一致性，同时保证消息一定能发送到下游。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-已经做的事&quot;&gt;&lt;a href=&quot;#1-已经做的事&quot; class=&quot;headerlink&quot; title=&quot;1.已经做的事&quot;&gt;&lt;/a&gt;1.已经做的事&lt;/h1&gt;&lt;p&gt;​    首先我们不会重复造轮子，因为如果市面上已经存在很好很优秀的框架或者解决方案，那么我建议使用
    
    </summary>
    
      <category term="开源项目" scheme="http://kingge.top/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="开源项目" scheme="http://kingge.top/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="最大努力通知方案" scheme="http://kingge.top/tags/%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>可靠消息解决数据最终一致性-开源项目rtm</title>
    <link href="http://kingge.top/2020/04/18/rtm%E6%95%B0%E6%8D%AE%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://kingge.top/2020/04/18/rtm数据最终一致性/</id>
    <published>2020-04-18T14:57:58.000Z</published>
    <updated>2020-05-04T08:15:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="为什么使用消息队列？"><a href="#为什么使用消息队列？" class="headerlink" title="为什么使用消息队列？"></a>为什么使用消息队列？</h2><h3 id="MQ出现的原因-优点"><a href="#MQ出现的原因-优点" class="headerlink" title="MQ出现的原因/优点"></a>MQ出现的原因/优点</h3><p>在回答这个问题之前，我们想一下，在没有消息队列之前我们的多个<strong>业务相互调用</strong>时他的逻辑实现是怎么样的？</p>
<p>画个图：</p>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20200424172621286.png" alt="image-20200424172621286"></p>
<p>​    这是一个很普通的业务调用，也是我们写的比较多的。整个业务逻辑是这样的，<strong>客户下订单，调用订单服务生成订单，那么在生成订单的时候，会去调用库存服务减少库存，再去调用用户服务查询用户信息</strong>。</p>
<p>​    这样咋一看没有什么问题，但是如果后面订单服务业务改进，需要在下订单的同时，需要查询<strong>优惠券服务</strong>，查询下订单时所使用的优惠券信息。那么这个时候，你必然要修改订单服务，然后增加调用的代码逻辑。</p>
<p>​    如下图：</p>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20200424173159358.png" alt="image-20200424173159358"></p>
<p><strong>而且后面如果订单服务还需要去调用其他服务，那么你就还需要疯狂的修改订单服务。</strong></p>
<p>而且，例如后面业务改进，订单服务不需要再调用优惠券服务了？那么你又得在订单服务中移除该服务。</p>
<p>非但如此，订单服务要时时刻刻考虑调用的库存服务、用户服务等等系统如果挂了咋办？我要不要重发？我要不要把消息存起来？？？？</p>
<p> 总而言之，订单服务所需要承载的责任太重了，而且需要负责的东西太多，这就是<strong>耦合</strong>。</p>
<p><strong>那么MQ的第一个作用就体现出来了：解耦</strong></p>
<p>上面的服务使用MQ后：</p>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20200424173753186.png" alt="image-20200424173753186"></p>
<p>那么经过改进后，整个订单服务就舒服多了，也清净了。订单服务处理完用户下单请求后，只需要发送一条消息到MQ中，代表我下单了，然后整个订单服务就结束了，<strong>不需要同步等待</strong>库存服务等等其他服务的响应。</p>
<p>​    库存服务，只需要订阅MQ的主题，然后完成自己的业务逻辑即可。</p>
<p>那么MQ还有其他什么优点呢？</p>
<p>其实在上面我已经说出来了，你有没有发现，在上面的例图中，我们引入了MQ，<strong>使得订单服务不再需要同步等待调用其他服务的返回结果。</strong></p>
<p>所以<strong>MQ的第二个优点就是</strong>：<strong>异步</strong></p>
<p>​    画个图来说明一下，A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms、450ms、200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近1s，用户感觉搞个什么东西，慢死了慢死了。</p>
<blockquote>
<p><strong>未使用MQ前</strong></p>
</blockquote>
<p><img src="/2020/04/18/rtm数据最终一致性/5.png" alt="5"></p>
<blockquote>
<p><strong>使用MQ后</strong></p>
</blockquote>
<p><img src="/2020/04/18/rtm数据最终一致性/2.png" alt="2"></p>
<p><strong>MQ的第三个优点：削峰</strong></p>
<p>​    每天0点到11点，A系统风平浪静，每秒并发请求数量就100个（qps=100）。结果每次一到11点~1点，每秒并发请求数量突然会暴增到1万条。但是系统最大的处理能力就只能是每秒钟处理1000个请求啊。。。尴尬了，系统会死。。。</p>
<pre><code>**所以MQ充当的角色类似于一个水库。汛期来临时水库首当其冲，起到缓冲作用，避免大量水流冲击下游。这个时候水库只需要开放部分出口，然后水流慢慢的留向下游，最后把水库里的水慢慢消耗最终接近平缓即可。**
</code></pre><blockquote>
<p><strong>未用MQ前？</strong></p>
</blockquote>
<p><img src="/2020/04/18/rtm数据最终一致性/6.png" alt="6"></p>
<blockquote>
<p><strong>使用mq后</strong></p>
</blockquote>
<p><img src="/2020/04/18/rtm数据最终一致性/7.png" alt="7"></p>
<p>总而言之：    <strong>队列的常见使用场景吧，其实场景有很多，但是比较核心的优点有3个：解耦、异步、削峰</strong></p>
<h3 id="MQ缺点"><a href="#MQ缺点" class="headerlink" title="MQ缺点"></a>MQ缺点</h3><p>缺点呢？显而易见的</p>
<ul>
<li>系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。（<strong>需要保证MQ高可用 - 增加系统复杂程度</strong>）</li>
</ul>
<ul>
<li>系统复杂性提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已，搞什么捏。（<strong>消息可靠性和消费幂等性</strong>）</li>
</ul>
<ul>
<li>一致性问题：A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。（<strong>分布式事务/数据最终一致性</strong>）</li>
</ul>
<p>​    <strong>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈耶，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的。。。但是得想好。</strong></p>
<p><a href="https://www.showdoc.cc/rmq?page_id=1796661553395018" target="_blank" rel="external">https://www.showdoc.cc/rmq?page_id=1796661553395018</a></p>
<h2 id="怎么解决数据的一致性"><a href="#怎么解决数据的一致性" class="headerlink" title="怎么解决数据的一致性"></a>怎么解决数据的一致性</h2><h3 id="分布式事务-强一致性"><a href="#分布式事务-强一致性" class="headerlink" title="分布式事务 - 强一致性"></a>分布式事务 - 强一致性</h3><h3 id="数据最终一致性-弱一致性"><a href="#数据最终一致性-弱一致性" class="headerlink" title="数据最终一致性 - 弱一致性"></a>数据最终一致性 - 弱一致性</h3><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>​    2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。Brewer认为在设计一个大规模的分布式系统时会遇到三个特性：一致性（consistency）、可用性（Availability）、分区容错（partition-tolerance），而一个分布式系统最多只能满足其中的2项。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p>
<p><img src="/2020/04/18/rtm数据最终一致性/10708517-72259de731fcf8a9.png" alt="img"></p>
<p>C：数据一致性（强一致性），<strong>集群中同一数据的多个副本是否实时相同</strong>。（一致性也分为，强一致性和弱一致性）</p>
<p>A：可用性，指系统提供的服务必须一直处于可用的状态，<strong>对于用户的每一个操作请求总是能够在有限的时间内返回结果。</strong></p>
<p> P:分区容错性，也就是如果出现网络震荡的时候，服务集群不能够全部挂掉，保证高可用。<strong>将同一服务分布在多个系统中，从而保证某一个系统宕机，仍然有其他系统提供相同的服务。</strong></p>
<p>​    <strong>在分布式系统中，P肯定要保证的。</strong></p>
<blockquote>
<p>​    <strong>为什么要保证p呢？</strong></p>
</blockquote>
<pre><code>当业务量猛增，单个服务器已经无法满足我们的业务需求的时候，就需要使用分布式系统，使用多个节点提供相同的功能（需要部署服务集群），从而整体上提升系统的性能，这就是使用分布式系统的第一个原因。那么分区容错性就必须满足。
</code></pre><p>​        那么我们只能在C和A中二选一，为什么A和C不能够同时选择呢？举个简单例子。我们在部署了五个订单服务，组成了集群。有一天需求修改了，那么需要更新这五个订单服务。这个时候，我们为了保证客户还是能够访问系统，那么就升级部分服务器，也就意味着，必然存在客户调用了新旧订单服务。那么这个时候数据肯定是不一致的。反之亦然，为了保证数据一致性，我们关闭五个服务器，然后更新后再重启，那么在这期间服务对外是不可用的，无法保证系统可用性。</p>
<p>​    例如我们在使用springcloud的Eureka服务注册中心时，他实现的机制就是 AP，能够保证服务的使用。</p>
<p>​    DUbbo的服务注册中心采用的是Zookeeper，那么因为zookeeper集群（选举机制），他实现的机制是CP（但是他的C数据一致性是，数据弱一致性，也就是存在某个时间salve的数据是不一致的–因为zk 的是更新操作是采取投票过半机制决定本次更新是否成功。）</p>
<p>​    所以具体的业务场景采用不同的策略，<strong>不过大多数互联网项目采用的是AP机制</strong>，以能够保证服务的使用为主。    <strong>因为在大谈用户体验的今天，如果业务系统时常出现“系统异常”、响应时间过长等情况，这使得用户对系统的好感度大打折扣。所以可用性还是要保证的</strong></p>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>​    CAP理论告诉我们一个悲惨但不得不接受的事实——我们只能在C、A、P中选择两个条件。而对于业务系统而言，我们往往选择<strong>牺牲一致性来换取系统的可用性和分区容错性</strong>。不过这里要指出的是，所谓的“牺牲一致性”并不是完全放弃数据一致性，而是牺牲强一致性换取弱一致性     </p>
<p>​    BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p>
<p>​    BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。</p>
<ol>
<li><strong>BA：</strong>基本可用（Basically Available）</li>
</ol>
<p>​        指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</p>
<ol>
<li><strong>S：</strong>软状态（ Soft State）</li>
</ol>
<p>​        指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。</p>
<ol>
<li><strong>E：</strong>最终一致（ Eventual Consistency）</li>
</ol>
<p>​      </p>
<p>  强调的是所有的数据更新操作，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>base理论的核心就是，<strong>经过一段时间后，能够保证数据的强一致性，在这之前，数据的一致性不是那么的强调</strong>。</p>
<p>​    举个简单的例子，例如在双十一购物中心，某件商品的点赞数量我们需不需要它实时的显示数量？很明显是不需要的，我们显示的数量可以使几个小时之前的。我们只需要在双十一过后，再去统计出最终该商品的点赞数量，然后显示即可。</p>
<p>​    <strong>其实大部分最终一致性是通过消息队列的方式实现的。例如我们对商品的点赞，发送一条消息到消息队列，然后消息消费者消费消息，实现点赞数量增加。这样的流程肯定会存在一定的延时，但是最终结果肯定是正确的，所以实现了最终一致性。</strong></p>
<h2 id="rocketmq事务消息"><a href="#rocketmq事务消息" class="headerlink" title="rocketmq事务消息"></a>rocketmq事务消息</h2><p><strong>设么是事务消息？</strong>先看案例场景</p>
<p>例如下图的场景：生成订单记录 -&gt; MQ -&gt; 增加积分</p>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20191211155712515.png" alt="image-20191211155712515"></p>
<p>我们是应该先 <strong>创建订单记录</strong>，还是先 <strong>发送MQ消息</strong> 呢？</p>
<ol>
<li><strong>先发送MQ消息</strong>：这个明显是不行的，因为如果消息发送成功，而订单创建失败的话是没办法把消息收回来的。因为发送消息后，下游消费者，已经消费提交。</li>
<li><strong>先创建订单记录</strong>：如果订单创建成功后MQ消息发送失败 <strong>抛出异常</strong>，因为两个操作都在本地事务中所以订单数据是可以 <strong>回滚</strong> 的。</li>
</ol>
<p>上面的 <strong>方式二</strong> 看似没问题，但是 <strong>网络是不可靠的</strong>！如果 <code>MQ</code> 的响应因为网络原因没有收到，所以在面对不确定的结果只好进行回滚；但是 <code>MQ</code> 端又确实是收到了这条消息的，只是回给客户端的 <strong>响应丢失</strong> 了！</p>
<p>所以 <code>事务消息</code> 就是用来保证 <strong>本地事务</strong> 与 <strong>MQ消息发送</strong> 的原子性！</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>图一</p>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20191211161342571.png" alt="image-20191211161342571"></p>
<p> <img src="/2020/04/18/rtm数据最终一致性/image-20191211161426489.png" alt="image-20191211161426489"> </p>
<p>主要的逻辑分为两个流程：</p>
<ul>
<li><strong>事务消息发送及提交</strong>：<ol>
<li>发送 <code>half消息</code></li>
<li><code>MQ服务端</code> 响应消息写入结果</li>
<li>根据发送结果执行 <code>本地事务</code>（如果写入失败，此时half消息对业务 <strong>不可见</strong>，本地逻辑不执行）</li>
<li>根据本地事务状态执行 <code>Commit</code> 或者 <code>Rollback</code>（Commit操作生成消息索引，消息对消费者 <strong>可见</strong>）</li>
</ol>
</li>
</ul>
<ul>
<li><strong>回查流程</strong>：<ol>
<li>对于长时间没有 <code>Commit/Rollback</code> 的事务消息（<code>pending</code> 状态的消息），mq服务端发起一次 <strong>回查</strong></li>
<li><code>Producer</code> 收到回查消息，检查回查消息对应的 <code>本地事务状态</code></li>
<li>根据本地事务状态，重新 <code>Commit</code> 或者 <code>Rollback</code></li>
</ol>
</li>
</ul>
<p><strong>逻辑时序图</strong></p>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20191211161601632.png" alt="image-20191211161601632"></p>
<h3 id="rocketmq事务消息的弊端"><a href="#rocketmq事务消息的弊端" class="headerlink" title="rocketmq事务消息的弊端"></a>rocketmq事务消息的弊端</h3><p>根据图1，你会发现，存在一个问题，那就是假设库存服务成功消费到了消息，但是删减库存失败。那么因为删除失败也是属于业务的一部分，那么他就会返回ack消息给，mq。那么整个流程结束。</p>
<p> <strong>从上面的原理可以发现 <code>事务消息</code> 仅仅只是保证本地事务和MQ消息发送形成整体的 <code>原子性</code>，而投递到MQ服务器后，并无法保证消费者一定能消费成功！</strong></p>
<p>如果 <strong>消费端消费失败</strong> 后的处理方式，建议是记录异常信息然后 <strong>人工处理</strong>，并不建议回滚上游服务的数据(因为两者是 <strong>解耦</strong> 的，而且 <strong>复杂度</strong> 太高) </p>
<p>我们可以利用 <code>MQ</code> 的两个特性 <code>重试</code> 和 <code>死信队列</code> 来协助消费端处理：</p>
<ol>
<li>消费失败后进行一定次数的 <code>重试</code></li>
<li>重试后也失败的话该消息丢进 <code>死信队列</code> 里</li>
<li>另外起一个线程监听消费 <code>死信队列</code> 里的消息，记录日志并且预警！</li>
</ol>
<p>因为有 <code>重试</code> 所以消费者需要实现 <code>幂等性</code></p>
<p>总而言之，rocketmq实现事务消息的两个核心概念：<strong>两阶段提交、事务状态定时回查</strong></p>
<h1 id="我要做什么？项目介绍"><a href="#我要做什么？项目介绍" class="headerlink" title="我要做什么？项目介绍"></a>我要做什么？项目介绍</h1><p>​    因为我们知道rocketmq是<strong>原生支持事务消息</strong>的，但是如果项目中，最初选型的时候，并没有选用rmq，而是选用了其他的MQ，例如rabbitmq，activemq，kafka等等，但是又想保<strong>证最终一致性事务呢</strong>？</p>
<p>​    <strong>那么我们仿照上面rmq的事务消息的原理，来自己实现一个提供事务消息的项目工程。</strong></p>
<p>​    那么这个项目我决定命名为<strong>RTM</strong>（滑稽脸）。    </p>
<p><strong>RTM( Reliable transaction message )</strong>是<strong>基于可靠消息的最终一致性</strong>的分布式事务解决方案。</p>
<blockquote>
<p><strong>框架定位</strong></p>
</blockquote>
<p><strong>RTM本身不生产消息队列，只是消息的搬运工。</strong><br><strong>RTM框架提供消息预发送、消息发送、消息确认、消息恢复、消息管理等功能，结合成熟的消息中间件，解决分布式事务，达到数据最终一致性。</strong></p>
<h1 id="RTM解决的问题"><a href="#RTM解决的问题" class="headerlink" title="RTM解决的问题"></a>RTM解决的问题</h1><blockquote>
<p><strong>引入消息中间件的场景</strong></p>
</blockquote>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20200426092909056.png" alt="image-20200426093019755"></p>
<p>​    存在问题，1处和2处，可能因为网络原因，导致数据一致性的问题产生，<strong>也就是无法保证A系统和B系统数据的一致性</strong>，无法保证。</p>
<p>​    举个例子，A系统发送完消息到MQ后，在执行自己业务过程中出现异常，本地事务回滚。但是此时消息已经发到MQ，下游服务B系统已经消费消息，B系统执行完自己的业务。那么此时A系统失败，B系统成功。这样就造成了整个业务流不是原子的，存在数据不一致性。</p>
<p>​    上面的场景还存在着很多数据不一致性的场景。这里就不一一列举，下面在讲解到RTM的细节时会一一说明。</p>
<blockquote>
<p><strong>引入RTM后的场景</strong></p>
</blockquote>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20200426095618201.png" alt="image-20200426095618201"></p>
<p>​    <strong>可以看到我们在RTM中引进了，rocketmq的事务消息的概念，RTM在这里仅仅只是作为一个协调者，协调上下游服务的业务操作。确保了是上下游服务能够保证数据的一致性，达到数据最终一致性，符合BASE理论。</strong></p>
<p>​    </p>
<p> RTM提供了，<strong>发送半消息、半消息确认、消息发送到MQ、消息消费确认、消息重复投递等等功能</strong>。</p>
<h1 id="RTM详细流程介绍"><a href="#RTM详细流程介绍" class="headerlink" title="RTM详细流程介绍"></a>RTM详细流程介绍</h1><p>​    通过上面的阐述，我们大概知道了RTM在分布式系统中的地位，<strong>协调者</strong>。但是至于他的请求流程，怎么保证数据一致性，下面我们拉一一说明。</p>
<p>​    我们将从三个方面来说明</p>
<ul>
<li>正常使用流程</li>
<li>消息发送到RTM，RTM成功投递流程</li>
<li>RTM确认消费者成功消费流程</li>
</ul>
<h2 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h2><p><img src="/2020/04/18/rtm数据最终一致性/image-20200426102034824.png" alt="image-20200426103349050"></p>
<p>梳理一下流程：</p>
<p>（1）首先A系统在执行业务之前，先投递半消息到RTM，RTM持久化成功后（这里使用mysql），发送成功消息给A系统，紧接着A系统执行本地业务。（一般这段逻辑需要开启本地事务，这样可以保证了消息发送成功后再执行本地业务，消息发送失败那么也就没有必要执行A系统本地业务了）</p>
<p>（2）接着A系统在执行完本地业务后，<strong>异步</strong>发送确认消息给RTM，然后RTM标记半消息为确认可投递，接着RTM会把消息发送给MQ。</p>
<p>（3）系统B收到MQ的消息，然后执行自己的业务逻辑，之后再调用RTM接口，确认消息已经消费，接着RTM会把该消息从数据库中删除。到这里整个流程结束</p>
<blockquote>
<p><strong>解释几个问题。</strong></p>
</blockquote>
<ul>
<li><p>在步骤二中，为什么需要异步通知RTM消息可投递。</p>
<ul>
<li><p>我们反过来想，如果用同步会发生什么？首先来看一下A系统调用RTM系统的伪代码</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Transactional</span>(rollbackFor = RuntimeException.class)<span class="comment">//开启事务</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">(Order order)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">// 1.调用RMQ，创建预发送消息</span></div><div class="line">      String msgID = rtmService.addHalfMessage(order);</div><div class="line">      <span class="comment">// 2.执行业务</span></div><div class="line">         。。。。。</div><div class="line">      <span class="comment">// 3.同步调用RTM，确认发送消息</span></div><div class="line">      rtmService.confirmHalfMessage(msgID);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>假设在第三处，调用RTM时，因为网络延迟或者其他原因，导致confirmHalfMessage()抛出异常，那么addOrder()方法回滚<strong>，A系统执行失败</strong>。但是实际上RTM还是调用成功了，也就是意味着RTM会往MQ发送消息，然后<strong>B系统收到消息后成功执行</strong>。那么此时A、B系统的数据是不一致性。</p>
</li>
<li><p>所以这里需要异步调用RTM，确认消息。目的就是解耦，保证了A系统的正常执行。</p>
</li>
<li><p><strong>但是如果使用异步后？出现A系统成功执行，但是调用RTM确认消息发送失败时，怎么处理呢？这个问题RTM会提供回查机制，确认半消息是删除还是确认投递。</strong></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        可以看到整个RTM正常流程下是能够保证数据的一致性的，满足base理论。</p>
<h2 id="消息发送到RTM，RTM成功投递流程"><a href="#消息发送到RTM，RTM成功投递流程" class="headerlink" title="消息发送到RTM，RTM成功投递流程"></a>消息发送到RTM，RTM成功投递流程</h2><p>​    上面我们只是把整个RTM使用的正常流程梳理了一遍，但是在使用过程中肯定会出现很多问题，出现问题的同时可能还会造成数据的不一致性问题，那么怎么保证数据的一致性呢？出现问题怎么解决呢？</p>
<p>​        </p>
<p>​    接下来我们来看一下，A系统在跟RTM通信这个阶段出现问题怎么解决？怎么保证数据一致性？</p>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20200426113538315.png" alt="image-20200426113538315"></p>
<p>​    接下来我们就来分析一下如果上面这六步如果出现了问题，那么RTM是怎么解决的，只要保证了这六步的正确性，那么我们也就保证了消息发送阶段的一致性。</p>
<ul>
<li><p>1处发送异常，A系统发送半消息失败。那么因为<strong>A系统</strong>还<strong>没执行本业务</strong>（没有执行到4处），而且<strong>RTM系统</strong>也<strong>没有持久化半消息</strong>。那么此时不会产生数据不一致，<strong>那么RTM系统不需要做处理。</strong></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Transactional</span>(rollbackFor = RuntimeException.class)<span class="comment">//开启事务</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">(Order order)</span> </span>&#123;<span class="comment">//A系统调用RTM，伪代码</span></div><div class="line">      <span class="comment">// 1.调用RMQ，创建预发送消息</span></div><div class="line">      String msgID = rtmService.addHalfMessage(order);<span class="comment">//上面1处，实际上就是对应这里的代码段，假设这里发生异常，因为addOrder()方法添加了事务，所以addORder()执行失败。数据一致性没有问题。</span></div><div class="line">      <span class="comment">// 2.执行业务</span></div><div class="line">         。。。。。</div><div class="line">      <span class="comment">// 3.同步调用RTM，确认发送消息</span></div><div class="line">      rtmService.confirmHalfMessage(msgID);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>2发生异常，RTM持久化半消息失败。同理，因为<strong>A系统</strong>还<strong>没执行本业务</strong>（没有执行到4处），而且<strong>RTM系统</strong>也<strong>没有持久化半消息</strong>。那么此时不会产生数据不一致，<strong>那么RTM系统不需要做处理</strong>。</li>
</ul>
<ul>
<li><p>3.处发生异常，RTM持久化消息成功。但是<strong>A系统</strong>还<strong>没执行本业务</strong>（没有执行到4处），这个时候数据不一致。那么RTM<strong>提供回查机制</strong>，RTM的会<strong>有定时器定时检查RTM系统中没有确认的消息</strong>，向A系统发起请求，请求检查A系统业务状态，如果执行业务失败，那么RTM删除持久化的半消息，否则A系统执行业务成功，那么RTM确认投递消息到MQ。</p>
<ul>
<li><p>什么情况下执行2处代码成功，但是上游却报异常呢？例如A系统设定调用 rtmService.addHalfMessage(order)的超时时间是5s，（也就是说在5s内addHalfMessage方法要给我响应，否则我就抛异常），但是addHalfMessage()方法执行需要7s，那么很明显A系统执行addHalfMessage()方法就会超时，然后A系统请求超时抛异常，<strong>A系统业务执行失败</strong>。但是A系统报异常并不影响RTM继续执行addHalfMessage()的逻辑，此时过了7s，addHalfMessage()执行成功。<strong>RTM成功持久化半消息</strong>。</p>
</li>
<li><p><strong>所以我们A系统需要提供回查的接口给RTM系统调用，让给RTM系统确认半消息是删除还是投递。</strong></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>4处发生异常，也就是A系统执行本地业务失败。此时RTM系统已经持久化半消息，那么数据是不一致的。<ul>
<li>怎么解决？<strong>跟解决上面的问题三一样，也是需要RTM的回查机制，进行回查A系统确定当前持久化的半消息是删除还是投递。</strong></li>
</ul>
</li>
</ul>
<ul>
<li>5处发生异常，A系统业务执行成功。但是RTM系统的半消息没有确认投递，数据不一致。<ul>
<li>解决办法，还是需要RTM系统的回查功能，<strong>进行回查A系统确定当前持久化的半消息是删除还是投递。</strong></li>
</ul>
</li>
</ul>
<ul>
<li>6处发生异常，A系统业务执行成功，RTM确认投递消息失败，数据不一致。<ul>
<li>解决办法，还是需要RTM系统的回查功能，<strong>进行回查A系统确定当前持久化的半消息是删除还是投递。</strong></li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>​    我们发现，除了一二处的异常，未产生数据不一致，不需要RTM系统进行干预外，3456处的异常需要RTM系统的回查机制进行确认RTM系统已经持久化的半消息是删除 还是投递。</p>
<p>​    这个时候，我们就应该得出，RTM系统需要具备一个<strong>定时回查A系统的模块</strong></p>
<p>分析到这里，我们发现。</p>
<ul>
<li><strong>上游系统A需要提供一个查询本地业务执行结果的接口。</strong></li>
<li><strong>RTM系统提供，创建半消息接口，确认半消息接口，定时回查A系统业务功能</strong></li>
</ul>
<h2 id="RTM确认消费者成功消费流程"><a href="#RTM确认消费者成功消费流程" class="headerlink" title="RTM确认消费者成功消费流程"></a>RTM确认消费者成功消费流程</h2><p>我们上面解决了上游系统跟RTM系统交互的可靠性，那么RTM系统跟下游系统的数据一致性，在呢么解决呢？请看流程图。</p>
<p><img src="/2020/04/18/rtm数据最终一致性/image-20200426145201920.png" alt="image-20200426151609573"></p>
<p>同理我们来分析，下面这几处的如果出现了异常RTM系统是如何处理的？</p>
<ul>
<li>7处发生异常，RTM系统的<strong>确认是否消费功能</strong>，会<strong>定时检查</strong>RTM系统中已经确认可以投递的消息（也即是经过操作6之后的消息），如果存在，那么就会<strong>重新投递到MQ中</strong>。（也就是说，<strong>B系统必须保证接口服务的幂等性，因为可能存在重复消费</strong>）</li>
</ul>
<ul>
<li>8处发生异常，同理RTM系统也会通过<strong>确认是否消费功能</strong>，<strong>定时重发</strong>RTM系统中<strong>未被B系统确认消费的消息</strong>。</li>
</ul>
<ul>
<li>9处发生异常，同理RTM系统也会通过<strong>确认是否消费功能</strong>，<strong>定时重发</strong>RTM系统中<strong>未被B系统确认消费的消息</strong>。</li>
</ul>
<ul>
<li>10处发生异常，同理RTM系统也会通过<strong>确认是否消费功能</strong>，<strong>定时重发</strong>RTM系统中<strong>未被B系统确认消费的消息</strong>。</li>
</ul>
<p><strong>总而言之，如果下游B系统如果没有向RTM系统确认消费消息，那么RTM系统就会通过定时器反复向MQ重发消息。（B系统必须保证接口服务的幂等性，因为可能存在重复消费）</strong></p>
<h3 id="超时重试次数和重试时间"><a href="#超时重试次数和重试时间" class="headerlink" title="超时重试次数和重试时间"></a>超时重试次数和重试时间</h3><p><strong>但是有个问题，那就是，无限次重发么？</strong>  <strong>隔几秒发一次呢？</strong></p>
<p>关于这个问题，我们可以仿照Rocketmq的重试逻辑<strong>，重试多次次后，那么就标记消息为死亡。（类似于rocketmq的死信队列）</strong></p>
<p>​    <strong>同时重试的时间间隔，也是采取递增的方式</strong>。例如重复通知时间间隔（单位：分钟） 举例： [0, 1, 4, 10, 30, 60] 第一次立即通知，如果业务方没有返回成功，则1分钟后再次通知。如果业务方还是没有返回成功，则4分钟后再次通知（<strong>此时距离第一次通知已经过了5分钟</strong>）。以此类推。<strong>那么这里一共可以重试几次呢？7次。</strong>  <strong>七次后还是没有得到下游B系统的确认消费通知，那么就标记当前消息为死亡。</strong></p>
<h3 id="那么消息死亡后怎么办？"><a href="#那么消息死亡后怎么办？" class="headerlink" title="那么消息死亡后怎么办？"></a>那么消息死亡后怎么办？</h3><p>消息重试次数超过限制次数后，消息就会被移动到死亡表中，然后你可以在后台进行人工重试。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>  经过上面的分析，我们知道，<strong>RTM系统需要提供一个接口，给下游服务B系统，确认消费成功。</strong></p>
<p>到这里，我们RTM系统一共需要哪些接口服务，我们再总结一下：</p>
<ul>
<li><strong>上游系统A需要提供一个查询本地业务执行结果的接口。</strong></li>
<li><p><strong>RTM系统提供，创建半消息接口，确认半消息接口，定时回查A系统业务功能</strong></p>
</li>
<li><p>RTM系统提供，确认消费成功接口，定时重发消息功能，定时</p>
</li>
</ul>
<h2 id="RTM项目总结"><a href="#RTM项目总结" class="headerlink" title="RTM项目总结"></a>RTM项目总结</h2><p>​    经过上面的总结，我想你应该对于RTM系统的定位，已经流程都已经有了一个比较充分的了解。那么我们接下来就总结一下实现RTM项目所需要的功能模块。</p>
<p>​    </p>
<h3 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h3><blockquote>
<p><strong>首先上游系统需要提供什么？</strong></p>
</blockquote>
<p>需要提供一个可以查询本地事务结果的接口，方便RTM回查上游系统业务结果，来决定持久化在RTM的半消息是删除还是确认投递。</p>
<blockquote>
<p><strong>RTM系统需要提供什么？</strong></p>
</blockquote>
<p><strong>（1）message-lifecycle-management模块（消息生命周期管理模块）</strong></p>
<ul>
<li>创建半消息的接口 <ul>
<li>提供上游系统在进行本地业务之前进行调用添加半消息。</li>
</ul>
</li>
</ul>
<ul>
<li>确认半消息投递接口<ul>
<li>提供给上游系统在执行成功本地业务后，调用该接口，实现确认半消息为可投递，并投递消息到MQ中。</li>
</ul>
</li>
</ul>
<ul>
<li>确认消息消费接口<ul>
<li>提供给下游系统，在成功消费MQ中的消息后，调用确认消息已经消费。</li>
</ul>
</li>
</ul>
<p><strong>（2）period-check-message模块（定时检查消息模块）</strong></p>
<ul>
<li>定时回查上游系统业务处理结果接口功能<ul>
<li>RTM系统定时调用，确认是否需要投递消息到MQ</li>
</ul>
</li>
</ul>
<ul>
<li>定时检查RTM持久化的消息是否已经被下游系统消费功能<ul>
<li>RTM系统定时调用，如果没有被消费，那么重复投递到MQ中</li>
</ul>
</li>
</ul>
<ul>
<li>定时检查RTM持久化的消息是否超过投递次数（也即是重复发送到mq次数达到上限，需要标记消息为死亡）<ul>
<li>RTM系统定时调用，同时把消息移动到死亡表中</li>
</ul>
</li>
</ul>
<ul>
<li>定时检查RTM持久化的消息是否已经被下游系统消费（如果是那么把已经消费的消息从系统中移除，放到消息历史表中）<ul>
<li>RTM系统定时调用</li>
</ul>
</li>
</ul>
<p>​    <strong>也就是说，这个模块需要提供四个定时器。</strong></p>
<blockquote>
<p><strong>下游系统需要提供什么？</strong></p>
</blockquote>
<p>不需要提供什么，但是需要保证消息消费的幂等性。</p>
<h3 id="数据库表（第一版）"><a href="#数据库表（第一版）" class="headerlink" title="数据库表（第一版）"></a><strong>数据库表（第一版）</strong></h3><p>第一版，因为时间关系，暂时没有提供前台界面，进行管理消息，后面有时间了，会加上去。</p>
<blockquote>
<p><strong>（1）数据库rtm</strong></p>
</blockquote>
<p>创建数据库rtm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE DATABASE /*!32312 IF NOT EXISTS*/`rtm` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;</div><div class="line"></div><div class="line">USE `rtm`;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>（2）数据库表</strong></p>
</blockquote>
<p><strong>消息表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t_k_message;</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_k_message</div><div class="line">(</div><div class="line">   msg_id               <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'id'</span>,</div><div class="line">   msg_name             <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息所属业务'</span>,</div><div class="line">   topic                <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息所属主题(看对接mq使用)'</span>,</div><div class="line">   quene_name           <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息所属队列(看对接mq使用)'</span>,</div><div class="line">   msg_content          <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">comment</span> <span class="string">'消息内容'</span>,</div><div class="line">   msg_status           <span class="built_in">varchar</span>(<span class="number">7</span>) <span class="keyword">comment</span> <span class="string">'消息状态，0-待确认，1-已确认发送中，2-已消费'</span>,</div><div class="line">   msg_d_status         <span class="built_in">varchar</span>(<span class="number">7</span>) <span class="keyword">comment</span> <span class="string">'消息是否死亡，0-正常，1-已死亡'</span>,</div><div class="line">   retry_counts         <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">comment</span> <span class="string">'重试次数'</span>,</div><div class="line">   check_url            <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">comment</span> <span class="string">'消息回查地址'</span>,</div><div class="line">   check_timeout        <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'消息回查超时时间'</span>,</div><div class="line">   check_duration       <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'消息回查周期时间，消息未确认时在这时间内需要回查'</span>,</div><div class="line">   create_msg_uid       <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息创建人id'</span>,</div><div class="line">   create_msg_time      datetime <span class="keyword">comment</span> <span class="string">'消息创建时间'</span>,</div><div class="line">   update_msg_uid       <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息更新人id'</span>,</div><div class="line">   update_msg_time      datetime <span class="keyword">comment</span> <span class="string">'消息更新时间'</span>,</div><div class="line">   confirm_msg_time     datetime <span class="keyword">comment</span> <span class="string">'消息确认投递时间'</span>,</div><div class="line">   resend_msg_uid       <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息重发人id'</span>,</div><div class="line">   resend_msg_time      datetime <span class="keyword">comment</span> <span class="string">'消息重发时间'</span>,</div><div class="line">   primary <span class="keyword">key</span> (msg_id)</div><div class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</div><div class="line"></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_k_message <span class="keyword">comment</span> <span class="string">'消息表'</span>;</div></pre></td></tr></table></figure>
<p><strong>确认消费消息表（历史表）也就是保存的是msg_status==2的消息</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t_k_message_consumed;</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_k_message_consumed</div><div class="line">(</div><div class="line">   msg_id               <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'id'</span>,</div><div class="line">   msg_name             <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息所属业务'</span>,</div><div class="line">   topic                <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息所属主题(看对接mq使用)'</span>,</div><div class="line">   quene_name           <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息所属队列(看对接mq使用)'</span>,</div><div class="line">   msg_content          <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">comment</span> <span class="string">'消息内容'</span>,</div><div class="line">   msg_status           <span class="built_in">varchar</span>(<span class="number">7</span>) <span class="keyword">comment</span> <span class="string">'消息状态，0-待确认，1-已确认发送中，2-已消费'</span>,</div><div class="line">   msg_d_status         <span class="built_in">varchar</span>(<span class="number">7</span>) <span class="keyword">comment</span> <span class="string">'消息是否死亡，0-正常，1-已死亡'</span>,</div><div class="line">   retry_counts         <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">comment</span> <span class="string">'重试次数'</span>,</div><div class="line">   check_url            <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">comment</span> <span class="string">'消息回查地址'</span>,</div><div class="line">   check_timeout        <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'消息回查超时时间'</span>,</div><div class="line">   check_duration       <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'消息回查周期时间，消息未确认时在这时间内需要回查'</span>,</div><div class="line">   create_msg_uid       <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息创建人id'</span>,</div><div class="line">   create_msg_time      datetime <span class="keyword">comment</span> <span class="string">'消息创建时间'</span>,</div><div class="line">   update_msg_uid       <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息更新人id'</span>,</div><div class="line">   update_msg_time      datetime <span class="keyword">comment</span> <span class="string">'消息更新时间'</span>,</div><div class="line">   confirm_msg_time     datetime <span class="keyword">comment</span> <span class="string">'消息确认投递时间'</span>,</div><div class="line">   resend_msg_uid       <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息重发人id'</span>,</div><div class="line">   resend_msg_time      datetime <span class="keyword">comment</span> <span class="string">'消息重发时间'</span>,</div><div class="line">   primary <span class="keyword">key</span> (msg_id)</div><div class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</div><div class="line"></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_k_message <span class="keyword">comment</span> <span class="string">'已消费消息历史表'</span>;</div></pre></td></tr></table></figure>
<p><strong>超时死亡消息表 - 保存的是msg_d_status==1的消息</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t_k_dead_message;</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_k_dead_message</div><div class="line">(</div><div class="line">   msg_id               <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'id'</span>,</div><div class="line">   msg_name             <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息所属业务'</span>,</div><div class="line">   topic                <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息所属主题(看对接mq使用)'</span>,</div><div class="line">   quene_name           <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息所属队列(看对接mq使用)'</span>,</div><div class="line">   msg_content          <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">comment</span> <span class="string">'消息内容'</span>,</div><div class="line">   msg_status           <span class="built_in">varchar</span>(<span class="number">7</span>) <span class="keyword">comment</span> <span class="string">'消息状态，0-待确认，1-已确认发送中，2-已消费'</span>,</div><div class="line">   msg_d_status         <span class="built_in">varchar</span>(<span class="number">7</span>) <span class="keyword">comment</span> <span class="string">'消息是否死亡，0-正常，1-已死亡'</span>,</div><div class="line">   retry_counts         <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">comment</span> <span class="string">'重试次数'</span>,</div><div class="line">   check_url            <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">comment</span> <span class="string">'消息回查地址'</span>,</div><div class="line">   check_timeout        <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'消息回查超时时间'</span>,</div><div class="line">   check_duration       <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">comment</span> <span class="string">'消息回查周期时间，消息未确认时在这时间内需要回查'</span>,</div><div class="line">   create_msg_uid       <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息创建人id'</span>,</div><div class="line">   create_msg_time      datetime <span class="keyword">comment</span> <span class="string">'消息创建时间'</span>,</div><div class="line">   update_msg_uid       <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息更新人id'</span>,</div><div class="line">   update_msg_time      datetime <span class="keyword">comment</span> <span class="string">'消息更新时间'</span>,</div><div class="line">   confirm_msg_time     datetime <span class="keyword">comment</span> <span class="string">'消息确认投递时间'</span>,</div><div class="line">   resend_msg_uid       <span class="built_in">varchar</span>(<span class="number">70</span>) <span class="keyword">comment</span> <span class="string">'消息重发人id'</span>,</div><div class="line">   resend_msg_time      datetime <span class="keyword">comment</span> <span class="string">'消息重发时间'</span>,</div><div class="line">   primary <span class="keyword">key</span> (msg_id)</div><div class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</div><div class="line"></div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_k_message <span class="keyword">comment</span> <span class="string">'消息表'</span>;</div></pre></td></tr></table></figure>
<h3 id="项目代码模块结构"><a href="#项目代码模块结构" class="headerlink" title="项目代码模块结构"></a>项目代码模块结构</h3><p><img src="/2020/04/18/rtm数据最终一致性/image-20200428162644118.png" alt="image-20200428162644118"></p>
<h3 id="RTM项目使用环境"><a href="#RTM项目使用环境" class="headerlink" title="RTM项目使用环境"></a>RTM项目使用环境</h3><blockquote>
<p><strong>依赖环境</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">环境</th>
<th style="text-align:left">版本</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">JDK</td>
<td style="text-align:left">1.8</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">MySQL</td>
<td style="text-align:left">5.7.25</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Zookeeper</td>
<td style="text-align:left">3.4.14</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">kafka</td>
<td style="text-align:left">5.15.6</td>
<td>因为原先上下游系统使用的是kafka，所以这里接入的就是kafka（如果是其他的mq则接入你自己的mq即可） -可选</td>
</tr>
<tr>
<td style="text-align:left">Maven</td>
<td style="text-align:left">3.3.9</td>
</tr>
</tbody>
</table>
<h1 id="RTM代码实现"><a href="#RTM代码实现" class="headerlink" title="RTM代码实现"></a>RTM代码实现</h1><h2 id="父工程-rtm"><a href="#父工程-rtm" class="headerlink" title="父工程 rtm"></a>父工程 rtm</h2><h3 id="接口层-rtm-api"><a href="#接口层-rtm-api" class="headerlink" title="接口层 rtm-api"></a>接口层 rtm-api</h3><p>保存rtm，对外暴露的接口</p>
<p><strong>依赖 rtm-pojo</strong></p>
<p>实现三个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.kingge.rtm.api;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.kingge.rtm.pojo.TKMessage;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@program</span>: rtm</span></div><div class="line"><span class="comment"> * <span class="doctag">@description</span>: rtm暴露接口，提供上下游服务调用</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>: JeremyKing</span></div><div class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-04-27 11:26</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRtmService</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@Description</span>: 创建半消息</span></div><div class="line"><span class="comment">     * <span class="doctag">@Param</span>: 消息实体</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: 消息id</span></div><div class="line"><span class="comment">     * <span class="doctag">@Author</span>: JeremyKing</span></div><div class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/4/27 0027</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">addHalfMessage</span><span class="params">(TKMessage message)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@Description</span>: 根据消息id，确认并发送半消息到mq</span></div><div class="line"><span class="comment">     * <span class="doctag">@Param</span>: 消息id</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>: void</span></div><div class="line"><span class="comment">     * <span class="doctag">@Author</span>: JeremyKing</span></div><div class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/4/27 0027</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitAndSendHalfMessage</span><span class="params">(String msg_id)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">      * <span class="doctag">@Description</span>: 根据消息id，确认消费消息</span></div><div class="line"><span class="comment">      * <span class="doctag">@Param</span>: 消息id</span></div><div class="line"><span class="comment">      * <span class="doctag">@return</span>: void</span></div><div class="line"><span class="comment">      * <span class="doctag">@Author</span>: JeremyKing</span></div><div class="line"><span class="comment">      * <span class="doctag">@Date</span>: 2020/4/27 0027</span></div><div class="line"><span class="comment">      */</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirmConsumeMessage</span><span class="params">(String msg_id)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实体类-rtm-pojo"><a href="#实体类-rtm-pojo" class="headerlink" title="实体类 rtm-pojo"></a>实体类 rtm-pojo</h3><p>保存rtm项目的实体类</p>
<p>根据mybatis-reverse，逆向生成数据库表对应的实体类和mapper、xml文件。</p>
<h3 id="工具层-rtm-common"><a href="#工具层-rtm-common" class="headerlink" title="工具层 rtm-common"></a>工具层 rtm-common</h3><h3 id="消息生命周期管理服务-rtm-mlm"><a href="#消息生命周期管理服务-rtm-mlm" class="headerlink" title="消息生命周期管理服务 rtm-mlm"></a>消息生命周期管理服务 rtm-mlm</h3><p><strong>message-lifecycle-management模块（消息生命周期管理模块）</strong> -  的简写，mlm</p>
<h3 id="定时检查消息模块-rtm-pcm"><a href="#定时检查消息模块-rtm-pcm" class="headerlink" title="定时检查消息模块 rtm-pcm"></a>定时检查消息模块 rtm-pcm</h3><p>period-check-message模块（定时检查消息模块） - 简写，pcm</p>
<h2 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h2><p><a href="https://github.com/JeremyKinge/rtm.git" target="_blank" rel="external">https://github.com/JeremyKinge/rtm.git</a></p>
<h1 id="怎么使用rtm"><a href="#怎么使用rtm" class="headerlink" title="怎么使用rtm"></a>怎么使用rtm</h1><p>目前rtm只提供了，dubbo版本，那么也就是在使用时，你需要配置dubbo环境。</p>
<h2 id="上游系统怎么使用？"><a href="#上游系统怎么使用？" class="headerlink" title="上游系统怎么使用？"></a>上游系统怎么使用？</h2><p>只需要在业务类中，通过dubbo的方式注入rtm服务即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.alibaba.dubbo.config.annotation.Reference;</div><div class="line">import com.kingge.rtm.api.IRtmService;</div><div class="line"></div><div class="line">@Reference</div><div class="line">IRtmService iRtmService;</div></pre></td></tr></table></figure>
<p>例如你的业务逻辑如下：订单支付后，需要给用户增加积分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Transactional</span>(rollbackFor = RuntimeException.class)<span class="comment">//开启事务</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOrder</span><span class="params">(Order order)</span> </span>&#123;</div><div class="line">      <span class="comment">// 1.调用RMQ，创建预发送消息</span></div><div class="line">       TKMessage message = <span class="keyword">new</span> TKMessage();</div><div class="line">      String msgID = iRtmService.addHalfMessage(TKMessage message);</div><div class="line">      <span class="comment">// 2.执行业务</span></div><div class="line">         。。。。。</div><div class="line">      <span class="comment">// 3.异步调用RTM，确认发送消息</span></div><div class="line">      iRtmService.submitAndSendHalfMessage(message.getMsgid());</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="下游系统怎么用？"><a href="#下游系统怎么用？" class="headerlink" title="下游系统怎么用？"></a>下游系统怎么用？</h2><p>根据上面的例子，下游会去mq订阅积分消息，那么需要在处理订阅的消息方法中。下游服务在处理完消息后，调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">iRtmService.confirmConsumeMessage(message.getMsgid());</div></pre></td></tr></table></figure>
<p>完成确认消息已经消费即可。</p>
<p><strong>需要注意的是：下游消费服务时，需要注意保证消息幂等性，因为可能因为网络等等原因，可能rtm会重发消息。</strong></p>
<h1 id="RTM项目亮点"><a href="#RTM项目亮点" class="headerlink" title="RTM项目亮点"></a>RTM项目亮点</h1><p>0.首先是给没有提供事务消息机制的mq提供了事务消息的方式</p>
<p>1.超时重试机制，类似rocketmq，根据时间递增间隔重试</p>
<p>2.死亡消息，可以在后台进行重发，手动干预</p>
<p>3.消息重试，采取线程池的方式，根据<strong>线程池的coresize大小（避免线程递增到maxsize）</strong>，去数据库中<strong>取相应数量</strong>需要重复发送搭到mq的消息。</p>
<p>4.重发消息时，从重发次数大到小进行重发（<strong>例如，RTM支持的最大重试次数是7。那么就先查重发次数是6的消息，处理完后。再接着查重发次数是5的消息</strong>），保证了优先处理快要到重试次数上限的消息，优先处理。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>​    也就是说rtm系统 在兼有rocketmq事务消息的同时，能够<strong>保证下游系统一定能消费消息（提供消费失败一定次数和时间间隔重试以及记录超过重试次数的消息）</strong>，从而保证了数据的最终一致性，同时提供管理界面，管理已经超过重发次数上限的消息，重新发送。</p>
<p>​    所以说，当你的项目架构在最初的技术选型时，并没有使用rocketmq，那么又想保证数据最终一致性，那么就可以引入rtm系统，非常方便快捷。</p>
<h1 id="RTM项目存在的缺点"><a href="#RTM项目存在的缺点" class="headerlink" title="RTM项目存在的缺点"></a>RTM项目存在的缺点</h1><p>1.<strong>目前没有支持多种</strong>mq的版本（现在只是实现了对接kafka版本）</p>
<p>2.分布式集群的搭建测试</p>
<p>3.项目模块的拆分还不够清晰，例如rtm-pcm模块，可以拆分成两个模块，一个是rtm-pcm-api模块（提供接口，他的实现类在rtm-pcm中），一个是rtm-pcm模块（真正的业务放到这里）</p>
<p>4.rtm-pcm或者rtm-web 模块过于依赖rtm-mlm模块，导致前两者，都需要在application.yaml中配置跟rtm-mlm相同的数据库数据源信息（因为前两者使用了rtm-mlm的mapper调用数据库。）。后面考虑由rtm-mlm提供数据库操作接口，让前两者通过dubbo的方式调用mapper调用数据库。 而不用直接使用rtm-mlm的mapper去调用。</p>
<p>在前两者移除 rtm-mlm依赖，依赖rtm-mlm-api</p>
<p>也就是说在增加一个rtm-mlm-api模块。里面提供操作数据库的接口，rtm-mlm实现接口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h1&gt;&lt;h2 id=&quot;为什么使用消息队列？&quot;&gt;&lt;a href=&quot;#为什么使用消息队列？&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="开源项目" scheme="http://kingge.top/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="开源项目" scheme="http://kingge.top/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="事务消息" scheme="http://kingge.top/tags/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
    
      <category term="kafka" scheme="http://kingge.top/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>java核心技术杂记</title>
    <link href="http://kingge.top/2020/03/09/java%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <id>http://kingge.top/2020/03/09/java基础核心技术/</id>
    <published>2020-03-09T04:57:58.000Z</published>
    <updated>2020-05-09T08:56:11.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>​    通过日常编码，发现，我们在编程的过程中，使用频率最高的变量或者对象，往往是字符串（可以通过分析jvm内存，可得，string类型的数据一般占用的内存排行在最前列），那么怎么优化string类型的字符串成为了一个重点。</p>
<p>​    而且优化的目的就是，复用已经存在的字符串，让他的存取类比于java基本类型的存取。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200111235950327.png" alt="image-20200111235950327"></p>
<p><strong>string并不是基本类型。</strong></p>
<p>通过看源码，发现String是一个final不可变的，换言说，如果你给一个String变量重新赋值，那么最终是会重新建立一个string类型数据复制给他，而不会覆盖之前的值。<code>final</code>修饰的成员变量，因此任何看似对String内容进行操作的方法，实际上都是返回了一个新的String对象，这就造就了一个String对象的被创建后，就一直会保持不变（所以要警惕，string的多次修改，因为会创建很多string值，那么常量池可能会占尽）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public final class String</div><div class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</div></pre></td></tr></table></figure>
<p>同时我们知道，string的值，是存放在jvm方法区中，具体位置是，方法区的常量池。这样做的好处就是，能够共享已经存在的string数据，避免重复创建。</p>
<p>举个简单例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">string a = &quot;123&quot;;</div><div class="line"></div><div class="line">string b = &quot;123&quot;;</div><div class="line"></div><div class="line">a == b?</div></pre></td></tr></table></figure>
<p>答案是true，为什么，因为创建a 变量时，就会在常量池中创建 123字符串，然后把该字符串在常量池的地址，复制给a变量。当发现b的值也是123的时候，那么他会现在常量池中寻找是否存在123字符串，如果存在，那么就直接把123的地址复制给b变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">string a = &quot;123&quot;;</div><div class="line">string b = &quot;12&quot;;</div><div class="line">b+=&quot;3&quot;</div><div class="line">a == b?</div><div class="line">答案，肯定也是true，因为b+=&quot;3&quot;会发生字符串堆叠，编译器会优化，生成123。但是我们知道a已经在常量池中创建了123，那么就会把地址直接返回给b。</div><div class="line">那么上面这段代码，创建了多少个对象？四个，a，“123”，b,&quot;12&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">string b = &quot;12&quot;;</div><div class="line">String a = &quot;1212&quot;</div><div class="line">String c = b+&quot;12&quot;</div><div class="line">a == c?</div><div class="line">答案是 false，因为c指向的是堆内存的地址。为什么呢？b+&quot;12&quot;因为是变量加上常量，那么只有在运行时才能够确定c的值。</div><div class="line">通过反编译这段代码（javap -verbose），发现实际上最终实现是：new Stringbuilder(&quot;12&quot;).append(&quot;12&quot;).toString(); 所以String c = b+&quot;12&quot;,一共创建了两个对象，一个是stringbuilder，一个是string，两个对象都在堆中。</div></pre></td></tr></table></figure>
<p>反编译代码：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200112095817759.png" alt="image-20200112095817759"></p>
<p>再来看一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String s = &quot;1&quot;+&quot;2&quot;+&quot;3&quot;;//这一行一共生成对少个对象？ 答案是1个，涉及到字符串堆叠的问题。</div><div class="line">        //他会直接在常量池生成&quot;123&quot;一个对象，s只是一个局部变量</div><div class="line">        String s1 = new String(&quot;hello&quot;);//这里的意思是，在堆内存创建一个String对象，然后他指向常量池的“hello”，这里一共创建了两个对象，一个是常量池的hello，一个是在堆中的对象</div><div class="line">        String s2 = &quot;hello&quot;;//s2指向常量池的“hello”，这里的hello是s1创建的。</div><div class="line">        String s3 = &quot;h&quot;+&quot;e&quot;+&quot;l&quot;+&quot;l&quot;+&quot;o&quot;;</div><div class="line">        System.out.println(s);//输出123</div><div class="line">        System.out.println(s1 == s2);//输出false，我们知道，s1指向的是堆内存分配的String的地址。s2指向的是常量池的“hello”</div><div class="line">        System.out.println(s1.equals(s2));//true，equal比较的是内容，string</div><div class="line">        重写了object的equals方法，object比较的是地址。</div><div class="line">        System.out.println(s2 == s3);//返回时true // 因为jvm会自动优化，在执行s3的时候，产生字符串堆叠，生成</div><div class="line">        //hello,然后发现常量池中已经存在一个hello（s1创建的），所以s3和s2都指向同一个常量池地址</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>String类型的常量池比较特殊。它的主要使用方法有两种：</p>
<p>1.直接使用双引号声明出来的String对象会直接存储在常量池中。</p>
<p>2.如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</p>
<p>查看string重写的equals方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public boolean equals(Object anObject) &#123;</div><div class="line">    if (this == anObject) &#123;//1.如果地址相同，那么说明内容肯定一样</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    if (anObject instanceof String) &#123;//2.紧接着获取两个要比较对象的char数组，然后逐个比较</div><div class="line">        String anotherString = (String)anObject;</div><div class="line">        int n = value.length;</div><div class="line">        if (n == anotherString.value.length) &#123;</div><div class="line">            char v1[] = value;</div><div class="line">            char v2[] = anotherString.value;</div><div class="line">            int i = 0;</div><div class="line">            while (n-- != 0) &#123;</div><div class="line">                if (v1[i] != v2[i])</div><div class="line">                    return false;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="什么是字面值？"><a href="#什么是字面值？" class="headerlink" title="什么是字面值？"></a>什么是字面值？</h2><p>字面值就是可以直接看到是多少的数据，在程序运行中其值不能发生改变。</p>
<p>以下这些就是字面值，字面值，都是存放在常量池中</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* 字符串，用双引号括起来的内容，例如：monkey</span></div><div class="line"><span class="comment">* 整数，所有整数，例如：1024</span></div><div class="line"><span class="comment">* 小数，所有小数，例如：3.14</span></div><div class="line"><span class="comment">* 字符，用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号</span></div><div class="line"><span class="comment">* 布尔，只有true和false</span></div><div class="line"><span class="comment">* 空，null</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConstantDemo01</span> &#123;                        </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line"></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"monkey"</span>);    <span class="comment">//字符串</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"monkey1024"</span>);    <span class="comment">//字符串</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="number">1024</span>);        <span class="comment">//整数</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="number">3.14</span>);        <span class="comment">//小数</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">'a'</span>);        <span class="comment">//''中必须放的是单个字符</span></div><div class="line">    <span class="comment">//error</span></div><div class="line">    <span class="comment">//System.out.println('ab');        //这个ab不是单个字符，而是字符串</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">' '</span>);        <span class="comment">//带表空格字符</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="literal">true</span>);        <span class="comment">//boolean类只有两个值,true和false</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Stringbuffer和Stringbuilder"><a href="#Stringbuffer和Stringbuilder" class="headerlink" title="Stringbuffer和Stringbuilder"></a>Stringbuffer和Stringbuilder</h2><p>这两者其实是一模一样的，区别在于，stringbuffer是线程安全的，而stringbuilder是线程不安全的。二者都继承了 AbstractStringBuilder，里面包含了基本操作。区别仅在于Stringbuffer的方法都加了 synchronized。</p>
<p><strong>我们在使用stringbuilder或者stringbuffer的时候，需要考虑到是否存在锁优化的问题（详情参见java并发总结文章）</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.string是一个不可变的变量，<strong>常量池中一定不存在两个相同的字符串</strong>。不可变的意思是，假设创建了这个值就不会再改变，针对于这个字符串的改变，都会重新创建一个新的字符串对象。（例如调用string的，substring，concat等方法，都是返回一个新的string对象）</p>
<p>2.两个字面值字符串相加，在编译期间就可以确定他们的值，他们的加值就存放在字符串常量池中。但是一个字面量加上一个字符串变量，只有在运行期间才会确定值，他们最终是通过stringbuilder的append方法实现相加，最终通过调用toString方法返回一个新的string对象。</p>
<p>关于string.iten的源码：<a href="http://cmsblogs.com/?p=5248" target="_blank" rel="external">http://cmsblogs.com/?p=5248</a></p>
<p>好的博客地址：<a href="https://www.cnblogs.com/dengchengchao/p/9713859.html" target="_blank" rel="external">https://www.cnblogs.com/dengchengchao/p/9713859.html</a> 重要</p>
<p><a href="https://blog.csdn.net/JohnDeng520/article/details/94914717" target="_blank" rel="external">https://blog.csdn.net/JohnDeng520/article/details/94914717</a></p>
<p>深入理解Java中的String（大坑）<a href="https://blog.csdn.net/qq_34490018/article/details/82110578" target="_blank" rel="external">https://blog.csdn.net/qq_34490018/article/details/82110578</a></p>
<p><a href="https://blog.csdn.net/ifwinds/article/details/80849184" target="_blank" rel="external">https://blog.csdn.net/ifwinds/article/details/80849184</a> 重要，iten方法的存在就是为了避免，创建过多的对象。</p>
<p><a href="https://www.cnblogs.com/airnew/p/11628017.html" target="_blank" rel="external">https://www.cnblogs.com/airnew/p/11628017.html</a> 重要 </p>
<h1 id="Exception和Error有什么区别？"><a href="#Exception和Error有什么区别？" class="headerlink" title="Exception和Error有什么区别？"></a><strong>Exception和Error有什么区别？</strong></h1><p>异常的出现，是为了解决在编码过程中，某个逻辑可能出现的意料之外的情况，我们通过捕获这种情况，然后做相应的修正逻辑或者后继处理，使得我们的程序更加健壮。</p>
<p>我们知道出现的意料之外的情况，可以能分为两种，出现问题后我们获取问题然后做拯救措施，程序紧着可以运行，另一种就是出现问题，就算我们再拯救也没用，那么就直接让程序挂掉，然后我们事后做分析。那就是，可以恢复和不可恢复，进而言之分为，exception和error。</p>
<p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p><strong>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类</strong>。Exception 是程序正常运行中，可以<strong>预料的意外情况，可能并且应该被捕获，进行相应处理。</strong></p>
<p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p>
<p>Exception 又分为<strong>可检查</strong>（checked）异常和<strong>不检查</strong>（unchecked）异常，可检查异常在源代码里<strong>必须显式地进行捕获处理</strong>，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。</p>
<p>不检查异常就是所谓的<strong>运行时异常</strong>，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p>
<h2 id="你了解哪些-Error、Exception-或者-RuntimeException？"><a href="#你了解哪些-Error、Exception-或者-RuntimeException？" class="headerlink" title="你了解哪些 Error、Exception 或者 RuntimeException？"></a>你了解哪些 Error、Exception 或者 RuntimeException？</h2><p><img src="/2020/03/09/java基础核心技术/image-20200112113301062.png" alt="image-20200112113301062"></p>
<p>NullPointerException，在写if判断逻辑的时候，没有考虑充分，导致某种情况的入参，没有做到对象的初始化，然后用对象去调用某个方法时，出现问题。</p>
<p>ClassCastException 类转化异常。报表导入时，做映射的时候。</p>
<p>继承于RuntimeException的异常都是可检查异常，继承Exception是非检查异常</p>
<h2 id="try-with-resources-自动关闭资源"><a href="#try-with-resources-自动关闭资源" class="headerlink" title="try-with-resources 自动关闭资源"></a>try-with-resources 自动关闭资源</h2><p>Try-with-resources是java7中一个新的异常处理机制，它能够很容易地关闭在try-catch语句块中使用的资源。</p>
<p>在以前的代码中，我们一般是通过finally做最后的资源回收工作，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static void printFile() throws IOException &#123;</div><div class="line"></div><div class="line">​    InputStream input = null;</div><div class="line"></div><div class="line">​    try &#123;</div><div class="line">​        input = &lt;strong&gt;new FileInputStream(&quot;file.txt&quot;);</div><div class="line">​        int data = &lt;strong&gt;input.read()</div><div class="line">​        while(data != -1)&#123;</div><div class="line">​            System.out.print((char) data);</div><div class="line">​            data = &lt;strong&gt;input.read()</div><div class="line">​        &#125;</div><div class="line">​    &#125; finally &#123;</div><div class="line">​        if(input != null)&#123;</div><div class="line">​            input.close();</div><div class="line">​        &#125;</div><div class="line">​    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在java7中，对于上面的例子可以用try-with-resource 结构这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static void printFileJava7() throws IOException &#123;</div><div class="line">    try(FileInputStream input = new FileInputStream(&quot;file.txt&quot;)) &#123;</div><div class="line">        int data = input.read();</div><div class="line">        while(data != -1)&#123;</div><div class="line">            System.out.print((char) data);</div><div class="line">            data = input.read();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是try-with-resource 结构的用法。FileInputStream 类型变量就在try关键字后面的括号中声明。而且一个FileInputStream 类型被实例化并被赋给了这个变量。</p>
<p>当try语句块运行结束时，FileInputStream 会被自动关闭。这是因为FileInputStream 实现了java中的java.lang.AutoCloseable接口。所有实现了这个接口的类都可以在try-with-resources结构中使用。</p>
<p>当try-with-resources结构中抛出一个异常，同时FileInputStreami被关闭时（调用了其close方法）也抛出一个异常，try-with-resources结构中抛出的异常会向外传播，而FileInputStreami被关闭时抛出的异常被抑制了。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a><strong>知识扩展</strong></h2><p>先开看第一个吧，下面的代码反映了异常处理中哪些不当之处？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try &#123;</div><div class="line">  // 业务代码</div><div class="line">  // …</div><div class="line">  Thread.sleep(1000L);</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">  // Ignore it</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码虽然很短，但是已经违反了异常处理的两个基本原则。</p>
<p>第一，<strong>尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常</strong>，在这里是 Thread.sleep() 抛出的 InterruptedException。</p>
<p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务让自己的代码能够直观地体现出尽量多的信息，而泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获。</p>
<p><strong>进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。</strong></p>
<p>第二，<strong>不要生吞（swallow）异常</strong>。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。</p>
<p>生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设！</p>
<p>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束。没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p>
<blockquote>
<p><strong>体会一下Throw early, catch late 原则</strong></p>
</blockquote>
<p>我们接下来看下面的代码段，体会一下<strong>Throw early, catch late 原则</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void readPreferences(String fileName)&#123;</div><div class="line">	 //...perform operations... </div><div class="line">	InputStream in = new FileInputStream(fileName);</div><div class="line">	 //...read the preferences file...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 fileName 是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。这个 NPE 只是作为例子，实际产品代码中，可能是各种情况，比如获取配置失败之类的。在发现问题的时候，第一时间抛出，能够更加清晰地反映问题。</p>
<p>我们可以修改一下，让问题“throw early”，对应的异常信息就非常直观了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void readPreferences(String filename) &#123;</div><div class="line">	Objects. requireNonNull(filename);</div><div class="line">	//...perform other operations... </div><div class="line">	InputStream in = new FileInputStream(filename);</div><div class="line">	 //...read the preferences file...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处理，可以选择保留原有异常的 cause 信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</p>
<p>有的时候，我们会根据需要自定义异常，这个时候除了保证提供足够的信息，还有两点需要考虑：</p>
<ul>
<li>是否需要定义成 Checked Exception，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。</li>
<li>在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。如果我们看 Java 的标准类库，你可能注意到类似 java.net.ConnectException，出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数据一般是不可以输出到日志里面的。</li>
</ul>
<p>业界有一种争论（甚至可以算是某种程度的共识），Java 语言的 Checked Exception 也许是个设计错误，反对者列举了几点：</p>
<ul>
<li>Checked Exception 的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception 的使用，已经大大偏离了最初的设计目的。</li>
<li>Checked Exception 不兼容 functional 编程，如果你写过 Lambda/Stream 代码，相信深有体会。</li>
</ul>
<p>我们从性能角度来审视一下 Java 的异常处理机制，这里有两个可能会相对昂贵的地方：</p>
<ul>
<li>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li>
<li>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</li>
</ul>
<p>所以，对于部分追求极致性能的底层类库，有种方式是尝试创建不进行栈快照的 Exception。这本身也存在争议，因为这样做的假设在于，我创建异常时知道未来是否需要堆栈。问题是，实际上可能吗？小范围或许可能，但是在大规模项目中，这么做可能不是个理智的选择。如果需要堆栈，但又没有收集这些信息，在复杂情况下，尤其是类似微服务这种分布式系统，这会大大增加诊断的难度。</p>
<p>当我们的服务出现反应变慢、吞吐量下降的时候，检查发生最频繁的 Exception 也是一种思路。关于诊断后台变慢的问题，我会在后面的 Java 性能基础模块中系统探讨。</p>
<h1 id="强引用、软引用、弱引用、幻象引用有什么区别？"><a href="#强引用、软引用、弱引用、幻象引用有什么区别？" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别？"></a><strong>强引用、软引用、弱引用、幻象引用有什么区别？</strong></h1><p>不同的引用类型，主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响</strong>。也就是说，他是跟</p>
<p>所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象（<strong>我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new 创建的对象所关联的引用就是强引用</strong>）。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>软引用（通过这个类实现SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。<strong>虽说难以下咽，但是弃之可惜，所以他是强引用的一种折中方案，当jvm堆内存充足不会回收，但是当堆内存不足的时候，就会被回收。换句话说，就是尽量留下来</strong></p>
<p>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p>
<p>对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。</p>
<h1 id="动态代理和反射是基于什么原理？"><a href="#动态代理和反射是基于什么原理？" class="headerlink" title="动态代理和反射是基于什么原理？"></a>动态代理和反射是基于什么原理？</h1><p>​     </p>
<p>​    什么叫代理，就是我代替你去做某件事情，例如代购，通过代理功能，我们可以在调用<strong>被代理对象（委托类）</strong>的某个方法的<strong>前后做一些逻辑补充操作</strong>，例如我们要做饭，那么我们在做饭之前先洗米，插上电源—&gt;&gt; 做饭 —&gt;拔下电源。</p>
<p>这个就是我们常说的切面，就是在<strong>原来的基础上（不改变委托类）</strong>，切入我们想要的逻辑。</p>
<p><strong>代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</strong></p>
<p>​    代理模式是一种常用的设计模式。代理模式为其对象提供了一种代理以控制对这个对象的访问。代理模式可以将主要业务与次要业务进行松耦合的组装。根据代理类的创建时机和创建方式的不同，可以将其分为静态代理和动态代理两种形式：<br>在程序运行前就已经存在的<strong>编译好的代理类</strong>是为静态代理。<br>在程序运行期间根据需要动态创建代理类及其实例来完成具体的功能是为动态代理。（<strong>动态代理的实现方式有两种，JDK动态代理和cglib动态代理</strong>）</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>就是通过继承委托类，生成代理类，然后重写委托类的方法，重新实现逻辑，完成代理的逻辑。</p>
<p>代理类是委托类的子类（有点cglib动态代理的味道）</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><strong>代理类和委托类，都实现同一个接口，代理类依赖委托类（代理类注入委托类）</strong></p>
<p>接下来看一下静态代理的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 委托接口</div><div class="line">public interface IHelloService &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 定义接口方法</div><div class="line">     * @param userName</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    String sayHello(String userName);</div><div class="line"></div><div class="line">&#125;</div><div class="line">// 委托类实现</div><div class="line">public class HelloService implements IHelloService &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String sayHello(String userName) &#123;</div><div class="line">        System.out.println(&quot;helloService&quot; + userName);</div><div class="line">        return &quot;HelloService&quot; + userName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 代理类</div><div class="line">public class StaticProxyHello implements IHelloService &#123;</div><div class="line"></div><div class="line">    private IHelloService helloService = new HelloService();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String sayHello(String userName) &#123;</div><div class="line">        /** 代理对象可以在此处包装一下*/</div><div class="line">        System.out.println(&quot;代理对象包装礼盒...&quot;);</div><div class="line">        return helloService.sayHello(userName);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 测试静态代理类</div><div class="line">public class MainStatic &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        StaticProxyHello staticProxyHello = new StaticProxyHello();</div><div class="line">        staticProxyHello.sayHello(&quot;isole&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    可以看到，代理类和委托类，<strong>都实现共同的接口IHelloService</strong>。静态代理，实际上就是在代理类中，注入委托类，然后代理类可以实现一些额外的方法，然后真正的调用时。通过代理类去调用委托类。我们可以看待，代码的结构是固定的，在编译前就可以确定代理类有哪些方法。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200113095241291.png" alt="image-20200113095241291"></p>
<p>​    使用静态代理的缺点是：只适用委托方法少的情况下, 试想一下如果委托类有几百上千个方法, 岂不是很难受, 要在代理类中写一堆的代理方法。换句话说，我们有三个开发，每个人在调用委托类的方法之前，都会有自己的迁入逻辑补充，那么也就意味着，需要在StaticProxyHello代理类中，实现各自的方法，那么代理类中的代理方法就会疯狂增多，那么就会导致代理类很难管理。也就是说，<strong>我们想要按需在代理类中添加我们想要切入的逻辑，那么这个就是要动态的添加代理方法了。</strong></p>
<p>   ①代理类和被代理类实现了相同的接口，导致代码的重复，如果接口增加一个方法，那么除了被代理类需要实现这个方法外，代理类也要实现这个方法，增加了代码维护的难度。<br>   ②代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。比如上面的例子，只是对用户的业务功能（IUserService）进行代理，如果是商品（IItemService）的业务功能那就无法代理，需要去编写商品服务的代理类。</p>
<blockquote>
<p><strong>实现静态代理有四个步骤：</strong></p>
</blockquote>
<ul>
<li>定义业务接口</li>
<li>定义委托类并实现业务接口</li>
<li>定义代理类并实现业务接口，同时依赖委托类（委托类是代理类的一个成员变量）</li>
</ul>
<p>这个需求，就需要动态代理。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理类在程序运行时创建的代理方式被成为 <code>动态代理</code>。在了解动态代理之前, 我们先简回顾一下 JVM 的类加载机制中的加载阶段要做的三件事情 ( 附 Java 中的类加载器 )</p>
<ol>
<li>通过一个类的全名或其它途径来获取这个类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 Class 对象, 作为方法区中对这个类访问的入口。</li>
</ol>
<p>​    而我们要说的动态代理，主要就发生在第一个阶段, 这个阶段类的二进制字节流的来源可以有很多, 比如 zip 包、网络、<code>运行时计算生成</code>、其它文件生成 (JSP)、数据库获取。其中运行时计算生成就是我们所说的动态代理技术，在 Proxy 类中, 就是运用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流。所谓的动态代理就是想办法根据接口或者目标对象计算出<code>代理类</code>的字节码然后加载进 JVM 中。实际计算的情况会很复杂，我们借助一些诸如 <strong>JDK 动态代理实现、CGLIB 第三方库来完成</strong>。</p>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>在 Java 的动态代理中, 主要涉及 2 个类,<code>java.lang.reflect.Proxy</code>和<code>java.lang.reflect.InvocationHandler</code> 我们需要一个实现 InvocationHandler 接口的<strong>中间类</strong>, 这个接口只有一个方法 invoke 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">public interface InvocationHandler &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 调用处理</span></div><div class="line"><span class="comment">     * @param proxy 代理类对象</span></div><div class="line"><span class="comment">     * @param methon 标识具体调用的是代理类的哪个方法</span></div><div class="line"><span class="comment">     * @param args 代理类方法的参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args)</div><div class="line">        throws Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>实际上最关键的就是这个中间类，通过中间类，我们可以拦截委托类所有方法的调用，然后做一些额外的工作。</strong></p>
<p>​    <strong>我们对处理类（中间类生成的代理对象）中的所有方法的调用都会变成对 invoke 方法的调用，这样我们可以在 invoke 方法中添加统一的处理逻辑（也可以根据 method 参数判断是哪个方法）</strong>。<strong>中间类 (实现了 InvocationHandler 的类)</strong> 有一个<strong>委托类对象引用</strong>, 在 Invoke 方法中调用了委托类对象的相应方法，通过这种<strong>聚合的方式</strong>持有委托类对象引用，把外部对 invoke 的调用最终都转为对委托类对象的调用。</p>
<p>​    实际上，中间类与委托类构成了静态代理关系（他们的关系就是在中间类总注入委托类，然后调用，编译时即可确定关系），在这个关系中，中间类是代理类，委托类是委托类。然后代理类与中间类也构成一个静态代理关系，在这个关系中，中间类是委托类，代理类是代理类。也就是说，<strong>动态代理关系由两组静态代理关系组成，这就是动态代理的原理</strong>。</p>
<p>jdk的reflect实现动态代理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 委托类接口</span></div><div class="line">public interface IHelloService &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法1</span></div><div class="line"><span class="comment">     * @param userName</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="built_in">String</span> sayHello(<span class="built_in">String</span> userName);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法2</span></div><div class="line"><span class="comment">     * @param userName</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="built_in">String</span> sayByeBye(<span class="built_in">String</span> userName);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 委托类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> <span class="title">implements</span> <span class="title">IHelloService</span> </span>&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public <span class="built_in">String</span> sayHello(<span class="built_in">String</span> userName) &#123;</div><div class="line">        System.out.println(userName + <span class="string">" hello"</span>);</div><div class="line">        <span class="keyword">return</span> userName + <span class="string">" hello"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public <span class="built_in">String</span> sayByeBye(<span class="built_in">String</span> userName) &#123;</div><div class="line">        System.out.println(userName + <span class="string">" ByeBye"</span>);</div><div class="line">        <span class="keyword">return</span> userName + <span class="string">" ByeBye"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 中间类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JavaProxyInvocationHandler</span> <span class="title">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 中间类持有委托类对象的引用,这里会构成一种静态代理关系</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    private <span class="built_in">Object</span> obj ;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 有参构造器,传入委托类的对象</span></div><div class="line"><span class="comment">     * @param obj 委托类的对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public JavaProxyInvocationHandler(<span class="built_in">Object</span> obj)&#123;</div><div class="line">        <span class="keyword">this</span>.obj = obj;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 动态生成代理类对象,Proxy.newProxyInstance</span></div><div class="line"><span class="comment">     * @return 返回代理类的实例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public <span class="built_in">Object</span> newProxyInstance() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Proxy</span>.newProxyInstance(</div><div class="line">                <span class="comment">//指定代理对象的类加载器，然后委托类跟代理类由同一个类加载器加载</span></div><div class="line">                obj.getClass().getClassLoader(),</div><div class="line">                <span class="comment">//代理对象需要实现的接口，可以同时指定多个接口</span></div><div class="line">                obj.getClass().getInterfaces(),</div><div class="line">                <span class="comment">//方法调用的实际处理者，代理对象的方法调用都会转发到这里</span></div><div class="line">                <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param proxy 代理对象</span></div><div class="line"><span class="comment">     * @param method 代理方法</span></div><div class="line"><span class="comment">     * @param args 方法的参数</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     * @throws Throwable</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    @Override</div><div class="line">    public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args) throws Throwable &#123;</div><div class="line">        System.out.println(<span class="string">"invoke before"</span>);</div><div class="line">        <span class="built_in">Object</span> result = method.invoke(obj, args);</div><div class="line">        System.out.println(<span class="string">"invoke after"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 测试动态代理类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainJavaProxy</span> </span>&#123;</div><div class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</div><div class="line">        JavaProxyInvocationHandler proxyInvocationHandler = <span class="keyword">new</span> JavaProxyInvocationHandler(<span class="keyword">new</span> HelloService());</div><div class="line">        IHelloService helloService = (IHelloService) proxyInvocationHandler.newProxyInstance();</div><div class="line">        helloService.sayByeBye(<span class="string">"paopao"</span>);</div><div class="line">        helloService.sayHello(<span class="string">"yupao"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    在上面的测试动态代理类中, 我们调用 Proxy 类的 <strong>newProxyInstance 方法来获取一个代理类实例</strong>。这个代理类<strong>实现了我们指定的接口</strong>并且会把方法调用分发到<strong>指定的调用处理器*</strong>（也就是invocationhandler的invoke方法）。</p>
<p>​    首先通过 newProxyInstance 方法获取<strong>代理类的实例</strong>, 之后就可以通过这个代理类的实例调用<strong>代理类的方法</strong>，对代理类的方法调用<strong>都会调用中间类 (实现了 invocationHandle 的类) 的 invoke 方法</strong>，在 invoke 方法中我们调用委托类的对应方法，然后加上自己的处理逻辑。</p>
<p>​    java 动态代理最大的特点就是<strong>动态生成的代理类和委托类实现同一个接口</strong>。java 动态代理其实内部是<strong>通过反射机制实现的，也就是已知的一个对象，在运行的时候动态调用它的方法，并且调用的时候还可以加一些自己的逻辑在里面。</strong></p>
<blockquote>
<p><strong>Proxy.newProxyInstance 源码阅读。</strong></p>
</blockquote>
<p>上面说过, Proxy.newProxyInstance 通过反射机制用来动态生成代理类对象, 为接口创建一个代理类，这个代理类实现这个接口。具体源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">public <span class="keyword">static</span> <span class="built_in">Object</span> newProxyInstance(ClassLoader loader,</div><div class="line">                                          Class&lt;?&gt;[] interfaces,</div><div class="line">                                          InvocationHandler h)</div><div class="line">        throws IllegalArgumentException</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 检查空指针</span></div><div class="line">        Objects.requireNonNull(h);</div><div class="line">        <span class="comment">// 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象</span></div><div class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</div><div class="line">        <span class="comment">// 获取系统的安全接口,不为空的话需要验证是否允许访问这种关系的代理访问</span></div><div class="line">        final SecurityManager sm = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</div><div class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * 查找或生成代理类 Class,通过类加载器和接口，如果已经存在代理类，则直接返回</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * 通过构造器来创建实例</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</div><div class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//获取所有的构造器</span></div><div class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class="line">            final InvocationHandler ih = h;</div><div class="line">            <span class="comment">// 构造器不是public的话需要设置可以访问</span></div><div class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</div><div class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">                    public Void run() &#123;</div><div class="line">                        cons.setAccessible(<span class="literal">true</span>);</div><div class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 返回创建的代理类Class的实例对象</span></div><div class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;h&#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">InternalError</span>(e.toString(), e);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            Throwable t = e.getCause();</div><div class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">                <span class="keyword">throw</span> (RuntimeException) t;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">InternalError</span>(t.toString(), t);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">InternalError</span>(e.toString(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>接着分析一下 getProxyClass0（）方法</p>
<p>我们发现他会先从<strong>缓存中查找</strong>是否存在相应的<strong>代理类的class对象</strong>，有则直接返回，没有则新增。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Generate a proxy class.  Must call the checkProxyAccess method</div><div class="line"> * to perform permission checks before calling this.</div><div class="line"> */</div><div class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</div><div class="line">                                       Class&lt;?&gt;... interfaces) &#123;</div><div class="line">    if (interfaces.length &gt; 65535) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // If the proxy class defined by the given loader implementing</div><div class="line">    // the given interfaces exists, this will simply return the cached copy;</div><div class="line">    // otherwise, it will create the proxy class via the ProxyClassFactory</div><div class="line">    //意思是：如果代理类被指定的类加载器loader定义了，并实现了给定的接口interfaces，</div><div class="line">    //那么就返回缓存的代理类对象，否则使用ProxyClassFactory创建代理类。</div><div class="line">    return proxyClassCache.get(loader, interfaces);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>超详细源码分析：<a href="https://www.jianshu.com/p/269afd0a52e6" target="_blank" rel="external">https://www.jianshu.com/p/269afd0a52e6</a></p>
<h4 id="为什么实现同一个接口是实现jdk动态代理的基础"><a href="#为什么实现同一个接口是实现jdk动态代理的基础" class="headerlink" title="为什么实现同一个接口是实现jdk动态代理的基础"></a>为什么实现同一个接口是实现jdk动态代理的基础</h4><p>为什么jdk动态代理就不能通过继承某个类的方式实现呢？</p>
<p>我们可以通过查看jdk动态动态代理方式生成的代理类，我们发现，代理类他最终的结构是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public final class ProxyClass extend Proxy implements  IHelloService</div><div class="line"></div><div class="line">可以看到生成的代理类已经继承了 Proxy类，那么java只支持单继承，那么所以就不能通过继承的方式生成代理类。</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p>​    我们发现，实际上，委托类和代理类本质上都是实现了同一个接口，<strong>实现同一个接口是实现动态代理的基础</strong>。jdk的动态代理，实际上是两组静态代理实现。代理类和中间类是静态代理关系，中间类和委托类是静态代理关系。</p>
<p>​    而且动态代理跟静态代理的区别，在于<strong>，我们不用实现一个静态的代理类（例如静态代理的StaticProxyHello），我们通过一个中间类（invocationhandler是实现类）生成代理类。然后我们可以定制自己在调用委托类方法之前，切入自己的逻辑。</strong> 也就是说，<strong>代理类是运行的时候才生成的。故叫动态代理</strong></p>
<p>​    同时我们注意源码的<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</code> 你会发现，它是会先查找缓存中是否存在代理类Class对象，如果存在则不新增。<strong>这样的好处就是，不会在jvm的metaspace区占满内存。</strong></p>
<p><strong>itss项目和固定资产项目，使用到了，动态反射，实现了资产的导入。</strong></p>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>​    JDK 动态代理依赖接口实现，而当我们只有类没有接口的时候就需要使用另一种动态代理技术 CGLIB 动态代理。首先 CGLIB 动态代理是第三方框架实现的，在 maven 工程中我们需要引入 cglib 的包, 如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;cglib&lt;<span class="regexp">/groupId&gt;</span></div><div class="line"><span class="regexp">    &lt;artifactId&gt;cglib&lt;/</span>artifactId&gt;</div><div class="line">    &lt;version&gt;<span class="number">2.2</span>&lt;<span class="regexp">/version&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>dependency&gt;</div></pre></td></tr></table></figure>
<p>​    CGLIB 代理是针对类来实现代理的，原理是对指定的委托类生成一个子类并重写其中业务方法来实现代理。代理类对象是由 Enhancer 类创建的。CGLIB 创建动态代理类的模式是:</p>
<ol>
<li>查找目标类上的所有非 final 的 public 类型的方法 (final 的不能被重写)</li>
<li>将这些方法的定义转成字节码</li>
<li>将组成的字节码转换成相应的代理的 Class 对象然后通过反射获得代理类的实例对象</li>
<li>实现 MethodInterceptor 接口, 用来处理对代理类上所有方法的请求</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 委托类,是一个简单类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CglibHelloClass</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法1</span></div><div class="line"><span class="comment">     * @param userName</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public <span class="built_in">String</span> sayHello(<span class="built_in">String</span> userName)&#123;</div><div class="line">        System.out.println(<span class="string">"目标对象的方法执行了"</span>);</div><div class="line">        <span class="keyword">return</span> userName + <span class="string">" sayHello"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public <span class="built_in">String</span> sayByeBye(<span class="built_in">String</span> userName)&#123;</div><div class="line">        System.out.println(<span class="string">"目标对象的方法执行了"</span>);</div><div class="line">        <span class="keyword">return</span> userName + <span class="string">" sayByeBye"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * CglibInterceptor 用于对方法调用拦截以及回调</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CglibInterceptor</span> <span class="title">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * CGLIB 增强类对象，代理类对象是由 Enhancer 类创建的，</span></div><div class="line"><span class="comment">     * Enhancer 是 CGLIB 的字节码增强器，可以很方便的对类进行拓展</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    private Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param obj  被代理的对象</span></div><div class="line"><span class="comment">     * @param method 代理的方法</span></div><div class="line"><span class="comment">     * @param args 方法的参数</span></div><div class="line"><span class="comment">     * @param proxy CGLIB方法代理对象</span></div><div class="line"><span class="comment">     * @return  cglib生成用来代替Method对象的一个对象，使用MethodProxy比调用JDK自身的Method直接执行方法效率会有提升</span></div><div class="line"><span class="comment">     * @throws Throwable</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    @Override</div><div class="line">    public <span class="built_in">Object</span> intercept(<span class="built_in">Object</span> obj, Method method, <span class="built_in">Object</span>[] args, MethodProxy proxy) throws Throwable &#123;</div><div class="line">        System.out.println(<span class="string">"方法调用之前"</span>);</div><div class="line">        <span class="built_in">Object</span> o = proxy.invokeSuper(obj, args);</div><div class="line">        System.out.println(<span class="string">"方法调用之后"</span>);</div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用动态代理创建一个代理对象</span></div><div class="line"><span class="comment">     * @param c</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public  <span class="built_in">Object</span> newProxyInstance(Class&lt;?&gt; c) &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 设置产生的代理对象的父类,增强类型</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        enhancer.setSuperclass(c);</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 定义代理逻辑对象为当前对象，要求当前对象实现 MethodInterceptor 接口</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        enhancer.setCallback(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 使用默认无参数的构造函数创建目标对象,这是一个前提,被代理的类要提供无参构造方法</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">return</span> enhancer.create();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainCglibProxy</span> </span>&#123;</div><div class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</div><div class="line">        CglibInterceptor cglibProxy = <span class="keyword">new</span> CglibInterceptor();</div><div class="line">        CglibHelloClass cglibHelloClass = (CglibHelloClass) cglibProxy.newProxyInstance(CglibHelloClass.class);</div><div class="line">        cglibHelloClass.sayHello(<span class="string">"isole"</span>);</div><div class="line">        cglibHelloClass.sayByeBye(<span class="string">"sss"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    对于需要被代理的类，它只是动态生成一个子类以覆盖非 final 的方法，同时绑定钩子回调自定义的拦截器。值得说的是，它比 JDK 动态代理还要快。值得注意的是，<strong>我们传入目标类作为代理的父类</strong>。</p>
<p>​    <strong>不同于 JDK 动态代理，我们不能使用目标对象来创建代理（我们是通过接口来实现代理类）。目标对象只能被 CGLIB 创建。</strong></p>
<p>​    在例子中，默认的无参构造方法被使用来创建目标对象。</p>
<p>​    <strong>可以看到使用CGLIB实现动态代理，少实现了一个类，那就是IHelloService。因为CGLIB实现的代理类的父类就是委托类。</strong></p>
<p>​    </p>
<p><strong>使用cglib要注意，开启使用缓存标志，否则，就会导致，因为动态生成过多的Class对象，从而挤爆永久代（metaspace）</strong></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>​    静态代理比较容易理解, 需要被代理的类和代理类实现自同一个接口, 然后在代理类中调用真正实现类, 并且静态代理的关系在编译期间就已经确定了。</p>
<p>​    而动态代理的关系是在运行期间确定的。静态代理实现简单，适合于代理类较少且确定的情况，而动态代理则给我们提供了更大的灵活性。</p>
<p>​    JDK 动态代理所用到的代理类在程序调用到代理类对象时才由 JVM 真正创建，JVM 根据传进来的 业务实现类对象 以及 方法名 ，动态地创建了一个代理类的 class 文件并被字节码引擎执行，然后通过该代理类对象进行方法调用。我们需要做的，只需指定代理类的预处理、调用后操作即可。</p>
<p>​    <strong>静态代理和动态代理都是基于接口实现的</strong>, 而对于那些<strong>没有提供接口只是提供了实现类</strong>的而言, 就<strong>只能选择 CGLIB 动态代理</strong>了</p>
<p><strong>JDK 动态代理和 CGLIB 动态代理的区别</strong></p>
<ul>
<li><p>JDK 动态代理基于 Java 反射机制实现, 必须要实现了接口的业务类才能用这种方法生成代理对象。</p>
</li>
<li><p>CGLIB 动态代理基于 ASM 框架通过生成业务类的子类来实现。</p>
</li>
<li><p><strong>JDK 动态代理的优势是最小化依赖关系，但是需要定义一个公有的接口（IHelloService）</strong>，减少依赖意味着简化开发和维护并且有 JDK 自身支持。还可以平滑进行 JDK 版本升级，代码实现简单。</p>
<p>基于 CGLIB 框架的优势是<strong>无须实现接口</strong>，达到代理类无侵入，我们只需操作我们关系的类，不必为其它相关类增加工作量，性能比较高。</p>
</li>
</ul>
<p><strong>描述代理的几种实现方式? 分别说出优缺点?</strong></p>
<p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK 动态代理” 和 “CGLIB 动态代理” 实现。</p>
<p><strong>静态代理</strong>：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object.</p>
<ul>
<li>优点：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li>
<li>缺点：不同的接口要有不同的代理类实现，会很冗余</li>
</ul>
<p><strong>JDK 动态代理</strong>： 为了解决静态代理中，生成大量的代理类造成的冗余； JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，</p>
<p>jdk 的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象 jdk 动态代理之所以只能代理接口是因为代理类本身已经 extends 了 Proxy，而 java 是不允许多重继承的，但是允许实现多个接口</p>
<ul>
<li>优点：解决了静态代理中冗余的代理实现类问题。</li>
<li>缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</li>
</ul>
<p><strong>CGLIB 代理：</strong> 由于 <strong>JDK 动态代理限制</strong>了<strong>只能基于接口设计</strong>，而对于没有接口的情况，JDK 方式解决不了； CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。 实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。</p>
<p>但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以<strong>对于单例的对象</strong>，因为无需频繁创建对象，<strong>用 CGLib 合适</strong>，反之，如果<strong>需要创建大量对象</strong>，<strong>使用 JDK 方式要更为合适</strong>一些。 同时，<strong>由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</strong></p>
<p>优点：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</p>
<p> 缺点：技术实现相对难理解些。</p>
<p>总而言之，<strong>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。</strong>  但是使用CGLIB要非常注意，因为</p>
<h2 id="为什么面试会问？"><a href="#为什么面试会问？" class="headerlink" title="为什么面试会问？"></a>为什么面试会问？</h2><p>从考察知识点的角度，这道题涉及的知识点比较庞杂，所以面试官能够扩展或者深挖的内容非常多，比如：</p>
<ul>
<li>考察你对反射机制的了解和掌握程度。</li>
<li>动态代理解决了什么问题，在你业务系统中的应用场景是什么？</li>
<li>JDK 动态代理在设计和实现上与 cglib 等方式有什么不同，进而如何取舍？</li>
</ul>
<h2 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h2><p>我们知道JDK生成代理类的方式，最终实现是是通过，反射的机制实现的，那么什么是反射呢？</p>
<p><strong>反射目的就是为了程序在运行过程中动态创建某个类。</strong></p>
<blockquote>
<p><strong>首先要知道Class类</strong></p>
</blockquote>
<p>​    对象照镜子后可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。</p>
<p>Class 对象只能由系统建立对象（不能自己new），<strong>在jvm加载字节码文件到元空间（永久代），就会自动创建Class对象。</strong></p>
<p>一个类在 JVM 中只会有一个Class实例 （<strong>类加载机制，双亲委任机制保证了字节码文件的唯一性</strong>）</p>
<p>每个类的实例都会记得自己是由哪个 Class 实例所生成 。</p>
<p>​    <strong>所以我们都是通过Class类获取某个对象的，已经定义方法，成员变量，构造函数等等，然后在运行过程中动态执行某个方法。</strong></p>
<p>获取一个对象的Class对象的方式有三种。</p>
<pre><code>1.通过对象的getClass方法获取
  Student stu1 = new Student();/
  Class class = stu1.getClass（）；
2. 通过类的class属性获取，该方法最为安全可靠，程序性能更高
  Class class = Student.class（）

3，通过Class对象的forName静态方法获取
   但是可能会抛出ClassNotFoundException异常
  Class class = Class.forName（&quot;www.kingge.top.Student&quot;）
</code></pre><p>​    </p>
<p>​    三种方式常用第三种，第一种对象都有了还要反射干什么(<strong>使用反射的目的是为了创建对象</strong>)。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p>
<blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p>反射的出现，目的就是让程序在运行过程中，动态生成我们所需要的类。</p>
<p>反射的实现，就是通过Class类，Class类是唯一的，因为通过双亲委任机制可以得知。</p>
<h1 id="Java-hashCode-和-equals-的若干问题解答"><a href="#Java-hashCode-和-equals-的若干问题解答" class="headerlink" title="Java hashCode() 和 equals()的若干问题解答"></a>Java hashCode() 和 equals()的若干问题解答</h1><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="external"></a></p>
<h1 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h1><p><a href="http://cmsblogs.com/?p=15717" target="_blank" rel="external">http://cmsblogs.com/?p=15717</a></p>
<p>这两个接口，都可以用来实现对象的排序。也就是说他们两个的功能实际上就是一样的。所以不要混着使用。也就是说，一个类最后不要同时实现这两个接口。</p>
<p>那么，他们的使用规则一般是：一个类，一般是通过实现Comparable接口实现排序（作为内部排序），但是当我们在不想修改类的代码结构的同时又想改变内部排序，这个时候可以使用Comparator接口实现重写排序逻辑（作为外部排序）。这样在排序的时候，默认的内部排序，就会被外部排序逻辑覆盖。</p>
<h1 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h1><p>​    JMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念 ，并不真实存在，它描述的是一组规则或规范通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式。</p>
<p>JMM关于同步规定:</p>
<p>1.线程解锁前,必须把共享变量的值刷新回主内存<br>2.线程加锁前,必须读取主内存的最新值到自己的工作内存<br>3.加锁解锁是同一把锁</p>
<p>​    由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间，实际上就是java虚拟机栈)，工作内存是每个线程的私有数据区域（<strong>java虚拟机栈</strong>），而Java内存模型中规定<strong>所有变量都存储在主内存</strong>，<strong>主内存是共享内存区域，所有线程都可访问</strong>，<strong>但线程对变量的操作(读取赋值等)必须在工作内存中进行，所以线程要将操作的变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存，不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝</strong>，因此不同的线程无法访问对方的工作内存,此案成间的通讯(传值) 必须通过主内存来完成,其简要访问过程如下图:</p>
<p> <img src="/2020/03/09/java基础核心技术/image-20200120163400968.png" alt="image-20200120163400968"></p>
<p>这个就是并发问题出现的根源之一，数据可见性。</p>
<p><strong>也就是说：JMM的存在就是为了保证，原子性，可见性，有序性。也即是，保证多线程访问资源的安全性</strong></p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a><strong>Volatile</strong></h1><p> <strong>首先声明，他不是一种锁。</strong>  <strong>它会确保我们对于某个变量的读取和写入，都一定会同步到主内存里，而不是从 Cache 里面读取（也就是我们通俗的说禁用缓存）</strong>。</p>
<p>volatile是java虚拟机提供的的<strong>轻量级的同步机制</strong>，它能够<strong>保证可见性和禁止指令重排序</strong>。但是<strong>不能够保证原子性（那就意味着，会产生线程不安全问题）</strong></p>
<blockquote>
<p><strong>什么叫可见性</strong></p>
</blockquote>
<p>一个线程对于共享资源的修改，对于另一个线程是可见的。也就是说，我修改后的值，你是可以看到的。<strong>也就意味着，假设另一个线程改完了，那么会通知到另一个线程。</strong></p>
<blockquote>
<p><strong>什么叫原子性</strong></p>
</blockquote>
<p>也就是一个线程操作某个逻辑的时候，它能够保证在执行的过程中，不会发生线程切换，<strong>要么都完成，要么都失败</strong>，而且我们能够所说的原子性是针对于CPU指令而言的（高级语言里一条语句往往需要多条 CPU 指令完成）。例如我们在执行，自增操作的时候，count+=1；<strong>你以为这是一个原子操作，就是执行一条指令而已，其实不是</strong>，因为他至少会分成三个cpu指令去执行。</p>
<ul>
<li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li>
<li>指令 2：之后，在寄存器中执行 +1 操作；</li>
<li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>
</ul>
<p>​    <strong>操作系统做任务切换</strong>，可以发生在任何一条<strong>CPU 指令</strong>执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200117091622074.png" alt="image-20200117091622074"></p>
<blockquote>
<p><strong>指令重排序</strong></p>
</blockquote>
<p>参见《java并发章节》</p>
<h2 id="那么volatile是怎么保证可见性（数据一致性）呢？"><a href="#那么volatile是怎么保证可见性（数据一致性）呢？" class="headerlink" title="那么volatile是怎么保证可见性（数据一致性）呢？"></a>那么volatile是怎么保证可见性（数据一致性）呢？</h2><p>首先查看下面例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class VolatileTets &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ShareData shareData = new ShareData();//主内存中，初始化了ShareData对象，并初始化了number值为0</div><div class="line">		</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println( Thread.currentThread().getName() +&quot;  开始执行&quot; );</div><div class="line">				try &#123;</div><div class="line">					TimeUnit.SECONDS.sleep(3);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				shareData.addNumber();</div><div class="line">				System.out.println( Thread.currentThread().getName() +&quot;  更新完毕 number的值是：&quot;+ shareData.number );</div><div class="line">			&#125;</div><div class="line">		&#125;, &quot;a&quot;).start();</div><div class="line">		</div><div class="line">		</div><div class="line">		while(shareData.number == 0) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println( Thread.currentThread().getName() + &quot; main线程执行结束  &quot;  );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ShareData&#123;</div><div class="line">	public int number = 0;</div><div class="line">	public void addNumber() &#123;</div><div class="line">		this.number = 60;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道上诉代码，一共创建了两个线程，一个是main线程，一个是a线程。</p>
<p>那么为什么在a线程内部停了三秒呢？目的就是，让a线程跟main线程，获取的共享资源的number都是一样的（也就是0），拷贝到自己的java虚拟机栈的number都是0。这样就能够保证，main线程，执行成功while循环，然后main线程不会结束。这样才能够验证volatile的可见性。</p>
<p>上诉代码，的执行结果，我们其实也能够看的出来，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a线程  开始执行</div><div class="line">a线程  更新完毕 number的值是：60</div></pre></td></tr></table></figure>
<p><strong>main线程，永久挂在那里，a线程执行完毕。</strong> 也就意味着，a线程虽然修改了number 的值，<strong>同时把主内存的number修改为60</strong>，但是对于main线程而言是不可见的，没有通知main线程，main线程认为还是0。否则，main线程应该结束while循环。</p>
<p><strong>那么我们说volatile可以解决可见性，那么是真是假呢？</strong></p>
<p>我们把 <code>public int number = 0;</code> 修改为<code>public volatile int number = 0;</code>，再次运行代码。</p>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a线程  开始执行</div><div class="line">a线程  更新完毕 number的值是：60</div><div class="line">main main线程执行结束</div></pre></td></tr></table></figure>
<p>我们惊喜的发现，main线程竟然退出了！！！，那也就意味着，a线程修改完number后，写入到主内存，然后成功通知了挂起来的main线程。</p>
<p><strong>所以，到这里，我们就成功的验证了volatile的可见性机制。</strong></p>
<h2 id="验证volatile不支持原子性"><a href="#验证volatile不支持原子性" class="headerlink" title="验证volatile不支持原子性"></a>验证volatile不支持原子性</h2><p>验证例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class VolatileTets &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ShareData shareData = new ShareData();</div><div class="line">		for (int i = 0; i &lt; 20000; i++) &#123;</div><div class="line">			new Thread(new Runnable() &#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					shareData.add();</div><div class="line">				&#125;</div><div class="line">			&#125;, String.valueOf(i)).start();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Thread.yield();</div><div class="line">		System.out.println( shareData.number );</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ShareData&#123;</div><div class="line">	</div><div class="line">	public volatile int number = 0;</div><div class="line"></div><div class="line">	public void add() &#123;</div><div class="line">		this.number++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会发现，输出的值，都是随机的，并不是我们预期的20000，<strong>所以volatile并不能保证原子性。</strong></p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p><strong>解决方案：使用synchronized内部锁或者Lock显示锁</strong>，但是加锁又太重，杀鸡用牛刀，我们可以考虑使用AtomicInteger来实现number++的问题。</p>
<h2 id="volatile怎么禁止指令重排序？"><a href="#volatile怎么禁止指令重排序？" class="headerlink" title="volatile怎么禁止指令重排序？"></a>volatile怎么禁止指令重排序？</h2><blockquote>
<p><strong>什么叫指令重排序</strong></p>
</blockquote>
<p>计算机在执行程序时,为了提高性能,编译器和处理器常常会做指令重排,一把分为以下3种：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200121094835443.png" alt="image-20200121094835443"></p>
<p>单线程环境里面能确保程序最终执行结果和代码顺序执行的结果一致。</p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程使用的变量能否保持一致性是无法确定的,结果无法预测。</p>
<p>但是处理器在进行重新排序是必须要<strong>考虑指令之间的数据依赖性</strong>。</p>
<blockquote>
<p><strong>指令重排例子1</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void mySort()&#123;</div><div class="line">    int x=11;//语句1</div><div class="line">    int y=12;//语句2</div><div class="line">    x=x+5;//语句3</div><div class="line">    y=x*x;//语句4</div><div class="line">&#125;</div><div class="line">例如我们从编程角度看上面代码，以为执行顺序是1234。</div><div class="line">但是，可能不是，可能会发生指令重排。例如，重拍后是按照 2134、1324这样的执行顺序。</div><div class="line"></div><div class="line">问题:</div><div class="line">请问语句4 可以重排后变成第一条码?</div><div class="line">存在数据的依赖性，没办法排到第一个，因为要执行语句4，需要依赖 y或者x，放到第一条，这个时候，y或者x还没有初始化。那么很明显语句四肯定执行失败，所以语句四不可能被重排到第一个</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>指令重排序例子2</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CP &#123;</div><div class="line">	</div><div class="line">	int a = 0;</div><div class="line">	boolean flag = false;</div><div class="line">	public void initValue() &#123;</div><div class="line">		a = 1;//1</div><div class="line">		flag = true;//2</div><div class="line">	&#125;</div><div class="line">	public void updateValue() &#123;</div><div class="line">		if(flag) &#123;//3</div><div class="line">			a = a + 5;//4</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个线程，分别调用initValue、updateValue这两个方法。</p>
<p>按照代码的顺序读，我们知道，当线程1调用完成initValue后，接着调用updateValue，那么代码3判断是成功的，然后a的最终值是6。</p>
<p>我们知道initValue方法的flag和a变量是<strong>没有依赖关系</strong>的，<strong>所以可能发生了指令重排</strong>，代码1和代码2的位置调换</p>
<pre><code>public void initValue() {
    flag = true;//1
    a = 1;//2
}
</code></pre><p>那么假设线程1执行完成代码1后，<strong>进行了线程切换</strong>，线程2获得了执行机会，线程2去执行updateValue，那么if判断通过，这个时候，a的值是0，那么执行a+5，那么a最终结果是5</p>
<p>很明显跟上面的结果是6不相等。所以就会产生线程不安全问题。</p>
<p><strong>解决方案，就是给flag，添加volatile修饰符，这样就能够通过给flag变量添加内存屏障的方式，禁止，指令重排。</strong></p>
<h2 id="你在哪些地方用到过volatile"><a href="#你在哪些地方用到过volatile" class="headerlink" title="你在哪些地方用到过volatile"></a>你在哪些地方用到过volatile</h2><p>1.首先我们知道 Atomic包下的类，大量使用到了volatile，例如AtomicInteger，AtomicReference等等。</p>
<p>2.单例模式DCL代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class SingletonDemo &#123;</div><div class="line"></div><div class="line">    private static volatile SingletonDemo instance=null;</div><div class="line">    private SingletonDemo()&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot;\t 构造方法&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 双重检测机制</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static SingletonDemo getInstance()&#123;</div><div class="line">        if(instance==null)&#123;</div><div class="line">            synchronized (SingletonDemo.class)&#123;</div><div class="line">                if(instance==null)&#123;</div><div class="line">                    instance=new SingletonDemo();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        for (int i = 1; i &lt;=10; i++) &#123;</div><div class="line">            new Thread(() -&gt;&#123;</div><div class="line">                SingletonDemo.getInstance();</div><div class="line">            &#125;,String.valueOf(i)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是最终的实现代码，可以解决多线程下单例请求问题。</p>
<p>但是你可能有个问题，为什么需要双重判断机制？<strong>问题一</strong></p>
<p>假设getInstance方法修改为：</p>
<pre><code>public static SingletonDemo getInstance(){
        synchronized (SingletonDemo.class){
            if(instance==null){
                instance=new SingletonDemo();
            }
        }
    return instance;
}
</code></pre><p>​    你觉得，有什么问题？那就是可能会引发多余的请求加锁操作，假设instance实例已经初始化了，但是每一次线程访问getInstance方法的时候，都会请求锁，这样就会耗费时间。所以我们需要在最外一层再包裹一个if判断。如果已经初始化，那么就直接返回。</p>
<p>那为什么最里层也要判断一下呢？<strong>问题二</strong></p>
<p>假设剔除最里层的if判断，最终代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static SingletonDemo getInstance()&#123;</div><div class="line">      if(instance==null)&#123;//代码1</div><div class="line">               //代码2</div><div class="line">          synchronized (SingletonDemo.class)&#123;//代码3</div><div class="line">                  instance=new SingletonDemo();//代码4</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      return instance;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>那么这样会有什么问题呢？</p>
<p>假设有 三个线程同时执行到了，代码二这个位置，那么开始执行代码3，只有一个线程能获取锁，然后实例化instance，然后返回instance，当前线程执行结束。这个时候，其他两个线程获得执行机会，也会执行到代码3，获取锁，然后又<strong>再次实例化instance</strong>。这个问题就出来，instance就不再是单例了。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>DCL(双端检锁) 机制不一定线程安全,原因是有指令重排的存在,加入volatile可以禁止指令重排。</p>
<p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 <code>instance == null</code> ，于是同时对 SingletonDemo.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 SingletonDemo实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 <code>instance == null</code> 时会发现，已经创建过 SingletonDemo实例了，所以线程 B 不会再创建一个 SingletonDemo实例。</p>
<p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p>
<ol>
<li>分配一块内存 M；</li>
<li>在内存 M 上初始化 SingletonDemo 对象；</li>
<li>然后 M 的地址赋值给 instance 变量。</li>
</ol>
<p>因为第2、第3步骤没有什么关系（<strong>没有相互依赖</strong>），那么是可以调换顺序的</p>
<p>但是实际上优化后的执行路径却是这样的：</p>
<ol>
<li>分配一块内存 M；</li>
<li>将 M 的地址赋值给 instance 变量；</li>
<li>最后在内存 M 上初始化 SingletonDemo对象。</li>
</ol>
<p>​    优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 <code>instance != null</code> ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就<strong>可能触发空指针异常。</strong></p>
<p><img src="/2020/03/09/java基础核心技术/image-20191218151354613.png" alt="image-20191218151354613"></p>
<ul>
<li><p>线程A进入第二个判空条件，进行初始化时，发生了时间片切换，即使没有释放锁，线程B刚要进入第一个判空条件时，发现条件不成立，直接返回instance引用，不用去获取锁。<strong>如果对instance进行volatile语义声明，就可以禁止指令重排序，避免该情况发生</strong>。</p>
<p>对于CPU缓存和内存的疑问，CPU缓存不存在于内存中的，它是一块比内存更小、读写速度更快的芯片，至于什么时候把数据从缓存写到内存，没有固定的时间，同样地，对于有volatile语义声明的变量，线程A执行完后会<strong>强制</strong>将值刷新到内存中，线程B进行相关操作时会强制重新把内存中的内容写入到自己的缓存，这就涉及到了volatile的写入屏障问题，当然也就是所谓<strong>happen-before问题</strong>。</p>
</li>
</ul>
<p>好的总结文档：<a href="https://dzone.com/articles/java-volatile-keyword-0" target="_blank" rel="external">https://dzone.com/articles/java-volatile-keyword-0</a></p>
<h2 id="MESI-cpu缓存一致性协议！！！重要！！！！保证了可见性"><a href="#MESI-cpu缓存一致性协议！！！重要！！！！保证了可见性" class="headerlink" title="MESI  cpu缓存一致性协议！！！重要！！！！保证了可见性"></a>MESI  cpu缓存一致性协议！！！重要！！！！保证了可见性</h2><p>MESI协议是一种基于无效的缓存一致性协议，他是基于硬件级别的优化</p>
<p>什么是基于无效呢？<br>    首先讲一下CPU和缓存的关系。计算机在数据处理或信号控制的时候，常与内存进行数据访问，但是内存和CPU的速度差别很大，所以会造成CPU资源浪费问题，为了解决两者的速度不匹配，所以在两者之间加了L1、L2、L3等缓存。在多核计算机中有多个CPU，每个CPU都有自己的缓存，所以就会造成缓存的数据不一致问题。<br>在早期解决缓存不一致是对<strong>总线使用LOCK（I/O总线）#锁</strong>，使得CPU访问某个变量的时候，其他CPU无法访问。但是这种<strong>效率很低</strong>。</p>
<p>MESI的主要思想：<strong>当CPU写数据时，如果该变量是共享数据，给其他CPU发送信号，使得其他的CPU中的该变量的缓存行无效。</strong></p>
<p>执行写操作的时候有两种策略，一种是write-back caches，另一种是write-through caches。<br>MESI支持write-back。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Write-through: write is done synchronously both to the cache and to the backing store.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Write-back (also called write-behind): initially, writing is done only to the cache. The write to the backing store is postponed until the modified content is about to be replaced by another cache block.</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>Write through就是直接写回主存</strong></p>
</blockquote>
<p><img src="/2020/03/09/java基础核心技术/writethrouth.png" style="zoom:30%;"></p>
<p>​    最简单的一种写入策略，叫作写直达（Write-Through）。在这个策略里，每一次数据都要写入到主内存里面。在写直达的策略里面，写入前，我们会先去判断数据是否已经在 Cache 里面了。如果数据已经在 Cache 里面了，我们先把数据写入更新到 Cache 里面，再写入到主内存里面；如果数据不在 Cache 里，我们就只更新主内存。</p>
<p>​    写直达的这个策略很直观，但是问题也很明显，那就是这个策略很慢。无论数据是不是在 Cache 里面，我们都需要把数据写到主内存里面。这个方式就有点儿像我们上面用 volatile 关键字，始终都要把数据同步到主内存里面。</p>
<blockquote>
<p><strong>Write back就是先标记不写回，等到使用的时候再写回主存。</strong></p>
</blockquote>
<p><img src="/2020/03/09/java基础核心技术/writeback.png" style="zoom:33%;"></p>
<p>这个时候，我们就想了，既然我们去读数据也是默认从 Cache 里面加载，能否不用把所有的写入都同步到主内存里呢？只写入 CPU Cache 里面是不是可以？</p>
<p>当然是可以的。在 CPU Cache 的写入策略里，还有一种策略就叫作写回（Write-Back）。这个策略里，我们不再是每次都把数据写入到主内存，而是只写到 CPU Cache 里。只有当 CPU Cache 里面的数据要被“替换”的时候，我们才把数据写入到主内存里面去。</p>
<p>写回策略的过程是这样的：如果发现我们要写入的数据，就在 CPU Cache 里面，那么我们就只是更新 CPU Cache 里面的数据。同时，我们会标记 CPU Cache 里的这个 Block 是脏（Dirty）的。所谓脏的，就是指这个时候，我们的 CPU Cache 里面的这个 Block 的数据，和主内存是不一致的。</p>
<p>如果我们发现，我们要写入的数据所对应的 Cache Block 里，放的是别的内存地址的数据，那么我们就要看一看，那个 Cache Block 里面的数据有没有被标记成脏的。如果是脏的话，我们要先把这个 Cache Block 里面的数据，写入到主内存里面。然后，再把当前要写入的数据，写入到 Cache 里，同时把 Cache Block 标记成脏的。如果 Block 里面的数据没有被标记成脏的，那么我们直接把数据写入到 Cache 里面，然后再把 Cache Block 标记成脏的就好了。</p>
<p>在用了写回这个策略之后，我们在加载内存数据到 Cache 里面的时候，也要多出一步同步脏 Cache 的动作。如果加载内存里面的数据到 Cache 的时候，发现 Cache Block 里面有脏标记，我们也要先把 Cache Block 里的数据写回到主内存，才能加载数据覆盖掉 Cache。</p>
<p>可以看到，在写回这个策略里，如果我们大量的操作，都能够命中缓存。那么大部分时间里，我们都不需要读写主内存，自然性能会比写直达的效果好很多。</p>
<p>​    然而，无论是写回还是写直达，其实都还没有解决我们在上面 volatile 程序示例中遇到的问题，也就是<strong>多个线程，或者是多个 CPU 核的缓存一致性的问题（就是如果两个线程都想写回内存，那么怎么解决这个问题）。这也就是我们在写入修改缓存后，需要解决的第二个问题。</strong></p>
<p>要解决这个问题，我们需要引入一个新的方法，叫作 MESI 协议。这是一个维护缓存一致性协议。这个协议不仅可以用在 CPU Cache 之间，也可以广泛用于各种需要使用缓存，同时缓存之间需要同步的场景下。</p>
<blockquote>
<p><strong>什么 叫缓存一致性问题</strong></p>
</blockquote>
<p>以下是多核cpu的cache缓存结构，一般而言多核 CPU 里的每一个 CPU 核，都有独立的属于自己的 L1 Cache 和 L2 Cache。多个 CPU 之间，只是共用 L3 Cache 和主内存。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318155625412.png" alt="image-20200318155625412"></p>
<p>那什么是缓存一致性呢？我们拿一个有两个核心的 CPU，来看一下。你可以看这里这张图，我们结合图来说。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318155816975.png" alt="image-20200318155816975"></p>
<p>​    比方说，iPhone 降价了，我们要把 iPhone 最新的价格更新到内存里。为了性能问题，它采用了上一讲我们说的写回策略，先把数据写入到 L2 Cache 里面，然后把 Cache Block 标记成脏的。这个时候，数据其实并没有被同步到 L3 Cache 或者主内存里。1 号核心希望在这个 Cache Block 要被交换出去的时候，数据才写入到主内存里。</p>
<p>​    如果我们的 CPU 只有 1 号核心这一个 CPU 核，那这其实是没有问题的。不过，我们旁边还有一个 2 号核心呢！这个时候，2 号核心尝试从内存里面去读取 iPhone 的价格，结果读到的是一个错误的价格。这是因为，iPhone 的价格刚刚被 1 号核心更新过。但是这个更新的信息，只出现在 1 号核心的 L2 Cache 里，而没有出现在 2 号核心的 L2 Cache 或者主内存里面。<strong>这个问题，就是所谓的缓存一致性问题，1 号核心和 2 号核心的缓存，在这个时候是不一致的。</strong></p>
<p>为了解决这个缓存不一致的问题，我们就需要有一种机制，来同步两个不同核心里面的缓存数据。那这样的机制需要满足什么条件呢？我觉得能够做到下面两点就是合理的。</p>
<p>第一点叫<strong>写传播</strong>（Write Propagation）。写传播是说，在一个 CPU 核心里，我们的 Cache 数据更新，必须能够传播到其他的对应节点的 Cache Line 里。</p>
<p>第二点叫<strong>事务的串行化</strong>（Transaction Serialization），事务串行化是说，我们在一个 CPU 核心里面的读取和写入，在其他的节点看起来，顺序是一样的。</p>
<p>第一点写传播很容易理解。既然我们数据写完了，自然要同步到其他 CPU 核的 Cache 里。但是第二点事务的串行化，可能没那么好理解，我这里仔细解释一下。</p>
<p>​    我们还拿刚才修改 iPhone 的价格来解释。这一次，我们找一个有 4 个核心的 CPU。1 号核心呢，先把 iPhone 的价格改成了 5000 块。差不多在同一个时间，2 号核心把 iPhone 的价格改成了 6000 块。这里两个修改，都会传播到 3 号核心和 4 号核心。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318160922524.png" alt="image-20200318160922524"></p>
<p><strong>我们发现，这样还是会导致，数据的不一致性。</strong></p>
<p>​    事实上，我们需要的是，<strong>从 1 号到 4 号核心</strong>，都能<strong>看到相同顺序的数据变化</strong>。比如说，都是先变成了 5000 块，再变成了 6000 块。这样，我们才能称之为实现了<strong>事务的串行化</strong>。</p>
<p>​    而在 CPU Cache 里做到事务串行化，需要做到两点，第一点是一个 CPU 核心对于数据的操作，需要同步通信给到其他 CPU 核心。第二点是，如果两个 CPU 核心里有同一个数据的 Cache，那么对于这个 Cache 数据的更新，需要有一个“锁”的概念。只有拿到了对应 Cache Block 的“锁”之后，才能进行对应的数据更新。接下来，我们就看看实现了这两个机制的 MESI 协议。</p>
<h3 id="总线嗅探机制和-MESI-协议"><a href="#总线嗅探机制和-MESI-协议" class="headerlink" title="总线嗅探机制和 MESI 协议"></a>总线嗅探机制和 MESI 协议</h3><p>​    要解决缓存一致性问题，首先要解决的是多个 CPU 核心之间的数据传播问题。最常见的一种解决方案呢，叫作<strong>总线嗅探</strong>（Bus Snooping）。这个名字听起来，你多半会很陌生，但是其实特很好理解。</p>
<p>​    这个策略，本质上就是把所有的读写请求都通过总线（Bus）广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。</p>
<p>​    总线本身就是一个特别适合广播进行数据传输的机制，所以总线嗅探这个办法也是我们日常使用的 Intel CPU 进行缓存一致性处理的解决方案。</p>
<p>​    <strong>基于总线嗅探机制，其实还可以分成很多种不同的缓存一致性协议</strong>。不过其中最常用的，就是今天我们要讲的 MESI 协议。和很多现代的 CPU 技术一样，MESI 协议也是在 Pentium 时代，被引入到 Intel CPU 中的。</p>
<p>​    <strong>MESI 协议</strong>，是一种叫作<strong>写失效</strong>（Write Invalidate）的协议。在写失效协议里，只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个 CPU 核心写入 Cache 之后，它会去广播一个“失效”请求告诉所有其他的 CPU 核心。其他的 CPU 核心，只是去判断自己是否也有一个“失效”版本的 Cache Block，然后把这个也标记成失效的就好了。</p>
<p>​    相对于写失效协议，还有一种叫作<strong>写广播</strong>（Write Broadcast）的协议。在那个协议里，一个写入请求广播到所有的 CPU 核心，同时更新各个核心里的 Cache。</p>
<p>​    写广播在实现上自然很简单，但是写广播需要占用更多的总线带宽。写失效只需要告诉其他的 CPU 核心，哪一个内存地址的缓存失效了，但是写广播还需要把对应的数据传输给其他 CPU 核心。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318162036721.png" alt="image-20200318162036721"></p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318162058308.png" alt="image-20200318162058308"></p>
<p>MESI 协议的由来呢，来自于我们对 Cache Line 的四个不同的标记，分别是：</p>
<ul>
<li>M：代表已修改（Modified）</li>
<li>E：代表独占（Exclusive）</li>
<li>S：代表共享（Shared）</li>
<li>I：代表已失效（Invalidated）</li>
</ul>
<p>我们先来看看“已修改”和“已失效”，这两个状态比较容易理解。所谓的“已修改”，就是我们上一讲所说的“脏”的 Cache Block。Cache Block 里面的内容我们已经更新过了，但是还没有写回到主内存里面。而所谓的“已失效“，自然是这个 Cache Block 里面的数据已经失效了，我们不可以相信这个 Cache Block 里面的数据。</p>
<p>然后，我们再来看“独占”和“共享”这两个状态。这就是 MESI 协议的精华所在了。无论是独占状态还是共享状态，缓存里面的数据都是“干净”的。这个“干净”，自然对应的是前面所说的“脏”的，也就是说，这个时候，<strong>Cache Block 里面的数据和主内存里面的数据是一致的。</strong></p>
<p>那么“独占”和“共享”这两个状态的差别在哪里呢？这个差别就在于，在独占状态下，对应的 Cache Line 只加载到了当前 CPU 核所拥有的 Cache 里。其他的 CPU 核，并没有加载对应的数据到自己的 Cache 里。这个时候，如果要向独占的 Cache Block 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。</p>
<p>在独占状态下的数据，如果收到了一个来自于总线的读取对应缓存的请求，它就会变成共享状态。这个共享状态是因为，这个时候，另外一个 CPU 核心，也把对应的 Cache Block，从内存里面加载到了自己的 Cache 里来。</p>
<p>而在共享状态下，因为同样的数据在多个 CPU 核心的 Cache 里都有。所以，当我们想要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的 Cache，都变成无效的状态，然后再更新当前 Cache 里面的数据。这个广播操作，一般叫作 RFO（Request For Ownership），<strong>也就是获取当前对应 Cache Block 数据的所有权</strong>。</p>
<p>​    有没有觉得这个操作有点儿像我们在多线程里面用到的读写锁。在共享状态下，大家都可以并行去读对应的数据。但是如果要写，我们就需要通过一个锁，获取当前写入位置的所有权。</p>
<p>​    整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把对应的状态机流转图放在了下面，你可以对照着<a href="https://zh.wikipedia.org/wiki/MESI协议" target="_blank" rel="external">Wikipedia 里面 MESI 的内容</a>，仔细研读一下。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318162644664.png" alt="image-20200318162644664"></p>
<p>好的文档：<a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="external">https://www.cnblogs.com/yanlong300/p/8986041.html</a></p>
<p>​                    <a href="https://www.jianshu.com/p/0e036fa7af2a" target="_blank" rel="external">https://www.jianshu.com/p/0e036fa7af2a</a></p>
<p>​                    <a href="https://www.cnblogs.com/ynyhl/p/12119690.html" target="_blank" rel="external">https://www.cnblogs.com/ynyhl/p/12119690.html</a> 不错</p>
<h2 id="面试中如果问到你对volatile的理解？"><a href="#面试中如果问到你对volatile的理解？" class="headerlink" title="面试中如果问到你对volatile的理解？"></a>面试中如果问到你对volatile的理解？</h2><p>那么首先你应该从内存模型，原子性，有序性，可见性的理解，然后才是volatile关键字的理解和他解决的问题。</p>
<p>，</p>
<h1 id="synchronized的对象头核心知识"><a href="#synchronized的对象头核心知识" class="headerlink" title="synchronized的对象头核心知识"></a>synchronized的对象头核心知识</h1><h2 id="synchronized-obj-到底锁的是什么-？-对象头"><a href="#synchronized-obj-到底锁的是什么-？-对象头" class="headerlink" title="synchronized(obj)到底锁的是什么 ？ - 对象头"></a>synchronized(obj)到底锁的是什么 ？ - 对象头</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (obj) &#123;</div><div class="line">	<span class="comment">///业务代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    synchronized到底锁的是整个业务代码块还是obj？</p>
<p>​    我们知道synchronized<strong>锁住的是obj对象</strong>，达到互斥的效果，<strong>那么在那里记录是那个线程锁住的呢？</strong>。而且synchronized是会锁升级的，<strong>那么在哪里记录这些锁的信息？哪里记录线程对obj对象上锁成功呢？</strong></p>
<p>​    <strong>举个例子，我们知道ReentrantLock的lock方法，是通过对state的cas操作标识是否上锁成功，state如果能从0设置成1，那么说明上锁成功，如果多次重入，那么state标识重入次数。</strong></p>
<p>​    <strong>我们发现单从这段代码<code>synchronized (obj)</code>，他并没有像lock 对象那样，有个成员属性state来做一些锁的标志和判断。而且synchronized 只是一个关键字，那么只有一种解释，那就是，加锁的信息，肯定是在obj对象里面保存着！！</strong></p>
<p>​    换句话说，我们的问题是：<strong>如果某个线程对obj对象加锁成功，那么他是怎么标记加锁成功的，到底修改了obj对象什么信息，来表示加锁成功？</strong></p>
<p>这里先说结论：<strong>加锁实际上是改变了对象的对象头！！</strong></p>
<h2 id="java对象的布局-计算对象大小"><a href="#java对象的布局-计算对象大小" class="headerlink" title="java对象的布局 - 计算对象大小"></a>java对象的布局 - 计算对象大小</h2><p>我们要了解对象头，那么首先首当其冲就要先了解一下对象的构成。首先我们可以确定，<strong>对象的属性</strong>肯定是构成对象的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span>  <span class="keyword">int</span> value;<span class="comment">//对象属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了对象属性之外，还有<strong>对象头</strong>和<strong>数据对齐</strong>两个模块。</p>
<p>也就是说对象是由：<strong>对象属性、对象头、数据对齐</strong>三个组件构成。</p>
<p>其中<strong>对象头是肯定存在的</strong>，但是<strong>对象属性和数据对齐却不一定存在</strong>。一个对象可以没有成员属性，这个我们是知道的，那么数据对齐是什么意思呢？我们首先要明确，java定义对象的大小时，规定，<strong>对象的字节大小必须是8的倍数</strong>。</p>
<p>​    <strong>那么数据对齐就是为了凑够8的倍数而来的。</strong>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span>  <span class="keyword">boolean</span> flag;<span class="comment">//1byte </span></div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;<span class="comment">//4个byte </span></div><div class="line">&#125;</div><div class="line"><span class="comment">//首先至于boolean到底占几个字节，java并没有明确规定，他说这个取决于jvm的实现，我这里假设是占1byte。</span></div></pre></td></tr></table></figure>
<p>​    那么上面student对象单从成员属性而言，一共是占了5个字节（<strong>这里先暂时不考虑对象头</strong>），那么很明显5不是8的倍数。所以需要<strong>补上3个字节</strong>，一共是8个字节，那么就是8的倍数。<strong>那么这里所说的补上3个字节，就是数据对齐模块的大小和作用。</strong></p>
<p>​    <strong>换言之，假设对象成员属性的大小本身就是8的倍数，那么数据对齐也就不存在了。</strong></p>
<p><strong>所以说，对象的布局中，至于对象头是固定存在的，其他两个是不一定存在。</strong></p>
<p><strong>也就是说，一个对象的大小，等于这三个组成的大小之和。</strong></p>
<blockquote>
<p><strong>怎么证明对象是由这三个部分组成？</strong></p>
</blockquote>
<p>接下来我们通过一个工具类来输出对象的信息，从而证明。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;0.10&lt;/version&gt;</div><div class="line">  &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>//计算对象大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span>  <span class="keyword">boolean</span> flag;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Obj obj  = <span class="keyword">new</span> Obj();</div><div class="line">        System.out.println( VM.current().details() );</div><div class="line">		System.out.println( ClassLayout.parseInstance(obj).toPrintable() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>Running 64-bit HotSpot VM.//<strong>此时表示是64位虚拟机上，因为32位虚拟机下面的输出会有不同</strong></p>
<p>Using compressed oop with 0-bit shift.、、</p>
<p>Using compressed klass with 3-bit shift.//<strong>开启指针压缩</strong></p>
<p>Objects are 8 bytes aligned.</p>
<p>Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</p>
<p>Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</p>
<p>com.kingge.obj.Obj object internals:<br> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE<br>      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      8     4           (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)<br>     12     4       int Obj.value                                 0<br>     16     1   boolean Obj.flag                                  false<br>     17     7           (loss due to the next object alignment)<br><strong>Instance size: 24 bytes</strong><br>Space losses: 0 bytes internal + 7 bytes external = 7 bytes total</p>
<p>​    <strong>可以看到一共是24个字节，其中对象头是12个字节，两个成员变量一共是5个字节，那么因为加起来17个字节，并不是8的倍数，那么需要数据对齐，于是加上7个字节的数据对齐。</strong></p>
<p>​    <strong>从而证明了，我们那上面所说的结论是正确的。</strong></p>
<p>假设对象修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Obj obj  = <span class="keyword">new</span> Obj();</div><div class="line">		System.out.println( ClassLayout.parseInstance(obj).toPrintable() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>com.kingge.obj.Obj object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      8     4        (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)<br>     12     4    int Obj.value                                 0<br><strong>Instance size: 16 bytes</strong><br>Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</p>
<p>​    你会发现，<strong>数据对齐，没有了</strong>？那是因为，刚好<strong>属性+对象头一共是16个字节，是8的倍数</strong>。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>对象是由：对象头（大小固定，64位虚拟机下一共占12字节），成员属性（大小根据数据类型决定），数据对齐（不一定存在）。</p>
<p>那么对象的大小就是由着三个部分组成。</p>
<h2 id="对象头的构成"><a href="#对象头的构成" class="headerlink" title="对象头的构成"></a>对象头的构成</h2><p><strong>在上面的分析中，我们得到64位虚拟机下，对象头的大小是12字节，一共是96位。</strong></p>
<p>我们通过查看一下官方文档，获得对象头构成：</p>
<p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="external">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">object header</div><div class="line">Common structure at the beginning of every GC-managed heap object. (Every oop points to an object header.) Includes fundamental information about the heap object&apos;s layout, type, GC state, synchronization state, and identity hash code. Consists of two words. In arrays it is immediately followed by a length field. Note that both Java objects and VM-internal objects have a common object header format.</div><div class="line"></div><div class="line"> ----- 翻译来自有道，可能不准确，但是可以知道大概意思----</div><div class="line"> </div><div class="line">每个gc管理的堆对象开头的公共结构。(每个oop都指向一个对象标头。)包括堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。由两个词组成。在数组中，它后面紧跟着一个长度字段。注意，Java对象和vm内部对象都有一个通用的对象头格式。</div></pre></td></tr></table></figure>
<p>​    也就是说：对象头包含了这些信息，<strong>堆对象的布局</strong>、<strong>类型</strong>、<strong>GC状态</strong>、<strong>同步状态</strong>和<strong>标识哈希码</strong>的基本信息。我么终于发现了，在文章最开始提出的问题的答案，那就是在那里记录了加锁的信息？就是这里的同步状态，而且我们发现，对象头还保存了对象hashcode的值。</p>
<p>   我们知道了对象头包含的信息，但是并没有说明对象头由哪些部分组成？</p>
<p>​    上面的翻译已经说了 Consists of two words。也就是<strong>对象头由两个部分组成</strong>：<strong>klass pointer和mark word</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">klass pointer - 保存了类的指针，也就是当前对象是基于那个Class创建的。</div><div class="line">The second word of every object header. Points to another object (a metaobject) which describes the layout and behavior of the original object. For Java objects, the &quot;klass&quot; contains a C++ style &quot;vtable&quot;.</div><div class="line"></div><div class="line">mark word</div><div class="line">The first word of every object header. Usually a set of bitfields including synchronization state and identity hash code. May also be a pointer (with characteristic low bit encoding) to synchronization related information. During GC, may contain GC state bits.</div></pre></td></tr></table></figure>
<p>那么markword他的结构是怎么样的呢？我们通过看源码的形式查看的他的结构</p>
<p><strong>openjdk\hotspot\src\share\vm\oops\markOop.hpp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// The markOop describes the header of an object.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Note that the mark is not a real oop but just a word.</span></div><div class="line"><span class="comment">// It is placed in the oop hierarchy for historical reasons.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">////////////////////这个位置就说明了，在32位和64位环境下，markword的结构、、、、、、</span></div><div class="line"><span class="comment">//  32 bits:</span></div><div class="line"><span class="comment">//  --------</span></div><div class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></div><div class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></div><div class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></div><div class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  64 bits:</span></div><div class="line"><span class="comment">//  --------</span></div><div class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></div><div class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></div><div class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></div><div class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></div><div class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></div><div class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></div><div class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  - hash contains the identity hash value: largest value is</span></div><div class="line"><span class="comment">//    31 bits, see os::random().  Also, 64-bit vm's require</span></div><div class="line"><span class="comment">//    a hash value no bigger than 32 bits because they will not</span></div><div class="line"><span class="comment">//    properly generate a mask larger than that: see library_call.cpp</span></div><div class="line"><span class="comment">//    and c1_CodePatterns_sparc.cpp.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  - the biased lock pattern is used to bias a lock toward a given</span></div><div class="line"><span class="comment">//    thread. When this pattern is set in the low three bits, the lock</span></div><div class="line"><span class="comment">//    is either biased toward a given thread or "anonymously" biased,</span></div><div class="line"><span class="comment">//    indicating that it is possible for it to be biased. When the</span></div><div class="line"><span class="comment">//    lock is biased toward a given thread, locking and unlocking can</span></div><div class="line"><span class="comment">//    be performed by that thread without using atomic operations.</span></div><div class="line"><span class="comment">//    When a lock's bias is revoked, it reverts back to the normal</span></div><div class="line"><span class="comment">//    locking scheme described below.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    Note that we are overloading the meaning of the "unlocked" state</span></div><div class="line"><span class="comment">//    of the header. Because we steal a bit from the age we can</span></div><div class="line"><span class="comment">//    guarantee that the bias pattern will never be seen for a truly</span></div><div class="line"><span class="comment">//    unlocked object.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    Note also that the biased state contains the age bits normally</span></div><div class="line"><span class="comment">//    contained in the object header. Large increases in scavenge</span></div><div class="line"><span class="comment">//    times were seen when these bits were absent and an arbitrary age</span></div><div class="line"><span class="comment">//    assigned to all biased objects, because they tended to consume a</span></div><div class="line"><span class="comment">//    significant fraction of the eden semispaces and were not</span></div><div class="line"><span class="comment">//    promoted promptly, causing an increase in the amount of copying</span></div><div class="line"><span class="comment">//    performed. The runtime system aligns all JavaThread* pointers to</span></div><div class="line"><span class="comment">//    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))</span></div><div class="line"><span class="comment">//    to make room for the age bits &amp; the epoch bits (used in support of</span></div><div class="line"><span class="comment">//    biased locking), and for the CMS "freeness" bit in the 64bVM (+COOPs).</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread</span></div><div class="line"><span class="comment">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  - the two lock bits are used to describe three states: locked/unlocked and monitor.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    [ptr             | 00]  locked             ptr points to real header on stack</span></div><div class="line"><span class="comment">//    [header      | 0 | 01]  unlocked           regular object header</span></div><div class="line"><span class="comment">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span></div><div class="line"><span class="comment">//    [ptr             | 11]  marked             used by markSweep to mark an object</span></div><div class="line"><span class="comment">//                                               not valid at any other time</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    We assume that stack/thread pointers have the lowest two bits cleared.</span></div></pre></td></tr></table></figure>
<p><strong>可以得到，markword的构成是：unused:25 hash:31 –&gt;| unused:1   age:4    biased_lock:1 lock:2</strong></p>
<blockquote>
<p>   <strong>特殊提醒，我们在JVM中讲到，为什么当对象年龄达到15的时候，才会进入老年代。那么15这个数字是怎么得来的，就是这里的age：4，他占四位，四位能够表达的最大数是15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因</strong></p>
</blockquote>
<p>​    <strong>也就是25+31+1+4+1+2 == 64bit，也就是说在64位对象头中，markword占64位，那么也就意味着，对象类型指针kclass pointer占32bit（96-64）</strong></p>
<p><strong>特殊提醒！！！！</strong>，有些时候我们发现kclass pointer的大小是：64位，也就是需要8个字节，并不是上面所说的需要32位。这两种说法都是对的，因为jvm默认开启了指针压缩，会把kclass pointer压缩成4个字节。如果没有卡其指针压缩，那么就是8个字节。</p>
<p>那么怎么知道jvm 是否开启了指针压缩呢？<code>System.out.println( VM.current().details() );</code> 通过这个命令就可以输出，jvm当前信息。</p>
<h3 id="检验kclass-pointer未压缩前大小是否是8个字节"><a href="#检验kclass-pointer未压缩前大小是否是8个字节" class="headerlink" title="检验kclass pointer未压缩前大小是否是8个字节"></a>检验kclass pointer未压缩前大小是否是8个字节</h3><p>测试例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Obj obj  = <span class="keyword">new</span> Obj();</div><div class="line">		System.out.println( VM.current().details() );</div><div class="line">		System.out.println( ClassLayout.parseInstance(obj).toPrintable() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Running 64-bit HotSpot VM.</div><div class="line"># Using compressed oop with 0-bit shift.</div><div class="line"># Using compressed klass with 3-bit shift.//默认开启指针压缩</div><div class="line"># Objects are 8 bytes aligned.</div><div class="line"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</div><div class="line"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</div><div class="line"></div><div class="line">com.kingge.obj.Obj object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)</div><div class="line">     12     4    int Obj.value                                 0</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</div></pre></td></tr></table></figure>
<p>可以看到输出：# Using compressed klass with 3-bit shift.<strong>//表示默认开启指针压缩</strong></p>
<p><strong>此时，对象头大小是12字节，其中markword占8个字节，对象指针kclass pointer 占4个字节。</strong></p>
<blockquote>
<p><strong>下面我们去掉指针压缩，再次运行。</strong></p>
</blockquote>
<p>使用jvm参数去掉指针压缩： <code>-XX:-UseCompressedOops</code> 。</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Running 64-bit HotSpot VM.</div><div class="line"># Objects are 8 bytes aligned.</div><div class="line"># Field sizes by type: 8, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</div><div class="line"># Array element sizes: 8, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</div><div class="line"></div><div class="line">com.kingge.obj.Obj object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           20 04 b1 17 (00100000 00000100 10110001 00010111) (397476896)</div><div class="line">     12     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">     16     4    int Obj.value                                 0</div><div class="line">     20     4        (loss due to the next object alignment)</div><div class="line">Instance size: 24 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div></pre></td></tr></table></figure>
<p>我们发现，此时，<strong>对象头大小是16字节，其中markword固定占8个字节，那么很明显剩下的8个字节就是对象指针kclass pointer 的大小。</strong></p>
<p><strong>得证！！！</strong>未开启压缩的情况下，对象指针在64位虚拟机下，占8个字节。</p>
<h2 id="markword构成"><a href="#markword构成" class="headerlink" title="markword构成"></a>markword构成</h2><p><strong>我们知道markword在64位虚拟机下，是占8个字节。</strong></p>
<p>首先我们要知道，对象一共有几个状态？</p>
<ul>
<li>初始状态 - 刚new出来</li>
<li>成为偏向锁</li>
<li>成为轻量级锁</li>
<li>成为重量级锁</li>
<li>GC标记-表示可垃圾回收</li>
</ul>
<p>再来看一下 markword结构：</p>
<blockquote>
<p> <strong>unused:25 hash:31 –&gt;| unused:1   age:4    biased_lock:1 lock:2</strong> </p>
<p>​                                           </p>
</blockquote>
<p>​    从上面可以看到，锁标记(lock)占了2位，那么两位的二级制，只有四种可能，00，01,10,11.那么他怎么表示上面这五种状态呢？</p>
<p>​    通过biased_lock偏向锁的1个标志位，来表示，对象的五种状态，右下图可见。</p>
<p>​    <strong>偏向锁和无锁状态表示为同一个状态（lock都是01），然后根据图中偏向锁的标识再去标识是无锁还是偏向锁状态；</strong></p>
<p><img src="/2020/03/09/java基础核心技术/820029-20190807082621811-2089453748.png" alt="img"></p>
<p>下面我们拉分析一下在初始状态下，对象的对象头的markword信息。</p>
<p>com.kingge.obj.Obj object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      8     4        (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)<br>     12     4    int Obj.value                                 0<br>Instance size: 16 bytes<br>Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</p>
<p><strong>从上面的图再根据下面输出的对象结构信息，我们可以得出，markword 一共是64位，八个字节。剩下的4个字节就是kclass pointer（也就是Obj.class的指针）</strong></p>
<p>markword也就是这64位：</p>
<p> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      0     4        (object header)                           01 00 00 00 (<strong>00000001 00000000 00000000 00000000</strong>) (1)<br>      4     4        (object header)                           00 00 00 00 (<strong>00000000 00000000 00000000 00000000</strong>) (0)<br>      8     4        (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) </p>
<p><strong>那么其中这8个字节，就是存储的markword的信息。</strong></p>
<p>  0     4        (object header)                           01 00 00 00 (00000001 <strong>00000000 00000000 00000000</strong>) (1)<br>  4     4        (object header)                           00 00 00 00 (<strong>00000000 00000000 00000000 00000000</strong>) (0)</p>
<p>剩下的未标黑色的8位保存的就是：<strong>unused:1   age:4    biased_lock:1 lock:2</strong> </p>
<p>​    这八位等于00000001，那么正好跟，初始化状态的对象的状态是一样的。前六位都是0，lock等于01表示正常（因为上面的代码中obj对象是刚new出来的。unuseed等于0，那么gc年龄肯定是0，也就是age的四位都是0，biaed_lock也是0，lock等于01）</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200402164715040.png" alt="image-20200402164715040"></p>
<blockquote>
<p><strong>那为什么在上面输出的31位的hashcode都是0？ </strong></p>
</blockquote>
<p>原因是没有调用对象的hashcode方法生成hashcode。</p>
<p>测试代码修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Obj &#123;</div><div class="line"></div><div class="line">    public  int value;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">		Obj obj  = new Obj();</div><div class="line">		System.out.println( VM.current().details() );</div><div class="line">		System.out.println( Integer.toHexString(obj.hashCode()));//多加了这一行，获取对象hashcode，以16进制输出。</div><div class="line">		System.out.println( ClassLayout.parseInstance(obj).toPrintable() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">obj对象hashcode：37bba400</div><div class="line">com.kingge.obj.Obj object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION          VALUE</div><div class="line">   0     4       (object header)         01 00 a4 bb (00000001 00000000 10100100 10111011) (-1146879999)</div><div class="line">      4     4        (object header)     37 00 00 00 (00110111 00000000 00000000 00000000) (55)</div><div class="line">      8     4        (object header)     05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)</div><div class="line">     12     4    int Obj.value                                 0</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</div></pre></td></tr></table></figure>
<p>你会发现，输出的对象结构信息中，<strong>hashcode的值，已经存在</strong>。且为：37bba400。</p>
<p>跟上面的value字段输出一致。</p>
<h3 id="模拟偏向锁和轻量级锁对象头"><a href="#模拟偏向锁和轻量级锁对象头" class="headerlink" title="模拟偏向锁和轻量级锁对象头"></a>模拟偏向锁和轻量级锁对象头</h3><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">// Thread.sleep(5000); 放开这一行，那么输出的就是偏向锁，或者设置-XX:BiasedLockingStartupDelay=0</span></div><div class="line">		 Obj obj  = <span class="keyword">new</span> Obj();</div><div class="line">		System.out.println(<span class="string">"befor lock"</span>);</div><div class="line">		System.out.println(ClassLayout.parseInstance(obj).toPrintable());</div><div class="line"></div><div class="line">	        <span class="keyword">synchronized</span> (obj)&#123;</div><div class="line">	        		 System.out.println(<span class="string">"lock ing"</span>);</div><div class="line">	        		 System.out.println(ClassLayout.parseInstance(obj).toPrintable());</div><div class="line">	        &#125;</div><div class="line">	        System.out.println(<span class="string">"after lock"</span>);</div><div class="line">	        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200402173402270.png" alt="image-20200402173402270"></p>
<p>如果把上面的 // Thread.sleep(5000); 注释放开或者设置-XX:BiasedLockingStartupDelay=0，那么此刻输出的是偏向锁的信息，前八位是：0 0000 1 01</p>
<h4 id="为什么不是偏向锁"><a href="#为什么不是偏向锁" class="headerlink" title="为什么不是偏向锁"></a>为什么不是偏向锁</h4><p><strong>为什么呢？从上面代码看，只有一个main线程在获取锁啊，应该是偏向锁才对啊？</strong></p>
<p>经过翻hotspot源码发现：</p>
<p>路径： <a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/globals.hpp" target="_blank" rel="external">http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/globals.hpp</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">product(bool, UseBiasedLocking, <span class="keyword">true</span>,                   </div><div class="line"></div><div class="line">    <span class="string">"Enable biased locking in JVM"</span>)                 </div><div class="line"></div><div class="line">                          </div><div class="line"></div><div class="line">product(intx, BiasedLockingStartupDelay, <span class="number">4000</span>,              </div><div class="line"></div><div class="line">    <span class="string">"Number of milliseconds to wait before enabling biased locking"</span>) </div><div class="line"></div><div class="line">    range(<span class="number">0</span>, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) </div><div class="line"></div><div class="line">    constraint(BiasedLockingStartupDelayFunc,AfterErgo)       </div><div class="line"></div><div class="line">BiasedLockingStartupDelay, <span class="number">4000</span>  <span class="comment">//偏向锁延迟4000ms启动</span></div><div class="line"></div><div class="line"><span class="comment">//所以我们需要让main线程jvm把偏向锁的初始化工作准备好，后再去争抢锁。</span></div></pre></td></tr></table></figure>
<p><strong>想想为什么偏向锁会延迟？</strong></p>
<p>我们来看官方解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> BiasedLocking::init() &#123;</div><div class="line">  <span class="comment">// If biased locking is enabled, schedule a task to fire a few</span></div><div class="line">  <span class="comment">// seconds into the run which turns on biased locking for all</span></div><div class="line">  <span class="comment">// currently loaded classes as well as future ones. This is a</span></div><div class="line">  <span class="comment">// workaround for startup time regressions due to a large number of</span></div><div class="line">  <span class="comment">// safepoints being taken during VM startup for bias revocation.</span></div><div class="line">  <span class="comment">// Ideally we would have a lower cost for individual bias revocation</span></div><div class="line">  <span class="comment">// and not need a mechanism like this.</span></div><div class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</div><div class="line">    <span class="keyword">if</span> (BiasedLockingStartupDelay &gt; <span class="number">0</span>) &#123;</div><div class="line">      EnableBiasedLockingTask* task = <span class="keyword">new</span> EnableBiasedLockingTask(BiasedLockingStartupDelay);</div><div class="line">      task-&gt;enroll();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="function">VM_EnableBiasedLocking <span class="title">op</span><span class="params">(<span class="keyword">false</span>)</span></span>;</div><div class="line">      VMThread::execute(&amp;op);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">注意看上面的注释和代码</div></pre></td></tr></table></figure>
<p>英文大概翻译为： <strong>当jvm启动记载资源的时候，初始化的对象加偏向锁会耗费资源，减少大量偏向锁撤销的成本（jvm的偏向锁的优化）</strong></p>
<p>这就解释了加上睡眠5000ms，偏向锁就会出现的原因；</p>
<p>​    为了方便我们测试我们可以直接通过修改jvm的参数来禁止偏向锁延迟（不用在代码睡眠了）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</div></pre></td></tr></table></figure>
<p>​    <strong>注意：这块严谨来说，在jdk 1.6之后，关于使用偏向锁和轻量级锁，jvm是有优化的，在没有禁止偏向锁延迟的情况下，使用的是轻量级锁；禁止偏向锁延迟的话，使用的是偏向锁；</strong></p>
<p>​    <strong>总而言之：因为jvm 在启动的时候需要加载资源，这些对象加上偏向锁没有任何意义啊，减少了大量偏向锁撤销的成本；所以默认就把偏向锁延迟了4000ms；</strong></p>
<p>如果还不能确定是否延迟，那么我们可以通过查看jvm默认启动参数来查看：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200403105339055.png" alt="image-20200403105339055"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ jinfo -flag BiasedLockingStartupDelay 16212</div><div class="line">-XX:BiasedLockingStartupDelay=4000</div><div class="line"></div><div class="line">可以发现启动的jvm。BiasedLockingStartupDelay默认是4000</div></pre></td></tr></table></figure>
<h3 id="比较偏向锁和轻量级锁性能"><a href="#比较偏向锁和轻量级锁性能" class="headerlink" title="比较偏向锁和轻量级锁性能"></a>比较偏向锁和轻量级锁性能</h3><p>测试轻量级锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj1</span> </span>&#123;</div><div class="line"></div><div class="line">	 	<span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span></span>&#123;</div><div class="line">	        i++;</div><div class="line">	    &#125;</div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">	        </div><div class="line">	    	Obj1 obj1 = <span class="keyword">new</span> Obj1();</div><div class="line">	        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">	        <span class="comment">//调用同步方法1000000000L 来计算1000000000L的++，对比偏向锁和轻量级锁的性能</span></div><div class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">1000000000L</span>;i++)&#123;</div><div class="line">	        	obj1.parse();</div><div class="line">	        &#125;</div><div class="line">	        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">	        System.out.println(String.format(<span class="string">"%sms"</span>, end - start));<span class="comment">//轻量级锁：21743ms</span></div><div class="line">	         																						   <span class="comment">//偏向锁：1801ms</span></div><div class="line">	        <span class="comment">//可以发现，偏向锁比轻量级锁快了12倍左右</span></div><div class="line">	    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试偏向锁，只需要运行的时候指定：-XX:BiasedLockingStartupDelay=0，表示不需要延迟设置偏向锁。</p>
<p>​    为什么呢？我们知道偏向锁是支持重入的，意思就是，假设下次获取锁的线程还是之前的线程，那么不需要在申请锁，只需要增加重入次数即可。这个假设是只有一个线程 需要获取锁的情况下。</p>
<p>​    但是如果存在多个线程获取锁，那么锁会升级，升级为轻量级锁，<strong>因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可</strong>。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> com.kingge.obj;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHeavyLock</span> </span>&#123;</div><div class="line"></div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		 ObjLock objLock = <span class="keyword">new</span> ObjLock();</div><div class="line">		 System.out.println(<span class="string">"befor lock"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());<span class="comment">//无锁</span></div><div class="line">		 </div><div class="line">		 Thread thread = <span class="keyword">new</span> Thread( () -&gt; &#123;</div><div class="line">			 <span class="keyword">synchronized</span> (objLock) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					TimeUnit.SECONDS.sleep(<span class="number">5</span>);<span class="comment">//休息五秒的目的是，让sysn也同时去获取锁，让锁升级</span></div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		 &#125; );</div><div class="line">		 thread.start();</div><div class="line">		 System.out.println(<span class="string">"thread locking"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());<span class="comment">//轻量级锁</span></div><div class="line">		 </div><div class="line">		 sysn(objLock);<span class="comment">//main线程请求锁，这个时候轻量级锁已经存在，那么锁升级</span></div><div class="line">		 </div><div class="line">		 System.out.println(<span class="string">"after  main  lock"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());<span class="comment">//重量级锁</span></div><div class="line">		 </div><div class="line">		 System.gc();</div><div class="line">		 System.out.println(<span class="string">"after  gc"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());<span class="comment">//无锁</span></div><div class="line">		 </div><div class="line">	&#125;</div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysn</span><span class="params">(ObjLock objLock)</span> </span>&#123;</div><div class="line">		 <span class="keyword">synchronized</span> (objLock) &#123;</div><div class="line">		System.out.println(<span class="string">"main lock ing"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	 </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjLock</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">befor lock</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div><div class="line"></div><div class="line">thread locking</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           60 f2 c9 1a (01100000 11110010 11001001 00011010) (449442400)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div><div class="line"></div><div class="line">main lock ing</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           4a 3c 4a 03 (01001010 00111100 01001010 00000011) (55196746)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div><div class="line"></div><div class="line">after  main  lock</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           4a 3c 4a 03 (01001010 00111100 01001010 00000011) (55196746)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div><div class="line"></div><div class="line">after  gc</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           09 00 00 00 (00001001 00000000 00000000 00000000) (9)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div></pre></td></tr></table></figure>
<p>分析锁的前八位：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">befor lock</div><div class="line">0 0000 0 01  //无锁，gc年龄是0</div><div class="line"> </div><div class="line">thread locking</div><div class="line">0 1100 0 00  //轻量级锁，gc年龄是12，说明ObjLock对象在survivor倒腾了12次</div><div class="line"> </div><div class="line">main lock ing</div><div class="line">0 1001 0 10  //重量级锁</div><div class="line"> </div><div class="line">after  main  lock</div><div class="line">0 1001 0 10 //重量级锁？？？？</div><div class="line"> </div><div class="line">after gc</div><div class="line">0 0001 0 01 //gc回收变无锁（就会发现gc回收过一次之后对象由最初刚开始的 0000 变成了 0001 年龄+1了）</div></pre></td></tr></table></figure>
<p>​    上面的分析应该很容易看得懂，那么我们注意，<strong>打问号的地方</strong>。按道理main线程执行完sync，也就意味着thread线程在这之前也已经释放了锁（不然sync方法也无法得到锁执行），objLock此刻是没有线程去锁住才对，那么应该是是无锁状态，那为什么还是输出的是重量级锁的信息呢？</p>
<p>​    <strong>是因为重量级锁释放会有延迟，可以在sync()方法中加入睡眠。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> public static void sysn(ObjLock objLock) throws InterruptedException &#123;</div><div class="line">	 synchronized (objLock) &#123;</div><div class="line">	System.out.println(&quot;main lock ing&quot;);</div><div class="line">	 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());</div><div class="line">	&#125;</div><div class="line">	 Thread.sleep(5000);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//此时再看输出，你会发现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">after  main  lock</div><div class="line">0 0000 0 01  //已经是无锁状态</div></pre></td></tr></table></figure>
<h3 id="偏向锁的epoch作用"><a href="#偏向锁的epoch作用" class="headerlink" title="偏向锁的epoch作用"></a>偏向锁的epoch作用</h3><p><strong>这里的</strong> <strong>epoch 值是一个什么概念呢？</strong></p>
<ul>
<li>我们先从偏向锁的撤销讲起。当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时（而且 epoch 值相等，如若不等，那么当前线程可以将该锁重偏向至自己），Java 虚拟机需要撤销该偏向锁。这个撤销过程非常麻烦，它要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁；</li>
<li>如果某一类锁对象的总撤销数超过了一个阈值（对应 jvm参数 <strong>-XX:BiasedLockingBulkRebiasThreshold，默认为 20</strong>），那么 Java 虚拟机会宣布这个类的偏向锁失效；（这里说的就是<strong>批量重偏向</strong>）</li>
</ul>
<p>​    JVM源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \</div><div class="line">        &quot;Threshold of number of revocations per type to try to &quot;          \</div><div class="line">        &quot;rebias all objects in the heap of that type&quot;)                    \</div><div class="line">        range(0, max_intx)                                                \</div><div class="line">        constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \</div></pre></td></tr></table></figure>
<ul>
<li>具体的做法便是在每个类中维护一个 epoch 值，你可以理解为第几代偏向锁。当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中；</li>
<li>在宣布某个类的偏向锁失效时，Java 虚拟机实则将该类的 epoch 值加 1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的 epoch 值；</li>
<li>为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态；</li>
<li>如果总撤销数超过另一个阈值（对应 jvm 参数 <strong>-XX:BiasedLockingBulkRevokeThreshold，默认值为 40</strong>），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁(这里说的就是<strong>偏向批量撤销</strong>)</li>
</ul>
<p>​    </p>
<p>JVM源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \</div><div class="line">        &quot;Threshold of number of revocations per type to permanently &quot;     \</div><div class="line">        &quot;revoke biases of all objects in the heap of that type&quot;)          \</div><div class="line">        range(0, max_intx)                                                \</div><div class="line">        constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)</div></pre></td></tr></table></figure>
<p>　　</p>
<h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><p>​    所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级：</p>
<ul>
<li>当没有竞争出现时，默认会使用偏向锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏向锁可以降低无竞争开销。</li>
<li>如果有另外的线程试图锁定某个已经被偏向过的对象，JVM 就需要撤销（revoke）偏向锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用轻量级锁；否则，进一步升级为重量级锁</li>
</ul>
<p><strong>膨胀过程的实现比较复杂，大概实现过程如下：</strong></p>
<p>1、整个膨胀过程在自旋下完成；</p>
<p>2、mark-&gt;has_monitor()方法判断当前是否为重量级锁，即Mark Word的锁标识位为 10，如果当前状态为重量级锁，执行步骤（3），否则执行步骤（4）；</p>
<p>3、mark-&gt;monitor()方法获取指向ObjectMonitor的指针，并返回，说明膨胀过程已经完成；</p>
<p>4、如果当前锁处于膨胀中，说明该锁正在被其它线程执行膨胀操作，则当前线程就进行自旋等待锁膨胀完成，这里需要注意一点，虽然是自旋操作，但不会一直占用cpu资源，每隔一段时间会通过os::NakedYield方法放弃cpu资源，或通过park方法挂起；如果其他线程完成锁的膨胀操作，则退出自旋并返回；</p>
<p>5、如果当前是轻量级锁状态，即锁标识位为 00，膨胀过程如下：</p>
<ul>
<li>通过omAlloc方法，获取一个可用的ObjectMonitor monitor，并重置monitor数据；</li>
<li>通过CAS尝试将Mark Word设置为markOopDesc:INFLATING，标识当前锁正在膨胀中，如果CAS失败，说明同一时刻其它线程已经将Mark Word设置为markOopDesc:INFLATING，当前线程进行自旋等待膨胀完成；</li>
<li>如果CAS成功，设置monitor的各个字段：_header、_owner和_object等，并返回；</li>
</ul>
<p>6、如果是无锁，重置监视器值；</p>
<h2 id="好的相关文档"><a href="#好的相关文档" class="headerlink" title="好的相关文档"></a>好的相关文档</h2><p><a href="https://www.cnblogs.com/JonaLin/p/11571482.html#autoid-2-0-0" target="_blank" rel="external">https://www.cnblogs.com/JonaLin/p/11571482.html#autoid-2-0-0</a> 非常推荐！！！！！</p>
<p><a href="https://www.cnblogs.com/yrjns/p/12152975.html" target="_blank" rel="external">https://www.cnblogs.com/yrjns/p/12152975.html</a></p>
<h2 id="题外话：Java中boolean类型占几个字节，你知道吗？"><a href="#题外话：Java中boolean类型占几个字节，你知道吗？" class="headerlink" title="题外话：Java中boolean类型占几个字节，你知道吗？"></a>题外话：Java中boolean类型占几个字节，你知道吗？</h2><p><a href="https://blog.csdn.net/amoscn/article/details/97377833" target="_blank" rel="external">https://blog.csdn.net/amoscn/article/details/97377833</a></p>
<h1 id="cas是什么-无锁并发安全实现-轻量级锁"><a href="#cas是什么-无锁并发安全实现-轻量级锁" class="headerlink" title="cas是什么 - 无锁并发安全实现 - 轻量级锁"></a>cas是什么 - 无锁并发安全实现 - 轻量级锁</h1><blockquote>
<p><strong>概念</strong></p>
</blockquote>
<p>他就是比较并交换的缩写 - compareAndSet。他的作用就是通过比较期望值，来判断本次操作能否成功。</p>
<p><strong>也就是说比较当前工作内存的值和主内存中的值，如果相等，那么执行相应的逻辑操作（临界区操作），如果不相等，那么一直比较到相同为止。</strong></p>
<p>那么他究竟是什么呢？</p>
<p>我们来回忆一下AtomicInteger的compareAndSet方法。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200120093410478.png" alt="image-20200120093410478"></p>
<p>第一个参数和第二个参数是相辅相成的，只有在第一个参数比较成功后，才能够成功赋值第二个参数的值。</p>
<p>那么第一个参数是跟谁比较呢？<strong>答案是，跟主内存中目前的值比较。</strong></p>
<p>​    重要提示：<strong>首先我们要明确一点，那就是，线程对数据的操作，都是先把数据从主内存（电脑内存），读取出来，然后load自己的线程栈中，再进行自己的运算逻辑，然后线程结束后，再把新值写回主内存。（那么可想而知，多线程的情况下，必然会发生线程不安全问题，因为每个线程把自己的处理结果写回主内存的时机不同，导致结果出现各种变化）</strong></p>
<blockquote>
<p><strong>接下来演示使用cas的例子：</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        AtomicInteger atomicInteger = new AtomicInteger(5);//在主内存中，设置共享变量的值为5</div><div class="line">        System.out.println(atomicInteger.compareAndSet(5, 2019)+&quot;\t current&quot;+atomicInteger.get());</div><div class="line">        System.out.println(atomicInteger.compareAndSet(5, 2014)+&quot;\t current&quot;+atomicInteger.get());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">true	 current 2019</div><div class="line">false	 current 2019</div></pre></td></tr></table></figure>
<p>​    为什么第一次compareAndSet能成功，第二次就不行了呢？这是因为，初始的AtomicInteger的值是5，那么在主内存中就是5。第一次执行cas操作，所要表达的逻辑是，我要把atomicInteger修改为2019，但是我是要从5修改为2019。也就是说，主内存中的atomicInteger的值必须是5，我才能<strong>紧接着</strong>把atomicInteger修改为2019。</p>
<p><strong>很明显在第一次cas操作之前，主内存中的atomicInteger一直是5，</strong> 所以<strong>比较成功</strong>。<strong>交换值</strong>，5修改为2019，成功写入主内存中的atomicInteger。</p>
<p>​    但是第二次cas操作，表达的是我要从5修改为2014，但是<strong>通过比较主内存</strong>中的atomicInteger，发现atomicInteger的值是2019，那么<strong>比较失败</strong>，<strong>值交换也相继失败</strong>。所以主内存中atomicInteger的值保持不变，还是2019。</p>
<p><strong>也就是说，CAS的本质就是，先比较后交换。</strong></p>
<blockquote>
<p><strong>我们接着查看一下compareAndSet的源码：</strong></p>
</blockquote>
<pre><code>/**
 * Atomically sets the value to the given updated value
 * if the current value {@code ==} the expected value.
 *
 * @param expect the expected value
 * @param update the new value
 * @return {@code true} if successful. False return indicates that
 * the actual value was not equal to the expected value.
 */
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
</code></pre><ul>
<li><p>this：就是当前的atomicInteger对象- AtomicInteger atomicInteger = new AtomicInteger(5);</p>
</li>
<li><p>valueOffset：我们知道atomicInteger的值是保存在value成员变量中，而且他是通过volatile修饰。而且这个值是在创建AtomicInteger之前（在调用构造器之前）通过静态代码块，进行赋值。目的就是求得，value成员变量在内存中的地址。</p>
<ul>
<li>static {<pre><code>try {
    valueOffset = unsafe.objectFieldOffset
        (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
} catch (Exception ex) { throw new Error(ex); }
</code></pre>}</li>
</ul>
</li>
<li><p>expect：我们的预期值，也即是5，也即是要更新为2019的<strong>条件值</strong>。<strong>那么value在主内存中现在的值是多少呢</strong>？怎么获取呢？</p>
<ul>
<li>通过前两个参数获取，通过this和valueOffset，就可以定位到，value属性在内存中的地址，从而获取它的值。</li>
</ul>
</li>
<li><p>update：要把内存中的值，更新update的值。</p>
</li>
</ul>
<blockquote>
<p><strong>抽象出来的CAS的逻辑</strong></p>
</blockquote>
<p>CAS(V, E, N)</p>
<ul>
<li>V：要更新的变量，目前内存中的变量的值。</li>
<li>E：预期值，条件值。要把v更新为n的条件值</li>
<li>N：新值<br>如果V值等于E值，则将V值设为N值；如果V值不等于E值，说明其他线程做了更新，那么当前线程什么也不做。（放弃操作或重新读取数据）</li>
</ul>
<blockquote>
<p><strong>疑问</strong></p>
</blockquote>
<p>​    compareAndSet方法，咋一看，是没有添加任何线程同步的处理，例如没有synchronized或者Lock，那么他是线程安全的么？</p>
<p><strong>答案：是线程安全的，因为使用cas原理（一种硬件原语），cas就能够保证线程安全。</strong></p>
<h2 id="AtomicInteger的CAS底层原理"><a href="#AtomicInteger的CAS底层原理" class="headerlink" title="AtomicInteger的CAS底层原理"></a>AtomicInteger的CAS底层原理</h2><p><strong>为什么cas能够保证线程安全？</strong></p>
<p>​    首先回顾一下我们做过的一个实例：实现两个线程对一个数自增，例如各自对number（共享数据）增加一百万。我们知道如果不对自增方法添加synchronized（或者使用Lock），那么就会导致，最终得数是变化不断的，是不会出现预期的两百万的得值，而是一个游离变化不断得值，<strong>因为这个就是线程安全的问题</strong>。</p>
<blockquote>
<p><strong>通过学习我们知道有多种方案，解决线程安全问题：</strong></p>
</blockquote>
<ul>
<li><p>通过给方法添加synchronized关键字</p>
</li>
<li><p>可以使用Lock来实现多线程同步问题。</p>
</li>
<li><p>也可以使用AtomicInteger来解决多线程同步问题。</p>
</li>
</ul>
<p><strong>前面两种，我们都已经测试过，但是AtomicInteger为什么能够保证线程安全？同时他是通过什么机制来保证线程安全？通过上面的学习我们知道 AtomicInteger 是通过CAS来保证线程安全，但是是怎么保证的？</strong></p>
<p>那么我们可以通过AtomicInteger来推导出CAS的底层原理。</p>
<blockquote>
<p><strong>看实现代码：通过添加synchronized</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CASDemo &#123;</div><div class="line">	</div><div class="line"> static class Share&#123;</div><div class="line">	 private  int number = 0;//</div><div class="line">	 </div><div class="line">	 public synchronized  void add() &#123;</div><div class="line">		 number++;</div><div class="line">	 &#125;</div><div class="line">	 public int get() &#123;</div><div class="line">		 return number;</div><div class="line">	 &#125;</div><div class="line"> &#125;</div><div class="line">	</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    	Share share = new Share();</div><div class="line">    	Thread pp = new Thread(new Runnable() &#123;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			 for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">   			  share.add1();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;,&quot;线程1&quot;);</div><div class="line">    	Thread ppp =  new Thread(new Runnable() &#123;</div><div class="line">    	  @Override</div><div class="line">    	  public void run() &#123;</div><div class="line">    		  for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">    			  share.add1();</div><div class="line">			&#125;</div><div class="line">    	  &#125;</div><div class="line">      &#125;,&quot;线程2&quot;);</div><div class="line">    	</div><div class="line">      pp.start();</div><div class="line">      ppp.start();</div><div class="line">      </div><div class="line">      pp.join();</div><div class="line">      ppp.join();</div><div class="line">      System.err.println( share.get() );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案，肯定是正确的，因为使用了synchronized内部锁，进行了线程安全的控制。</p>
<blockquote>
<p><strong>我们知道可以使用，AtomicInteger来实现相同的功能</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CASDemo &#123;</div><div class="line">	</div><div class="line"> static class Share&#123;</div><div class="line">	  AtomicInteger atomicInteger = new AtomicInteger(0);//在主内存中，设置共享变量的值为0</div><div class="line">	 public   void add1() &#123;</div><div class="line">		 atomicInteger.incrementAndGet();</div><div class="line">	 &#125;</div><div class="line">	 public int get1() &#123;</div><div class="line">		 return atomicInteger.get();</div><div class="line">	 &#125;</div><div class="line">	 </div><div class="line"> &#125;</div><div class="line">	</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    	Share share = new Share();</div><div class="line">    	Thread pp = new Thread(new Runnable() &#123;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			 for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">   			  share.add1();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;,&quot;线程1&quot;);</div><div class="line">    	Thread ppp =  new Thread(new Runnable() &#123;</div><div class="line">    	  @Override</div><div class="line">    	  public void run() &#123;</div><div class="line">    		  for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">    			  share.add1();</div><div class="line">			&#125;</div><div class="line">    	  &#125;</div><div class="line">      &#125;,&quot;线程2&quot;);</div><div class="line">    	</div><div class="line">      pp.start();</div><div class="line">      ppp.start();</div><div class="line">      </div><div class="line">      pp.join();</div><div class="line">      ppp.join();</div><div class="line">      System.err.println( share.get1() );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现add1方法，根本就没有添加synchronized关键字修饰，但是他为什么能够保证数值就是2000000呢？</p>
<p><strong>通过查看上面的代码，我们发现是通过<code>atomicInteger.incrementAndGet()</code>解决了，number++在多线程访问下竟态线程安全问题。那么具体是怎么实现呢，往下看</strong></p>
<blockquote>
<p><strong>通过查看incrementAndGet方法</strong></p>
</blockquote>
<pre><code>/**
 * Atomically increments by one the current value.
 *
 * @return the updated value
 */
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
</code></pre><p>​    <strong>发现它内部实现是通过调用UnSafe类的方法。那么很明显UnSafe就是多线程同步的关键</strong></p>
<p>​    通过上面的分析我们知道，<code>unsafe.getAndAddInt(this, valueOffset, 1)</code>，this参数就是atomicInteger实例，valueOffset就是atomicInteger实例的成员变量value在内存中的偏移量（也就是内存地址 ），<strong>通过前两个参数，就可以获取当前value在主内存的值。</strong>，第三个参数就是自增1。</p>
<blockquote>
<p><strong>我们接着查看unsafe.getAndAddInt源码</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> /**</div><div class="line">  * Atomically adds the given value to the current value of a field</div><div class="line">  * or array element within the given object &lt;code&gt;o&lt;/code&gt;</div><div class="line">  * at the given &lt;code&gt;offset&lt;/code&gt;.</div><div class="line">  *</div><div class="line">  * @param o object/array to update the field/element in</div><div class="line">  * @param offset field/element offset</div><div class="line">  * @param delta the value to add</div><div class="line">  * @return the previous value</div><div class="line">  * @since 1.8</div><div class="line">  */</div><div class="line"> public final int getAndAddInt(Object o, long offset, int delta) &#123;</div><div class="line">     int v;</div><div class="line">     do &#123;</div><div class="line">         v = getIntVolatile(o, offset);</div><div class="line">     &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</div><div class="line">     return v;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"></div><div class="line">/** Volatile version of &#123;@link #getInt(Object, long)&#125;  */</div><div class="line"> public native int     getIntVolatile(Object o, long offset);//调用操作系统的方法获取当前atomicInteger实例在主内存中value的值。</div><div class="line"> </div><div class="line"> </div><div class="line">     /**</div><div class="line">  * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</div><div class="line">  * holding &lt;tt&gt;expected&lt;/tt&gt;.</div><div class="line">  * @return &lt;tt&gt;true&lt;/tt&gt; if successful</div><div class="line">  */</div><div class="line"> public final native boolean compareAndSwapInt(Object o, long offset,</div><div class="line">                                               int expected,</div><div class="line">                                               int x);</div></pre></td></tr></table></figure>
<p>1.首先看这个方法getAndAddInt，刚开始执行一次do操作，调用getIntVolatile方法</p>
<ul>
<li>目的是获取当前的atomicInteger共享资源，对应的value值，<strong>在主内存中现在的值</strong>（因为可能有其他线程已经修改了它的值，所以要获取最新的值）。然后赋值给v变量。</li>
</ul>
<p>2.然后进行while判断，这个就是核心的cas的原理关键，比较和交换。</p>
<ul>
<li><p>​    compareAndSwapInt方法，一共有四个参数。第一个参数，就是atomicInteger共享资源（<strong>就是我们 AtomicInteger atomicInteger = new AtomicInteger(0)这里new出来的实例本身</strong>），保存自己首次从主内存中，捞取的value数据（因为我们知道，任何线程对数据的操作，都是先从主内存加载到自己的栈内存中，进行操作，也就是cas的expect值）</p>
</li>
<li><p>第二个参数：就是atomicInteger共享资源的value属性在内存的地址。</p>
<ul>
<li>这样通过第一和第二参数，我们就可以获取cas的expect值。</li>
</ul>
</li>
</ul>
<p>第三个参数：就是目前value在主内存中的值。</p>
<p>第四个参数：就是update值，更新最新的值，v + delta。线程操作成功。</p>
<p>通过前面三个参数，我们就可以<strong>实现cas中的compare阶段</strong>，比较期望值跟主内存中value值，是否一致，如果一致，那么就直接更新值，<strong>实现cas的set阶段</strong>，<strong>更新成功</strong>，然后返回v变量的值（没有进行v + delta前的值）</p>
<p>如果比对失败，那么compareAndSwapInt返回false，那么<code>while (!compareAndSwapInt(o, offset, v, v + delta));</code>判断成功，然后接着进行do操作，<strong>无线循环，直到while判断成功</strong>。</p>
<blockquote>
<p><strong>我们在捋一下思路</strong></p>
</blockquote>
<p>  假设线程A和线程B两个线程同时执行getAndAddInt操作(分别在不同的CPU上):</p>
<p>1.AtomicInteger里面的value原始值为3,即主内存中AtomicInteger的value为3,根据JMM模型,线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存.</p>
<p>2.线程A通过getIntVolatile(var1,var2) 拿到value值3,这时线程A被挂起.</p>
<p>3.线程B也通过getIntVolatile(var1,var2) 拿到value值3,此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存中的值也是3 成功修改主内存的值为4 线程B打完收工 一切OK.</p>
<p> 4.这是线程A恢复,执行compareAndSwapInt方法比较,发现自己手里的数值（3）和内存中的数字4不一致,说明该值已经被其他线程抢先一步修改了,那A线程修改失败,只能重新来一遍了.（while循环判断失败，重新进入do逻辑获取主内存的value值）</p>
<p> 5.线程A重新获取value值,因为变量value是volatile修饰,所以其他线程对他的修改,线程A总是能够看到,线程A继续执行compareAndSwapInt方法进行比较替换,直到成功.</p>
<blockquote>
<p><strong>我们知道上述方法都是通过Unsafe类进行调用的，那么UnSafe是是什么？</strong></p>
</blockquote>
<p>​     是CAS的核心类 由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法.<br>​    注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务<br>  变量ValueOffset,便是该变量在内存中的偏移地址,因为UnSafe就是根据内存偏移地址获取数据的。</p>
<h3 id="那么cas到底是怎么保证了并发问题？"><a href="#那么cas到底是怎么保证了并发问题？" class="headerlink" title="那么cas到底是怎么保证了并发问题？"></a><strong>那么cas到底是怎么保证了并发问题？</strong></h3><p>​    CAS的全称为Compare-And-Swap ,它是一条CPU并发原语。</p>
<p>​    它的功能是判断内存某个位置的值是否为预期值,如果是则更新为新的值,<strong>这个过程是原子的.</strong></p>
<p>​    CAS并发原语提现在Java语言中就是sun.misc.UnSaffe类中的各个方法.调用UnSafe类中的CAS方法,<strong>JVM会帮我实现CAS汇编指令</strong>.这是一种完全依赖于硬件 功能,通过它<strong>实现了原子操作</strong>。</p>
<p>​    再次强调,由于CAS是一种系统原语。原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程,并且原语的执行必须是连续的,在执行过程中<strong>不允许中断</strong>，<strong>也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题.</strong></p>
<p><img src="/2020/03/09/java基础核心技术/4840092-f85e70e2262b72312878.png" alt="image-20200120144908032"></p>
<p>也就是说，cas为什么能够保证并发安全，靠的就是底层的汇编命令，指令的原子性。</p>
<h3 id="为什么使用cas不使用synchronized？"><a href="#为什么使用cas不使用synchronized？" class="headerlink" title="为什么使用cas不使用synchronized？"></a>为什么使用cas不使用synchronized？</h3><p>我们通过上面的源码知道，cas是不会加锁的，他是通过一个无线循环，来进行比对值，然后设置值的思路。这样就可以让<strong>多个线程在同一个时刻同时进入逻辑</strong>。</p>
<p>然而synchronized或者lock，只能在<strong>同一个时刻，只有一个线程</strong>获取锁后，才能进入逻辑。</p>
<p>所以并发上，cas更佳。但是synchronized至少能够保证，我做完一然后接着下一个，很稳定。cas虽然是可以大家一起做，但是不一定能成功。</p>
<p>但是cas只能够保证一个资源的并发安全，多个资源他无法保证。synchronized是可以保证多个资源的并发安全。</p>
<h2 id="AtomicReference-实现对象的资源保护"><a href="#AtomicReference-实现对象的资源保护" class="headerlink" title="AtomicReference 实现对象的资源保护"></a>AtomicReference 实现对象的资源保护</h2><p>我们知道java.util.concurrent.atomic包下提供了，多种通过cas实现并发安全的各种类。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200120153246954.png" alt="image-20200120153246954"></p>
<p>那么我们之前已经使用了AtomicInteger，通过它可以保证某个int类型数据的并发安全。</p>
<p>但是如果共享资源是多个属性，或者说是一个对象的话，那么怎么办？那么就可以使用 AtomicReference<t>。</t></p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class AtomicReferenceDemo &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		User user = new User(&quot;kingge&quot;, 12);</div><div class="line">		User userCopy = new User(&quot;kingge&quot;, 12);</div><div class="line">		User user1 = new User(&quot;kingger&quot;, 12);</div><div class="line">		AtomicReference&lt;User&gt; reference = new AtomicReference&lt;&gt;();</div><div class="line">		reference.set(user);</div><div class="line">	        System.out.println(reference.compareAndSet(user, user1)+&quot;\t&quot;+reference.get().toString());</div><div class="line">	        System.out.println(reference.compareAndSet(user, user1)+&quot;\t&quot;+reference.get().toString());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class User&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">	public User(String name, int age) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">//省略get/set方法</div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">true	User [name=kingger, age=12]</div><div class="line">false	User [name=kingger, age=12]</div></pre></td></tr></table></figure>
<p>需要注意的是：这里需要注意下，这里的比对两个对象，比对的方式不是<code>equals</code>而是<code>==</code>,意味着比对的是内存的中地址，这个我们可以通过<code>unsafe.compareAndSwapObject()</code>方法查看，他是一个native方法。</p>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><blockquote>
<p><strong>1.循环时间长开销很大，可能某个线程一直操作不成功，那么一直循环，对cpu造成压力大。</strong></p>
</blockquote>
<pre><code>public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
</code></pre><blockquote>
<p><strong>2.只能保证一个共享变量的原子性。</strong></p>
</blockquote>
<p>​    你看代码，你会发现，他是无法保证多个共享资源的并发安全。但是synchronized是可以的，可以对一段代码进行并发安全控制。</p>
<blockquote>
<p><strong>3.引出来ABA问题</strong></p>
</blockquote>
<p><img src="/2020/03/09/java基础核心技术/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200120150958113.png" alt="image-20200120150958113"></p>
<p><strong>什么是ABA问题</strong></p>
<p>cas算法实现的一个重要前提就是需要取出内存中某个时刻的数据并在当下时刻比较替换，那么在这个时间差内，会导致数据的变化。</p>
<p>比如说，一个线程从a从内存位置o中取出A，这个时候另一个线程b，也从内存中取出A，并且线程b进行了一些操作将主内存的A变成了B，然后线程b又将主内存中位置o的数据从B修改为了A。这个时候，线程a进行cas操作，发现主内存中仍然是A，然后线程a操作成功。</p>
<p>尽管线程a的cas操作成功，但是并不代表这个过程是没有问题的，也就是说cas值关注头尾，只要对应的上就操作成功。所以说ABA问题，是存在的，但是这个也不算是问题，因为有可能你的业务就是只关注头尾是否相同，中间不论发生什么，我都不在意。</p>
<p><strong>怎么解决ABA问题</strong></p>
<p>很明显，解决的思路就是，通过时间戳或者记录版本号的方式，只要修改一次版本号就记录一次，自增1。</p>
<p>实现方式就是通过，AtomicStampedReference，类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Description: ABA问题的解决</div><div class="line"> **/</div><div class="line">public class ABADemo &#123;</div><div class="line">    private static AtomicReference&lt;Integer&gt; atomicReference=new AtomicReference&lt;&gt;(100);//通过atomicReference演示ABA问题的产生</div><div class="line">    </div><div class="line">    private static AtomicStampedReference&lt;Integer&gt; stampedReference=new AtomicStampedReference&lt;&gt;(100,1);//通过stampedReference演示ABA的解决方案</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;===以下是ABA问题的产生===&quot;);</div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            atomicReference.compareAndSet(100,101);</div><div class="line">            atomicReference.compareAndSet(101,100);</div><div class="line">        &#125;,&quot;t1&quot;).start();</div><div class="line"></div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            //先暂停1秒 也即是保证t1线程先执行 保证完成ABA。</div><div class="line">            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line">            System.out.println(atomicReference.compareAndSet(100, 2019)+&quot;\t&quot;+atomicReference.get());</div><div class="line">        &#125;,&quot;t2&quot;).start();</div><div class="line">        try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line">        //很明显t2是可以修改成功的，因为这里他并不关注ABA的出现，只关注头尾，因为最开始</div><div class="line">        </div><div class="line">        </div><div class="line">        System.out.println(&quot;===以下是ABA问题的解决===&quot;);</div><div class="line"></div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            int stamp = stampedReference.getStamp();</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 第1次版本号&quot;+stamp+&quot;\t值是&quot;+stampedReference.getReference());</div><div class="line">            //暂停1秒钟t3线程</div><div class="line">            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line"></div><div class="line">            stampedReference.compareAndSet(100,101,stampedReference.getStamp(),stampedReference.getStamp()+1);</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 第2次版本号&quot;+stampedReference.getStamp()+&quot;\t值是&quot;+stampedReference.getReference());</div><div class="line">            stampedReference.compareAndSet(101,100,stampedReference.getStamp(),stampedReference.getStamp()+1);</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 第3次版本号&quot;+stampedReference.getStamp()+&quot;\t值是&quot;+stampedReference.getReference());</div><div class="line">        &#125;,&quot;t3&quot;).start();</div><div class="line"></div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            int stamp = stampedReference.getStamp();</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 第1次版本号&quot;+stamp+&quot;\t值是&quot;+stampedReference.getReference());</div><div class="line">            //保证线程3完成1次ABA</div><div class="line">            try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line">            boolean result = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1);</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 修改成功否&quot;+result+&quot;\t最新版本号&quot;+stampedReference.getStamp());</div><div class="line">            System.out.println(&quot;最新的值\t&quot;+stampedReference.getReference());</div><div class="line">        &#125;,&quot;t4&quot;).start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">===以下是ABA问题的产生===</div><div class="line">true	2019</div><div class="line">===以下是ABA问题的解决===</div><div class="line">t3	 第1次版本号1	值是100</div><div class="line">t4	 第1次版本号1	值是100</div><div class="line">t3	 第2次版本号2	值是101</div><div class="line">t3	 第3次版本号3	值是100</div><div class="line">t4	 修改成功否false	最新版本号3</div><div class="line">最新的值	100</div></pre></td></tr></table></figure>
<h2 id="atomic包下的工具类，都是基于CAS实现线程安全"><a href="#atomic包下的工具类，都是基于CAS实现线程安全" class="headerlink" title="atomic包下的工具类，都是基于CAS实现线程安全"></a>atomic包下的工具类，都是基于CAS实现线程安全</h2><h1 id="ArrayList线程不安全解决"><a href="#ArrayList线程不安全解决" class="headerlink" title="ArrayList线程不安全解决"></a>ArrayList线程不安全解决</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class ArrayListTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">		for (int i = 0; i &lt; 30; i++) &#123;</div><div class="line">			new Thread(new Runnable() &#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					list.add(UUID.randomUUID().toString().substring(0, 8));</div><div class="line">					System.out.println(list);</div><div class="line">				&#125;</div><div class="line">			&#125;, String.valueOf(i)).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>30个线程，共同操作list，那么就会出现下面的问题：<code>Exception in thread &quot;10&quot; Exception in thread &quot;26&quot; java.util.ConcurrentModificationException</code></p>
<p>多个线程，进行add数据的时候，可能会报这个错误</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200119173919024.png" alt="image-20200119173919024"></p>
<p>这种情况就是因为add方法，可以让多个线程同时执行，那么某个线程正在写入list数组的某个下标时，其他写成也可能在下入同一个下标，那么这个时候就会触发并发修改异常。</p>
<p><strong>那么怎么解决呢？</strong></p>
<p>备选方案，使用Vector，vector提供了synchronized修饰的方法，需要加锁，并发能力下降。</p>
<p>我们可以使用    Collections.synchronizedList(list)，通过传递一个list，然后他会返回一个线程安全的list给你，实际上返回的线程安全list内部实现，就是通过在方法内部加上synchronized的方式实现线程安全，他跟vector是一样的。</p>
<p>以上两个方案，如果公司都不建议使用，那么可以使用下面的类。</p>
<p>我们推荐使用 CopyOnWriteArrayList 类。查看他的add方法</p>
<pre><code>/**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return {@code true} (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>发现他实际上就是通过ReentrantLock进行加锁和解锁，很简单，所以他能够解决并发问题。</p>
<p>我们在深入的看一下CopyOnWriteArrayList的源码：</p>
<pre><code>/** The lock protecting all mutators */
final transient ReentrantLock lock = new ReentrantLock();

/** The array, accessed only via getArray/setArray. */
private transient volatile Object[] array;
</code></pre><p>可以看到他的成员属性有这两个，一个加锁的实例对象，一个保存list数据的 volatile类型的数组。</p>
<h2 id="同理hashset和hashmap也是线程不安全的"><a href="#同理hashset和hashmap也是线程不安全的" class="headerlink" title="同理hashset和hashmap也是线程不安全的"></a>同理hashset和hashmap也是线程不安全的</h2><p>那么他们的解决方案，其实跟ArrayList是一样的。</p>
<p>hashset线程不安全解决的方案是，可以使用Collections生成线程安全的set，那么也是可以使用CopyOnWriteArraySet（你会发现，他底层依赖的就是CopyOnWriteArrayList实现）。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200121154028153.png" alt="image-20200121154028153"></p>
<p>hashmap的解决方案是：可以使用hashtable，或者Collections集合类生成 线程安全的map，那么也是可以使用ConcurrentHashMap</p>
<p><strong>特别提示：hashset的底层实现是hashmap，但是hashset的add方法参数只有一个，hashmap的入参是一个k-v键值对，怎么回事？</strong></p>
<p><strong>原来hashset的k就是add方法的入参，但是我们只关注k，所以value的值，是一个恒定使用final修饰的new Object()对象。</strong></p>
<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><p>请查看&lt;面试突击第三季.md&gt;里面有完整分析</p>
<h1 id="公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解-请手写一个自旋锁"><a href="#公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解-请手写一个自旋锁" class="headerlink" title="公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解?请手写一个自旋锁"></a>公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解?请手写一个自旋锁</h1><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁<br>    是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到。<br>非公平锁<br>    是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象。</p>
<p>  <strong>并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Creates an instance of &#123;@code ReentrantLock&#125;.</div><div class="line"> * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</div><div class="line"> */</div><div class="line">public ReentrantLock() &#123;</div><div class="line">    sync = new NonfairSync();//Nonfair 默认是非公平锁 。</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Creates an instance of &#123;@code ReentrantLock&#125; with the</div><div class="line"> * given fairness policy.</div><div class="line"> *</div><div class="line"> * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</div><div class="line"> */</div><div class="line">public ReentrantLock(boolean fair) &#123;</div><div class="line">    sync = fair ? new FairSync() : new NonfairSync();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>synchronized和默认创建的lock都是非公平锁。</strong></p>
<h2 id="可重入锁-又名递归锁"><a href="#可重入锁-又名递归锁" class="headerlink" title="可重入锁(又名递归锁)"></a>可重入锁(又名递归锁)</h2><p><img src="/2020/03/09/java基础核心技术/image-20200121163129464.png" alt="image-20200121163129464"></p>
<p><strong>也就是说，同步方法内部，再去访问另一个同步方法，可以不用再请求锁，只需要记录重入次数即可，释放锁后减少重入次数即可 。（好处是这样就不会死锁）</strong></p>
<p><strong>ReentrantLock/synchronized就是一个典型的可重入锁</strong>。</p>
<p><strong>可重入锁最大的作用就是避免死锁</strong></p>
<p>例子一：使用synchronized实现可重入锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.cas;</div><div class="line"></div><div class="line">class Phone&#123;</div><div class="line">    public synchronized void sendSms() throws Exception&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot;\tsendSms&quot;);</div><div class="line">        sendEmail();</div><div class="line">    &#125;</div><div class="line">    public synchronized void sendEmail() throws Exception&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot;\tsendEmail&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">/**</div><div class="line"></div><div class="line"> *  也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块</div><div class="line"> **/</div><div class="line"></div><div class="line">public class ReenterLockDemo &#123;</div><div class="line">	 public static void main(String[] args) &#123;</div><div class="line">	        Phone phone = new Phone();</div><div class="line">	        new Thread(()-&gt;&#123;</div><div class="line">	            try &#123;</div><div class="line">	                phone.sendSms();</div><div class="line">	            &#125; catch (Exception e) &#123;</div><div class="line">	                e.printStackTrace();</div><div class="line">	            &#125;</div><div class="line">	        &#125;,&quot;t1&quot;).start();</div><div class="line">	        new Thread(()-&gt;&#123;</div><div class="line">	            try &#123;</div><div class="line">	                phone.sendSms();</div><div class="line">	            &#125; catch (Exception e) &#123;</div><div class="line">	                e.printStackTrace();</div><div class="line">	            &#125;</div><div class="line">	        &#125;,&quot;t2&quot;).start();</div><div class="line">	    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">t1	sendSms</div><div class="line">t1	sendEmail</div><div class="line">t2	sendSms</div><div class="line">t2	sendEmail</div></pre></td></tr></table></figure>
<p>​    很明显sendSms是一个同步方法，在sendSms（外层函数）内部调用的sendEmail（内层函数）也是一个同步方法。那么假设线程获取锁后能够进入sendSms方法，那么在调用sendSms方法的时候，就不需要再申请锁了，所以锁时可以重复使用的，即是，可重入锁。</p>
<p><strong>sendSms和sendEmail都是请求同一个锁资源（this），那么假设没有重入锁。程序运行，t1线程获取锁资源成功，那么执行 phone.sendSms()，接着调用sendEmail()方法，那么因为sendSms()还占据着this锁，很明显在调用sendEmail时会阻塞，sendEmail方法会等待sendSms方法释放资源，但是sendSms方法要等sendEmail方法执行完才释放资源，相互等待，产生死锁。</strong></p>
<p><strong>举个例子，你能用锁进入你家，那么进入你家的厕所，肯定是可以的，也就不要再开锁了。</strong></p>
<p><strong>需要注意的是：sendSms和sendSms本质上请求的都是同一把锁（Phone.class），所以是可以重入的。</strong></p>
<p>例子二：使用Lock演示可重入锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Phone implements Runnable &#123;</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void get() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\tget&quot;);</div><div class="line">            set();</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void set() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\tset&quot;);</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class ReenterLockDemo &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Phone phone = new Phone();</div><div class="line">        Thread t3 = new Thread(phone);</div><div class="line">        Thread t4 = new Thread(phone);</div><div class="line">        t3.start();</div><div class="line">        t4.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Thread-0	get</div><div class="line">Thread-0	set</div><div class="line">Thread-1	get</div><div class="line">Thread-1	set</div></pre></td></tr></table></figure>
<h2 id="自旋锁-似锁非锁"><a href="#自旋锁-似锁非锁" class="headerlink" title="自旋锁 似锁非锁"></a>自旋锁 似锁非锁</h2><p>我们之前，学过Unsafe和cas，就已经接触过自旋锁。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200121170115696.png" alt="image-20200121170115696"></p>
<p>也就是说：<strong>自旋锁实现的本质，就是通过while循环加上cas方法实现。</strong></p>
<p>其实自旋锁，也可以说，不是锁，这样说的很绕。我们先回顾一下，我们之前学习的，内部锁（synchronized）和显示锁（lock），当多个线程访问共享资源时，只有一个线程能够获取锁，然后进入临界区，操作逻辑。那么这个时候其他锁，是在锁池等待，<strong>是阻塞的</strong>。也就是说，其他线程，根本没有进入临界区的机会。</p>
<p>但是自旋锁，不一样，他是<strong>允许所有</strong>，线程都进入临界区，<strong>操作共享资源数据</strong>，<strong>没有线程是阻塞的</strong>。他实际上就是乐观锁的意思，就是先尝试修改数据，如果不行再请求锁。</p>
<p>他是通过cas硬件原语的，机制，来实现，原子性。通过比较预期值和实际值是否一致，来决定是否做更新操作。如果一致，那么更新值，while循环结束，返回true，线程结束。</p>
<p>如果不一致，那么while循环，持续判断，直到判断成功。</p>
<h3 id="实现一个自旋锁"><a href="#实现一个自旋锁" class="headerlink" title="实现一个自旋锁"></a>实现一个自旋锁</h3><p>那么我们知道，自旋锁的本质就是，<strong>while加上cas</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.zixuan;</div><div class="line"></div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line">import java.util.concurrent.atomic.AtomicReference;</div><div class="line"></div><div class="line">public class SpinLockDemo &#123;</div><div class="line">	//原子引用线程</div><div class="line">	AtomicReference&lt;Thread&gt; reference = new AtomicReference&lt;&gt;();//我们知道，他的底层是private volatile V value; 存储共享资源，也就是说，这段代码执行完成后，value的值是null。因为没有赋值</div><div class="line"></div><div class="line">	public void myLock() &#123;</div><div class="line">		Thread currentThread = Thread.currentThread();</div><div class="line">		System.out.println( currentThread.getName() + &quot; 开始加锁 。。。 &quot; );</div><div class="line">		//自旋锁核心逻辑</div><div class="line">		//通过cas比较，获取锁</div><div class="line">		//他的核心逻辑是：只要当前reference的值跟预期值一样都是null，那么我就把reference的值设置为当前线程，也就意味着，当前线程成功取到了锁，成功进行了资源操作。</div><div class="line">		//那么如果返回true，那么就不需要进行while循环，所以这里是用!取反，只要不满足，就一直死循环，直到满足未知。</div><div class="line">		while( !reference.compareAndSet(null, currentThread) ) &#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void myUnLock() &#123;</div><div class="line">		Thread currentThread = Thread.currentThread();</div><div class="line">		System.out.println( currentThread.getName() + &quot; 开始解锁 。。。 &quot; );</div><div class="line">		//这个意思就是，当前线程操作完了逻辑，那么解锁操作，也要比对一下。</div><div class="line">		//如果reference的值是当前线程，那么就解锁，加锁完成后把reference更新为null，这样才能够让下一个线程继续加锁。</div><div class="line">		reference.compareAndSet(currentThread, null);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpinLockDemo spinLockDemo = new SpinLockDemo();</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				//开始占用锁</div><div class="line">				spinLockDemo.myLock();</div><div class="line">				//处理业务逻辑，这里假设处理业务逻辑需要5s，这样也能在A线程处理业务的同时，B线程</div><div class="line">				//也进入加锁逻辑，这样才能判断自旋锁是否成功</div><div class="line">				try &#123;</div><div class="line">					TimeUnit.SECONDS.sleep(5);</div><div class="line">					System.out.println( Thread.currentThread().getName() +&quot;  执行完毕。。&quot; );</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				//解锁</div><div class="line">				spinLockDemo.myUnLock();</div><div class="line">			&#125;</div><div class="line">		&#125;, &quot;A&quot;).start();</div><div class="line">		</div><div class="line">		//这里暂停1s的目的就是，让main线程暂停1s，保证A线程先启动运行。接着启动B线程</div><div class="line">		try &#123;</div><div class="line">			TimeUnit.SECONDS.sleep(1);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				//开始占用锁</div><div class="line">				spinLockDemo.myLock();</div><div class="line">				//解锁</div><div class="line">				spinLockDemo.myUnLock();</div><div class="line">			&#125;</div><div class="line">		&#125;, &quot;B&quot;).start();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A 开始加锁 。。。 </div><div class="line">B 开始加锁 。。。 </div><div class="line">A  执行完毕。。</div><div class="line">A 开始解锁 。。。 </div><div class="line">B 开始解锁 。。。</div></pre></td></tr></table></figure>
<p>可以看到，虽然A、B同时加锁，但是最终只有A线程获取了锁，那么也就意味着，线程B在while循环里面自旋。直到线程A执行完，业务逻辑后，解锁。线程Bwhile循环结束，获取锁，然后执行业务逻辑，最后解锁。</p>
<h2 id="独占锁-写锁-共享锁-读锁-互斥锁"><a href="#独占锁-写锁-共享锁-读锁-互斥锁" class="headerlink" title="独占锁(写锁)/共享锁(读锁)/互斥锁"></a>独占锁(写锁)/共享锁(读锁)/互斥锁</h2><p><img src="/2020/03/09/java基础核心技术/image-20200122100331106.png" alt="image-20200122100331106"></p>
<p>那么既然有了ReentrantLock，为什么还需要读写锁（ReentrantReadWriteLock）呢？为了更细致化的使用锁，实现读写分离。</p>
<p>我们知道ReentrantLock是不管什么操作逻辑，只要进入临界区访问共享资源，那么就会加锁，也就意味着，假设，我只是想读共享资源而已，那么还要去申请锁？这个就有点不符合道理了。<strong>这样会造成什么问题呢？多线程情况下读取资源，还需要等锁，那这个并发量就下降了，而且也没有必要加锁。</strong></p>
<p><strong>也就是说</strong></p>
<p><strong>为了并发量，可以允许多个线程同时进行读取共享资源，但是，如果有一个线程想去写共享资源， 那么就不应该有其他线程对资源进行读或写。</strong></p>
<p>代码例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.cas;</div><div class="line"></div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 资源类</div><div class="line"> */</div><div class="line">class MyCaChe &#123;</div><div class="line">    /**</div><div class="line">     * 保证可见性</div><div class="line">     */</div><div class="line">    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</div><div class="line">    private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 写</div><div class="line">     *</div><div class="line">     * @param key</div><div class="line">     * @param value</div><div class="line">     */</div><div class="line">    public void put(String key, Object value) &#123;</div><div class="line">        reentrantReadWriteLock.writeLock().lock();</div><div class="line">        try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t正在写入的key是：&quot; + key);</div><div class="line">            //模拟网络延时</div><div class="line">            try &#123;</div><div class="line">                TimeUnit.MICROSECONDS.sleep(300);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            map.put(key, value);</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 写入完成&quot;);</div><div class="line">        &#125; finally &#123;</div><div class="line">            reentrantReadWriteLock.writeLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 读</div><div class="line">     *</div><div class="line">     * @param key</div><div class="line">     */</div><div class="line">    public void get(String key) &#123;</div><div class="line">        reentrantReadWriteLock.readLock().lock();</div><div class="line">        try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t正在读取&quot;);</div><div class="line">            //模拟网络延时</div><div class="line">            try &#123;</div><div class="line">                TimeUnit.MICROSECONDS.sleep(300);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            Object result = map.get(key);</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t读取完成 &quot; + result);</div><div class="line">        &#125; finally &#123;</div><div class="line">            reentrantReadWriteLock.readLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void clearCaChe() &#123;</div><div class="line">        map.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Description:</div><div class="line"> * 多个线程同时操作 一个资源类没有任何问题 所以为了满足并发量</div><div class="line"> * 读取共享资源应该可以同时进行</div><div class="line"> * 但是</div><div class="line"> * 如果有一个线程想去写共享资源来  就不应该有其他线程可以对资源进行读或写</div><div class="line"> * &lt;p&gt;</div><div class="line"> * 小总结:</div><div class="line"> * 读 读能共存</div><div class="line"> * 读 写不能共存</div><div class="line"> * 写 写不能共存</div><div class="line"> * 写操作 原子+独占 整个过程必须是一个完成的统一整体 中间不允许被分割 被打断</div><div class="line"> *</div><div class="line"> **/</div><div class="line">public class ReadWriteLockDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyCaChe myCaChe = new MyCaChe();</div><div class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</div><div class="line">            final int temp = i;</div><div class="line">            new Thread(() -&gt; &#123;</div><div class="line">                myCaChe.put(temp + &quot;&quot;, temp);</div><div class="line">            &#125;, String.valueOf(i)).start();</div><div class="line">        &#125;</div><div class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</div><div class="line">            int finalI = i;</div><div class="line">            new Thread(() -&gt; &#123;</div><div class="line">                myCaChe.get(finalI + &quot;&quot;);</div><div class="line">            &#125;, String.valueOf(i)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1	正在写入的key是：1</div><div class="line">1	 写入完成</div><div class="line">2	正在写入的key是：2</div><div class="line">2	 写入完成</div><div class="line">3	正在写入的key是：3</div><div class="line">3	 写入完成</div><div class="line">5	正在写入的key是：5</div><div class="line">5	 写入完成</div><div class="line">4	正在写入的key是：4</div><div class="line">4	 写入完成</div><div class="line">1	正在读取</div><div class="line">2	正在读取</div><div class="line">3	正在读取</div><div class="line">4	正在读取</div><div class="line">5	正在读取</div><div class="line">1	读取完成 1</div><div class="line">2	读取完成 2</div><div class="line">5	读取完成 5</div><div class="line">3	读取完成 3</div><div class="line">4	读取完成 4</div></pre></td></tr></table></figure>
<p>你会发现，写操作，都是原子性，没有中断（正在写入和写入完成是一对出现）。中间不会存在其他线程的读取或者写入。</p>
<p>读取的时候，是可以多个线程进行读取，你会发现，读取完成和读取结束并不是一对出现，这个是允许的，因为不需要原子性。</p>
<p><strong>所以满足读写锁的要求。</strong></p>
<h1 id="CountDownLatch-CyclicBarrier-Semaphore"><a href="#CountDownLatch-CyclicBarrier-Semaphore" class="headerlink" title="CountDownLatch/CyclicBarrier/Semaphore"></a>CountDownLatch/CyclicBarrier/Semaphore</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是基于AQS的阻塞工具，阻塞一个或者多个线程，直到所有的线程都执行完成。</p>
<blockquote>
<p><strong>CountDownLatch解决了什么问题</strong></p>
</blockquote>
<p>当一个任务运算量比较大的时候，需要拆分为各种子任务，必须要所有子任务完成后才能汇总为总任务。<br>使用并发模拟的时候可以使用CountDownLatch.也可以设置超时等待时间。同时CountDownLatch也提供了可以设置超时等待的await方法。</p>
<p>让一些线程阻塞直到另外一些完成后才被唤醒。类似于wait和notify。</p>
<p>CountDownLatch主要有两个方法,当一个或多个线程调用await方法时,调用线程会被阻塞.其他线程调用countDown方法计数器减1(调用countDown方法时线程不会阻塞),当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行</p>
<blockquote>
<p><strong>举个例子：</strong></p>
</blockquote>
<p>​    假设，教室中有七个人，其中六个人是同学，一个是班长，班长要等这六个人都出教室了，然后再关门，那么这种等待其他子线程完成后主线程才操作的就很适合使用CountDownLatch。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CountDownLatchDemo &#123;</div><div class="line">	static CountDownLatch countDownLatch = new   CountDownLatch(6);</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		 for (int i = 1; i &lt;= 6; i++) &#123;</div><div class="line">	            new Thread(() -&gt; &#123;</div><div class="line">	                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + &quot;上完自习&quot;);</div><div class="line">	                countDownLatch.countDown();</div><div class="line">	            &#125;, String.valueOf(i)).start();</div><div class="line">	        &#125;</div><div class="line">	        countDownLatch.await();//挂起main线程，等到countDownLatch减到0时，main线程被唤醒</div><div class="line">	        //也就意味着，要等前面六个线程执行完毕后才会唤醒main线程</div><div class="line">	        System.out.println(Thread.currentThread().getName() + &quot;\t班长锁门离开教室&quot;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><blockquote>
<p><strong>例子</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">public class CDL extends Thread &#123;</div><div class="line">	</div><div class="line"></div><div class="line">	public CDL(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static CountDownLatch countDownLatch = new   CountDownLatch(1); </div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		try &#123;</div><div class="line">			countDownLatch.await();</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println( Thread.currentThread().getName() + &quot; 执行 &quot; );</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		for (int i = 0; i &lt;3; i++) &#123;</div><div class="line">			new CDL(String.valueOf(i)).start();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println( &quot;123 &quot; );</div><div class="line">		countDownLatch.countDown();</div><div class="line">		System.out.println( &quot;345 &quot; );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道CountDownLatch是 基于共享锁的形式，建立阻塞队列。也就是 Node.SHARE，意味着，多个线程可以同时阻塞在countDownLatch.await()，等到计数器减到0时，多个线程会同时进行执行await后面的代码。</p>
<p><strong>他跟 ReentrantLock不同，lock采用的是独占锁的方式，Node.EXCLUSIVE，在某个时刻，只能够允许一个线程在执行。</strong></p>
<p>​    <strong>所以共享锁的方式，更加的验证了，CountDownLatch的应用场景，在计数器未减少到0时，线程可以同时进行自己各自的业务代码，等计数器减少到0后，那么被await的线程唤醒，然后执行。</strong></p>
<p><strong>以下使用CDL简称CountDownLatch</strong></p>
<blockquote>
<p><strong>查看CDL构造函数</strong></p>
</blockquote>
<pre><code>public CountDownLatch(int count) {
    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);
    this.sync = new Sync(count);
}

        Sync(int count) {//Sync是CDL内部类，Sync继承了AQS
            setState(count);
        }
  这里可以看到，aqs的state属性，在CDL这里的含义是，计数器的数量。而不再是之前我们所说的是否获取锁的标志位/重入次数。被赋予了新的含义
</code></pre><blockquote>
<p><strong>1.查看await（）方法</strong></p>
</blockquote>
<p>java.util.concurrent.CountDownLatch.await()</p>
<pre><code>public void await() throws InterruptedException {//顾名思义，他是请求共享锁，并且可以响应中断

    sync.acquireSharedInterruptibly(1);
}
</code></pre><p>​<br>​        public final void AbstractQueuedSynchronizer.acquireSharedInterruptibly(int arg)<br>​                throws InterruptedException {<br>​            if (Thread.interrupted())<br>​                throw new InterruptedException();<br>​            if (tryAcquireShared(arg) &lt; 0)//首次进来，state一般是不等于0的，因为计数器还为减少到0，所以tryAcquireShared返回-1<br>​                doAcquireSharedInterruptibly(arg);<br>​        }</p>
<p>​<br>​<br>​            protected int tryAcquireShared(int acquires) {//如果计数器减少到0，那么返回1，否则返回-1<br>​                return (getState() == 0) ? 1 : -1;<br>​            }</p>
<p><strong>接着执行 doAcquireSharedInterruptibly 方法</strong></p>
<p>java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(int)</p>
<pre><code>/**
 * Acquires in shared interruptible mode.
 * @param arg the acquire argument
 */
private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);//这个就是将当前线程节点，放到aqs阻塞队列中。返回当前线程节点
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);//判断计数器state是否==0，如果是返回1，表示阻塞的线程可以开始唤醒执行
                if (r &gt;= 0) {
                    setHeadAndPropagate(node, r);//注意这里，这里会遍历整个aqs阻塞队列，然后逐个释放
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())//我们知道线程最终都会阻塞在这里
                throw new InterruptedException();//这里可以直接响应中断，直接抛出异常
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre><p>​    <strong>也就是说，实际上，await（）方法的最终目的就是：将所有调用await方法的线程，都放到aqs阻塞队列中，开始在阻塞。什么时候唤醒呢？等到计数器state==0，也就是countdown到0。</strong></p>
<p>​    <strong>我们发现他跟ReentrantLock整个加锁的流程是类似的，主要的区别在于，lock是独占锁，state表示的是锁标记。CDL在计数器到零后，会unpark所有在aqs阻塞队列的线程，而lock只会唤醒aqs阻塞队列首节点（所以说是独占锁）</strong></p>
<blockquote>
<p><strong>2.查看CDL的countDown（）</strong></p>
</blockquote>
<p>java.util.concurrent.CountDownLatch.countDown()</p>
<pre><code>public void countDown() {
    sync.releaseShared(1);
}
</code></pre><p>​<br>​        public final boolean AbstractQueuedSynchronizer.releaseShared(int arg) {<br>​            if (tryReleaseShared(arg)) {<br>​                doReleaseShared();<br>​                return true;<br>​            }<br>​            return false;<br>​        }</p>
<p><strong>首先调用tryReleaseShared（）方法，state减-1 </strong></p>
<p>java.util.concurrent.CountDownLatch.Sync.tryReleaseShared(int)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = getState();</div><div class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果返回true，说明state已经变为了0。那么需要唤醒阻塞的线程。</p>
<p><strong>接着调用doReleaseShared方法，释放共享锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;<span class="comment">//一个for循环。持续一个一个的唤醒aqs阻塞队列中节点</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                unparkSuccessor(h);<span class="comment">//释放锁，然后唤醒线程</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (h == head) <span class="comment">//循环唤醒aqs阻塞队列的线程，直到队列没有元素，那么跳出循环                  // loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>3.唤醒线程后</strong></p>
</blockquote>
<p>接着调用doAcquireSharedInterruptibly的parkAndCheckInterrupt，然后，继续执行for循环，然后执行 setHeadAndPropagate(node, r)方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">              parkAndCheckInterrupt())//我们知道线程最终都会阻塞在这里</div><div class="line">              throw new InterruptedException();//这里可以直接响应中断，直接抛出异常</div></pre></td></tr></table></figure>
<pre><code>private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);//将当前线程设置为头结点，这样的好处是，释放一个就将当前线程设置为头结点，然后再doReleaseShared方法中，总会触发 if (h == head)，这样才能够跳出doReleaseShared（）的for循环。唤醒所有阻塞队列线程结束。

    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
        (h = head) == null || h.waitStatus &lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();//接着唤醒，当前节点的下一个节点，以此类推。直到唤醒完所有的阻塞队列的节点。
    }
}
</code></pre><blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p>​    CDL使用共享锁（不需要竞争）的方式阻塞所有的线程，所有线程阻塞到阻塞队列中，直到countdown到0。就会去唤醒阻塞队列中<strong>所有线程</strong>（共享锁，不需要竞争）。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>例如zookeeper的server的启动挂起，唤醒关闭server就是利用CountDownLatch实现的。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>这个跟CountDownLatch是相反的，他是做加法，当增加到某一个值后，那么就会唤醒阻塞的线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CyclicBarrierDemo &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		CyclicBarrier barrier = new CyclicBarrier(7, () -&gt; &#123;System.out.println( &quot;增加到7了，被唤醒当前线程&quot; );&#125;);</div><div class="line">		</div><div class="line">		for (int i = 1; i &lt;  8; i++) &#123;</div><div class="line">			final int index = i;</div><div class="line">			 new Thread(() -&gt; &#123;</div><div class="line">				  System.out.println( &quot;开始执行业务 &quot; + Thread.currentThread().getName()  );</div><div class="line">				  </div><div class="line">				  try &#123;</div><div class="line">					barrier.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				  </div><div class="line">			 &#125;,String.valueOf(i)).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Semaphore-可以用作限流"><a href="#Semaphore-可以用作限流" class="headerlink" title="Semaphore - 可以用作限流"></a>Semaphore - 可以用作限流</h2><p><strong>它的本质实际上就是基于信号量（PV操作）的机制实现。</strong></p>
<p>信号量的主要用户两个目的，一个是用于多个共享资源的相互排斥使用，另一个用于并发资源数的控制。</p>
<p>​    也就是说，我们可以限制资源的数量（令牌），那么多个请求进来后，去争抢固定数量的令牌，如果令牌争抢完，后面还没有得到令牌的线程就会阻塞，直到后令牌释放，然后才会去争抢（争抢的过程中，也可以插队，也就是说Semaphore也是有公平锁和非公平锁的区分）</p>
<p>以下案例，模拟六辆车抢占三个车位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class SemaphoreDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //模拟3个停车位</div><div class="line">        Semaphore semaphore = new Semaphore(3);</div><div class="line">        //模拟6部汽车</div><div class="line">        for (int i = 1; i &lt;= 6; i++) &#123;</div><div class="line">            new Thread(() -&gt; &#123;</div><div class="line">                try &#123;</div><div class="line">                    //抢到资源，拿不到，那么就会阻塞在这里</div><div class="line">                    semaphore.acquire();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + &quot;\t抢到车位&quot;);</div><div class="line">                    try &#123;</div><div class="line">                        TimeUnit.SECONDS.sleep(3);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + &quot;\t 停3秒离开车位&quot;);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    //释放资源</div><div class="line">                    semaphore.release();</div><div class="line">                &#125;</div><div class="line">            &#125;, String.valueOf(i)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>很明显，Semaphore是可以替代，synchronized和lock的，只需要把信号量修改为1即可。因为内部锁和显示锁的本质就是抢占一个资源。</strong></p>
<p>而且我们发现，Semapore实际上是CountDownLatch和CyclicBarrier的结合体。CountDownLatch是减少到某个数然后唤醒某个线程，CyclicBarrier是新增到某个数，然后唤醒某个线程。</p>
<p>但是Semapore是有增有减，可以提供给多个线程功能抢占资源，线程使用完资源后，马上释放，然后另一个线程可以马上的抢占资源。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>​    你会发现，Semaphore获取资源的源代码跟COuntDownlatch基本上是一样的，也是通过共享锁的形式，进行资源的争抢（只不过他有公平和非公平两种实现方式，共享公平锁和共享非公平锁的区别跟ReentrantLock一样，公平锁多了hasQueuedPredecessors方法的判断）</p>
<h1 id="ConcurrentHashMap源码分析"><a href="#ConcurrentHashMap源码分析" class="headerlink" title="ConcurrentHashMap源码分析"></a>ConcurrentHashMap源码分析</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ConcurrentHashMap&lt;String, String&gt; chm = new ConcurrentHashMap&lt;&gt;();</div><div class="line">chm.put(&quot;kingge&quot;, &quot;123&quot;);</div></pre></td></tr></table></figure>
<p><strong>以下ConcurrentHashMap简称chm。</strong></p>
<p>​    <strong>我们阅读源码的原则是，第一时刻考虑如果是多线程访问时，这段代码会不会有问题。第二，不要通读所有代码，而是根据if条件或者其他条件，选择性的读取某段代码。</strong></p>
<h2 id="查看put操作"><a href="#查看put操作" class="headerlink" title="查看put操作"></a><strong>查看put操作</strong></h2><p>我们知道，map是通过数组+链表/红黑树的数据结构保存数据，其中数组是保存key经过hash后得到下标。</p>
<p><strong>在chm中，数组使用 transient volatile Node<k,v>[] table 实现。 </k,v></strong>  <strong>下面简称chm数组（如果不特别指定，那么数组，也代表chm数组）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//阅读时，要注意每个步骤的方法，他是如何保证线程安全的</span></div><div class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="comment">//chm的key和value不能为null，跟hashtable一样。hashmap是允许key和value为null</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());<span class="comment">//获取key对应 hash值，通过右移16位，再通过异或，保证高低16位的特征，这样在进行hash计算数组下标时，更加离散</span></div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<span class="comment">//一个死循环，进行put操作 </span></div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//首先判断数组是否为空，为空则进行初始化数组</span></div><div class="line">            tab = initTable();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;<span class="comment">//b1</span></div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">        &#125;<span class="comment">//end b1</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">// b12 区域</span></div><div class="line">            tab = helpTransfer(tab, f);<span class="comment">//当前节点是转移状态，说明，正在数组扩容，那么当前线程就需要帮助扩容 - 我们知道chm是支持多个线程同时进行扩容操作的</span></div><div class="line">        <span class="keyword">else</span> &#123;<span class="comment">// b2 区域</span></div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;<span class="comment">//直接锁住某个node数组下标，锁粒度细化，保证了其他下标能够被其他线程操作</span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        binCount = <span class="number">1</span>;<span class="comment">//当前数组下标节点，链表元素的个数。方便转化为红黑树进行判断，bincount &gt;= 7,进行单链表转化为红黑树</span></div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<span class="comment">//遍历插入链表中</span></div><div class="line">                            K ek;</div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<span class="comment">//key和hash值相等，那么更新value值即可</span></div><div class="line">                                oldVal = e.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="comment">// end synchronized</span></div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="comment">//end b2</span></div><div class="line">    &#125;<span class="comment">//end for</span></div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="initTable数组初始化工作-sizeCtl属性"><a href="#initTable数组初始化工作-sizeCtl属性" class="headerlink" title="initTable数组初始化工作 - sizeCtl属性"></a>initTable数组初始化工作 - sizeCtl属性</h3><p>首先我们要明确一点，多线程情况下，initTable()方法的调用是存在线程安全的，所以我们需要注意chm对于initTable()是如何保证线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)<span class="comment">//如果sizeCtl小于，表示数组已经初始化，那么就没有必要再次初始化数组，当前线程让出cpu，给其他线程执行，当前线程回到就绪状态</span></div><div class="line">，            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;<span class="comment">//可以看到这里是通过了cas保证了初始化数组的原子性，sizeCtl设置为-1</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;<span class="comment">//初始化数组,长度默认是16</span></div><div class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//关键点 ， 假设数组长度是16，那么sc=12，相当于n*0.75，</span></div><div class="line">                    <span class="comment">//那为什么这里要用n - (n &gt;&gt;&gt; 2) 呢？因为位运算比算术运算要快</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                sizeCtl = sc;<span class="comment">//sizeCtl = 12，这里sizeCtl被赋予了另外一种含义，表示下次数组扩容的数量</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了一个chm的一个非常重要的成员变量     <strong>private transient volatile int sizeCtl</strong></p>
<p>​    通过<code>U.compareAndSwapInt(this, SIZECTL, sc, -1)</code> cas操作，保证了高并发下只有一个线程能够进行初始化数组，比较sizeCtl是否跟预期值一致（等于0），如果是，那么把sizeCtl设置为-1，进入初始化数组逻辑。</p>
<p>​    否则cas失败，表示数组已经初始化，那么退出whil循环（此时table已经不为null），返回数组。</p>
<blockquote>
<p><strong>sizeCtl的三个作用</strong></p>
</blockquote>
<p><strong>通过上面的源码我们发现，是否已经初始化的数组是通过sizeCtl和cas来进行判断和操作的。而且sizeCtl一共有两个作用：sizeCtl  == -1 ，表示当前已经有线程抢到了初始化chm数组的权限、sizeCtl &gt; 0，sizeCtl=sc=n*0.75，表示下一次数组扩容大小。</strong></p>
<p>​    <strong>sizectl的第三个作用，当sizeCtl是负数，但不是-1，就表示当前有几个线程在进行扩容操作，例如sizeCtl=-2，表示有两个线程在执行扩容操作（ 关于第三个作用，在下面的addCount()方法的第二段if，里面会有用到 ）</strong></p>
<h3 id="tabat和casTabAt，获取key对应的数组下标"><a href="#tabat和casTabAt，获取key对应的数组下标" class="headerlink" title="tabat和casTabAt，获取key对应的数组下标"></a>tabat和casTabAt，获取key对应的数组下标</h3><p>同时这两个方法也是需要保证线程安全的。我们来看源代码。他们是怎么保证线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//////////初始化为数组后，for死循环，会执行到这段代码，获取key对应的数组下标</span></div><div class="line"><span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">            &#125;</div><div class="line">            </div><div class="line">  <span class="comment">////////////////为了避免高并发下，key被覆盖问题，那么需要保证tabAt的线程安全</span></div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//通过底层保证tabAt线程安全</span></div><div class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通过cas保证了 put操作的线程安全</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></div><div class="line"><span class="function"><span class="params">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="addCount-1L-binCount-最终执行"><a href="#addCount-1L-binCount-最终执行" class="headerlink" title="addCount(1L, binCount) 最终执行"></a>addCount(1L, binCount) 最终执行</h3><p>我们知道不管，put最终都会执行到addCount(1L, binCount)，顾名思义 ，就是计数的意思，新增put一条数据，那么size就会增1。</p>
<p>​    那么怎么保证高并发下，addCount方法线程安全呢？通过cas、加锁？虽然这两种方法都可以保证线程安全，但是会有性能影响。那么我们来看一下他是怎么进行线程安全控制的</p>
<p>​    他是怎么维护chm的size呢？</p>
<p>那么我们来看一下他的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;<span class="comment">//第一个传的就是1，表示增加chm元素个数，因为put一次元素个数肯定是自增1，所以 这里固定传1.那么第二个参数是是检查是否需要扩容的依据，一般是表示当前chm数组某个下标，构建的单链表的元素个数，根据该值判断是否需要扩容</span></div><div class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</div><div class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</div><div class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<span class="comment">//尝试对于basecount进行一次cas操作，如果失败，那么说明当前访问addCount方法的线程过多，为了避免无效的cas操作，浪费加剧cpu操作，那么往下执行，引入CounterCell数组，进行线程分流操作。</span></div><div class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</div><div class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</div><div class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</div><div class="line">            !(uncontended =</div><div class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</div><div class="line">            fullAddCount(x, uncontended);<span class="comment">//初始化CounterCell数组</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        s = sumCount();</div><div class="line">    &#125;<span class="comment">//size增加1</span></div><div class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;<span class="comment">//检查是否需要扩容</span></div><div class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</div><div class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<span class="comment">//判断s当前chm元素个数，是否大于sizectl（这里等于12，因为此时sizectl得知是在initTable()方法中进行初始化的），且chm数组不为空，且chm数组长度不大于最大值。</span></div><div class="line">            <span class="keyword">int</span> rs = resizeStamp(n);<span class="comment">//</span></div><div class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                    transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</div><div class="line">                transfer(tab, <span class="keyword">null</span>);</div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// </span></div><div class="line"></div><div class="line">ThreadLocalRandom.getProbe() &amp; m <span class="comment">//ThreadLocalRandom.getProbe() ，获得一个随机数，然后跟counterCells数组长度进行与运算，最终获得某个线程需要操作counterCells数组哪个下标的位置。起到分流作用，降低无效cas操作</span></div><div class="line">    <span class="comment">//这样那么多个线程会被分配到不同的数组下标，然后取到数组下标已经存在的value值，再进行cas自增1。完成本次的chm元素数量增加1操作</span></div></pre></td></tr></table></figure>
<p>结论：</p>
<p>   <strong>chm的size，数据个数，是通过chm的baseCount和counterCells这两个成员属性来进行控制的或者说得到的。</strong></p>
<p>​    首先我们回顾一下，hashmap或者arrayList，都是通过一个成员属性size来进行元素个数的维护，那么为什么chm不通过这样的方式来维护元素个数呢？</p>
<p>​    实际上，chm是通过这样的策略进行元素个数的维护：</p>
<p>​         <strong>如果在线程数不是很多的情况下，那么对baseCount进行cas操作，自增1，实现元素数量的增加维护。</strong></p>
<p>​        <strong>但是假设是高并发情况下或者说对于baseCount的cas操作失败，那么就会增加一个counterCells数组来进行高并发下分流操作，避免无效的cas操作。</strong></p>
<p>​        <strong>总而言之，在对chm元素数量自增1的时候，会尝试进行一次对baseCount进行cas的自增操作，假设失败，马上使用counterCells数组进行数组元素的维护。</strong></p>
<blockquote>
<p><strong>下面详细分析</strong></p>
</blockquote>
<p>​    首先我们假设chm只通过baseCount，来进行元素个数的维护，那么在put一条数据的时候，我们知道baseCount需要自增1，那么为了线程安全，baseCount的自增需要通过加锁或者cas的方式进行，一般使用cas。</p>
<p>​    那么如果使用只使用baseCount来维护chm元素个数，那么进行cas自增1的时候就会面临一个问题，假设高并发情况下，多个线程同时执行put操作，cas只能够运行一个线程修改成功，那么其他线程就会做没有意义的cas操作，线程多的情况下，cpu压力会上升。</p>
<p>​    那么怎么改变这种情况呢？<strong>那就是引入分段的概念，就是可以让多个线程执行同时执行cas自增操作，类似于部署多个节点，支持高并发。那么就引出了counterCells数组，每个数组位置，都保存一个value值，表示chm元素个数，这样求得整个chm元素个数的时候，只需要遍历counterCells数组然后累加再加上baseCount就等于chm元素个数（详情查看chm的size()方法）</strong></p>
<p>​    <strong>那么引入后上面的高并发cas的问题，怎么解决了呢？</strong></p>
<p>​    假设counterCells数组初始化为2，那么假设有三个线程，put操作完，三个线程需要调用addCount增加元素个数。那么就会给这三个线程，随机分配一个关于counterCells数组的下标，让他们各自去数组下标的位置，进行自增1操作。那么这样就起到了分流的作用，这样就减少了无效cas的个数。</p>
<p>​    <strong>也就是说，CounterCell数组，保存了chm的元素个数。</strong></p>
<p>为了加深上面的理论，我们查看一下chm的size() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> n = sumCount();</div><div class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</div><div class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</div><div class="line">            (<span class="keyword">int</span>)n);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        CounterCell[] as = counterCells; CounterCell a;</div><div class="line">        <span class="keyword">long</span> sum = baseCount;</div><div class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;<span class="comment">//遍历CounterCell数组，累加里面的个数，再加上baseCount，就是整个chm元素个数</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</div><div class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</div><div class="line">                    sum += a.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="fullAddCount（）初始化counterCells数组"><a href="#fullAddCount（）初始化counterCells数组" class="headerlink" title="fullAddCount（）初始化counterCells数组"></a>fullAddCount（）初始化counterCells数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// See LongAdder version for explanation</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</div><div class="line">         ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></div><div class="line">         h = ThreadLocalRandom.getProbe();</div><div class="line">         wasUncontended = <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></div><div class="line">     <span class="keyword">for</span> (;;) &#123;</div><div class="line">         CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</div><div class="line">          <span class="keyword">if</span>()&#123;<span class="comment">//先忽略这部分代码，判断counterCells数组是否为空</span></div><div class="line">            ......<span class="comment">//不为空则执行这部分代码</span></div><div class="line">          &#125;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</div><div class="line">                  U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//cellsBusy==0,那么当前线程获取锁，得到执行当前counterCells数组的机会，并将cellsBusy设置为1</span></div><div class="line">             <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</div><div class="line">             <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></div><div class="line">                 <span class="keyword">if</span> (counterCells == as) &#123;</div><div class="line">                     CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];<span class="comment">//初始化一个两个数量的CounterCell数组</span></div><div class="line">                     rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);<span class="comment">//因为CounterCell数组长度为 2，所以我们为了获取当前线程分配到所需要操作的CounterCell数组下标，那么要进行，（h &amp; 1，随机数&amp;1），因为长度为2的数组，最终有两个结果，那就是0或者1。</span></div><div class="line">                     counterCells = rs;</div><div class="line">                     init = <span class="keyword">true</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                 cellsBusy = <span class="number">0</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (init)</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</div><div class="line">             <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>首先我们要知道，counterCells数组某个下标也会存在线程安全问题，因为，可能有多个线程通过随机数&amp;m的计算得到了，相同的数组下标。为了避免自增的线程安全，所需要也是需要进行加锁控制。</p>
<p>​    这里是通过chm的成员属性cellsBusy，进行数组下标锁的控制，默认是0，通过cas判断，当前数组下标是否存在操作的线程，如果不存在则把cellsBusy设置为1（<code>U.compareAndSwapInt(this, CELLSBUSY, 0, 1)</code>），然后执行里面的业务操作 .</p>
<h4 id="resizeStamp-扩容操作"><a href="#resizeStamp-扩容操作" class="headerlink" title="resizeStamp() 扩容操作"></a>resizeStamp() 扩容操作</h4><p>扩容操作的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;<span class="comment">//检查是否需要扩容</span></div><div class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</div><div class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<span class="comment">//判断s当前chm元素个数，是否大于sizectl（这里等于12，因为此时sizectl得知是在initTable()方法中进行初始化的），且chm数组不为空，且chm数组长度不大于最大值。</span></div><div class="line">            <span class="keyword">int</span> rs = resizeStamp(n);<span class="comment">//获得一个值，此时n是16，那么返回的是32795，得到一个唯一的扩容戳</span></div><div class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;<span class="comment">//这里的sc==sizeCtl==12，所以首次进来时，那么if判断不满足。但是当第二个线程进来后，发现sc已经是一个负数（因为此前已经被(U.compareAndSwapInt(this, SIZECTL, sc,(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) 设置为负数），满足条件，进入逻辑</span></div><div class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                    transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                    transfer(tab, nt);<span class="comment">//扩容操作</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))<span class="comment">//sc &gt;= 0 执行cas操作。将sc设置为一个负数。</span></div><div class="line">                transfer(tab, <span class="keyword">null</span>);<span class="comment">//扩容操作</span></div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//返回无符号整型i的最高非零位前面的0的个数，包括符号位在内；如果i为负数，这个方法将会返回0，符号位为1.比如说，10的二进制表示为 0000 0000 0000 0000 0000 0000 0000 1010，java的整型长度为32位。那么这个方法返回的就是28（32-4，因为10的最高非零是第四位的1，他前面还有28个0 - 即是：0000 0000 0000 0000 0000 0000 0000）</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此时通过resizeStamp(16)得到的值是32795，二进制是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">else if (U.compareAndSwapInt(this, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))//sc &gt;= 0 执行cas操作。</div><div class="line">                                         </div><div class="line"></div><div class="line">0000 ‭0000 ‭0000 ‭0000 ‭1000 0000 0001 1011‬ 然后rs &lt;&lt; RESIZE_STAMP_SHIFT，表示左移16位</div><div class="line">1000 0000 0001 1011‬ 0000 ‭0000 ‭0000 ‭0000 也就是相当于低十六位移动到高十六位，接着+2</div><div class="line">1000 0000 0001 1011‬ 0000 ‭0000 ‭0000 ‭0010 </div><div class="line"></div><div class="line">高十六位代表扩容的标记，低十六位代表参加扩容的线程数（需要注意的是chm的扩容是可以多个线程并行扩容的，所以这里要记录参与扩容操作的线程数），也就是说，这里的+2，就表示当前有1个线程在扩容。</div><div class="line"></div><div class="line">最终通过cas把扩容戳转化为如上的数值，他是一个负数，执行cas成功，那么接着在执行扩容操作：  transfer(tab, null);</div></pre></td></tr></table></figure>
<p><strong>需要注意的是chm的扩容是可以多个线程并行扩容的，所以才需要通过sc的低十六位来记录参与扩容操作的线程个数！！！！！！！！！！！！！！</strong></p>
<h4 id="transfer-扩容操作"><a href="#transfer-扩容操作" class="headerlink" title="transfer() 扩容操作"></a>transfer() 扩容操作</h4><p>我们知道扩容操作，要做的事情就两件：</p>
<ul>
<li>增加chm数组的长度</li>
<li>转移原数组的节点到新数组 - 数据转移（这一步支持多个线程同时操作，提升效率）</li>
</ul>
<p>因为方法比较长，所以在这里我们需要进行分段分析。为了方便分析，<strong>我们这里假设chm原数组长度是32</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> n = tab.length, stride;<span class="comment">// n == 32</span></div><div class="line">      <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">          stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></div><div class="line">    <span class="comment">//NCPU是等于电脑cpu核数，我这里是4，所有NCPU=4，这里n还是32，那么stride = (4 &gt; 1) ? (32&gt;&gt;&gt; 3) / 4 : 32 就等于1. 又因为 1 &lt; MIN_TRANSFER_STRIDE,所以if成立，最终stride == 16。表示一个线程可以处理16个数组下标的位置。那么刚好此时数组长度是32，所以这里只需要2个线程进行扩容操作即可。</span></div><div class="line">    </div><div class="line">    </div><div class="line">   <span class="comment">// 也就是表示需要2个线程同时进行扩容操作（最多支持CPU核心数的数量的线程，这里是4，但是因为数组长度是32，每个线程处理16个下标，所以这里只需要2个线程）。那么他们具体是怎么进行协调工作呢？还是分而治之的思路，</span></div><div class="line">   <span class="comment">//我们知道目前chm数组长度是n==32,那么我们这里一共需要2个线程同时进行扩容操作，那么每个线程刚好负责一个数组的16个下标，负责处理转移自己负责的数组下标的node节点数据到新数组。</span></div><div class="line">    </div><div class="line">    <span class="comment">//按道理通过上面的分析，我们可以得到这两个线程负责的数组下标区间，那么线程1负责下标为0-15的数据，线程2负责16-31的数据，转移到新数组。</span></div><div class="line">    </div><div class="line">    <span class="comment">//说了这么多，那么新数组的长度是多少呢？</span></div><div class="line">    </div><div class="line">    </div><div class="line">      <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating初始化新数组，</span></div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">              <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">              Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];<span class="comment">//长度是n&lt;&lt; 1 也即是 32&lt;&lt; 1 等于64，那么也就是说，新数组长度为64位</span></div><div class="line">              nextTab = nt;</div><div class="line">          &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></div><div class="line">              sizeCtl = Integer.MAX_VALUE;</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line">          nextTable = nextTab;</div><div class="line">          transferIndex = n;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> nextn = nextTab.length;</div><div class="line">      ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">      <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></div></pre></td></tr></table></figure>
<p>​    <strong>通过上面的代码，我们知道可以设置多个线程进行并发的参与扩容操作，那么这么确定每个线程自己负责哪一段的数组下标呢？</strong></p>
<p>接着往下看代码</p>
<p>可以看到这里是通过一个无限循环进行分割，每个线程负责的下标区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</div><div class="line">    Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</div><div class="line">    <span class="keyword">while</span> (advance) &#123;</div><div class="line">        <span class="keyword">int</span> nextIndex, nextBound;</div><div class="line">        <span class="keyword">if</span> (--i &gt;= bound || finishing)</div><div class="line">            advance = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</div><div class="line">            i = -<span class="number">1</span>;</div><div class="line">            advance = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//关键代码在这里，通过cas来确定每个线程负责的数组下标区间</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</div><div class="line">                 (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</div><div class="line">                  nextBound = (nextIndex &gt; stride ?</div><div class="line">                               nextIndex - stride : <span class="number">0</span>))) &#123;<span class="comment">//首先nextIndex== 32，那么32 &gt; 16，所以nextBound = 32-16 == 16，然后cas操作，将TRANSFERINDEX设置为16</span></div><div class="line">            <span class="comment">//首先</span></div><div class="line">            bound = nextBound;<span class="comment">//所以bound = nextBound == 16</span></div><div class="line">            i = nextIndex - <span class="number">1</span>;<span class="comment">//  i == 32-1== 31</span></div><div class="line">            advance = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//那么通过上面的操作，就得到了当前线程所需要的操作的线程区间，那就是（i，bound）=== (31,16)</span></div><div class="line">            <span class="comment">//那么第二个线程进来后，他负责的就是（15,0），跟我们上面的推测一致</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​    </p>
<p><strong>我们知道上面的代码只是确定了线程负责数组区间，但是真正进行数据迁移到新数组的代码还在下面。</strong></p>
<p>​    <strong>首先我们需要明确一点，迁移数据是从数组的后面往前迁移的，`</strong> if (–i &gt;= bound || finishing)<strong>`  由这段代码可以看出，i–的方式从后往前一个一个的迁移</strong></p>
<blockquote>
<p><strong>迁移数据代码</strong></p>
</blockquote>
<p>​    迁移数据的代码块就是在for循环里面的，synchronize代码段。线程在他负责的数组下标区间进行，从后往前的数组下标数据的逐个迁移。最终每个数组的下标的数据，都会拆分成两个链表，高位链表和低位链表（  Node<k,v> ln, hn）。低位链表，可以直接迁移到跟旧数组下标一样的新数组对应的下标的位置（例如链表本来在旧数组i==2的位置，那么迁移到新数组，也还是迁移到下标为2的位置），高位链表，需要迁移到i+n位置（例如旧数组下表是i==2，上面的代码数组长度n就是32，那么迁移到新数组的下标就是32+2 == 34）</k,v></p>
<p>​    形成高低位链表迁移的好处就是，可以批量迁移节点到新数组。如果不怎么做，那么就需要把旧数组下标的链表逐个rehash，然后再逐个放到新数组，这样的效率太慢。</p>
<p>那么为什么低位链表可以直接平移，高位链表移到新数组对应的下标，要用原来的下标+原来数组长度呢？</p>
<p>我们来证明一下：</p>
<p>假设原来数组长度是 n == 16，通过put（“k”,”k”），那么key要通过 <code>hash&amp;(n-1)</code> 算法得到他所属的数组下标，那么key==k的hash值假设等于9.</p>
<p>那么<code>hash&amp;(n-1)</code> 等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hash     0000 1001</div><div class="line">&amp;</div><div class="line">n-1== 15 0000 1111</div><div class="line">==       0000 1001 等于9，也就是key等于k的节点应该归属于数组的9下标位置</div></pre></td></tr></table></figure>
<p>假设n 扩容到 32，那么需要rehash原先在旧数组的值，然后通过<code>hash&amp;(n-1)</code> 算法得到他所属的新数组的下标</p>
<p>那么<code>hash&amp;(n-1)</code> 等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hash     0000 1001</div><div class="line">&amp;</div><div class="line">32-1== 31 0001 1111</div><div class="line">==       0000 1001 等于9，也就是该节点在新数组还是对应下标9.</div></pre></td></tr></table></figure>
<p>所以我们发现低位链表可以直接平移到新数组（因为key的hash的高位都是0，所以计算获取数组下标时，取决于低位）</p>
<p>同理证明高位链表，为什么需要n+i。假设key的hash是20，他的二进制是：0001 0100</p>
<p>那么<code>hash&amp;(n-1)</code> 等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hash     0001 0100</div><div class="line">&amp;</div><div class="line">n-1== 15 0000 1111</div><div class="line">==       0000 0100 等于9</div></pre></td></tr></table></figure>
<p>假设数组扩容到32</p>
<p>那么<code>hash&amp;(n-1)</code> 等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hash      0001 0100</div><div class="line">&amp;</div><div class="line">32-1== 31 0001 1111</div><div class="line">==        0001 0100 等于16+4 == 20，也就是 n+i</div></pre></td></tr></table></figure>
<p><strong>证明完毕</strong></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>​     换句话说，addCount方法的<strong>第一个if代码块</strong>核心就是，进行chm元素个数的自增1。如果在单线程情况下，直接通过对baseCount的cas操作，进行数量的自增1.</p>
<p>​    但是如果存在多个线程进行增加元素个数的操作时，不再使用对baseCount进行cas的方式进行数量增加，进而转化为使用一个counterCells数组的方式，进行分而治之的方式，通过对数组每个下标的cas操作，达到高效率高性能的元素数量自增。</p>
<h3 id="执行到b2-区域-代码块"><a href="#执行到b2-区域-代码块" class="headerlink" title="执行到b2 区域 代码块"></a>执行到b2 区域 代码块</h3><p>如果执行到这部分代码那就表示，当前put操作的key对应的数组下标的位置，已经存在节点。（也就是冲突）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    V oldVal = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">synchronized</span> (f) &#123;<span class="comment">// f就是当前数组下标的节点信息 node，然后锁着这个数组这个位置的节点</span></div><div class="line">        <span class="comment">//可以看到加锁的粒度很细，这样能够拥有更高的性能，这样其他线程仍然能够操作node数组的其他下标节点。保证了当前节点的线程安全</span></div><div class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">            <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                binCount = <span class="number">1</span>;<span class="comment">//当前数组下标，链表的元素个数，这个值，我们知道 在addCount(1L, binCount)，方法会使用，通过他来判断你是否需要扩容</span></div><div class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                    K ek;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((ek = e.key) == key ||</div><div class="line">                         (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                        oldVal = e.val;</div><div class="line">                        <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                            e.val = value;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;<span class="comment">//这个if的作用就是，判断当前插入的节点，的hash，key信息是否相等，如果相等，那么覆盖value值。然后退出当前循环，否则往下执行</span></div><div class="line">                    Node&lt;K,V&gt; pred = e;</div><div class="line">                    <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;<span class="comment">//因为hash和key不同，那么，在当前数组节点，构建一个链表，把新加入的节点，使用单链表连接保存</span></div><div class="line">                        pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                  value, <span class="keyword">null</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                Node&lt;K,V&gt; p;</div><div class="line">                binCount = <span class="number">2</span>;</div><div class="line">                <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                               value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                    oldVal = p.val;</div><div class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                        p.val = value;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">            treeifyBin(tab, i);</div><div class="line">        <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> oldVal;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先来看一下Node节点的数据结构</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200324211514948.png" alt="image-20200324211514948"></p>
<p>​    hash就是当前节点的key的hash值，key和val就是put操作是传入的key和value，原样保存，next就是冲突时，需要构建的单链表指向下一个占据相同数组下标的节点。</p>
<h3 id="什么时候转化为红黑树"><a href="#什么时候转化为红黑树" class="headerlink" title="什么时候转化为红黑树"></a>什么时候转化为红黑树</h3><p>如果链表长度大于8和node数组长度大于64的时候，如果再往当前链表添加数据，那么就会将当前链表转化为红黑树。</p>
<p>如果扩容后，当前数组节点的链表树小于8，他又会把红黑树转化为单链表</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>一下就是chm的核心要点</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200325002730647.png" alt="image-20200325002730647"></p>
<p><a href="https://blog.csdn.net/yyzzhc999/article/details/96724885" target="_blank" rel="external">https://blog.csdn.net/yyzzhc999/article/details/96724885</a></p>
<h1 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 - BlockingQueue"></a>阻塞队列 - BlockingQueue</h1><p>阻塞队列，顾名思义，首先它是一个队列,而一个阻塞队列在数据结构中所起的作用大致如图所示:<br><img src="/2020/03/09/java基础核心技术/1582083684068.png" alt="1582083684068"><br>                                                <strong>线程1往阻塞队列中添加元素二线程2从队列中移除元素</strong></p>
<p><strong>当阻塞队列是空时,从队列中获取元素的操作将会被阻塞.</strong><br><strong>当阻塞队列是满时,往队列中添加元素的操作将会被阻塞.</strong></p>
<p>同样</p>
<p>​    试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他线程从队列中移除一个或者多个元素或者全清空队列后使队列重新变得空闲起来并后续新增。</p>
<h2 id="为什么用-有什么好处"><a href="#为什么用-有什么好处" class="headerlink" title="为什么用?有什么好处?"></a><strong>为什么用?有什么好处?</strong></h2><p>​    在多线程领域：所谓阻塞，在某些情况下会挂起线程(即线程阻塞)，一旦条件满足,被挂起的线程优惠被自动唤醒。</p>
<p>​    <strong>为什么需要使用BlockingQueue，好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为BlockingQueue都一手给你包办好了。</strong></p>
<p>​    <strong>在concurrent包 发布以前,在多线程环境下，我们每个程序员都必须自己去控制这些细节（通过wait和notify），尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</strong></p>
<p>BlockingQueue的结构</p>
<p><img src="/2020/03/09/java基础核心技术/1582084167742.png" alt="1582084167742"></p>
<ul>
<li><p><strong>ArrayBlockingQueue</strong>: 由数组结构组成的有界阻塞队列.</p>
</li>
<li><p><strong>LinkedBlockingDeque</strong>: 由链表结构组成的有界(但大小默认值Integer&gt;MAX_VALUE)阻塞队列.</p>
</li>
<li><p>PriorityBlockingQueue:支持优先级排序的无界阻塞队列.</p>
</li>
</ul>
<ul>
<li>DelayQueue: 使用优先级队列实现的延迟无界阻塞队列.</li>
</ul>
<ul>
<li><p><strong>SynchronousQueue</strong>:不存储元素的阻塞队列,也即是单个元素的队列.</p>
<ul>
<li><p>SynchronousQueue没有容量</p>
<p>与其他BlcokingQueue不同,SynchronousQueue是一个不存储元素的BlcokingQueue</p>
<p>每个put操作必须要等待一个take操作,否则不能继续添加元素,反之亦然.</p>
<p><strong>生产就马上用</strong></p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 阻塞队列SynchronousQueue演示</div><div class="line"> **/</div><div class="line">public class SynchronousQueueDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;();</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t put 1&quot;);</div><div class="line">                blockingQueue.put(&quot;1&quot;);//阻塞，等待take</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t put 2&quot;);</div><div class="line">                blockingQueue.put(&quot;2&quot;);//阻塞，等待take</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t put 3&quot;);</div><div class="line">                blockingQueue.put(&quot;3&quot;);//阻塞，等待take</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;, &quot;AAA&quot;).start();</div><div class="line"></div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            try &#123;</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(5);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + blockingQueue.take());//取出阻塞队列中队列头元素 1。 然后这个时候才能够put（2）</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(5);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + blockingQueue.take());//取出阻塞队列中队列头元素 2。 然后这个时候才能够put（3）</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(5);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + blockingQueue.take());</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;, &quot;BBB&quot;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
</li>
<li><p>AAA     put 1<br>BBB    1<br>AAA     put 2<br>BBB    2<br>AAA     put 3<br>BBB    3</p>
</li>
<li><p>可以看到，他是生产一个，然后生产线程阻塞，等待消费者，take消费。然后再接着生产。。。。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>LinkedTransferQueue:由链表结构组成的无界阻塞队列.</li>
</ul>
<ul>
<li>LinkedBlockingDeque:由了解结构组成的双向阻塞队列.</li>
</ul>
<h2 id="BlockingQueue的核心方法"><a href="#BlockingQueue的核心方法" class="headerlink" title="BlockingQueue的核心方法"></a>BlockingQueue的核心方法</h2><p><img src="/2020/03/09/java基础核心技术/1582093357161.png" alt="1582093357161"></p>
<p><img src="/2020/03/09/java基础核心技术/1582093389451.png" alt="1582093389451"></p>
<p>实际上，这四组api是适用于不同的应用场景的。</p>
<blockquote>
<p><strong>校验第一组api，使用的时候，会抛出异常。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class BlockingQueueDemo &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);//因为ArrayBlockingQueue是有界的，所有必须传入有界值</div><div class="line">		System.out.println(blockingQueue.add(&quot;a&quot;));</div><div class="line">		System.out.println(blockingQueue.add(&quot;b&quot;));</div><div class="line">		System.out.println(blockingQueue.add(&quot;c&quot;));</div><div class="line">//		System.out.println(blockingQueue.add(&quot;d&quot;));//插入失败，提示java.lang.IllegalStateException: Queue full。因为我们设置的数组长度最大是3.</div><div class="line">		</div><div class="line">/*		System.out.println(blockingQueue.remove());//不指定删除的元素，那么就会默认删除队列头元素</div><div class="line">		System.out.println(blockingQueue.remove());</div><div class="line">		System.out.println(blockingQueue.remove());*/</div><div class="line">//		System.out.println(blockingQueue.remove());//删除失败，因为数组最大长度只允许有三个元素。抛出异常 java.util.NoSuchElementException</div><div class="line">		</div><div class="line">		System.out.println( blockingQueue.element() );//获取队列头元素，不存在则抛出异常-NoSuchElementException</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>校验第二组api</strong></p>
</blockquote>
<p>offer，插入元素，假设插入元素后，数组长度超过了设定的有界值，那么返回false（相比第一组api的add，offer不会抛出异常）</p>
<p>poll，移除元素，同理，要移除的元素不存在则返回null</p>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>生产一个消费一个</p>
<h4 id="wait和notify版本"><a href="#wait和notify版本" class="headerlink" title="wait和notify版本"></a>wait和notify版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.test;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.Condition;</div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 共享资源类</div><div class="line"> */</div><div class="line">class ShareData &#123;</div><div class="line">    private int num = 0;</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line">    private Condition condition = lock.newCondition();</div><div class="line"></div><div class="line">    public void increment() throws Exception &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            //判断</div><div class="line">            while (num != 0) &#123;</div><div class="line">                //等待 不生产</div><div class="line">                condition.await();</div><div class="line">            &#125;</div><div class="line">            //干活</div><div class="line">            num++;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);</div><div class="line">            //通知唤醒</div><div class="line">            condition.signalAll();</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void deIncrement() throws Exception &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            //判断</div><div class="line">            while (num == 0) &#123;</div><div class="line">                //等待 不消费</div><div class="line">                condition.await();</div><div class="line">            &#125;</div><div class="line">            //干活</div><div class="line">            num--;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);</div><div class="line">            //通知唤醒</div><div class="line">            condition.signalAll();</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 一个初始值为0的变量 两个线程交替操作 一个加1 一个减1来5轮</div><div class="line"> **/</div><div class="line">public class ProdConsumerTraditionDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ShareData shareData = new ShareData();</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            for (int i = 1; i &lt;= 5; i++) &#123;</div><div class="line">                try &#123;</div><div class="line">                    shareData.increment();</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, &quot;AA&quot;).start();</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            for (int i = 1; i &lt;= 5; i++) &#123;</div><div class="line">                try &#123;</div><div class="line">                    shareData.deIncrement();</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, &quot;BB&quot;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AA	1</div><div class="line">BB	0</div><div class="line">AA	1</div><div class="line">BB	0</div><div class="line">AA	1</div><div class="line">BB	0</div><div class="line">AA	1</div><div class="line">BB	0</div><div class="line">AA	1</div><div class="line">BB	0</div></pre></td></tr></table></figure>
<h4 id="阻塞队列版"><a href="#阻塞队列版" class="headerlink" title="阻塞队列版"></a>阻塞队列版</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.test;</div><div class="line"></div><div class="line">import java.util.concurrent.ArrayBlockingQueue;</div><div class="line">import java.util.concurrent.BlockingQueue;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line">import java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line">class MyResource &#123;</div><div class="line">    /**</div><div class="line">     * 默认开启 进行生产消费的交互</div><div class="line">     */</div><div class="line">    private volatile boolean flag = true;</div><div class="line">    /**</div><div class="line">     * 默认值是0</div><div class="line">     */</div><div class="line">    private AtomicInteger atomicInteger = new AtomicInteger();</div><div class="line"></div><div class="line">    private BlockingQueue&lt;String&gt; blockingQueue = null;</div><div class="line"></div><div class="line">    public MyResource(BlockingQueue&lt;String&gt; blockingQueue) &#123;</div><div class="line">        this.blockingQueue = blockingQueue;</div><div class="line">        System.out.println(blockingQueue.getClass().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void myProd() throws Exception &#123;</div><div class="line">        String data = null;</div><div class="line">        boolean returnValue;</div><div class="line">        while (flag) &#123;</div><div class="line">            data = atomicInteger.incrementAndGet() + &quot;&quot;;</div><div class="line">            returnValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);</div><div class="line">            if (returnValue) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t 插入队列数据&quot; + data + &quot;成功&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t 插入队列数据&quot; + data + &quot;失败&quot;);</div><div class="line">            &#125;</div><div class="line">            TimeUnit.SECONDS.sleep(1);//1s生产一个</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 停止 表示 flag&quot; + flag);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void myConsumer() throws Exception &#123;</div><div class="line">        String result = null;</div><div class="line">        while (flag) &#123;</div><div class="line">            result = blockingQueue.poll(2L, TimeUnit.SECONDS);</div><div class="line">            if(null==result||&quot;&quot;.equalsIgnoreCase(result))&#123;</div><div class="line">                flag=false;</div><div class="line">                System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+&quot;超过2m没有取到 消费退出&quot;);</div><div class="line">                System.out.println();</div><div class="line">                System.out.println();</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;消费队列&quot; + result + &quot;成功&quot;);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void stop() throws Exception&#123;</div><div class="line">        flag=false;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * volatile/CAS/atomicInteger/BlockQueue/线程交互/原子引用</div><div class="line"> **/</div><div class="line">public class ProdConsumerBlockQueueDemo &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        MyResource myResource = new MyResource(new ArrayBlockingQueue&lt;&gt;(10));</div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t生产线程启动&quot;);</div><div class="line">            try &#123;</div><div class="line">                myResource.myProd();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;,&quot;Prod&quot;).start();</div><div class="line"></div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t消费线程启动&quot;);</div><div class="line">            try &#123;</div><div class="line">                myResource.myConsumer();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;,&quot;consumer&quot;).start();</div><div class="line">        try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line">        System.out.println();</div><div class="line">        System.out.println();</div><div class="line">        System.out.println();</div><div class="line">        System.out.println(&quot;时间到,停止活动&quot;);</div><div class="line">        myResource.stop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java.util.concurrent.ArrayBlockingQueue</div><div class="line">Prod	生产线程启动</div><div class="line">consumer	消费线程启动</div><div class="line">Prod	 插入队列数据1成功</div><div class="line">consumer消费队列1成功</div><div class="line">Prod	 插入队列数据2成功</div><div class="line">consumer消费队列2成功</div><div class="line">Prod	 插入队列数据3成功</div><div class="line">consumer消费队列3成功</div><div class="line">consumer消费队列4成功</div><div class="line">Prod	 插入队列数据4成功</div><div class="line">consumer消费队列5成功</div><div class="line">Prod	 插入队列数据5成功</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">时间到,停止活动</div><div class="line">Prod	 停止 表示 flagfalse</div><div class="line">consumer	超过2m没有取到 消费退出</div></pre></td></tr></table></figure>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>​    通过查看take源码，我们就可以知道，为什么take能够实现阻塞。实际上就是利用了ReentrantLock的condition的await机制，进行阻塞，然后把当前执行take 操作的线程加入到notEmpty的condition等待队列中，然后等待其他线程加入元素后，那么就会执行notEmpty.signal（）方法唤醒在等待队列的take线程，加入到aqs阻塞队列，然后等待获取锁，然后接着执行take操作。</p>
<p><strong>也就是说，阻塞队列，是基于ReentrantLock来实现的。</strong></p>
<h1 id="获取线程的第三种方式-Callable"><a href="#获取线程的第三种方式-Callable" class="headerlink" title="获取线程的第三种方式 - Callable"></a>获取线程的第三种方式 - Callable</h1><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。 </p>
<p>这2种方式都有一个缺陷就是：<strong>在执行完任务之后无法获取执行结果</strong>。 </p>
<p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p>
<blockquote>
<p><strong>Callable和Future介绍</strong></p>
</blockquote>
<p>​    Callable接口代表一段<strong>可以调用并返回结果的代码</strong>。Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p>
<p>​    Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法在线程池中执行Callable内的任务。由于Callable任务是并行的（并行就是整体看上去是并行的，其实在某个时间点只有一个线程在执行），我们必须等待它返回的结果。 </p>
<p>​    java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以<strong>等待Callable结束并获取它的执行结果</strong>。</p>
<p>这里说的是通过实现Callable接口，来创建线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Callable&lt;V&gt; &#123;</div><div class="line">    /**</div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * @return computed result</div><div class="line">     * @throws Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    V call() throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>相比实现Runnable的run方法，Callable的call方法，是具备返回值的，而且能够抛出异常。</strong></p>
<p>那么怎么使用呢？跟Runnable一样，传入Thread构造函数中，然后创建实例？</p>
<p>我们查看Thread的构造函数，发现并没有入参是Callable的构造器。</p>
<p><img src="/2020/03/09/java基础核心技术/1582100947354.png" alt="1582100947354"></p>
<p>那么我们这个时候就想，有没有什么接口实现了Runnable接口.</p>
<p><img src="/2020/03/09/java基础核心技术/1582102255142.png" alt="1582102255142"></p>
<p>很明显这里找到了，这个接口或者实现类。通过查看，我们可以得知FutureTask类，既提供了Callable为入参的构造器。</p>
<p><strong>最终示例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CallableDemo implements Callable&lt;Integer&gt;&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Integer call() throws Exception &#123;</div><div class="line">		System.out.println(&quot;开始执行call 方法&quot;);</div><div class="line">		return 1024;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</div><div class="line">		FutureTask&lt;Integer&gt; futureTask = new  FutureTask&lt;&gt;(new CallableDemo());</div><div class="line">		Thread thread = new Thread(futureTask);</div><div class="line">		thread.start();</div><div class="line">		</div><div class="line">		System.out.println( &quot;获取call方法返回的回执： &quot; + futureTask.get() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>测试futureTask.get()方法的阻塞性</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class CallableResource implements Callable&lt;Integer&gt;&#123;</div><div class="line"></div><div class="line">	private Long awaitTime;</div><div class="line">	public CallableResource(  Long awaitTime ) &#123;</div><div class="line">		this.awaitTime = awaitTime;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public Integer call() throws Exception &#123;</div><div class="line">		System.out.println( Thread.currentThread().getName() + &quot; 开始执行call 方法&quot;);</div><div class="line">		TimeUnit.SECONDS.sleep(this.awaitTime);</div><div class="line">		return 1024;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CallableDemo  &#123;</div><div class="line"> public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</div><div class="line">	 FutureTask&lt;Integer&gt; target = new FutureTask&lt;&gt;(new CallableResource(10l));</div><div class="line">       Thread thread = new Thread(target,&quot;AA&quot;);	 </div><div class="line">       thread.start();</div><div class="line">       System.out.println( target.get() );//执行到这里会阻塞，等待十秒后拿到call的返回结果，才往下执行。</div><div class="line">       System.out.println( &quot;执行main线程&quot; );</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>所以说，建议把futuretask.get方法放到最后，不然，一直阻塞，影响其他线程执行。</strong></p>
<h1 id="获取线程的第四种方式：线程池-底层由ThreadPoolExecutor实现"><a href="#获取线程的第四种方式：线程池-底层由ThreadPoolExecutor实现" class="headerlink" title="获取线程的第四种方式：线程池- 底层由ThreadPoolExecutor实现"></a>获取线程的第四种方式：线程池- 底层由ThreadPoolExecutor实现</h1><p>  线程池做的工作主要是控制运行的线程的数量，处理过程中将任务加入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出的数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>他的主要特点为：线程复用，控制最大并发数，管理线程。</p>
<p>第一：降低资源消耗，通过重复利用自己创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>第三：提高线程的可管理性，线程是稀缺资源，如果无限的创建，不仅会消耗资源（JVM的内存管理），还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。</p>
<h2 id="线程池架构实现"><a href="#线程池架构实现" class="headerlink" title="线程池架构实现"></a>线程池架构实现</h2><p>Java中的线程池是通过Executor框架实现的。该框架中用到了Executor,Executors,ExecutorService,ThreadPoolExecutor这几个类.</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200302141610073.png" alt="image-20200302141610073"></p>
<p>其中Executors是工具类，类似于。Arrays、Collections。</p>
<h2 id="编码实现-五种方式创建线程池"><a href="#编码实现-五种方式创建线程池" class="headerlink" title="编码实现 - 五种方式创建线程池"></a>编码实现 - 五种方式创建线程池</h2><h3 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool()"></a><strong>Executors.newScheduledThreadPool()</strong></h3><h3 id="Executors-newWorkStealingPool-int"><a href="#Executors-newWorkStealingPool-int" class="headerlink" title="Executors.newWorkStealingPool(int)"></a><strong>Executors.newWorkStealingPool(int)</strong></h3><p>java8新增,使用目前机器上可以的处理器作为他的并行级别，不常用。</p>
<h3 id="Executors-newFixedThreadPool-int"><a href="#Executors-newFixedThreadPool-int" class="headerlink" title="Executors.newFixedThreadPool(int)"></a><strong>Executors.newFixedThreadPool(int)</strong></h3><p>主要特点如下:<br>1.创建一个<strong>定长线程池</strong>，可控制线程的最大并发数，超出的线程会在队列中等待。<br>2.newFixedThreadPool创建的线程池corePoolSize和MaxmumPoolSize是 相等的,它使用的的LinkedBlockingQueue。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312085301969.png" alt="image-20200312085301969"></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);//设置一个线程个数为5的线程池</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			for (int i = 0; i &lt; 10; i++) &#123;//模拟十个用户进行请求</div><div class="line">				fixedThreadPool.submit( () -&gt; &#123;</div><div class="line">					 System.out.println( &quot;使用线程 &quot; +Thread.currentThread().getName() + &quot; 处理业务&quot; );</div><div class="line">				&#125; );</div><div class="line">			&#125;</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;finally &#123;</div><div class="line">			fixedThreadPool.shutdown();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div></pre></td></tr></table></figure>
<p>可以看到，不管有多少个请求，最多有五个线程进行交替处理这十个请求。</p>
<h3 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor()"></a>Executors.newSingleThreadExecutor()</h3><p>一个任务一个线程执行的任务场景，线程池中只有一个线程来处理业务。</p>
<p>他就类似于，<strong>Executors.newFixedThreadPool(1)</strong>，不管有多少个请求，线程池内只有一个线程在执行这些请求 。</p>
<p>主要特点如下:<br>1.创建一个单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务都按照指定顺序执行.<br>2.newSingleThreadExecutor将corePoolSize和MaxmumPoolSize都设置为1,它使用的的LinkedBlockingQueue</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312085233353.png" alt="image-20200312085233353"></p>
<h3 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h3><p>这个是一池N线程，也就是，不知道线程池中有多少个线程，当请求过来时，他会自动的创建相应的线程，线程池中的线程不是固定数量，有时候可能创建5个，也有可能创建1个，就看每个线程的执行能力，自动创建。</p>
<p>适用:执行很多短期异步的小程序或者负载较轻的服务器。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312085320578.png" alt="image-20200312085320578"></p>
<p> 主要特点如下:<br>1.创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则创建新线程.<br>2.newCachedThreadPool将corePoolSize设置为0，MaxmumPoolSize设置为Integer.MAX_VALUE,它使用的是SynchronousQUeue,也就是说来了任务就创建线程运行,如果线程空闲超过60秒,就销毁线程</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>可以看到，后面三个线程池的创建，底层代码，都是通过ThreadPoolExecutor进行创建的。</p>
<h2 id="线程池几个重要参数介绍-重要"><a href="#线程池几个重要参数介绍-重要" class="headerlink" title="线程池几个重要参数介绍 - 重要"></a>线程池几个重要参数介绍 - 重要</h2><p>刚才我们看了fixedThreadPool、singleThreadPool、cachedThreadPool发现他们最终的实现都是ThreadPoolExecutor，只有五个参数啊？哪来的七个参数呢？</p>
<p>我们再接着查看ThreadPoolExecutor构造器，发下他内部调用的this就是传递了七个参数。</p>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
</code></pre><p>再接着看this</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</div><div class="line"> * parameters.</div><div class="line"> *</div><div class="line"> * @param corePoolSize the number of threads to keep in the pool, even</div><div class="line"> *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</div><div class="line"> * @param maximumPoolSize the maximum number of threads to allow in the</div><div class="line"> *        pool</div><div class="line"> * @param keepAliveTime when the number of threads is greater than</div><div class="line"> *        the core, this is the maximum time that excess idle threads</div><div class="line"> *        will wait for new tasks before terminating.</div><div class="line"> * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</div><div class="line"> * @param workQueue the queue to use for holding tasks before they are</div><div class="line"> *        executed.  This queue will hold only the &#123;@code Runnable&#125;</div><div class="line"> *        tasks submitted by the &#123;@code execute&#125; method.</div><div class="line"> * @param threadFactory the factory to use when the executor</div><div class="line"> *        creates a new thread</div><div class="line"> * @param handler the handler to use when execution is blocked</div><div class="line"> *        because the thread bounds and queue capacities are reached</div><div class="line"> * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</div><div class="line"> *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</div><div class="line"> *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</div><div class="line"> *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;</div><div class="line"> *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</div><div class="line"> * @throws NullPointerException if &#123;@code workQueue&#125;</div><div class="line"> *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</div><div class="line"> */</div><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    if (corePoolSize &lt; 0 ||</div><div class="line">        maximumPoolSize &lt;= 0 ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    if (workQueue == null || threadFactory == null || handler == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    this.corePoolSize = corePoolSize;</div><div class="line">    this.maximumPoolSize = maximumPoolSize;</div><div class="line">    this.workQueue = workQueue;</div><div class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    this.threadFactory = threadFactory;</div><div class="line">    this.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p> <strong>corePoolSize:线程池中的常驻核心线程数</strong></p>
</blockquote>
<p>1.在创建了线程池后,当有请求任务来之后,就会安排池中的线程去执行请求任务,近视理解为今日当值线程</p>
<p>2.当线程池中的线程数目达到corePoolSize后,就会把到达的任务放入到缓存队列当中。</p>
<p><strong>通俗来讲，就是，不管你用不用得到，线程池创建后，里面就有corePoolSize个线程在等着你使用。</strong>类似于银行的办事窗口，不管有没有办业务，窗口还是这么多个等着你。</p>
<blockquote>
<p><strong>maximumPoolSize:线程池能够容纳同时执行的最大线程数,此值大于等于1</strong></p>
</blockquote>
<p>也就是说，线程池中，最多最多有maximumPoolSize个线程，已经是峰值了，不能再增加了。<strong>也就是说当corePoolSize不够用了，那么可能增加到maximumPoolSize个线程。</strong>这里说的是，<strong>可能会增加</strong>，但是什么时候增加呢？</p>
<p><strong>答案是：当corePoolSize个线程已经被使用，而且，任务队列（workQueue）中等待执行的任务也已经占满了队列，那么这个时候，如果还有任务请求进来，那么这个时候就会扩展线程到maximumPoolSize个，然后先执行之前在任务队列中阻塞的任务，把后来的任务放到任务队列中继续等待。</strong></p>
<p><strong>但是可能会有个问题，这个时候，又有新的任务进来了，此刻线程已经扩展到maximumPoolSize个，任务队列也已经占满。那么为了避免其他情况的发生，这个时候就需要拒绝后来的任务。这个时候，第七个参数的重要性就来了。handler拒绝策略</strong></p>
<blockquote>
<p><strong>keepAliveTime:多余的空闲线程存活时间。</strong></p>
</blockquote>
<p>当空间时间达到keepAliveTime值时，发现没有任务执行了，那么多余的线程会被销毁直到只剩下corePoolSize个线程为止。</p>
<p>默认情况下:</p>
<p>只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用,直到线程中的线程数不大于corepoolSIze,</p>
<p>​    <strong>这个很好理解，因为创建线程太多（最多maximumPoolSize个）会消耗内存资源，所以我们肯定要有个销毁机制，但是我们又不能全部销毁线程池中的所有线程（创建线程也需要开销），所以我们一般是销毁到corePoolSize个就停止。</strong></p>
<blockquote>
<p><strong>unit</strong>: </p>
</blockquote>
<p>keepAliveTime的单位</p>
<blockquote>
<p><strong>workQueue:任务队列,被提交但尚未被执行的任务.</strong></p>
</blockquote>
<p>这个也很好理解，就是线程不够用了（达到corePoolSize个），那么后面进来的请求，就等待阻塞。这里一般是通过阻塞队列进行实现。</p>
<blockquote>
<p><strong>threadFactory:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般用默认即可</strong></p>
<p><strong>handler:拒绝策略,表示当线程队列满了并且工作线程大于等于线程池的最大 数(maxnumPoolSize)时如何来拒绝.</strong></p>
</blockquote>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>换句话说，corePoolSize是线程池的初始值，如果任务上涨，那么maximumPoolSize和workQueue就是保底策略，当任务还是持续上涨，那么handler拒绝策略是最终解决方案。</p>
<p>反之如果任务从高峰开始下降，那么keepAliveTime和unit就是收尾工作的保证。</p>
<h2 id="线程池的底层工作原理-重要！！！！！！！！！"><a href="#线程池的底层工作原理-重要！！！！！！！！！" class="headerlink" title="线程池的底层工作原理 - 重要！！！！！！！！！"></a>线程池的底层工作原理 - 重要！！！！！！！！！</h2><p><img src="/2020/03/09/java基础核心技术/image-20200311231236281.png" alt="image-20200312095632702"></p>
<p>这张图就是对应了整个线程池七个参数的的使用和执行流程。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312100605462.png" alt="image-20200312100605462"></p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312100651905.png" alt="image-20200312100651905"></p>
<h2 id="线程池用过吗-生产上你是如何设置合理参数"><a href="#线程池用过吗-生产上你是如何设置合理参数" class="headerlink" title="线程池用过吗?生产上你是如何设置合理参数"></a>线程池用过吗?生产上你是如何设置合理参数</h2><h3 id="线程池的拒绝策略请你谈谈"><a href="#线程池的拒绝策略请你谈谈" class="headerlink" title="线程池的拒绝策略请你谈谈"></a>线程池的拒绝策略请你谈谈</h3><blockquote>
<p><strong>拒绝策略什么时候生效？</strong></p>
</blockquote>
<p>等待队列也已经排满了,再也塞不下新的任务了，同时，线程池的max也到达了,无法继续为新任务服务，这时我们需要拒绝策略机制合理的处理这个问题。</p>
<blockquote>
<p><strong>JDK内置的拒绝策略</strong></p>
</blockquote>
<ul>
<li>AbortPolicy(默认):直接抛出RejectedException异常阻止系统正常运行</li>
</ul>
<ul>
<li>CallerRunPolicy:”调用者运行”一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是将某些任务回退到调用者</li>
</ul>
<ul>
<li>DiscardOldestPolicy:抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交。</li>
</ul>
<ul>
<li>DiscardPolicy:直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的一种方案。</li>
</ul>
<p><strong>以上内置策略均实现了RejectExecutionHandler接口。</strong></p>
<h3 id="你在工作中单一的-固定数的-可变你的三种创建线程池的方法-你用哪个多-超级大坑"><a href="#你在工作中单一的-固定数的-可变你的三种创建线程池的方法-你用哪个多-超级大坑" class="headerlink" title="你在工作中单一的/固定数的/可变你的三种创建线程池的方法,你用哪个多?超级大坑"></a>你在工作中单一的/固定数的/可变你的三种创建线程池的方法,你用哪个多?超级大坑</h3><p><strong>正确答案是：一个都不用，我们生产上只能使用自定义的。</strong></p>
<p>参考阿里巴巴java开发手册</p>
<p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 </p>
<p>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明：Executors返回的线程池对象的弊端如下：<br>1）FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。<br>2）CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p>
<h3 id="自定义过线程池使用-并使用拒绝策略"><a href="#自定义过线程池使用-并使用拒绝策略" class="headerlink" title="自定义过线程池使用 - 并使用拒绝策略"></a>自定义过线程池使用 - 并使用拒绝策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	</div><div class="line">	ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">			<span class="number">2</span>, <span class="number">5</span>, </div><div class="line">			<span class="number">1</span>, TimeUnit.SECONDS, </div><div class="line">			<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</div><div class="line">	</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</div><div class="line">			poolExecutor.execute( () -&gt; &#123;</div><div class="line">				 System.out.println( <span class="string">"使用线程 "</span> +Thread.currentThread().getName() + <span class="string">" 处理业务"</span> );</div><div class="line">			&#125; );</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;<span class="keyword">finally</span> &#123;</div><div class="line">		poolExecutor.shutdown();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面代码，我们知道，<strong>线程池最多容纳8个任务（最大值5+阻塞队列3 = 8，5个任务在执行，3个任务在阻塞队列等待）</strong>，那么执行的任务达到9个时候，很明显就会触发拒绝策略。</p>
<p>运行上面代码输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">java.util.concurrent.RejectedExecutionException: Task kingge.CustomThreadPool$$Lambda$1/681842940@2a84aee7 rejected from java.util.concurrent.ThreadPoolExecutor@a09ee92[Running, pool size = 5, active threads = 5, queued tasks = 0, completed tasks = 3]</div><div class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)</div><div class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)</div><div class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)</div><div class="line">	at kingge.CustomThreadPool.main(CustomThreadPool.java:19)</div><div class="line">使用线程 pool-1-thread-5 处理业务</div></pre></td></tr></table></figure>
<p>很明显报了异常RejectedExecutionException。这个就是默认的AbortPolicy策略发出的。</p>
<h4 id="使用CallerRunPolicy策略"><a href="#使用CallerRunPolicy策略" class="headerlink" title="使用CallerRunPolicy策略"></a>使用CallerRunPolicy策略</h4><pre><code>ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(
        2, 5, 
        1, TimeUnit.SECONDS, 
        new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunPolicy());
</code></pre><p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 main 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div></pre></td></tr></table></figure>
<p>你会发现他成功执行了8个任务（这个是符合我们对于线程池的设置），但是我们发现，他并没有报异常，但是输出了这么一行日志<code>使用线程 main 处理业务</code>。</p>
<p>我们再回过头来看一下CallerRunPolicy拒绝策略的定义：</p>
<p><strong>该策略既不会抛弃任务,也不会抛出异常,而是将某些任务回退到调用者</strong>。那么谁是线程调用者？很明显上诉代码中，main线程就是任务的调用者。所以这里让main新成进行了处理</p>
<h4 id="DiscardOldestPolicy拒绝策略"><a href="#DiscardOldestPolicy拒绝策略" class="headerlink" title="DiscardOldestPolicy拒绝策略"></a>DiscardOldestPolicy拒绝策略</h4><p>抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(</div><div class="line">				2, 5, </div><div class="line">				1, TimeUnit.SECONDS, </div><div class="line">				new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy());</div></pre></td></tr></table></figure>
<p>我们发现，他每次只执行8个任务（服务设置），其余两个任务被抛弃，不会抛出异常。</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div></pre></td></tr></table></figure>
<h4 id="DiscardPolicy拒绝策略"><a href="#DiscardPolicy拒绝策略" class="headerlink" title="DiscardPolicy拒绝策略"></a>DiscardPolicy拒绝策略</h4><p>直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的一种方案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(</div><div class="line">		2, 5, </div><div class="line">		1, TimeUnit.SECONDS, </div><div class="line">		new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardPolicy());</div></pre></td></tr></table></figure>
<p>他的运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div></pre></td></tr></table></figure>
<p>他跟DiscardOldestPolicy策略类似，只不过DiscardOldestPolicy是从阻塞队列中抛弃长时间的任务，而，DiscardPolicy是从一开始就抛弃多余任务，压根就没进阻塞队列。</p>
<h3 id="合理配置线程池你是如何考虑的"><a href="#合理配置线程池你是如何考虑的" class="headerlink" title="合理配置线程池你是如何考虑的?"></a>合理配置线程池你是如何考虑的?</h3><p>首先查看CPU核数</p>
<blockquote>
<p><strong>CPU密集型</strong></p>
</blockquote>
<p>System.out.println(Runtime.getRuntime().availableProcessors());查看CPU核数</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312113121360.png" alt="image-20200312113121360"></p>
<blockquote>
<p><strong>IO密集型</strong></p>
</blockquote>
<p><img src="/2020/03/09/java基础核心技术/image-20200312113143163.png" alt="image-20200312113143163"></p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312113152044.png" alt="image-20200312113152044"></p>
<h2 id="如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？"><a href="#如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？" class="headerlink" title="如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？"></a>如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？</h2><p>阻塞队列中的请求，都是存放在内存中的，那么如果机器宕机，那么队列中的请求必然会丢失。那么怎么解决呢？</p>
<p>第一反应，应该就是，本地化，保存到本地硬盘（例如数据库等等）</p>
<p><strong>解决方案：</strong></p>
<p>  如果你要提交一个任务到线程池之前，先把任务的信息，保存到数据库中，并更新他的状态（未提交，已提交，已完成），提交成功后，他的状态修改为已提交。</p>
<p>假设机器宕机，那么当机器重启后，系统启动，后台线程可以去扫描数据库中的数据，然后把未提交和已提交的任务拿出来，再次重新提交到线程池中，继续执行</p>
<h1 id="死锁编码及定位分析"><a href="#死锁编码及定位分析" class="headerlink" title="死锁编码及定位分析"></a>死锁编码及定位分析</h1><p><img src="/2020/03/09/java基础核心技术/image-20200312114117435.png" alt="image-20200312114117435"></p>
<p>产生死锁的主要原因：系统资源不足、进程运行推进的顺序不合适、资源分配不当。</p>
<p>代码实现死锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package kingge;</div><div class="line"></div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line">class HoldThread implements Runnable &#123;</div><div class="line"></div><div class="line">    private String lockA;</div><div class="line">    private String lockB;</div><div class="line"></div><div class="line">    public HoldThread(String lockA, String lockB) &#123;</div><div class="line">        this.lockA = lockA;</div><div class="line">        this.lockB = lockB;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        synchronized (lockA) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 自己持有锁&quot; + lockA + &quot;尝试获得&quot; + lockB);</div><div class="line">            try &#123;</div><div class="line">                TimeUnit.SECONDS.sleep(1);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            synchronized (lockB) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t 自己持有锁&quot; + lockB + &quot;尝试获得&quot; + lockA);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Description:</div><div class="line"> * 死锁是指两个或者以上的进程在执行过程中,</div><div class="line"> * 因争夺资源而造成的一种相互等待的现象,</div><div class="line"> * 若无外力干涉那他们都将无法推进下去</div><div class="line"> **/</div><div class="line">public class DeadLockDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String lockA = &quot;lockA&quot;;</div><div class="line">        String lockB = &quot;lockB&quot;;</div><div class="line">        new Thread(new HoldThread(lockA, lockB), &quot;threadAAA&quot;).start();</div><div class="line">        new Thread(new HoldThread(lockB, lockA), &quot;threadBBB&quot;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312115119402.png" alt="image-20200312115119402"></p>
<p>你会发现程序卡死在这里</p>
<h2 id="解决死锁-重要！！！！"><a href="#解决死锁-重要！！！！" class="headerlink" title="解决死锁 - 重要！！！！"></a>解决死锁 - 重要！！！！</h2><blockquote>
<p><strong>1.jps命令定位进程编号</strong></p>
</blockquote>
<p>获取死锁程序的进程编号- 使用 jps -l </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">King哥@JeremyKing MINGW64 ~/Desktop</div><div class="line">$ jps -l</div><div class="line">9268 kingge.DeadLockDemo</div><div class="line">7736</div><div class="line">10908 sun.tools.jps.Jps</div></pre></td></tr></table></figure>
<p>可以知道是9268</p>
<blockquote>
<p><strong>2.jstack找到死锁查看</strong></p>
</blockquote>
<p>使用命令 ： jstack 9268</p>
<p>查看输出日志可以得到：</p>
<p><img src="/2020/03/09/java基础核心技术/学习总结\java基础核心技术\java基础核心技术\image-20200312115529333.png" alt="image-20200312115529333"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Java stack information for the threads listed above:</div><div class="line">===================================================</div><div class="line">&quot;threadBBB&quot;:</div><div class="line">        at kingge.HoldThread.run(DeadLockDemo.java:25)</div><div class="line">        - waiting to lock &lt;0x00000000d5c9b7e0&gt; (a java.lang.String)</div><div class="line">        - locked &lt;0x00000000d5c9b818&gt; (a java.lang.String)</div><div class="line">        at java.lang.Thread.run(Thread.java:745)</div><div class="line">&quot;threadAAA&quot;:</div><div class="line">        at kingge.HoldThread.run(DeadLockDemo.java:25)</div><div class="line">        - waiting to lock &lt;0x00000000d5c9b818&gt; (a java.lang.String)</div><div class="line">        - locked &lt;0x00000000d5c9b7e0&gt; (a java.lang.String)</div><div class="line">        at java.lang.Thread.run(Thread.java:745)</div><div class="line"></div><div class="line">Found 1 deadlock.</div></pre></td></tr></table></figure>
<p>可以看到 threadBBB 锁着0x00000000d5c9b818，等待0x00000000d5c9b7e0。然而threadAAA锁着0x00000000d5c9b7e0，等待0x00000000d5c9b818。就是死锁。</p>
<h1 id="缓存的重要性"><a href="#缓存的重要性" class="headerlink" title="缓存的重要性"></a>缓存的重要性</h1><p>缓存就是利用了<strong>局部性原理</strong>实现了数据的高效读取。局部性原理包括<strong>时间局部性</strong>（temporal locality）和<strong>空间局部性</strong>（spatial locality）这两种策略。</p>
<p>​    在实际的计算机日常的开发和应用中，我们对于<strong>数据的访问总是会存在一定的局部性</strong>。有时候，这个局部性是<strong>时间局部性</strong>，就是我们最近访问过的数据还会被反复访问。有时候，这个局部性是<strong>空间局部性</strong>，就是我们最近访问过数据附近的数据很快会被访问到。</p>
<p>​    而局部性的存在，使得我们可以在应用开发中<strong>使用缓存</strong>这个有利的武器。比如，通过将热点数据加载并保留在速度更快的存储设备里面，我们可以用更低的成本来支撑服务器。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318145712228.png" alt="image-20200318145712228"></p>
<h1 id="序列化和反序列化原理分析"><a href="#序列化和反序列化原理分析" class="headerlink" title="序列化和反序列化原理分析"></a>序列化和反序列化原理分析</h1><p>设么叫序列化：把存储在内存中的数据，保存到本地硬盘或者传输</p>
<p>trensiant：修饰某个属性，目的就是阻止这个属性进行序列化</p>
<p>那么为什么会存在writeObject和readObject？这两个方法就是序列化和反序列化调用的方法。</p>
<p>可以通过这个方法制订序列化和反序列化规则，例如某个字段虽然被trensiant修饰，但是我们可以在writeObejct方法中对这个字段打破trensiant的作用，也就是，可以序列化。让trensiant失效</p>
<p>java原生序列化，需要实现接口，Serializable。同时建议制订一个serialVersionUID，目的就是给序列化的对象加个版本号，也就是说我当前序列化这个对象的版本是serialVersionUID，那么你反序列化的时候，也要是这个serialVersionUID，一模一样，如果你修改了这个值serialVersionUID，再去反序列化那么就会报异常。，这样保证了数据的安全性。</p>
<p>​    <strong>如果不指定serialVersionUID，默认会生成一个，但是建议制订。避免后面来的开发人员，发现，咦，你这个要序列化的类竟然没有制订serialVersionUID，那么他随手给你加上了，导致，下次反序列化的时候，发现版本号不一致（默认生成的serialVersionUID跟后来人加上的serialVersionUID，不相等），反序列化失败，对象数据就拿不到了。</strong></p>
<p>现在常用的序列化格式有，json，xml，hessian等等</p>
<p>xml的好处是：阅读性强，可以保存更多的东西，例如类名，等等。缺点是，序列化后很大，占据的空间多</p>
<p>json，就是比较轻量级，类似{name:”King哥”,age:12} 这样的格式，好处就是轻量级，传输所需要的带宽少，缺点就是不能够携带更多的信息。</p>
<p>所以具体选择哪种序列化手段，得看你具体业务场景，和你对带宽的要求</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;p&gt;​    通过日常编码，发现，我们在编程的过程中，使用频率最高的变量或者对象，往往是字符串（可以通过分析jv
    
    </summary>
    
      <category term="java核心技术杂记" scheme="http://kingge.top/categories/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="动态代理" scheme="http://kingge.top/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="juc" scheme="http://kingge.top/tags/juc/"/>
    
      <category term="对象头" scheme="http://kingge.top/tags/%E5%AF%B9%E8%B1%A1%E5%A4%B4/"/>
    
      <category term="chm" scheme="http://kingge.top/tags/chm/"/>
    
      <category term="cas" scheme="http://kingge.top/tags/cas/"/>
    
  </entry>
  
  <entry>
    <title>jmeter压测工具使用总结</title>
    <link href="http://kingge.top/2020/03/05/jmeter%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://kingge.top/2020/03/05/jmeter使用总结/</id>
    <published>2020-03-05T14:21:59.000Z</published>
    <updated>2020-05-08T03:02:09.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用压测工具比对"><a href="#常用压测工具比对" class="headerlink" title="常用压测工具比对"></a>常用压测工具比对</h1><pre><code>1、loadrunner
    性能稳定，压测结果及细粒度大，可以自定义脚本进行压测，但是太过于重大，功能比较繁多

2、apache ab(单接口压测最方便)
    模拟多线程并发请求,ab命令对发出负载的计算机要求很低，既不会占用很多CPU，也不会占用太多的内存，但却会给目标服务器造成巨大的负载, 简单DDOS攻击等

3、webbench
    webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。
</code></pre><h1 id="Jmeter介绍和安装"><a href="#Jmeter介绍和安装" class="headerlink" title="Jmeter介绍和安装"></a>Jmeter介绍和安装</h1><h2 id="Jmeter基本介绍和使用场景"><a href="#Jmeter基本介绍和使用场景" class="headerlink" title="Jmeter基本介绍和使用场景"></a>Jmeter基本介绍和使用场景</h2><blockquote>
<p><strong>压测不同的协议和应用</strong></p>
</blockquote>
<p>​            1) Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …)<br>​            2) SOAP / REST Webservices<br>​            3) FTP<br>​            4) Database via JDBC<br>​            5) LDAP  轻量目录访问协议<br>​            6) Message-oriented middleware (MOM) via JMS<br>​            7) Mail - SMTP(S), POP3(S) and IMAP(S)<br>​            8) TCP等等</p>
<blockquote>
<p>​    <strong>使用场景及优点</strong></p>
</blockquote>
<p>​        1）功能测试<br>​        2）压力测试<br>​        3）分布式压力测试<br>​        4）纯java开发<br>​        5）上手容易，高性能<br>​        4）提供测试数据分析<br>​        5）各种报表数据图形展示</p>
<h2 id="Jmeter4-0安装"><a href="#Jmeter4-0安装" class="headerlink" title="Jmeter4.0安装"></a>Jmeter4.0安装</h2><p> 简介：GUI图形界面的安装<br>     1、需要安装JDK8。或者JDK9,JDK10<br>     2、快速下载<br>         windows： <a href="http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip" target="_blank" rel="external">http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip</a><br>         mac或者linux：<a href="http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.tgz" target="_blank" rel="external">http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.tgz</a></p>
<p> 3、文档地址：<a href="http://jmeter.apache.org/usermanual/get-started.html" target="_blank" rel="external">http://jmeter.apache.org/usermanual/get-started.html</a></p>
<p> 4、建议安装JDK环境，虽然JRE也可以，但是压测https需要JDK里面的 keytool工具</p>
<blockquote>
<p><strong>下载完成解压后</strong></p>
</blockquote>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310230802324.png" alt="image-20200310230802324"></p>
<p>目录<br>        bin:核心可执行文件，包含配置<br>            jmeter.bat: windows启动文件：也就是说，在windows平台下，直接双击这个bat文件，即可启动jmeter。</p>
<p>​            jmeter: mac或者linux启动文件：<br>​            jmeter-server：mac或者Liunx分布式压测使用的启动文件<br>​            jmeter-server.bat：mac或者Liunx分布式压测使用的启动文件<br>​            jmeter.properties: 核心配置文件，例如可以设置GUI界面的语言（中文还是英文）<br>​                    </p>
<p>​    extras：插件拓展的包<br>​    lib:核心的依赖包<br>​        ext:核心包<br>​        junit:单元测试包</p>
<blockquote>
<p><strong>Jmeter语言版本中英文切换</strong></p>
</blockquote>
<p>​        1、控制台修改<br>​            menu -&gt; options -&gt; choose language<br>​        2、配置文件修改<br>​            bin目录 -&gt; jmeter.properties<br>​                默认 #language=en<br>​                改为 language=zh_CN </p>
<h1 id="Jmeter使用"><a href="#Jmeter使用" class="headerlink" title="Jmeter使用"></a>Jmeter使用</h1><p>首先我们双击<code>jmeter.bat</code> 启动jmeter：</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310231331858.png" alt="image-20200310231331858"></p>
<h2 id="创建线程组"><a href="#创建线程组" class="headerlink" title="创建线程组"></a>创建线程组</h2><p>右键TestPlan，开始创建测试计划，<strong>首先创建线程组，作用是控制总体并发</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310231440556.png" alt="image-20200310231440556"></p>
<blockquote>
<p><strong>接着看测试组的界面设置</strong></p>
</blockquote>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310231658973.png" alt="image-20200310231658973"></p>
<p>这里主要介绍着三个重要的设置：</p>
<p>线程数：虚拟用户数。一个虚拟用户占用一个进程或线程，也就是说，你想模拟100个人访问接口，那么这里就填100。</p>
<p>​        准备时长（Ramp-Up Period(in seconds)）：全部线程启动的时长，比如100个线程，20秒，则表示20秒内100个线程都要启动完成，每秒启动5个线程。也就是说，这个参数模拟的是，用户访问数量的逐渐上涨，随着时间的增加，慢慢增长到设置的“线程数”。因为在真实的环境中，访问某个接口的用户量是慢慢上涨的，一般不会是1s内暴增很多个 用户。 - 总而言之，就是在这个时间过后达到上面设置的线程数。<br>​<br>​        循环次数：每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选永远循环，那么就会一直重复发送请求。</p>
<p><strong>我这里为这三个参数自上而下设置的是：</strong>10、5、1。 表示，一共模拟十个用户请求，5s内发送这十个请求，也就意味着每两秒请求两次接口，第五秒后请求结束。1表示，这进行一轮测试，也就是发送完10个请求后便停止请求。</p>
<p><strong>那么如果你想模拟，每秒并发1000，持续发送5次，那么就需要由上到下设置为：1000/1/5。</strong></p>
<h2 id="创建采样器-模拟请求"><a href="#创建采样器-模拟请求" class="headerlink" title="创建采样器 - 模拟请求"></a>创建采样器 - 模拟请求</h2><p>我们在上面通过线程组创建了请求的频率和请求的用户数等设置，那么我们怎么开始发送请求呢？那么这个时候就需要采样器。</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310232229628.png" alt="image-20200310232229628"></p>
<p>可以看到，你可以在线程组下面创建多种类型的请求采样器。我这里创建的是http请求采样器。</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310232421864.png" alt="image-20200310232421864"></p>
<p>设置完成后，我们就可以，点击上面的启动按钮，这样就可以发送请求，可以看到，请求后台的接口，每两秒打印两次输出，一共打印了五次，一共是10个请求（因为线程组设置10个请求5s内发完，只进行一轮请求）</p>
<p>看到这里我们，可能会有疑问，那就是，我怎么看请求返回的值或者请求的状态呢？能不能跟踪请求呢？</p>
<h2 id="创建结果收集树-查看测试结果"><a href="#创建结果收集树-查看测试结果" class="headerlink" title="创建结果收集树 - 查看测试结果"></a>创建结果收集树 - 查看测试结果</h2><p>我们可以右键线程组，然后创建一个结果收集器。</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310233106267.png" alt="image-20200310233106267"></p>
<p>启动采样器发出请求后，查看结果收集树。</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310233205408.png" alt="image-20200310233205408"></p>
<p>可以看到在线程组下面每个请求的详细信息包括返回值。</p>
<p><strong>上面的结果树是在线程组上面进行添加，也就意味着，线程组下面多个采样器，那么他们都将使用同一个结果数查看（可以看到上面结果树输出了users、login接口两个的请求信息），当然你也可以专门为某一个接口创建单独的结果树（右键采样器，创建即可）</strong></p>
<h2 id="模拟一次性请求多个接口"><a href="#模拟一次性请求多个接口" class="headerlink" title="模拟一次性请求多个接口"></a>模拟一次性请求多个接口</h2><p>上面的演示，我们是在线程组下面只创建了一个 采样器。实际上我们可以在线程组下面创建多个采样器。那么这样就意味着，多个接口同时遵循线程组的设置信息。</p>
<p>例如：</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310233434511.png" alt="image-20200310233434511"></p>
<p>如图，创建了两个采样器，那么当启动线程组的时候，是会同时请求这两个接口的，<strong>这样就可以模拟在某一秒的时候，同时去请求多个接口，这种业务场景在现实中也是很常见的。</strong></p>
<p>上面线程组设置是：10、5、1。启动线程组，查看结果收集树：</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200310233655324.png" alt="image-20200310233655324"></p>
<p>​    <strong>可以看到，确实是两个采样器使用了通个线程组的配置。1s内发送了两个请求，访问了users接口和login接口。然后一共发送5s，users和login接口各自请求了10次，只进行一轮请求。</strong></p>
<h1 id="Jmeter的断言"><a href="#Jmeter的断言" class="headerlink" title="Jmeter的断言"></a>Jmeter的断言</h1><p>他的作用就是，结合采样器使用。通过自定义一些判断依据，判断请求接口是否成功，是否达到我们想要的结果。例如我们可以增加一个判断响应状态是202的断言，只有当请求接口相应状态码是202，那么就说明请求成功，否则可以自定义一些错误信息。</p>
<h2 id="响应断言"><a href="#响应断言" class="headerlink" title="响应断言"></a>响应断言</h2><p><strong>增加断言: 线程组 -&gt; 添加 -&gt; 断言 -&gt; 响应断言</strong>  </p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311212037626.png" alt="image-20200311212037626"></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311212241796.png" alt="image-20200311212241796"></p>
<p>​        apply to(应用范围):<br>​            Main sample only: 仅当前父取样器 进行断言，一般一个请求，如果发一个请求会触发多个，则就有sub sample（比较少用）</p>
<p>​        要测试的响应字段：<strong>也就是区域1的内容</strong><br>​            响应文本：即响应的数据，比如json等文本<br>​            响应代码：http的响应状态码，比如200，302，404这些<br>​            响应信息：http响应代码对应的响应信息，例如：OK, Found<br>​            Response Header: 响应头</p>
<p>​        模式匹配规则：<strong>也就是区域2的内容</strong><br>​            包括：包含在里面就成功<br>​            匹配：响应内容完全匹配，不区分大小写<br>​            equals：完全匹配，区分大小写</p>
<p>​            Substring：判断子串</p>
<p>​           </p>
<p>​         匹配值：<strong>也就是区域3的内容</strong></p>
<p>​              根据匹配规则，设定值</p>
<p>​          自定义匹配失败信息：<strong>也就是区域4的内容</strong></p>
<p>​              当匹配失败的时候，返回的错误说明。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p><img src="/2020/03/05/jmeter使用总结/image-20200311212543404.png" alt="image-20200311212543404"></p>
<p>我们根据接口相应数据，进行判断。当响应数据等于kingge的时候，请求成功，否则请求失败，提示下面的错误信息“users接口返回值，不等于kingge”</p>
<p>我们知道正常访问users接口的返回值是“laojiang”，当我们启动采样器请求users接口，肯定是断言失败的。</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311212809140.png" alt="image-20200311212809140"></p>
<p><strong>断言失败，查看结果树任务结果颜色标红(通过结果数里面双击不通过的记录，可以看到错误信息)</strong></p>
<p><strong>每个sample采样器下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总，这样的架构是最常用的。</strong></p>
<h1 id="第一部分总结"><a href="#第一部分总结" class="headerlink" title="第一部分总结"></a>第一部分总结</h1><p>​    我们一般进行接口测试，对应在jmeter需要<strong>创建一个线程组</strong>。一个<strong>接口可能调用了多个接口</strong>，那么这个时候我们就需要<strong>在线程组下面创建多个采样器</strong>，同时在<strong>线程组下面创建</strong>一个<strong>多个采样器共同使用的结果树</strong>，这样的好处是，<strong>可以查看所有采样器的请求结果。</strong>，当然我们也可以在线程组下面创建一个或者多个断言，进行某些规则的匹配从而判断采样器请求是否满足我们的需求（需要注意，这个时候线程组下面的所有采样器，统一使用创建的断言）。</p>
<p>​    我们也可以单独为某个接口采样器创建相应的结果树和断言，这样能够单独查看某个接口的请求情况和单独的断言判断。</p>
<h1 id="Jmeter压测结果聚合报告"><a href="#Jmeter压测结果聚合报告" class="headerlink" title="Jmeter压测结果聚合报告"></a>Jmeter压测结果聚合报告</h1><p>新增聚合报告：1. 增加线程组整体的聚合报告，统计线程组下所有的采样器请求数据报告：</p>
<p>​                                    线程组-&gt;添加-&gt;监听器-&gt;聚合报告（Aggregate Report）</p>
<p>​                            2.给单个采样器添加聚合报告：</p>
<p>​                                    sample采样器-&gt;添加-&gt;监听器-&gt;聚合报告（Aggregate Report）</p>
<p><strong>下面演示的是，给users采样器添加一个聚合报告。</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311214419503.png" alt="image-20200311214419503"></p>
<p>这里我们设置线程组的参数为30/5/2。也就是一共发送两轮请求，每轮发送30个，每轮发送5s，也就是每秒发送5个请求。</p>
<p>启动采样器，查看结果：</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311214627477.png" alt="image-20200311214627477"></p>
<p>​        lable: sampler的名称<br>​        Samples: 一共发出去多少请求，上面的60个请求<br>​        Average: 平均响应时间，4ms<br>​        Median: 中位数，也就是 50％ 用户的响应时间，4ms</p>
<p>​        90% Line : 90％ 用户的响应不会超过该时间 （90% of the samples took no more than this time. The remaining samples at least as long as this）</p>
<p>​        95% Line : 95％ 用户的响应不会超过该时间</p>
<p>​        99% Line : 99％ 用户的响应不会超过该时间</p>
<p>​        min : 最小响应时间</p>
<p>​        max : 最大响应时间<br>​<br>​        Error%：错误的请求的数量/请求的总数<br>​        Throughput： 吞吐量——默认情况下表示每秒完成的请求数（Request per Second) 可类比为qps<br>​        KB/Sec: 每秒接收数据量</p>
<p>​    <strong>所以在实际的压测过程中，我们会关注Throughput吞吐量，随着我们通过增加并发数，观察Throughput的值，他的最大值是多少，那么相应的并发数就是最大并发数，再增大并发数，吞吐量反而会下降了。</strong></p>
<h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a><strong>测试案例</strong></h2><p>我们进行测试users接口，线程组设置为3000/5/10。</p>
<p>通过逐渐增加并发数，查看吞吐量的瓶颈。</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311222042363.png" alt="image-20200311222042363"></p>
<p>我们发现这个时候每秒可以处理请求是593差不多600。</p>
<p>那么再继续加大并发数，查看qps瓶颈。</p>
<p><strong>线程组设置为6000/5/10。</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311222231277.png" alt="image-20200311222231277"></p>
<p>可以看到qps上涨为1166个，那么说明此时并发数还不是瓶颈。继续加大</p>
<p><strong>线程组设置为15000/5/10。</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311222504580.png" alt="image-20200311222504580"></p>
<p>可以看到qps上涨为1852个，那么说明此时并发数还不是瓶颈。继续加大</p>
<p><strong>线程组设置为20000/5/10。</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311222556879.png" alt="image-20200311222556879"></p>
<p>这个时候，我们发现，qps下降了，变成了1460。那么也就意味着当总并发数到达20000个的时候，程序的qps开始下降了，所以说，程序的瓶颈已经出现了，那么我们可以知道<strong>线程组设置为1500/5/10。</strong>的时候 qps是最高的。</p>
<p>可以通过多次次测试，得到qps最大值。上面是通过增加并发数的方式进行测试，当然了你也可以设置多少s发送这个参数（ramp-up period ），进行压测。</p>
<h1 id="Jmeter压测脚本JMX讲解"><a href="#Jmeter压测脚本JMX讲解" class="headerlink" title="Jmeter压测脚本JMX讲解"></a>Jmeter压测脚本JMX讲解</h1><p>我们知道，上面我们设置的测试计划，他最终是保存在一个jmx后缀的文件中的。所以说，后期我们一般是通过直接修改jmx文件的方式，去修改他的并发数等等参数。</p>
<p>打开你会发现他实际上是一个xml文件</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311220520958.png" alt="image-20200311220520958"></p>
<h1 id="自定义变量和CSV可变参数实操"><a href="#自定义变量和CSV可变参数实操" class="headerlink" title="自定义变量和CSV可变参数实操"></a>自定义变量和CSV可变参数实操</h1><h2 id="jmeter用户自定义变量"><a href="#jmeter用户自定义变量" class="headerlink" title="jmeter用户自定义变量"></a>jmeter用户自定义变量</h2><p>为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用。比如服务器地址。</p>
<p>例如一个线程组中我们添加了一百多个采样器，那么每个采样器的服务器ip都一样，这个时候我们就可以通过自定义变量的方式，统一使用自定义好的ip变量。这样的好处是，后期如果ip或者端口号需要变动，那么我们只需要修改自定义变量的值即可，不需要单独去修改一百多个采样器的ip和端口号。</p>
<p>​    1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; User Definde Variable（用户定义的变量）</p>
<p>​     <img src="/2020/03/05/jmeter使用总结/image-20200311223636629.png" alt="image-20200311223636629"></p>
<p>定义一个自定义变量</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311223743534.png" alt="image-20200311223743534"></p>
<p>​    </p>
<p>​    2、引用方式${XXX}，在接口中变量中使用</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311223800590.png" alt="image-20200311223800590"></p>
<h2 id="CSV可变参数压测"><a href="#CSV可变参数压测" class="headerlink" title="CSV可变参数压测"></a>CSV可变参数压测</h2><p>它的作用就是，模拟请求数据，然后去压测。例如你要压测登录接口，就可以使用这个功能，进行模拟多个用户数据进行传入压测。</p>
<p>实战操作jmeter读取CSV和Txt文本文件里面的参数进行压测</p>
<p>​        1、线程组-&gt;add -&gt; Config Element(配置原件)-&gt; CSV data set config (CSV数据文件设置)</p>
<p>​       这列可以传入txt文件和csv文件，下面就演示一下txt文件设置可变参数。</p>
<blockquote>
<p><strong>1.首先后台定义一个接口，如入参是用户名和密码，模拟详情接口</strong></p>
</blockquote>
<pre><code>/**
 * 用户自定义变量测试
 */
@RequestMapping(value = &quot;info&quot;, method = RequestMethod.GET)  
public @ResponseBody Object info(String name, String pwd) {
    List&lt;String&gt; userList = new ArrayList&lt;&gt;();
    userList.add(name);
    userList.add(pwd);
    userList.add(name.length()+&quot;&quot;);
    System.out.println(&quot;get request, info api&quot;);
    return userList;
}
</code></pre><blockquote>
<p><strong>2.创建一个txt文件保存可变参数</strong></p>
</blockquote>
<p>内容是如下，使用<code>|</code>  进行分割</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kingge1|123</div><div class="line">kingge2|1234</div><div class="line">kingge3|1235</div><div class="line">kingge4|1236</div></pre></td></tr></table></figure>
<p>对应的csv文件是：需要知道，默认的分隔符是<code>,</code></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311225555594.png" alt="image-20200311225555594"></p>
<blockquote>
<p><strong>在线程组下面创建可变参数</strong></p>
</blockquote>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311225811699.png" alt="image-20200311225811699"></p>
<p>需要注意的是，变量名这里需要配置两个（当然你也可以配置一个），这样才能按照分隔符进行分割后，他们的值对应的变量名才能匹配上。否者采样器就无法使用了。</p>
<blockquote>
<p><strong>采样器中引用</strong></p>
</blockquote>
<p><img src="/2020/03/05/jmeter使用总结/image-20200311230216916.png" alt="image-20200311230216916"></p>
<p>通过结果树查看，请求url的参数拼接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET http://127.0.0.1:8080/info?name=kingge1&amp;pwd=123</div><div class="line">GET http://127.0.0.1:8080/info?name=kingge2&amp;pwd=1234</div><div class="line">GET http://127.0.0.1:8080/info?name=kingge3&amp;pwd=1235</div><div class="line">GET http://127.0.0.1:8080/info?name=kingge4&amp;pwd=1236</div><div class="line">//参数取完后，如果还有请求需要发送，那么就会从头再拿一遍，不断循环。</div><div class="line">GET http://127.0.0.1:8080/info?name=kingge1&amp;pwd=123</div><div class="line">GET http://127.0.0.1:8080/info?name=kingge2&amp;pwd=1234</div><div class="line">。。。。。。</div></pre></td></tr></table></figure>
<h1 id="Mysql数据库压测实操"><a href="#Mysql数据库压测实操" class="headerlink" title="Mysql数据库压测实操"></a>Mysql数据库压测实操</h1><p>这里通过建立JDBC采样器的方式，进行对数据库的直接测试</p>
<h2 id="测试案例1-简单查询"><a href="#测试案例1-简单查询" class="headerlink" title="测试案例1 - 简单查询"></a>测试案例1 - 简单查询</h2><h3 id="新建线程组和JDBC采样器"><a href="#新建线程组和JDBC采样器" class="headerlink" title="新建线程组和JDBC采样器"></a>新建线程组和JDBC采样器</h3><p><img src="/2020/03/05/jmeter使用总结/image-20200316205942866.png" alt="image-20200316205942866"></p>
<p>这里的意思是一共执行两轮，一轮3次，一轮3次在两秒内完成。</p>
<blockquote>
<p><strong>建立jdbc采样器</strong></p>
</blockquote>
<p><strong>Thread Group -&gt; add -&gt; sampler -&gt; jdbc request</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316210223007.png" alt="image-20200316210223007"></p>
<p><strong>绿色的说明，方框的值，需要先进行下面的《建立JDBC连接配置》后才能给出。</strong></p>
<p>当前界面相关参数的值的含义，<strong>查询类型</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316212601275.png" alt="image-20200316212601275"></p>
<p>自上而下是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">查询语句 - 也就是普通查询语句</div><div class="line"></div><div class="line">更新语句</div><div class="line"></div><div class="line">存储过程</div><div class="line"></div><div class="line">预查询语句 - 也就是带问号（动态参数）的查询语句 ，例如 select * from user where name = ？</div><div class="line"></div><div class="line">预更新语句 - 同上就是带问号，动态参数的更新语句</div><div class="line"></div><div class="line">提交</div><div class="line"></div><div class="line">回滚</div><div class="line"></div><div class="line">自动提交</div></pre></td></tr></table></figure>
<pre><code>1、variable name of pool declared in JDBC connection configuration（和配置文件同名） 也就是下面的jdbc_connector

    3、parameter values 参数值
    4、parameter types  参数类型
    5、variable names  sql执行结果变量名
    6、result variable names 所有结果当做一个对象存储
    7、query timeouts  查询超时时间 
    8、 handle results  处理结果集
</code></pre><h3 id="建立JDBC连接配置"><a href="#建立JDBC连接配置" class="headerlink" title="建立JDBC连接配置"></a>建立JDBC连接配置</h3><p><strong>JDBC request-&gt;add -&gt; config element -&gt; JDBC connection configuration</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316210300862.png" alt="image-20200316210300862"></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316210629984.png" alt="image-20200316210629984"></p>
<p>​            核心配置<br>​                Max Number of connections : 最大连接数<br>​                MAX wait :最大等待时间<br>​                Auto Commit: 是否自动提交事务</p>
<p>​                DataBase URL : 数据库连接地址 jdbc:mysql://127.0.0.1:3306/blog<br>​                JDBC Driver Class : 数据库驱动，选择对应的mysql<br>​                username:数据库用户名<br>​                password:数据库密码</p>
<h3 id="添加jdbc连接mysqljar包"><a href="#添加jdbc连接mysqljar包" class="headerlink" title="添加jdbc连接mysqljar包"></a>添加jdbc连接mysqljar包</h3><p><img src="/2020/03/05/jmeter使用总结/image-20200316210813569.png" alt="image-20200316210813569"></p>
<p>我这里因为使用的是mysql8.0，所以jdbc_url必须是com.mysql.cj.jdbc.Driver，mysql-connector.jar是mysql-connector-java-5.1.30.jar</p>
<h3 id="完整连接测试"><a href="#完整连接测试" class="headerlink" title="完整连接测试"></a>完整连接测试</h3><p><img src="/2020/03/05/jmeter使用总结/image-20200316211954620.png" alt="image-20200316211954620"></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316212013962.png" alt="image-20200316212013962"></p>
<p>添加了聚合报告和查看结果数</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316212034160.png" alt="image-20200316212034160"></p>
<p>运行结果查看：</p>
<p>查看结果树</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316212049583.png" alt="image-20200316212049583"></p>
<p>聚合报告</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316212103747.png" alt="image-20200316212103747"></p>
<h2 id="带参数的复杂查询"><a href="#带参数的复杂查询" class="headerlink" title="带参数的复杂查询"></a>带参数的复杂查询</h2><h3 id="预查询语句"><a href="#预查询语句" class="headerlink" title="预查询语句"></a>预查询语句</h3><p><img src="/2020/03/05/jmeter使用总结/image-20200316213223900.png" alt="image-20200316213223900"></p>
<p>如果多个条件呢？ <strong>那就用逗号分隔开</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316213458203.png" alt="image-20200316213458203"></p>
<h3 id="预更新语句"><a href="#预更新语句" class="headerlink" title="预更新语句"></a>预更新语句</h3><p>同上</p>
<h3 id="演示查询结果集handle-resultset"><a href="#演示查询结果集handle-resultset" class="headerlink" title="演示查询结果集handle resultset"></a>演示查询结果集handle resultset</h3><p>接下来的案例主要演示下面这三个参数</p>
<pre><code>5、variable names  sql执行结果变量名
6、result variable names 所有结果当做一个对象存储
8、 handle resultset  处理结果集
</code></pre><p>也就是说，我们把结果输出到指定的类型</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316214044773.png" alt="image-20200316214044773"></p>
<p>需要结合debug sample采样器进行查看，查询的结果集（<strong>在线程组下面新建debug采样器</strong>）</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316214201102.png" alt="image-20200316214201102"></p>
<blockquote>
<p><strong>开始执行执行程序</strong></p>
</blockquote>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316214301250.png" alt="image-20200316214301250"></p>
<p>在结果树就可以看到</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316214624552.png" alt="image-20200316214624552"></p>
<h1 id="阿里云Linux服务器压测接口实战"><a href="#阿里云Linux服务器压测接口实战" class="headerlink" title="阿里云Linux服务器压测接口实战"></a>阿里云Linux服务器压测接口实战</h1><h2 id="Jmeter非GUI界面-参数讲解-一般压测不会使用gui界面进行操作，因为比较耗性能"><a href="#Jmeter非GUI界面-参数讲解-一般压测不会使用gui界面进行操作，因为比较耗性能" class="headerlink" title="Jmeter非GUI界面 参数讲解 - 一般压测不会使用gui界面进行操作，因为比较耗性能"></a>Jmeter非GUI界面 参数讲解 - 一般压测不会使用gui界面进行操作，因为比较耗性能</h2><p><img src="/2020/03/05/jmeter使用总结/image-20200316223338946.png" alt="image-20200316223338946"></p>
<p><strong>官方也是不推荐使用，gui窗口进行压测。**</strong>那么gui界面主要是用用来生成和调试jmx压力测试文件的，生成后，再使用jmeter命令进行命令行方式的脚本压测**</p>
<blockquote>
<p><strong>jmeter 命令行</strong></p>
</blockquote>
<p>​            -h 帮助<br>​            -n 非GUI模式<br>​            -t 指定要运行的 JMeter 测试脚本文件<br>​            -l 记录结果的文件 每次运行之前，(要确保之前没有运行过,即目录下的xxx.jtl不存在，不然报错)<br>​            -r Jmter.properties文件中指定的所有远程服务器<br>​            -e 在脚本运行结束后生成html报告<br>​            -o 用于存放html报告的目录（目录要为空，不然报错）</p>
<pre><code>官方配置文件地址 http://jmeter.apache.org/usermanual/get-started.html
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用例子</div><div class="line">jmeter -n -t linux_users_api.jmx -l result.jtl -e -o /usr/local/softwate/jmeter/temp/ResultReport</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>所以整个压测流程是：</strong></p>
</blockquote>
<ul>
<li><p><strong>首先在windows使用gui界面，创建测试计划（jmx文件）</strong></p>
</li>
<li><p><strong>接着上传jmx测试脚本到需要测试服务器（一般跟项目所在服务器不同）（例如项目在147，那么测试肯定不在147上进行，可以在其他服务器，例如在148进行测试脚本的执行）</strong></p>
</li>
<li><p><strong>获取测试报告进行分析</strong></p>
</li>
</ul>
<h2 id="压测后的jtl结果文件"><a href="#压测后的jtl结果文件" class="headerlink" title="压测后的jtl结果文件"></a>压测后的jtl结果文件</h2><p>通过上面的测试，我们会得到一个结果文件<code>result.jtl</code> ，那么我们接下来就把他从linux上下载到windows本机上进行查看。</p>
<p><strong>可以通过打开jmeter，新建线程组–&gt;监听器-&gt;summary report-&gt;浏览文件.</strong></p>
<p><strong>然后选择我们下载下来的result.jtl进行查看</strong></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200508100152073.png" alt="image-20200508100152073"></p>
<p>你会发现他的测试报告就跟上面我们创建的<code>聚合报告</code> 是一样的。</p>
<h2 id="html压测报告分析"><a href="#html压测报告分析" class="headerlink" title="html压测报告分析"></a>html压测报告分析</h2><blockquote>
<p><strong>Dashboard的核心指标</strong></p>
</blockquote>
<pre><code>1）Test and Report informations
    Source file：jtl文件名
    Start Time ：压测开始时间
    End Time ：压测结束时间
    Filter for display：过滤器
    Lable:sampler采样器名称    

2）APDEX(Application performance Index)
    apdex:应用程序性能指标,范围在0~1之间，1表示达到所有用户均满意
    T(Toleration threshold)：可接受阀值
    F(Frustration threshold)：失败阀值

3）Requests Summary
    OK:成功率
    KO:失败率
4）Statistics 统计数据
    lable:sampler采样器名称

    samples:请求总数，并发数*循环次数
    KO:失败次数
    Error%:失败率

    Average:平均响应时间
    Min:最小响应时间
    Max:最大响应时间
    90th pct: 90%的用户响应时间不会超过这个值（关注这个就可以了）
     举个例子，假设有10个请求，每个请求可能服务器相应的时间都不一样：2ms,3ms,4,5,2,6,8,3,9,11
     那么，我们去掉极端的%10，也就是响应时间是11s，那么剩下的百分之90，最大的响应时间就是9ms，那么也就意味着，90%的用户响应时间不会超过这个9ms这个值

    95th pct: 95%的用户响应时间不会超过这个值
    99th pct: 99%的用户响应时间不会超过这个值 (存在极端值)
    throughtput:Request per Second吞吐量 qps

    received:每秒从服务器接收的数据量
    send：每秒发送的数据量
</code></pre><blockquote>
<p><strong>Charts的核心指标</strong></p>
</blockquote>
<pre><code>1、charts讲解
    1)Over Time（随着时间的变化）
        Response Times Over Time：响应时间变化趋势（比较关注）
        Response Time Percentiles Over Time (successful responses)：最大，最小，平均，用户响应时间分布
        Active Threads Over Time：并发用户数趋势
        Bytes Throughput Over Time：每秒接收和请求字节数变化，蓝色表示发送，黄色表示接受
        Latencies Over Time：平均响应延时趋势
        Connect Time Over Time    ：连接耗时趋势

    1)Throughput
        Hits Per Second (excluding embedded resources):每秒点击次数
        Codes Per Second (excluding embedded resources)：每秒状态码数量
        Transactions Per Second：即TPS，每秒事务数
        Response Time Vs Request：响应时间和请求数对比
        Latency Vs Request：延迟时间和请求数对比

    1)Response Times（接口整体性能）
        Response Time Percentiles：响应时间百分比
        Response Time Overview：响应时间概述
        Time Vs Threads：活跃线程数和响应时间
        Response Time Distribution：响应时间分布图
</code></pre><h2 id="Jmeter压测接口的性能优化"><a href="#Jmeter压测接口的性能优化" class="headerlink" title="Jmeter压测接口的性能优化"></a><strong>Jmeter压测接口的性能优化</strong></h2><p>在使用Jmeter压测减少资源使用的一些建议，即压测结果更准确：</p>
<p>1、使用非GUI模式：jmeter -n -t test.jmx -l result.jtl</p>
<p>2、少使用Listener， 如果使用-l参数，它们都可以被删除或禁用（我们还记得之前创建过的查看结果数、聚合报告等等listener，在真实测试时，最好去掉）。<br>3、在加载测试期间不要使用“查看结果树”或“查看结果”表监听器，只能在脚本阶段使用它们来调试脚本。</p>
<p>4、包含控制器在这里没有帮助，因为它将文件中的所有测试元素添加到测试计划中<br>5、不要使用功能模式,使用CSV输出而不是XML<br>6、只保存你需要的数据,尽可能少地使用断言</p>
<p>7、如果测试需要大量数据，可以提前准备好测试数据放到数据文件中，以CSV Read方式读取。<br>8、用内网压测，减少其他带宽影响压测结果<br>9、如果压测大流量，尽量用多几个节点以非GUI模式向服务器施压</p>
<p>官方推荐 ：<a href="http://jakarta.apache.org/jmeter/usermanual/best-practices.html#lean_mean" target="_blank" rel="external">http://jakarta.apache.org/jmeter/usermanual/best-practices.html#lean_mean</a></p>
<h1 id="分布式压测基础知识"><a href="#分布式压测基础知识" class="headerlink" title="分布式压测基础知识"></a>分布式压测基础知识</h1><p> 普通压测：单台机可以对目标机器产生的压力比较小，受限因素包括CPU，网络，IO等<br>         分布式压测：利用多台机器向目标机器产生压力，模拟几万用户并发访问</p>
<p><strong>Jmeter分布式压测原理</strong></p>
<p>​        1、总控机器的节点master，其他产生压力的机器叫“肉鸡” server<br>​        2、master会把压测脚本发送到 server上面</p>
<p>​    3、执行的时候，server上只需要把jmeter-server打开就可以了，不用启动jmeter<br>​    4、结束后，server会把压测数据回传给master,然后master汇总输出报告<br>​    5、配置详情</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200316220705994.png" alt="image-20200316220705994"></p>
<blockquote>
<p><strong>分布式压测注意事项：</strong></p>
</blockquote>
<p>​    the firewalls on the systems are turned off or correct ports are opened.<br>​            系统上的防火墙被关闭或正确的端口被打开。</p>
<p>​        all the clients are on the same subnet.<br>​        所有的客户端都在同一个子网上。</p>
<p>​        the server is in the same subnet, if 192.x.x.x or 10.x.x.x IP addresses are used. If the server doesn’t use 192.xx or 10.xx IP address, there shouldn’t be any problems.<br>​        如果使用192.x.x.x或10.x.x.x IP地址，则服务器位于同一子网中。 如果服务器不使用192.xx或10.xx IP地址，则不应该有任何问题。</p>
<p>​        Make sure JMeter can access the server.<br>​        确保JMeter可以访问服务器。</p>
<p>​        Make sure you use the same version of JMeter and Java on all the systems. Mixing versions will not work correctly.<br>​        确保在所有系统上使用相同版本的JMeter和Java。 混合版本将无法正常工作。</p>
<p>​        You have setup SSL for RMI or disabled it.<br>​        您已为RMI设置SSL或将其禁用。</p>
<p>​        官网地址 <a href="http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html" target="_blank" rel="external">http://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html</a></p>
<p>​        <strong>压测注意事项：一定要用内网IP，不用用公网IP,用ping去检查</strong></p>
<blockquote>
<p>注意事项</p>
</blockquote>
<p><strong>（1）启动 slave</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">	./jmeter-server 或者    nohup ./jmeter-server &amp;</div><div class="line"></div><div class="line">检查启动是否成功</div><div class="line">	ps -ef|grep jmeter-server</div><div class="line">	ps aux|grep jmeter-server</div></pre></td></tr></table></figure>
<p>启动slave的过程中可能遇到问题，那么这些问题的解决方案如下：</p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200508104723019.png" alt="image-20200508104723019"></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200508104740337.png" alt="image-20200508104740337"></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200508104801678.png" alt="image-20200508104801678"></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200508104908936.png" alt="image-20200508104908936"></p>
<p><img src="/2020/03/05/jmeter使用总结/image-20200508105008406.png" alt="image-20200508105008406"></p>
<h2 id="开始分布式压测"><a href="#开始分布式压测" class="headerlink" title="开始分布式压测"></a>开始分布式压测</h2><p>​    1.修改master节点信息：<br>​        jemeter.properties 值是slave机器的ip+端口号，如果有多个，用逗号分隔</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">remote_hosts=192.168.0.102:8899,192.168.0.101:8899</div><div class="line">server.rmi.ssl.disable=true (前面有说到)</div></pre></td></tr></table></figure>
<p>​    </p>
<p> 2.启动slave机器，注意要同个网段，ip地址用内网ip</p>
<pre><code>./jmeter-server
        Using local port: 8899
        Created remote object: UnicastServerRef2 [liveRef: [endpoint:[192.168.0.102:8899](local),objID:[3a585a4d:162724586ab:-7fff, 3963132813614033916]]]
</code></pre><p>3.启动master开始压测</p>
<pre><code>./jmeter -n -t /Users/jack/Desktop/remote.jmx -r -l /Users/jack/Desktop/jtl/result.jtl -e -o /Users/jack/Desktop/result

        Creating summariser &lt;summary&gt;
        Created the tree successfully using /Users/jack/Desktop/remote.jmx
        Configuring remote engine: 172.20.10.3:8899
        Using local port: 8899
        Configuring remote engine: 172.20.10.11:8899
        Starting remote engines
        Starting the test @ Thu Mar 29 23:21:13 CST 2018 (1522336873931)
        Remote engines have been started
        Waiting for possible Shutdown/StopTestNow/Heapdump message on port 4445
        summary =      4 in 00:00:22 =    0.2/s Avg:  5582 Min:    94 Max: 21006 Err:     1 (25.00%)
        Tidying up remote @ Thu Mar 29 23:21:36 CST 2018 (1522336896842)
        ... end of run


    相关资料：
        https://www.cnblogs.com/Fine-Chan/p/6233823.html
        https://blog.csdn.net/liujingqiu/article/details/52635289
        https://www.cnblogs.com/puresoul/p/4844539.html
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用压测工具比对&quot;&gt;&lt;a href=&quot;#常用压测工具比对&quot; class=&quot;headerlink&quot; title=&quot;常用压测工具比对&quot;&gt;&lt;/a&gt;常用压测工具比对&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1、loadrunner
    性能稳定，压测结果及细粒度大，可以自定义脚
    
    </summary>
    
      <category term="压测工具" scheme="http://kingge.top/categories/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jmeter" scheme="http://kingge.top/tags/Jmeter/"/>
    
      <category term="Jmeter压测" scheme="http://kingge.top/tags/Jmeter%E5%8E%8B%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper源码解析</title>
    <link href="http://kingge.top/2020/02/02/zookeeper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://kingge.top/2020/02/02/zookeeper源码解析/</id>
    <published>2020-02-02T11:12:44.000Z</published>
    <updated>2020-05-09T09:16:41.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zk集群角色"><a href="#zk集群角色" class="headerlink" title="zk集群角色"></a>zk集群角色</h1><p>leader：负责进行投票的发起和决议，最终更新状态。</p>
<p>follower：用于接收客户请求，并返回结果。参与竞争leader的投票。</p>
<p>observer：可以接收客户的请求，将写请求转发给leader节点，但是<strong>observer不参与投票</strong>，只是同步leader的状态（同步leader的数据）。observer是作为系统扩展节点。</p>
<p>learner：和leader进行状态同步的server统称为学习者。例如上面的跟随者和观察者都是learner。</p>
<h2 id="为什么需要observer"><a href="#为什么需要observer" class="headerlink" title="为什么需要observer"></a>为什么需要observer</h2><p>​    如果我们想增加follower来进行应对多客户的请求，那么会有个问题，那么就是follower是会参与leader的投票的，增加了服务器的数量，意味着，增加了zab协议中投票过程的压力，从而使得zk集群的不可用时间增加。</p>
<p>​    因为leader节点必须等待集群中过半server响应投票，于是节点的增加使得部分计算机运行缓慢，从而拖慢整个投票过程的可能性也随着提高。写操作效率也会下降。zk集群的不断增大，但是写操作的吞吐量反而下降，这就违背了我们的意愿。</p>
<p>​    <strong>那么我们就需要增加一种跟follower不同的server，他是不参与投票的。那么这个就是observer。</strong></p>
<p>也就是说observer除了不参与投票外，他跟follower是一样的。</p>
<blockquote>
<p><strong>zk集群配置observer</strong></p>
</blockquote>
<p>zoo.cfg文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">peerType=observer</div><div class="line">server.4=0.0.0.0:2888:3888:observer</div></pre></td></tr></table></figure>
<p>然后启动就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ./zkServer.sh status</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: J:\JavaSoftwareRuntime\apache-zookeeper-3.5.7-bin\conf\zoo.cfg</div><div class="line">Client port found: 2181. Client address: localhost.</div><div class="line">Mode: observer</div></pre></td></tr></table></figure>
<h2 id="怎么保证一致性"><a href="#怎么保证一致性" class="headerlink" title="怎么保证一致性"></a>怎么保证一致性</h2><p>​    zk集群中的所有server都可以接受客户的请求，如果是读请求，那么当前server直接处理并返回结果，但是如果是写请求，那么当前server节点需要转发请求给leader进行处理。这个协议就是我们所说的<strong>zab协议。</strong></p>
<p>​    简答来说，zab协议规定，来自客户端的所有写请求，都要转发给zk集群中的唯一一台leader处理，有leader根据该请求发起一个proposal，收到proposal的server进行投票，之后返回结果给leader，leader收集结果。当投票结果过半时leader会向所有的server发送一个通知请求。</p>
<p>​    最后server收到请求后，会把该操作更新到内存中，完成写请求。然后返回结果给客户端。</p>
<p>​    zk满足了CAP原则中的CP。比如现在集群中有Leader和Follower两种角色，那么当其中任意一台服务器挂掉了，都要重新进行选举，在选举过程中，集群是不可用的，这就是牺牲了可用性。</p>
<p>​     但是，如果集群中有Leader、Follower、Observer三种角色，那么如果挂掉的是Observer，那么对于集群来说 并没有影响，集群还是可以用的，只是Observer节点的数据不同了，从这个角度考虑，Zookeeper又牺牲了 一致性，满足了AP。</p>
<p>需要注意的是：<strong>zk并不能够保证强一致性（在某个时刻，任意客户端读取到的数据都是一样的），它能够保证在一定时间范围内数据是一致的。他保证了顺序一致性。（至于为为什么，请看下面的源码分析）</strong></p>
<h1 id="zk的ACL节点权限"><a href="#zk的ACL节点权限" class="headerlink" title="zk的ACL节点权限"></a>zk的ACL节点权限</h1><p>在实际开发中，某些zk 的节点，我们不允许其他人任意的修改和删除，所以需要个特定的节点添加权限，保证节点的安全。</p>
<p>其特性如下：</p>
<ol>
<li>ZooKeeper的权限控制是基于<strong>每个znode节点的，需要对每个节点设置权限</strong>。</li>
<li>每个znode支持设置多种权限控制方案和多个权限</li>
<li><strong>子节点不会继承父节点的权限</strong>，客户端无权访问某节点，但可能可以访问它的子节点。</li>
</ol>
<p><strong>zk支持准确的控制某个节点的权限，权限的设置也仅仅只是对当前节点生效。</strong></p>
<blockquote>
<p><strong>zk的权限:</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">权限</th>
<th style="text-align:left">ACL简写</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CREATE</td>
<td style="text-align:left">c</td>
<td style="text-align:left">可以创建子节点</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">d</td>
<td style="text-align:left">可以删除子节点（仅下一级节点）</td>
</tr>
<tr>
<td style="text-align:left">READ</td>
<td style="text-align:left">r</td>
<td style="text-align:left">可以读取节点数据及显示子节点列表</td>
</tr>
<tr>
<td style="text-align:left">WRITE</td>
<td style="text-align:left">w</td>
<td style="text-align:left">可以设置节点数据</td>
</tr>
<tr>
<td style="text-align:left">ADMIN</td>
<td style="text-align:left">a</td>
<td style="text-align:left">可以设置节点访问控制列表权限</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>zk权限认证方式</strong></p>
</blockquote>
<p><strong>ACL 权限控制，使用：schema​ : id:permission 来标识，主要涵盖 3 个方面：</strong></p>
<ol>
<li><strong>权限模式（Schema）：鉴权的策略</strong></li>
<li><strong>授权对象（ID）</strong></li>
<li><strong>权限（Permission）</strong></li>
</ol>
<p><strong>1、schema：</strong></p>
<p><strong>ZooKeeper内置了一些权限控制方案，可以用以下方案为每个节点设置权限：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>方案</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>world</strong></td>
<td style="text-align:center"><strong>只有一个用户：anyone，代表所有人都能够操作（创建的节点，默认就是这个策略）</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>ip</strong></td>
<td style="text-align:center"><strong>使用IP地址认证</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>auth</strong></td>
<td style="text-align:center"><strong>使用已添加认证的用户认证。代表已经认证通过的用户(cli中可以通过addauth digest user:pwd 来添加当前上下文中的授权用户)</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>digest</strong></td>
<td style="text-align:center"><strong>使用“用户名:密码”方式认证</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>Super</strong></td>
<td style="text-align:center"><strong>超级用户</strong></td>
</tr>
</tbody>
</table>
<p><strong>2、id</strong></p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200408144623344.png" alt="image-20200408144623344"></p>
<blockquote>
<p><strong>权限相关命令：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">使用方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getAcl</td>
<td style="text-align:left">getAcl <path></path></td>
<td style="text-align:left">读取ACL权限</td>
</tr>
<tr>
<td style="text-align:left">setAcl</td>
<td style="text-align:left">setAcl <path></path> <acl></acl></td>
<td style="text-align:left">设置ACL权限</td>
</tr>
<tr>
<td style="text-align:left">addauth</td>
<td style="text-align:left">addauth <scheme> <auth></auth></scheme></td>
<td style="text-align:left">添加认证用户</td>
</tr>
</tbody>
</table>
<h2 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h2><blockquote>
<p><strong>默认权限</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">11</span>] create /kingge</div><div class="line">Created /kingge</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">12</span>] getAcl /kingge</div><div class="line"><span class="string">'world,'</span>anyone</div><div class="line">: cdrwa</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">13</span>]</div></pre></td></tr></table></figure>
<p>可以看到默认的权限是： 对于所有用户都具有cdrwa。也就是任意操作</p>
<blockquote>
<p><strong>设置acl</strong></p>
</blockquote>
<p><strong>1.设置写和管理权限</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">13</span>] setAcl /kingge world:anyone:wa</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">14</span>] getAcl /kingge</div><div class="line"><span class="string">'world,'</span>anyone</div><div class="line">: wa</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">15</span>] get /kingge</div><div class="line">org.apache.zookeeper.KeeperException$NoAuthException: KeeperErrorCode = NoAuth <span class="keyword">for</span> /kingge</div><div class="line"></div><div class="line">你会发现，客户端已经失去了对kingge节点的读权限。</div></pre></td></tr></table></figure>
<h2 id="好的文档"><a href="#好的文档" class="headerlink" title="好的文档"></a>好的文档</h2><p><a href="https://blog.csdn.net/weixin_40861707/article/details/80403213" target="_blank" rel="external">https://blog.csdn.net/weixin_40861707/article/details/80403213</a></p>
<p><a href="https://blog.csdn.net/liuxiao723846/article/details/79391650" target="_blank" rel="external">https://blog.csdn.net/liuxiao723846/article/details/79391650</a></p>
<h1 id="zk客户端创建的三种方式"><a href="#zk客户端创建的三种方式" class="headerlink" title="zk客户端创建的三种方式"></a>zk客户端创建的三种方式</h1><h2 id="原生方式"><a href="#原生方式" class="headerlink" title="原生方式"></a>原生方式</h2><p>也就是直接使用ZooKeeper这个类构件一个client客户端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ZooKeeper keeper = new ZooKeeper(&quot;localhost:2181&quot;, 5000, new Watcher() &#123;</div><div class="line">	@Override</div><div class="line">	public void process(WatchedEvent event) &#123;</div><div class="line">		System.out.println( &quot;输出的事件：&quot;+ event.toString() );</div><div class="line">	&#125;</div><div class="line">&#125;);//；连接客户端</div><div class="line"></div><div class="line">//创建临时节点</div><div class="line">keeper.create(&quot;/app2&quot;, &quot;123&quot;.getBytes(), null, CreateMode.EPHEMERAL, null, null);</div><div class="line"></div><div class="line">//监听节点</div><div class="line">		Stat stat = new Stat();;</div><div class="line">keeper.getData(&quot;/app&quot;, new Watcher() &#123;</div><div class="line">	@Override</div><div class="line">	public void process(WatchedEvent event) &#123;</div><div class="line">		System.out.println( &quot;监听kinge节点输出的事件：&quot;+event );</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;, stat );//只能监听一次</div></pre></td></tr></table></figure>
<p>需要依赖的是，zookeeper的jar包，例如zookeeper-3.4.10.jar。</p>
<p><strong>先看看zookeeper本身自带的客户端的问题。</strong></p>
<p>1) ZooKeeper的Watcher是一次性的，用过了需要再注册（<strong>zk的特性，监听器只能够使用一次，如果需要重复监听，那么需要再注册）</strong></p>
<p>2) session的超时后没有自动重连，生产环境中如果网络出现不稳定情况，那么这种情况出现的更加明显；</p>
<p>3) 没有领导选举机制，集群情况下可能需要实现stand by，一个服务挂了，另一个需要接替的效果；</p>
<p>4) 客户端只提供了存储byte数组的接口，而项目中一般都会使用对象。</p>
<p>5) 客户端接口需要处理的异常太多，并且通常，我们也不知道如何处理这些异常。</p>
<h2 id="使用zkClient"><a href="#使用zkClient" class="headerlink" title="使用zkClient"></a>使用zkClient</h2><p>需要依赖 zkclient的jar包，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;com.101tec&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;0.10&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<pre><code>ZkClient client = new ZkClient(&quot;localhost:2181&quot;, 5000, 5000);//客户端
    client.createEphemeral(&quot;/app2&quot;, null);//创建临时节点

    //监听节点
    client.subscribeDataChanges(&quot;/app&quot;, new IZkDataListener() {

            @Override
            public void handleDataDeleted(String t) throws Exception {
                     System.out.println( &quot; handleDataDeleted :&quot; +  t);            
            }

            @Override
            public void handleDataChange(String arg0, Object arg1) throws Exception {

                System.out.println( &quot; handleDataChange :&quot; +  arg0  + &quot; - &quot; + arg1);            
            }
        });//可以多次监听，多次调用handleDataDeleted或者handleDataChange方法
</code></pre><p>解决了zookeeper原生客户端不能够多次监听的缺点。</p>
<h2 id="curator客户端"><a href="#curator客户端" class="headerlink" title="curator客户端"></a>curator客户端</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">		&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-client&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>，如果是导入jar的形式，则是依赖着三个：<img src="/2020/02/02/zookeeper源码解析/image-20200408161037598.png" alt="image-20200408161037598"></p>
<h1 id="zookeeper中zoo-cfg详解"><a href="#zookeeper中zoo-cfg详解" class="headerlink" title="zookeeper中zoo.cfg详解"></a>zookeeper中zoo.cfg详解</h1><p>zookeeper通常采用配置文件zoo.cfg加载配置，其可以配置的参数为：</p>
<ul>
<li><code>clientPort:</code>用于配置当前服务器<code>对客户端暴露的端口</code>，一般配置为2181,无默认值</li>
<li><code>dataDir:</code>用于配置zookeeper服务器存储快照文件（zookeeper 节点数据）的目录，无默认值</li>
<li><code>dataLogDir:</code>用于配置服务器存储事务日志文件的目录，有默认值dataDir,但是建议将两个目录分别配置，防止磁盘的并发读写，影响服务器性能。可将其配置在一个单独的磁盘上。</li>
<li><code>tickTime:</code>心跳时间，用于配置服务器最小时间的单位，默认值3000ms,心跳检测时间通常是该单位的倍数。如客户端与服务端之间的会话超时时间在2<em>tickTime~20</em>tickTime之间。</li>
<li><code>initLimit:</code>用于配置leader服务器等待Follewer服务器启动，并完成数据同步的时间，默认为10，表示10*tickTime</li>
<li><code>syncLimit:</code>用于配置leader服务器和Follewer服务器之间进行心跳检测的最大延时时间，默认为5，表示5*tickTime</li>
<li><code>minSessionTimeout &amp; maxSessionout:</code>用于服务端对客户端会话超时时间的限制，也就是客户端自定义的超时时间必须在minSessionTimeout~maxSessionout内，其默认为分别为2 和 20，时间表示为2<em>tickTime~20</em>tickTime</li>
<li><code>maxClientCnxns:</code>从socket层面限制单个客户端和单台服务器之间的最大并发连接数，即以IP地址粒度来进行连接数的限制，如果为0，表示不作限制，默认为60</li>
<li><code>clientPortAddress:</code>针对多网卡的机器，该参数允许为每个IP地址指定不同的监听端口</li>
<li><code>server.id=host:port:port:</code>用于配置组成zookeeper集群的机器列表，其中id为serverId,与myid文件中的值对应。第一个端口用于指定Leader服务器和Follewer服务器进行运行时通信和数据同步所使用的端口，第二个端口用于进行Leader选举过程中的投票通信</li>
<li><code>autopurge.snapRetainCount:</code>用于配置zookeeper在自动清理的时候需要保留的快照数据文件数量和对应的事务日志文件，默认为3，切自定义值小于3也会取值3</li>
</ul>
<hr>
<p>仅支持系统属性方式配置的参数：</p>
<ul>
<li><p><code>snapCount:</code>用于配置相邻两次数据快照之间的事务操作次数，即zookeeper会在snapCount次事务之后进行一次数据快照，默认为100000</p>
</li>
<li><p><code>preAllocSize:</code>用于配置zookeeper事务日志文件预分配的磁盘空间大小,默认为65536，单位KB,即64MB,与snapCount同时修改，如将snapCount设置为500，每次事务操作的数据量最多为1KB,则preAllocSize设置为500即可<br> <code>forceSync:</code>用于配置zookeeper是否在事务提交的时候，将日志写入操作强制刷入磁盘，默认为yes,表示强制刷盘<br> <code>skipAcl:</code>用于配置zookeeper是否跳过ACL权限检查，默认为mo，即会对每一个客户端请求进行权限检查</p>
</li>
</ul>
<p>zoo.cfg介绍<br> <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Flikui360%2Fp%2F5985588.html" target="_blank" rel="external">https://www.cnblogs.com/likui360/p/5985588.html</a></p>
<h1 id="单机模式"><a href="#单机模式" class="headerlink" title="########单机模式"></a>########单机模式</h1><h1 id="zk客户端源码解析"><a href="#zk客户端源码解析" class="headerlink" title="zk客户端源码解析"></a>zk客户端源码解析</h1><h2 id="使用zkCli-sh起送客户端"><a href="#使用zkCli-sh起送客户端" class="headerlink" title="使用zkCli.sh起送客户端"></a>使用zkCli.sh起送客户端</h2><p>我们来查看一下zkCli.sh文件的内容</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409083750078.png" alt="image-20200409083750078"></p>
<p>发现他最终是通过运行org.apache.zookeeper.ZooKeeperMain 这个类来启动客户端</p>
<h2 id="ZooKeeperMain源码-初始化zk客户端"><a href="#ZooKeeperMain源码-初始化zk客户端" class="headerlink" title="ZooKeeperMain源码 - 初始化zk客户端"></a>ZooKeeperMain源码 - 初始化zk客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connectToZK</span><span class="params">(String newHost)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (zk != <span class="keyword">null</span> &amp;&amp; zk.getState().isAlive()) &#123;</div><div class="line">            zk.close();</div><div class="line">        &#125;</div><div class="line">        host = newHost;</div><div class="line">        <span class="keyword">boolean</span> readOnly = cl.getOption(<span class="string">"readonly"</span>) != <span class="keyword">null</span>;</div><div class="line">        zk = <span class="keyword">new</span> ZooKeeper(host,</div><div class="line">                 Integer.parseInt(cl.getOption(<span class="string">"timeout"</span>)),</div><div class="line">                 <span class="keyword">new</span> MyWatcher(), readOnly);<span class="comment">//3.使用zk原生客户端连接方式，进行连接</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="comment">//1.首先执行main方法</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> KeeperException, IOException, InterruptedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        ZooKeeperMain main = <span class="keyword">new</span> ZooKeeperMain(args);</div><div class="line">        main.run();<span class="comment">//1.1 while循环，解析客户端命令行，然后判断操作类型，用connectToZK构建的zk客户端，请求服务端执行相应操作指令。例如客户端输入create /app 123  ，那么就会调用zk.create（"/app",123）请求服务端。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperMain</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">        cl.parseOptions(args);</div><div class="line">        System.out.println(<span class="string">"Connecting to "</span> + cl.getOption(<span class="string">"server"</span>));</div><div class="line">        connectToZK(cl.getOption(<span class="string">"server"</span>));<span class="comment">//2.构建zk连接</span></div><div class="line">        <span class="comment">//zk = new ZooKeeper(cl.getOption("server"),</span></div><div class="line"><span class="comment">//                Integer.parseInt(cl.getOption("timeout")), new MyWatcher());</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​    由上面可以得知，zkmain类，最终的目的是：解析命令行的参数，保存到MyCommandOptions配置类，然后通过zookeeper类，构建一个到服务端的连接。</p>
<h3 id="zookeeper构建连接源码"><a href="#zookeeper构建连接源码" class="headerlink" title="zookeeper构建连接源码"></a>zookeeper构建连接源码</h3><p>上面构建zk客户端的连接最终的调用的代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> canBeReadOnly)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        LOG.info(<span class="string">"Initiating client connection, connectString="</span> + connectString</div><div class="line">                + <span class="string">" sessionTimeout="</span> + sessionTimeout + <span class="string">" watcher="</span> + watcher);</div><div class="line"></div><div class="line">        watchManager.defaultWatcher = watcher;<span class="comment">//默认的总的监听器。</span></div><div class="line"></div><div class="line">        <span class="comment">//connectString可能是：localhost:2181,localhost:2182，这样的集群地址</span></div><div class="line">        ConnectStringParser connectStringParser = <span class="keyword">new</span> ConnectStringParser(</div><div class="line">                connectString);<span class="comment">//1.解析zk的server地址，因为有可能是集群，所以需要根据，分割</span></div><div class="line">        <span class="comment">//最后保存在ArrayList&lt;InetSocketAddress&gt; serverAddresses中</span></div><div class="line">        HostProvider hostProvider = <span class="keyword">new</span> StaticHostProvider(</div><div class="line">                connectStringParser.getServerAddresses());<span class="comment">//2.将上面解析到的server地址列表，赋值给HostProvider。同时StaticHostProvider类包含了如何选出集群中server地址，以便客户端连接。</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        cnxn = <span class="keyword">new</span> ClientCnxn(connectStringParser.getChrootPath(),</div><div class="line">                hostProvider, sessionTimeout, <span class="keyword">this</span>, watchManager,</div><div class="line">                getClientCnxnSocket(), canBeReadOnly);<span class="comment">//3.chrootPat默认是null，canBeReadOnly是否是只读模式</span></div><div class="line">        cnxn.start();<span class="comment">//4.启动ClientCnxn创建的两个线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//解释一下只读模式，假设集群有三台服务器，但是挂了两台，按道理整个集群是不可用的，但是我们可以开启只读模式，然后客户端还是能够请求集群获取数据，但是更新不了数据。</span></div></pre></td></tr></table></figure>
<p>​    <strong>代码1处</strong>，就是解析server端的地址，最后放到ConnectStringParser类的ArrayList<inetsocketaddress> serverAddresses 成员属性中。看里面的源码可以得知，connectString.split(“,”)，集群的地址，必须使用<code>,</code>分隔开。</inetsocketaddress></p>
<p><strong>代码2处</strong>，根据第一步解析出来的server端地址，然后<strong>打乱list里面的server地址</strong>，然后再<strong>随机取一个地址</strong>，进行连接。</p>
<p><strong>代码3处</strong>，首先根据getClientCnxnSocket()构建一个<strong>客户端连接服务端的socket</strong>，这里是通过NIO的形式（<strong>默认实现是ClientCnxnSocketNIO</strong>）。</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409085351851.png" alt="image-20200409085351851"></p>
<p>接着构建zk客户端连接 new ClientCnxn(..)。ClientCnxn可以理解创建了一个上下文<strong>，最终创建了两个线程</strong></p>
<p><strong>这两个线程很重要！！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClientCnxn</span><span class="params">(String chrootPath, HostProvider hostProvider, <span class="keyword">int</span> sessionTimeout, ZooKeeper zooKeeper,</span></span></div><div class="line"><span class="function"><span class="params">          ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span></span></div><div class="line"><span class="function"><span class="params">          <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd, <span class="keyword">boolean</span> canBeReadOnly)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.zooKeeper = zooKeeper;</div><div class="line">      <span class="keyword">this</span>.watcher = watcher;</div><div class="line">      <span class="keyword">this</span>.sessionId = sessionId;</div><div class="line">      <span class="keyword">this</span>.sessionPasswd = sessionPasswd;</div><div class="line">      <span class="keyword">this</span>.sessionTimeout = sessionTimeout;</div><div class="line">      <span class="keyword">this</span>.hostProvider = hostProvider;</div><div class="line">      <span class="keyword">this</span>.chrootPath = chrootPath;</div><div class="line"><span class="comment">//连接超时时间</span></div><div class="line">      connectTimeout = sessionTimeout / hostProvider.size();</div><div class="line">      <span class="comment">//读超时 时间</span></div><div class="line">      readTimeout = sessionTimeout * <span class="number">2</span> / <span class="number">3</span>;</div><div class="line">      readOnly = canBeReadOnly;</div><div class="line"></div><div class="line">      sendThread = <span class="keyword">new</span> SendThread(clientCnxnSocket);<span class="comment">//我们可以看到sendThread是以ClientCnxnSocketNIO为入参说明他是负责发送请求给服务端的。具体实现：他是负责从outgoingqueue队列中获取客户端要发送的请求，然后发送给服务端 - 处理客户端请求的线程</span></div><div class="line">  eventThread = <span class="keyword">new</span> EventThread();<span class="comment">//处理watcher事件的线程，在后面的代码分析中你会发现EventThread处理event事件数据来源，是在从SendThread哪里进行赋值到waitEventQueue队列中的。</span></div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>代码4</strong>，启动上面创建的两个线程，sendThread开始处理客户端发出的请求，eventThread开始处理根据服务端发出的响应事件的请求，开始处理事件。</p>
<p>​    这两个线程都是通过生产者和消费者模式，进行工作的进行，将请求都放到队列中，然后在他们的run方法中逐个拿出请求进行处理。</p>
<h4 id="SendThread初始化NIO进行与server端的通信-负责发送请求给服务端"><a href="#SendThread初始化NIO进行与server端的通信-负责发送请求给服务端" class="headerlink" title="SendThread初始化NIO进行与server端的通信 - 负责发送请求给服务端"></a>SendThread初始化NIO进行与server端的通信 - 负责发送请求给服务端</h4><p>​    我们知道 cnxn.start()最终会启动两个线程，那么我们先看一下SendThread线程，看名字应该知道他是一个发送消息的线程，也就是发送我们客户端的操作命令，例如”ls /“。</p>
<p>​    <strong>我们直接来看他的run方法</strong></p>
<p>​    首先判断客户端<strong>是否已经连接</strong>服务端，那么会进入这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!clientCnxnSocket.isConnected()) &#123;<span class="comment">//socket是否已经连接</span></div><div class="line">    <span class="keyword">if</span>(!isFirstConnect)&#123;<span class="comment">//如果不是首次连接，那么需要随机睡一会</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(r.nextInt(<span class="number">1000</span>));</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            LOG.warn(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// don't re-establish connection if we are closing</span></div><div class="line">    <span class="keyword">if</span> (closing || !state.isAlive()) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rwServerAddress != <span class="keyword">null</span>) &#123;</div><div class="line">        serverAddress = rwServerAddress;</div><div class="line">        rwServerAddress = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serverAddress = hostProvider.next(<span class="number">1000</span>);<span class="comment">//取下一个server连接的地址</span></div><div class="line">        <span class="comment">//如果是集群那么在next方法会进行逻辑判断，然后选取出下一个连接的server</span></div><div class="line">        <span class="comment">//地址,一般是调用Collections.shuffle()打乱地址列表然后随机获取</span></div><div class="line">    &#125;</div><div class="line">    startConnect(serverAddress);<span class="comment">//代码1处，最终会执行到，这里创建一个链接，接着调用 clientCnxnSocket.connect(addr);然后通过上面创建NIOorg.apache.zookeeper.ClientCnxnSocketNIO.connect(InetSocketAddress)，进行创建NIO连接</span></div><div class="line">    clientCnxnSocket.updateLastSendAndHeard();<span class="comment">//更新Socket最后一次发送以及收到消息的时间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们查看代码1处最终调用：一下方法都在ClientCnxnSocketNIO类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(InetSocketAddress addr)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    SocketChannel sock = createSock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">       registerAndConnect(sock, addr);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        LOG.error(<span class="string">"Unable to open socket to "</span> + addr);</div><div class="line">        sock.close();</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">    initialized = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Reset incomingBuffer</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    lenBuffer.clear();</div><div class="line">    incomingBuffer = lenBuffer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function">SocketChannel <span class="title">createSock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        SocketChannel sock;</div><div class="line">        sock = SocketChannel.open();</div><div class="line">        sock.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        sock.socket().setSoLinger(<span class="keyword">false</span>, -<span class="number">1</span>);</div><div class="line">        sock.socket().setTcpNoDelay(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> sock;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerAndConnect</span><span class="params">(SocketChannel sock, InetSocketAddress addr)</span> </span></div><div class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</div><div class="line">        <span class="keyword">boolean</span> immediateConnect = sock.connect(addr);</div><div class="line">        <span class="keyword">if</span> (immediateConnect) &#123;</div><div class="line">            sendThread.primeConnection();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="eventThread-处理watcher事件"><a href="#eventThread-处理watcher事件" class="headerlink" title="eventThread 处理watcher事件"></a>eventThread 处理watcher事件</h4><p><strong>关于这一章节的详细内容，在下面的《为什么监听的事件只处理一次之watcher源码解析中会讲到》</strong></p>
<h2 id="ZooKeeperMain-run-解析命令行，处理请求"><a href="#ZooKeeperMain-run-解析命令行，处理请求" class="headerlink" title="ZooKeeperMain.run() - 解析命令行，处理请求"></a>ZooKeeperMain.run() - 解析命令行，处理请求</h2><p><strong>经过上面初始化了zk客户端，那么接下来就是进行处理命令行的逻辑了。</strong></p>
<p>​    通过上面的分析，我们可以构建了一个zookeeper客户端，能够与服务端取得了连接，但是我们并没有看到在那里处理或者说，解析了命令行 。</p>
<p>​    例如我们输入 <code>create /kingge</code>创建一个节点，那么在那里解析这一行代码呢？</p>
<p><strong>那就是根据上面创建好的ZooKeeperMain，然后调用run方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, IOException, InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (cl.getCommand() == <span class="keyword">null</span>) &#123;</div><div class="line">        System.out.println(<span class="string">"Welcome to ZooKeeper!"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> jlinemissing = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// only use jline if it's in the classpath</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; consoleC = Class.forName(<span class="string">"jline.ConsoleReader"</span>);<span class="comment">//这个类就是控制台</span></div><div class="line">            Class&lt;?&gt; completorC =</div><div class="line">                Class.forName(<span class="string">"org.apache.zookeeper.JLineZNodeCompletor"</span>);<span class="comment">//自动补齐类</span></div><div class="line"></div><div class="line">            System.out.println(<span class="string">"JLine support is enabled"</span>);</div><div class="line"></div><div class="line">            Object console =</div><div class="line">                consoleC.getConstructor().newInstance();</div><div class="line"></div><div class="line">            Object completor =</div><div class="line">                completorC.getConstructor(ZooKeeper.class).newInstance(zk);</div><div class="line">            Method addCompletor = consoleC.getMethod(<span class="string">"addCompletor"</span>,</div><div class="line">                    Class.forName(<span class="string">"jline.Completor"</span>));</div><div class="line">            addCompletor.invoke(console, completor);</div><div class="line"></div><div class="line">            String line;</div><div class="line">            Method readLine = consoleC.getMethod(<span class="string">"readLine"</span>, String.class);</div><div class="line">            <span class="keyword">while</span> ((line = (String)readLine.invoke(console, getPrompt())) != <span class="keyword">null</span>) &#123;</div><div class="line">                executeLine(line);<span class="comment">//while循环处理请求。在这里解析命令行的操作</span></div><div class="line">            &#125;</div><div class="line">            。。。。</div></pre></td></tr></table></figure>
<p>我们是否还记得，当我们通过zkClie.sh连接到服务端的时候，控制台会输出这样的一行前缀：</p>
<p><code>[zk: localhost:2181(CONNECTED) 1]</code>  那么这一段输出，其实就是通过这里的getPrompt()方法进行打印的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getPrompt</span><span class="params">()</span> </span>&#123;       </div><div class="line">    <span class="keyword">return</span> <span class="string">"[zk: "</span> + host + <span class="string">"("</span>+zk.getState()+<span class="string">")"</span> + <span class="string">" "</span> + commandCount + <span class="string">"] "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们接着看executeLine()方法，发下他的内部实现，其实也很简单。最终调用processZKCmd()方法：</p>
<p>​    发现他就是通过，各种if对于命令的判断，然后执行相应的操作，例如输入的create命令，那么接着判断创建的是临时节点，还是持久化节点，等等，然后接着调用zk.create（）原生api进行节点的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (cmd.equals(<span class="string">"create"</span>) &amp;&amp; args.length &gt;= <span class="number">3</span>) &#123;</div><div class="line">           <span class="keyword">int</span> first = <span class="number">0</span>;</div><div class="line">           CreateMode flags = CreateMode.PERSISTENT;</div><div class="line">           <span class="keyword">if</span> ((args[<span class="number">1</span>].equals(<span class="string">"-e"</span>) &amp;&amp; args[<span class="number">2</span>].equals(<span class="string">"-s"</span>))</div><div class="line">                   || (args[<span class="number">1</span>]).equals(<span class="string">"-s"</span>) &amp;&amp; (args[<span class="number">2</span>].equals(<span class="string">"-e"</span>))) &#123;</div><div class="line">               first+=<span class="number">2</span>;</div><div class="line">               flags = CreateMode.EPHEMERAL_SEQUENTIAL;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>].equals(<span class="string">"-e"</span>)) &#123;</div><div class="line">               first++;</div><div class="line">               flags = CreateMode.EPHEMERAL;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>].equals(<span class="string">"-s"</span>)) &#123;</div><div class="line">               first++;</div><div class="line">               flags = CreateMode.PERSISTENT_SEQUENTIAL;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (args.length == first + <span class="number">4</span>) &#123;</div><div class="line">               acl = parseACLs(args[first+<span class="number">3</span>]);</div><div class="line">           &#125;</div><div class="line">           path = args[first + <span class="number">1</span>];</div><div class="line">           String newPath = zk.create(path, args[first+<span class="number">2</span>].getBytes(), acl,</div><div class="line">                   flags);<span class="comment">//这里的zk，就是前一步 ZooKeeperMain main = new ZooKeeperMain(args);创建出来的客户端。</span></div><div class="line">           System.err.println(<span class="string">"Created "</span> + newPath);<span class="comment">//控制台打印，创建节点路径</span></div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>​    下面我们就通过zk.create()这一种命令方式（<strong>其他的get，set命令类似的create的执行步骤，这里通过create命令进行分析</strong>），查看一下他的源码，分析一下，客户端究竟是怎么发送请求给服务端的。</p>
<h3 id="构建请求到请求队列中"><a href="#构建请求到请求队列中" class="headerlink" title="构建请求到请求队列中"></a>构建请求到请求队列中</h3><blockquote>
<p><strong>首先调用zookeeper.create（）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], List&lt;ACL&gt; acl,</span></span></div><div class="line"><span class="function"><span class="params">        CreateMode createMode)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">final</span> String clientPath = path;</div><div class="line">    PathUtils.validatePath(clientPath, createMode.isSequential());</div><div class="line"></div><div class="line">    <span class="keyword">final</span> String serverPath = prependChroot(clientPath);</div><div class="line"></div><div class="line">    RequestHeader h = <span class="keyword">new</span> RequestHeader();<span class="comment">//1.构建请求头</span></div><div class="line">    h.setType(ZooDefs.OpCode.create);<span class="comment">//2.请求类型，每种操作命令都对应着一个状态码，例如create命令是1，delete是2，getACL是6等等</span></div><div class="line">    CreateRequest request = <span class="keyword">new</span> CreateRequest();<span class="comment">//构建请求体</span></div><div class="line">    CreateResponse response = <span class="keyword">new</span> CreateResponse();<span class="comment">//构建响应，保存请求的结果</span></div><div class="line">    request.setData(data);</div><div class="line">    request.setFlags(createMode.toFlag());</div><div class="line">    request.setPath(serverPath);</div><div class="line">    <span class="keyword">if</span> (acl != <span class="keyword">null</span> &amp;&amp; acl.size() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.InvalidACLException();</div><div class="line">    &#125;</div><div class="line">    request.setAcl(acl);</div><div class="line">    ReplyHeader r = cnxn.submitRequest(h, request, response, <span class="keyword">null</span>);<span class="comment">//3.提交请求</span></div><div class="line">    <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()),</div><div class="line">                clientPath);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (cnxn.chrootPath == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> response.getPath();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> response.getPath().substring(cnxn.chrootPath.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里着重的看一下cnxn.submitRequest()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ReplyHeader <span class="title">submitRequest</span><span class="params">(RequestHeader h, Record request,</span></span></div><div class="line"><span class="function"><span class="params">        Record response, WatchRegistration watchRegistration)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    ReplyHeader r = <span class="keyword">new</span> ReplyHeader();</div><div class="line">    Packet packet = queuePacket(h, r, request, response, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</div><div class="line">                <span class="keyword">null</span>, watchRegistration);<span class="comment">//会把请求信息包装成一个Packet，然后把Packet放到一个队列中，LinkedList&lt;Packet&gt; outgoingQueue，接着调用 sendThread.getClientCnxnSocket().wakeupCnxn();</span></div><div class="line">    <span class="keyword">synchronized</span> (packet) &#123;<span class="comment">//阻塞，等待响应结果</span></div><div class="line">        <span class="keyword">while</span> (!packet.finished) &#123;<span class="comment">//如果packet没有处理完成则阻塞等待，什么时候完成呢？详情参见下面的doIO的获取响应结果的代码 - finishPacket(packet)。</span></div><div class="line">            packet.wait();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line">    sendThread.getClientCnxnSocket().wakeupCnxn();</div></pre></td></tr></table></figure>
<p>​    换句话说，zk会把create命令封装的请求，放在一个outgoingQueue的链表中，然后退出queuePacket()方法，接着阻塞synchronized (packet) 等待响应结果。</p>
<p>​    看到这里你有没有发现一个问题，那就是，到这里为止，<strong>仅仅只是把请求放到outgoingQueue队列中，那么什么时候处理队列里面的数据呢？也就是什么时候处理封装好的请求呢？</strong></p>
<p>​    <strong>那就是SendThread的run方法。</strong></p>
<p>​    还记得我们在上面说过，在创建zk客户端的时候，创建了两个线程，并启动。其中一个就是SendThread，<strong>那么他调用run方法，内部实现是一个while循环，从outgoingqueue中拿出请求进行发送给服务端</strong></p>
<h3 id="SendThread的run方法循环处理客户端请求和服务端响应"><a href="#SendThread的run方法循环处理客户端请求和服务端响应" class="headerlink" title="SendThread的run方法循环处理客户端请求和服务端响应"></a>SendThread的run方法循环处理客户端请求和服务端响应</h3><p>run方法内部就是通过这样一个方法，进行处理outgoingQueue队列中的请求，该方法，最终调用的是：<code>org.apache.zookeeper.ClientCnxnSocketNIO.doTransport</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue, ClientCnxn.<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>然后看里面的代码，因为我们执行的是create命令，那么需要查看NIO通道是否可写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != <span class="number">0</span>) &#123;</div><div class="line">                doIO(pendingQueue, outgoingQueue, cnxn);<span class="comment">//判断通道读或者写是否就绪，如果读就绪说明服务端已经处理请求完毕返回响应。如果写就绪说明，可以将请求发送给服务端。</span></div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>也就是说，<strong>doIO方法是处理客户端请求和服务端响应的核心方法。</strong></p>
<h4 id="发送客户端请求给服务端"><a href="#发送客户端请求给服务端" class="headerlink" title="发送客户端请求给服务端"></a>发送客户端请求给服务端</h4><blockquote>
<p><strong>接着查看doIO方法 - 关于发送请求的部分代码</strong></p>
</blockquote>
<p>写请求部分关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (sockKey.isWritable()) &#123;</div><div class="line">           <span class="keyword">synchronized</span>(outgoingQueue) &#123;</div><div class="line">               Packet p = findSendablePacket(outgoingQueue,</div><div class="line">                       cnxn.sendThread.clientTunneledAuthenticationInProgress());<span class="comment">//拿出队列中第一个packet请求。</span></div><div class="line"></div><div class="line">               <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                   updateLastSend();</div><div class="line">                   <span class="comment">// If we already started writing p, p.bb will already exist</span></div><div class="line">                   <span class="keyword">if</span> (p.bb == <span class="keyword">null</span>) &#123;</div><div class="line">                       <span class="keyword">if</span> ((p.requestHeader != <span class="keyword">null</span>) &amp;&amp;</div><div class="line">                               (p.requestHeader.getType() != OpCode.ping) &amp;&amp;</div><div class="line">                               (p.requestHeader.getType() != OpCode.auth)) &#123;</div><div class="line">                           p.requestHeader.setXid(cnxn.getXid());</div><div class="line">                       &#125;</div><div class="line">                       p.createBB();<span class="comment">//序列化请求，zk自己的序列化工具jute。没有用java的序列化工具</span></div><div class="line">                   &#125;</div><div class="line">                   sock.write(p.bb);<span class="comment">//发送请求给服务端</span></div><div class="line">                   <span class="keyword">if</span> (!p.bb.hasRemaining()) &#123;<span class="comment">//</span></div><div class="line">                       sentCount++;</div><div class="line">                       outgoingQueue.removeFirstOccurrence(p);<span class="comment">//从队列中移除已经处理的请求</span></div><div class="line">                       <span class="keyword">if</span> (p.requestHeader != <span class="keyword">null</span></div><div class="line">                               &amp;&amp; p.requestHeader.getType() != OpCode.ping</div><div class="line">                               &amp;&amp; p.requestHeader.getType() != OpCode.auth) &#123;</div><div class="line">                           <span class="keyword">synchronized</span> (pendingQueue) &#123;<span class="comment">//将已经处理的请求放到pendingQueue队列中</span></div><div class="line">                               pendingQueue.add(p);</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div></pre></td></tr></table></figure>
<p>为什么要将已经处理的请求放到判定队列中呢？那是因为，上面代码仅仅只是发送请求成功， 但是<strong>服务端还没有响应数据。</strong> 但是我们已经把outgoingQueue中已经发出去的请求给删除了，那么我怎么知道请求有没有发送成功，服务端有没有响应呢？</p>
<p>​    <strong>所以需要把将已经处理的请求放到pendingQueue判定队列中，等待判定。</strong></p>
<h4 id="处理服务端返回的响应数据"><a href="#处理服务端返回的响应数据" class="headerlink" title="处理服务端返回的响应数据"></a>处理服务端返回的响应数据</h4><p>​    实际上得到服务端响应结果的代码也是在doIO中。<strong>服务端的写请求对应的是客户端的读请求。</strong>所以我们查看一下这代码段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (sockKey.isReadable()) &#123;<span class="comment">//服务端可读，说明服务端已经返回数据</span></div><div class="line">    <span class="keyword">int</span> rc = sock.read(incomingBuffer);</div><div class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(</div><div class="line">                <span class="string">"Unable to read additional data from server sessionid 0x"</span></div><div class="line">                        + Long.toHexString(sessionId)</div><div class="line">                        + <span class="string">", likely server has closed socket"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!incomingBuffer.hasRemaining()) &#123;</div><div class="line">        incomingBuffer.flip();</div><div class="line">        <span class="keyword">if</span> (incomingBuffer == lenBuffer) &#123;</div><div class="line">            recvCount++;</div><div class="line">            readLength();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!initialized) &#123;</div><div class="line">            readConnectResult();</div><div class="line">            enableRead();</div><div class="line">            <span class="keyword">if</span> (findSendablePacket(outgoingQueue,</div><div class="line">                    cnxn.sendThread.clientTunneledAuthenticationInProgress()) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Since SASL authentication has completed (if client is configured to do so),</span></div><div class="line">                <span class="comment">// outgoing packets waiting in the outgoingQueue can now be sent.</span></div><div class="line">                enableWrite();</div><div class="line">            &#125;</div><div class="line">            lenBuffer.clear();</div><div class="line">            incomingBuffer = lenBuffer;</div><div class="line">            updateLastHeard();</div><div class="line">            initialized = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sendThread.readResponse(incomingBuffer);<span class="comment">//获取结果，然后从pendingqueue中移除已经获取响应结果的packet，然后最终 finishPacket(packet);，标记请求的packet已经完成，然后唤醒监听packet节点的线程。 p.notifyAll();</span></div><div class="line">            lenBuffer.clear();</div><div class="line">            incomingBuffer = lenBuffer;</div><div class="line">            updateLastHeard();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="sendThread-readResponse-读取服务端返回的信息"><a href="#sendThread-readResponse-读取服务端返回的信息" class="headerlink" title="sendThread.readResponse() - 读取服务端返回的信息"></a><strong>sendThread.readResponse() - 读取服务端返回的信息</strong></h5><p>需要注意的是，这个方法可能还<strong>额外处理服务端发出的其他请求</strong>。<strong>例如触发事件的请求</strong>。</p>
<p><strong>设么意思呢？</strong></p>
<p>举个例子：</p>
<pre><code>客户端A，执行命令getData(&quot;/app&quot;,true)，这里的true代表是本次getData请求，在获取app节点数据的同时，告诉服务端我要顺便绑定一个在app节点监听器（使用zk客户端默认监听器），如果app节点有什么变动你要通知我。
</code></pre><p>​    那么也就意味着，服务端在处理请求getData的时候，返回app节点数据给客户端，然后再readResponse()方法执行。本次请求结束。</p>
<p>​    那么当客户端紧接着在请求setData(“app”,123)，服务端在<strong>响应客户端说，我处理成功了的同时</strong>，<strong>还会再发出一个响应</strong>，就是通知客户端说你上次在我这里绑定了关于app节点的监听器，你要触发一下。</p>
<p>​    那么本次客户端的setData请求，<strong>总共会得到两个响应</strong>，那么这两个响应都是在readResponse()方法处理。</p>
<p>​    那么客户端怎么知道本次响应时普通的操作响应还是时间触发响应呢？通过xid的值进行判断，当xid==-1时说明本次响应时触发事件响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   。。。。。。。<span class="comment">//省略部分代码</span></div><div class="line"></div><div class="line">    Packet packet;</div><div class="line">    <span class="keyword">synchronized</span> (pendingQueue) &#123;<span class="comment">//获取响应结果后，然后从pendingqueue中移除已经获取响应结果的请求packet</span></div><div class="line">        <span class="keyword">if</span> (pendingQueue.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Nothing in the queue, but got "</span></div><div class="line">                    + replyHdr.getXid());</div><div class="line">        &#125;</div><div class="line">        packet = pendingQueue.remove();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">                <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">4</span>) &#123;</div><div class="line">            <span class="comment">// -4 is the xid for AuthPacket               </span></div><div class="line">            <span class="keyword">if</span>(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) &#123;</div><div class="line">                state = States.AUTH_FAILED;                    </div><div class="line">                eventThread.queueEvent( <span class="keyword">new</span> WatchedEvent(Watcher.Event.EventType.None, </div><div class="line">                        Watcher.Event.KeeperState.AuthFailed, <span class="keyword">null</span>) );            		            		</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                LOG.debug(<span class="string">"Got auth sessionid:0x"</span></div><div class="line">                        + Long.toHexString(sessionId));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">1</span>) &#123;<span class="comment">//处理服务端发出的触发事件的响应</span></div><div class="line">            <span class="comment">// -1 means notification</span></div><div class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                LOG.debug(<span class="string">"Got notification sessionid:0x"</span></div><div class="line">                    + Long.toHexString(sessionId));</div><div class="line">            &#125;</div><div class="line">            WatcherEvent event = <span class="keyword">new</span> WatcherEvent();</div><div class="line">            event.deserialize(bbia, <span class="string">"response"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// convert from a server path to a client path</span></div><div class="line">            <span class="keyword">if</span> (chrootPath != <span class="keyword">null</span>) &#123;</div><div class="line">                String serverPath = event.getPath();</div><div class="line">                <span class="keyword">if</span>(serverPath.compareTo(chrootPath)==<span class="number">0</span>)</div><div class="line">                    event.setPath(<span class="string">"/"</span>);</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</div><div class="line">                    event.setPath(serverPath.substring(chrootPath.length()));</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                	LOG.warn(<span class="string">"Got server path "</span> + event.getPath()</div><div class="line">                			+ <span class="string">" which is too short for chroot path "</span></div><div class="line">                			+ chrootPath);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</div><div class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                LOG.debug(<span class="string">"Got "</span> + we + <span class="string">" for sessionid 0x"</span></div><div class="line">                        + Long.toHexString(sessionId));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            eventThread.queueEvent( we );</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Since requests are processed in order, we better get a response</span></div><div class="line"><span class="comment">     * to the first request!</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</div><div class="line">            packet.replyHeader.setErr(</div><div class="line">                    KeeperException.Code.CONNECTIONLOSS.intValue());</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Xid out of order. Got Xid "</span></div><div class="line">                    + replyHdr.getXid() + <span class="string">" with err "</span> +</div><div class="line">                    + replyHdr.getErr() +</div><div class="line">                    <span class="string">" expected Xid "</span></div><div class="line">                    + packet.requestHeader.getXid()</div><div class="line">                    + <span class="string">" for a packet with details: "</span></div><div class="line">                    + packet );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        packet.replyHeader.setXid(replyHdr.getXid());</div><div class="line">        packet.replyHeader.setErr(replyHdr.getErr());</div><div class="line">        packet.replyHeader.setZxid(replyHdr.getZxid());</div><div class="line">        <span class="keyword">if</span> (replyHdr.getZxid() &gt; <span class="number">0</span>) &#123;</div><div class="line">            lastZxid = replyHdr.getZxid();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (packet.response != <span class="keyword">null</span> &amp;&amp; replyHdr.getErr() == <span class="number">0</span>) &#123;</div><div class="line">            packet.response.deserialize(bbia, <span class="string">"response"</span>);<span class="comment">//拿到响应，发到请求的packet中的response属性中，赋值。</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">            LOG.debug(<span class="string">"Reading reply sessionid:0x"</span></div><div class="line">                    + Long.toHexString(sessionId) + <span class="string">", packet:: "</span> + packet);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        finishPacket(packet);<span class="comment">//处理正常的请求响应。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="最后处理finishPacket-请求"><a href="#最后处理finishPacket-请求" class="headerlink" title="最后处理finishPacket()请求"></a><strong>最后处理finishPacket()请求</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishPacket</span><span class="params">(Packet p)</span> </span>&#123;</div><div class="line">    <span class="comment">//首先还记得，watchRegistration是在什么时候进行初始化么？例如在客户端调用api发出例如调用exists操作命令时，调用zk.exists()时，在exists()内部初始化。</span></div><div class="line">     <span class="comment">//create等命令是没有注册监听器的功能的，也就是说：实际上能够注册监听器的，也只有，exists、getDate，getChildren 这三个api才能绑定监听器。</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) &#123;</div><div class="line">        p.watchRegistration.register(p.replyHeader.getErr());<span class="comment">//重要！！！！这个方法，会把客户端注册某个节点路径的监听事件，放到hashmap中。 -- 回答了下面提出的问题。保存节点监听事件的map什么时候赋值。就这这个方法赋值。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (p) &#123;</div><div class="line">            p.finished = <span class="keyword">true</span>;</div><div class="line">            p.notifyAll();<span class="comment">//唤醒之前客户端在cnxn.submitRequest()发送请求后，阻塞等待结果的线程</span></div><div class="line">            <span class="comment">//标识本次客户端请求，最终获得响应</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        p.finished = <span class="keyword">true</span>;</div><div class="line">        eventThread.queuePacket(p);<span class="comment">//然后开始处理监听事件 -- </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>开始注册对某个节点路径的监听到map中  p.watchRegistration.register</strong></p>
</blockquote>
<p>key是path-节点路径</p>
<p>value是注册的监听。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">int</span> rc)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shouldAddWatch(rc)) &#123;</div><div class="line">        Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</div><div class="line">        <span class="keyword">synchronized</span>(watches) &#123;</div><div class="line">            Set&lt;Watcher&gt; watchers = watches.get(clientPath);</div><div class="line">            <span class="keyword">if</span> (watchers == <span class="keyword">null</span>) &#123;</div><div class="line">                watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</div><div class="line">                watches.put(clientPath, watchers);</div><div class="line">            &#125;</div><div class="line">            watchers.add(watcher);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="eventThread处理监听事件"><a href="#eventThread处理监听事件" class="headerlink" title="eventThread处理监听事件"></a>eventThread处理监听事件</h4><p>waitingEvents保存需要处理的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;Object&gt; waitingEvents =</div><div class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;();</div></pre></td></tr></table></figure>
<p>//保存需要处理的事件到waitingEvents队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queuePacket</span><span class="params">(Packet packet)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (wasKilled) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (waitingEvents) &#123;</div><div class="line">         <span class="keyword">if</span> (isRunning) waitingEvents.add(packet);</div><div class="line">         <span class="keyword">else</span> processEvent(packet);</div><div class="line">      &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">      waitingEvents.add(packet);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>因为他跟SendThread一样是一个线程，同时也是遵循生产者和消费者模型，那么就会去执行run方法，所以最终处理事件的逻辑还是在run方法中。</strong></p>
<blockquote>
<p><strong>eventThread.run方法</strong></p>
</blockquote>
<p>处理事件的核心方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      isRunning = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">         Object event = waitingEvents.take();<span class="comment">//从等待处理事件队列中获取事件并处理。拿一个就移除一个 - 这个也就是为什么事件只能够监听一次的原因</span></div><div class="line">         <span class="keyword">if</span> (event == eventOfDeath) &#123;</div><div class="line">            wasKilled = <span class="keyword">true</span>;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">            processEvent(event);<span class="comment">//真正调用监听事件的逻辑，然后完成监听事件的触发。</span></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (wasKilled)</div><div class="line">            <span class="keyword">synchronized</span> (waitingEvents) &#123;</div><div class="line">               <span class="keyword">if</span> (waitingEvents.isEmpty()) &#123;</div><div class="line">                  isRunning = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      LOG.error(<span class="string">"Event thread exiting due to interruption"</span>, e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    LOG.info(<span class="string">"EventThread shut down for session: 0x&#123;&#125;"</span>,</div><div class="line">             Long.toHexString(getSessionId()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>那么waitingEvents事件队列在哪些地方还能赋值呢？</strong></p>
<p>在上面的sendThread.readResponse（）方法中。</p>
<p>对于服务端的响应类型if (replyHdr.getXid() == -1)  也会存放数据到waitingEvents事件队列中。</p>
<p>举个例子：</p>
<p>​    假设客户端调用的api是：zk.getData(“/app”,new wahcher(){})// 在app节点上注册了监听，那么当下次客户发出请求zk.setDate(“/app”,”123”)，是不是会触发事件？是的。</p>
<p>​    那么当服务端收到setData请求类型后，调用final处理器，然后调用dataTree.setData()最后持久化数据到内存，那么此时就需要给客户端一个通知，说我修改了数据，你要触发一下你在app节点注册的事件。然后此时设置replyHdr.getXid() = -1。</p>
<p>​    客户端收到响应后，在sendThread.readResponse（）方法中处理响应数据，发现replyHdr.getXid() == -1。说明app节点数据被修改，那么需要触发事件，那么就会把赋值数据到waitingEvents事件队列中。然后等到eventThread的run方法处理。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    以上就是整个触发事件的逻辑。我们不难发现。如果客户端再某个节点上注册了监听事件，那么当他请求服务端时不会吧该监听事件一并发过去（例如客户端发起：zk.getData(“/app”,new wahcher(){})请求），只是发送了一个标志位watch==true，代表我再这个节点注册了监听。（因为最终处理监听事件的逻辑会在客户端）</p>
<p>​    服务端收到请求后，然后处理调用处理链处理请求，最后在final处理器中，判断发现，客户端在这个节点上注册了监听，那么服务端就需要记录一下，把记录的值放到<code>HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable</code>中。然后响应客户端的请求。整个逻辑结束。<strong>1.服务端收到需要触发事件通知然后保存触发事件的节点路径和通知客户端触发事件的cnx</strong></p>
<p>​    因为我们知道：zk.getData(“/app”,new wahcher(){})这样的请求，只是去拿zpp节点的数据，然后顺便绑定一个事件。并不会触发事件，只有当下次app节点数据修改了，才会触发事件。</p>
<p>​    那么当下次客户端调用zk.setDate(“/app”,”123”)时，服务端处理流程一样，也是通过处理链最后经过final处理器，但是唯一不同的是，这次操作是个更新操作，事务操作。那么最终会执行dataTree.setData()持久化数据到zk服务器内存。</p>
<p> 接着在dataTree.setData()最后，服务端会通知客户端触发事件，因为app节点的值修改了，你上次也绑定了一个事件。<strong>2.需要客户端触发事件</strong></p>
<p>​    那么服务端发出请求会通知客户端触发事件，通过ServercnxNIO发送通知，这个通知的xid设置为-1，表示这个请求是个触发事件的请求，然后从watchTable中移除相应事件（这个也就是为什么事件只能触发一次的原因，触发一次，就移除一次） – <strong>在这里我们不难发现服务端通知客户端触发事件并不能保证客户端一定能触发成功，他只是通知而已，服务端并没有确认是否触发成功机制</strong></p>
<p>​    接着客户端再sendThread.readRespose（）中获得服务端的请求，然后判断xid，如果等于1，那么说明服务端需要客户端触发事件，那么就把往waitingEvents中存放数据，然后等待eventThread线程的run方法执行，然后触发事件。 <strong>3.客户端触发事件，触发事件流程结束</strong></p>
<h2 id="！！为什么监听的事件只处理一次-watcher机制源码！！"><a href="#！！为什么监听的事件只处理一次-watcher机制源码！！" class="headerlink" title="！！为什么监听的事件只处理一次 - watcher机制源码！！"></a>！！为什么监听的事件只处理一次 - watcher机制源码！！</h2><p>在开始查看源码前，我们先思考几个问题，这样带着问题去读源码会更有效果。</p>
<p><strong>问题一：为什么监听的事件只能调用一次。</strong></p>
<blockquote>
<p>​    <strong>我们知道，原生的zk客户端监听节点事件的时候，只能够监听一次。</strong>那么他的本质是什么呢？为什么只有一次监听。</p>
<p>这里先说结论：</p>
<p>​    <strong>因为，服务端和客户端把对于某个节点的事件都放到一个列表中，每触发一个，就remove一个而不是take，所以只能够监听一次。（这里解释了为什么监听只会触发一次的原因）</strong></p>
</blockquote>
<p>详情代码验证，请看上面的<eventthread处理监听事件之eventthread.run方法分析>和下面<watcher监听事件机制之triggerwatch方法的分析></watcher监听事件机制之triggerwatch方法的分析></eventthread处理监听事件之eventthread.run方法分析></p>
<p><strong>问题二：客户端会把监听的watcher发送给服务端么？</strong></p>
<p>​    但是这个时候存在第二个疑问？那就是如果客户端监听了某个节点，那么在请求服务端操作的时候，会把监听器也一并发送给服务端么？例如如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stat stat = <span class="keyword">new</span> Stat();;</div><div class="line">keeper.getData(<span class="string">"/app"</span>, <span class="keyword">new</span> Watcher() &#123;<span class="comment">//给app节点，创建新的监听器</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">		System.out.println( <span class="string">"监听kinge节点输出的事件："</span>+event );</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;, stat );<span class="comment">//那么此时给服务端你发送getdata请求时，会把new出来的watcher一并发送过去么？然后由服务端来调用new出来的watcher然后出发么？是怎么样的一个操作逻辑？？</span></div></pre></td></tr></table></figure>
<p>答案是：不会发送new出来的watcher给服务端，没有必要，只会发送标志位过去（会在请求中设置watch==true的标志位）</p>
<p><strong>问题三：zk客户端怎么存储监听的事件？</strong></p>
<p>​    为了方便直接出发监听器，那么存储的数据结构，应该是一个这样的结构<code>map&lt;string，Set&lt;Watcher&gt;&gt;</code>，key是保存着节点的路径，value是监听这个节点路径的所有watcher。</p>
<p>​    <strong>那么这样就可以轻松的触发某个节点的所有监听器。</strong></p>
<p>​    <strong>!!!!那么这个map是什么时候赋值的呢？!!!!!!</strong>  是在调用api的时候就马上put到map还是什么时候呢？例如调用keeper.exists(“/app”, true)。的时候就直接put监听器到map中么？</p>
<p>  这里先说答案：<strong>不是</strong>，<strong>只有当收到服务端响应请求后，再去注册事件，然后才把事件监听放到map中。然后再去触发。</strong>（详情参见上面代码分析&lt;<strong>最后处理finishPacket()请求</strong>&gt;）</p>
<blockquote>
<p><strong>zk能够注册监听的三种方式</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ZooKeeper keeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:2181"</span>, <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;<span class="comment">//zk默认的总体的监听器，代码1</span></div><div class="line">			System.out.println( <span class="string">"输出的事件："</span>+ event.toString() );</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">keeper.exists(<span class="string">"/app"</span>, <span class="keyword">true</span>);<span class="comment">//注册的事件存放到existWatches</span></div><div class="line">keeper.getData(path, watcher, stat)<span class="comment">//注册的事件存放到dataWatches</span></div><div class="line">keeper.getChildren(path, watch, stat)<span class="comment">//注册的事件存放到childWatches</span></div><div class="line"></div><div class="line"><span class="comment">//也就是说zk只有在这三种操作的时候，才能够注册监听。如果在调用这三种api时，不指定新的watcher监听器，那么就会默认使用创建zk客户端时创建的监听器（代码1处）</span></div></pre></td></tr></table></figure>
<p>​    接下来我们就通过<code>keeper.exists(&quot;/app&quot;, true)&lt;这里的true表示监听app节点是否存在，并且使用默认的zk监听器&gt;</code> 来走一遍流程，探究一下watcher事件是如何触发的。</p>
<p>​    </p>
<p>结合问题三：我们发现这三种api对应的事件监听都会分别放到一个map中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">org.apache.zookeeper.ZooKeeper.ZKWatchManager  </div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>exists()源码</strong></p>
</blockquote>
<p>‘可以看到，如果是watch===true，那么就会使用zk默认的监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(String path, <span class="keyword">boolean</span> watch)</span> <span class="keyword">throws</span> KeeperException,</span></div><div class="line"><span class="function">    InterruptedException</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> exists(path, watch ? watchManager.defaultWatcher : <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//接着调用</span></div><div class="line"> <span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">final</span> String clientPath = path;</div><div class="line">        PathUtils.validatePath(clientPath);</div><div class="line"></div><div class="line">        <span class="comment">// the watch contains the un-chroot path</span></div><div class="line">        WatchRegistration wcb = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</div><div class="line">            wcb = <span class="keyword">new</span> ExistsWatchRegistration(watcher, clientPath);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> String serverPath = prependChroot(clientPath);</div><div class="line"></div><div class="line">     <span class="comment">//下面这段代码，我们在上面的zk客户端发送create请求说过。最终发送的请求都会封装成一个request</span></div><div class="line">        RequestHeader h = <span class="keyword">new</span> RequestHeader();</div><div class="line">        h.setType(ZooDefs.OpCode.exists);</div><div class="line">        ExistsRequest request = <span class="keyword">new</span> ExistsRequest();</div><div class="line">        request.setPath(serverPath);<span class="comment">//设置请求节点路径</span></div><div class="line">        request.setWatch(watcher != <span class="keyword">null</span>);<span class="comment">//很关键，如果监听器不为空，那么说明当前调用是需要触发监听器的。</span></div><div class="line">        SetDataResponse response = <span class="keyword">new</span> SetDataResponse();</div><div class="line">        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);<span class="comment">//提交请求</span></div><div class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (r.getErr() == KeeperException.Code.NONODE.intValue()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()),</div><div class="line">                    clientPath);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> response.getStat().getCzxid() == -<span class="number">1</span> ? <span class="keyword">null</span> : response.getStat();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​    <strong>在这段代码中，我们不难发现，实际上发送给服务端的请求，实际上，并没有带上注册的监听器，仅仅只是设置了一个标志位 request.setWatch（true） </strong>  —– <strong>验证了我们上面提出的问题二的结论</strong></p>
<blockquote>
<p><strong>接着调用cnx.submitRequest（）发送请求</strong></p>
</blockquote>
<p>​    关于这段代码的逻辑，在上面我们已经说过了，就不再具体说明。</p>
<p>​    简单说一下。在这个方法中会把请求信息包装成一个Packet，然后把Packet放到一个队列中，LinkedList<packet> outgoingQueue。然后结束。</packet></p>
<p>​    那么什么时候发送请求给服务端呢？通过SendThread的run方法进行发送。（sendThread线程在这之前就已经启动了）。</p>
<p>那么我们还记得在启动SendThread线程的同时，还启动了另外一个线程：<strong>EventThread线程</strong></p>
<p>那么他就是用来处理watcher事件的。</p>
<p>那么我们知道 <strong>调用cnx.submitRequest（）发送请求后。客户端会阻塞等待服务端响应，那么这个时候接下来就需要看server端处理请求的逻辑了 – 客户端执行逻辑到这里就结束了</strong>。</p>
<p>​    <strong>接下来的核心就是继续研究server端的处理请求逻辑了，我们跟踪到server端的final处理器，会发现，server端封装了两个hashmap来保存处理事件的监听机制(详情请看《watcher监听事件机制》)</strong></p>
<p>### </p>
<h2 id="客户端执行quit退出命令行操作会发生什么"><a href="#客户端执行quit退出命令行操作会发生什么" class="headerlink" title="客户端执行quit退出命令行操作会发生什么"></a>客户端执行quit退出命令行操作会发生什么</h2><p>​    我们知道，凡是客户端的操作，都会涉及到一个操作类型，例如是create，delete，getData，setAcl等等，那么quit操作，对应会发送一个closeSession的操作码给服务端，然后服务端，经过处理链的处理，最后在final处理器，删除session（客户端跟服务端的连接，都会维持一个session），删除在内存中的临时节点（我们知道临时节点在客户端断开连接后，自动会被删除）</p>
<h2 id="zookeeper集群优先选择连接节点改造"><a href="#zookeeper集群优先选择连接节点改造" class="headerlink" title="zookeeper集群优先选择连接节点改造"></a>zookeeper集群优先选择连接节点改造</h2><p>本质是修改StaticHostProvider类，选出下一个连接server的地址的逻辑。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>运行zkCli.sh文件最终发生这几部动作：</p>
<ul>
<li>创建zookeeper客户端<ul>
<li>创建ClientCnxnSocket，准确的说是：ClientCnxnSocketNIO</li>
<li>创建SendThread线程<ul>
<li>目的是通过NIO方式构建一个到服务端的连接</li>
</ul>
</li>
<li>创建EventThread线程</li>
<li>启动上面两个线程，SendThread初始化NIO的socket连接，发送请求给客户端。</li>
</ul>
</li>
<li>解析命令行，然后发送请求给服务端<ul>
<li>根据请求，封装成一个packet，放到outgoingqueue队列中，然后阻塞等待处理结果。</li>
<li>接着SendThread线程会在while循环中，不断的从outgoingqueue队列中取出请求的packet，通过初始化好的ClientCnxnSocketNIO，发送packet给服务端，然后将已经处理的packet节点从outgoingqueue中移除，并加入到pendingqueue中，等待处理结果。</li>
<li>根据doIO方法，处理outgoingqueue中的packet，然后把处理后的packet加入pendingqueue，等待服务端的响应</li>
<li>在doIO方法中处理服务端的响应，然后从pendingqueue移除已经处理的packet，然后标记当前packet节点为完成，finished=true。</li>
<li>然后服务端响应结果给客户端，完成请求。</li>
</ul>
</li>
</ul>
<ul>
<li>EventThread处理监听事件<ul>
<li>从waitEventQueue中获取事件，然后在run方法中触发调用。</li>
</ul>
</li>
</ul>
<p>​    <strong>我们可以发现，同一个客户端的请求，按其发送顺序依次执行。（根据outgoingqueue从头部逐个取出）</strong></p>
<p>​    客户端主要是通过两个线程进行主要的工作。其中SendThread主要是进行，请求的发送和处理服务端响应的结果。EventThread主要是处理触发的事件（客户端在操作节点时绑定的监听器）</p>
<p>​    <strong>同时我们发现doIO方法，会在处理正常客户端请求后服务端返回的响应数据，也会处理服务端发出触发事件的请求。</strong></p>
<p> 换句话说，EventThread线程处理的waitEventQueue队列数据的来源，就是在doIO中进行赋值。</p>
<h1 id="zk客户端连接服务端超时源码解析"><a href="#zk客户端连接服务端超时源码解析" class="headerlink" title="zk客户端连接服务端超时源码解析"></a>zk客户端连接服务端超时源码解析</h1><p>核心源码处理，就在SendThread线程中的run方法。而且我们知道<strong>run方法内部是一个while循环</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">       <span class="keyword">if</span> (state.isConnected()) &#123;</div><div class="line">             <span class="comment">// determine whether we need to send an AuthFailed event.</span></div><div class="line">             <span class="keyword">if</span> (zooKeeperSaslClient != <span class="keyword">null</span>) &#123;</div><div class="line">                 <span class="keyword">boolean</span> sendAuthEvent = <span class="keyword">false</span>;</div><div class="line">                 <span class="keyword">if</span> (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) &#123;</div><div class="line">                     <span class="keyword">try</span> &#123;</div><div class="line">                         zooKeeperSaslClient.initialize(ClientCnxn.<span class="keyword">this</span>);</div><div class="line">                     &#125; <span class="keyword">catch</span> (SaslException e) &#123;</div><div class="line">                        LOG.error(<span class="string">"SASL authentication with Zookeeper Quorum member failed: "</span> + e);</div><div class="line">                         state = States.AUTH_FAILED;</div><div class="line">                         sendAuthEvent = <span class="keyword">true</span>;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">                 KeeperState authState = zooKeeperSaslClient.getKeeperState();</div><div class="line">                 <span class="keyword">if</span> (authState != <span class="keyword">null</span>) &#123;</div><div class="line">                     <span class="keyword">if</span> (authState == KeeperState.AuthFailed) &#123;</div><div class="line">                         <span class="comment">// An authentication error occurred during authentication with the Zookeeper Server.</span></div><div class="line">                         state = States.AUTH_FAILED;</div><div class="line">                         sendAuthEvent = <span class="keyword">true</span>;</div><div class="line">                     &#125; <span class="keyword">else</span> &#123;</div><div class="line">                         <span class="keyword">if</span> (authState == KeeperState.SaslAuthenticated) &#123;</div><div class="line">                             sendAuthEvent = <span class="keyword">true</span>;</div><div class="line">                         &#125;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="keyword">if</span> (sendAuthEvent == <span class="keyword">true</span>) &#123;</div><div class="line">                     eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(</div><div class="line">                           Watcher.Event.EventType.None,</div><div class="line">                           authState,<span class="keyword">null</span>));</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">            <span class="comment">// 下一次超时时间</span></div><div class="line">             to = readTimeout - clientCnxnSocket.getIdleRecv();</div><div class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果还没连接上 重置当前剩余可连接时间</span></div><div class="line">             to = connectTimeout - clientCnxnSocket.getIdleRecv();</div><div class="line">         &#125;</div><div class="line"><span class="keyword">if</span> (to &lt;= <span class="number">0</span>) &#123;<span class="comment">//如果小于0，那么说明已经超时连接，就抛出异常，那么在哪里处理异常呢？还是在SendThread的run方法中，异常处理完成后，然后接着再次进入while循环，然后重新从server服务地址列表中，随机取一个地址进行连接（  serverAddress = hostProvider.next(1000);）</span></div><div class="line">                 String warnInfo;</div><div class="line">                 warnInfo = <span class="string">"Client session timed out, have not heard from server in "</span></div><div class="line">                     + clientCnxnSocket.getIdleRecv()</div><div class="line">                     + <span class="string">"ms"</span></div><div class="line">                     + <span class="string">" for sessionid 0x"</span></div><div class="line">                     + Long.toHexString(sessionId);</div><div class="line">                 LOG.warn(warnInfo);</div><div class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> SessionTimeoutException(warnInfo);</div><div class="line">             &#125;</div></pre></td></tr></table></figure>
<h1 id="zk服务端源码解析-单机模式"><a href="#zk服务端源码解析-单机模式" class="headerlink" title="zk服务端源码解析 - 单机模式"></a>zk服务端源码解析 - 单机模式</h1><p>​    我们知道，zk的服务端有单机模式和集群模式，实际上两者的区别，就是在zoo.cfg配置文件中，集群模式比单机模式多了，server.*这样的配置列表。</p>
<p>​    这里先说单机模式的服务端源码解析。</p>
<p>同理，启动服务端，调用的脚本文件是：zkServer.sh，最终会去执行org.apache.zookeeper.server.quorum.QuorumPeerMain#main类。</p>
<h2 id="QuorumPeerMain类源码"><a href="#QuorumPeerMain类源码" class="headerlink" title="QuorumPeerMain类源码"></a>QuorumPeerMain类源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ZooKeeperServerMain main = <span class="keyword">new</span> ZooKeeperServerMain();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        main.initializeAndRun(args);<span class="comment">//根据配置zoo.cfg文件，解析出配置的信息</span></div><div class="line">    &#125;</div><div class="line">。。。。。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着调用initializeAndRun方法，然后执行里面的 config.parse()，解析配置文件，最终所有配置信息，都会保存到QuorumPeerConfig类中。</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409113142773.png" alt="image-20200409113142773"></p>
<h3 id="解析zoo-cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略"><a href="#解析zoo-cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略" class="headerlink" title="解析zoo.cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略"></a>解析zoo.cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略</h3><p><strong>那么他是怎么识别是集群模式还是单机模式，就是在解析配置文件的过程中，进行判断的。</strong></p>
<p>解析的方法，最终会调用<code>org.apache.zookeeper.server.quorum.QuorumPeerConfig.parseProperties(Properties)</code></p>
<p>里面有一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(<span class="string">"server."</span>)) &#123;<span class="comment">//判断配置文件中是否存在，server.这样的配置信息，如果有，说明是集群模式，并把配置信息放到servers的Map中，保存，需要注意，如果server是观察者，那么需要放到observers中。因为观察者不参与投票，servsers中的节点是需要参与投票的。</span></div><div class="line">                <span class="keyword">int</span> dot = key.indexOf(<span class="string">'.'</span>);</div><div class="line">                <span class="keyword">long</span> sid = Long.parseLong(key.substring(dot + <span class="number">1</span>));</div><div class="line">                String parts[] = splitWithLeadingHostname(value);</div><div class="line">                <span class="keyword">if</span> ((parts.length != <span class="number">2</span>) &amp;&amp; (parts.length != <span class="number">3</span>) &amp;&amp; (parts.length !=<span class="number">4</span>)) &#123;</div><div class="line">                    LOG.error(value</div><div class="line">                       + <span class="string">" does not have the form host:port or host:port:port "</span> +</div><div class="line">                       <span class="string">" or host:port:port:type"</span>);</div><div class="line">                &#125;</div><div class="line">                LearnerType type = <span class="keyword">null</span>;</div><div class="line">                String hostname = parts[<span class="number">0</span>];</div><div class="line">                Integer port = Integer.parseInt(parts[<span class="number">1</span>]);</div><div class="line">                Integer electionPort = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">2</span>)&#123;</div><div class="line">                	electionPort=Integer.parseInt(parts[<span class="number">2</span>]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">3</span>)&#123;</div><div class="line">                    <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">"observer"</span>)) &#123;</div><div class="line">                        type = LearnerType.OBSERVER;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">"participant"</span>)) &#123;</div><div class="line">                        type = LearnerType.PARTICIPANT;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigException(<span class="string">"Unrecognised peertype: "</span> + value);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (type == LearnerType.OBSERVER)&#123;</div><div class="line">                    observers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    servers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<p>我们往下看你会发现，一个涉及到我们经常说的，半数选举策略。 <code>quorumVerifier = new QuorumMaj(servers.size());</code>  通过servers的数量获得半数数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuorumMaj</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.half = n/<span class="number">2</span>;<span class="comment">// 例如 13/2 == 6</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断启动的是单机版server还是集群模式"><a href="#判断启动的是单机版server还是集群模式" class="headerlink" title="判断启动的是单机版server还是集群模式"></a>判断启动的是单机版server还是集群模式</h3><p>配置信息解析完成后，下一步就是启动server，那么在启动之前，会涉及到单机模式还是集群模式的判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeAndRun</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> ConfigException, IOException</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    QuorumPeerConfig config = <span class="keyword">new</span> QuorumPeerConfig();</div><div class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</div><div class="line">        config.parse(args[<span class="number">0</span>]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Start and schedule the the purge task</span></div><div class="line">    DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(config</div><div class="line">            .getDataDir(), config.getDataLogDir(), config</div><div class="line">            .getSnapRetainCount(), config.getPurgeInterval());</div><div class="line">    purgeMgr.start();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.servers.size() &gt; <span class="number">0</span>) &#123;<span class="comment">//集群模式</span></div><div class="line">        runFromConfig(config);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//单机模式</span></div><div class="line">        LOG.warn(<span class="string">"Either no config or no quorum defined in config, running "</span></div><div class="line">                + <span class="string">" in standalone mode"</span>);</div><div class="line">        <span class="comment">// there is only server in the quorum -- run as standalone</span></div><div class="line">        ZooKeeperServerMain.main(args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    因为这里分析的是单机模式的server，所以最后最终调用的是，<code>ZooKeeperServerMain.main(args);</code>  ， 然后紧接着最终调用的是<code>org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig(ServerConfig)</code></p>
<p><strong>启动单机模式的server。</strong></p>
<h3 id="启动单机版server"><a href="#启动单机版server" class="headerlink" title="启动单机版server"></a>启动单机版server</h3><p>我们查看一下，启动单机模式的server主要代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(ServerConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    LOG.info(<span class="string">"Starting server"</span>);</div><div class="line">    FileTxnSnapLog txnLog = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> ZooKeeperServer zkServer = <span class="keyword">new</span> ZooKeeperServer();<span class="comment">//zk服务端，对应客户端的Zookeeper,负责维护一个处理器链表processor chain</span></div><div class="line"></div><div class="line">        <span class="keyword">final</span> CountDownLatch shutdownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);<span class="comment">//使用cd，启动server后挂起，直到server出异常或者被关闭，执行countDown()，然后唤醒当前main线程，执行关闭服务操作</span></div><div class="line">        zkServer.registerServerShutdownHandler(</div><div class="line">                <span class="keyword">new</span> ZooKeeperServerShutdownHandler(shutdownLatch));</div><div class="line"></div><div class="line">        txnLog = <span class="keyword">new</span> FileTxnSnapLog(<span class="keyword">new</span> File(config.dataLogDir), <span class="keyword">new</span> File(</div><div class="line">                config.dataDir));<span class="comment">//FileTxnSnapLog,管理FileTxLog和FileSnap</span></div><div class="line">        txnLog.setServerStats(zkServer.serverStats());</div><div class="line">        zkServer.setTxnLogFactory(txnLog);</div><div class="line">        zkServer.setTickTime(config.tickTime);</div><div class="line">        zkServer.setMinSessionTimeout(config.minSessionTimeout);</div><div class="line">        zkServer.setMaxSessionTimeout(config.maxSessionTimeout);</div><div class="line">         <span class="comment">// 建立socket,默认是NIOServerCnxnFactory（是一个线程）</span></div><div class="line">        cnxnFactory = ServerCnxnFactory.createFactory();<span class="comment">//代码1，创建一个上下文处理器,管理来自客户端的连接，</span></div><div class="line">        cnxnFactory.configure(config.getClientPortAddress(),</div><div class="line">                config.getMaxClientCnxns());</div><div class="line">        cnxnFactory.startup(zkServer);</div><div class="line">        shutdownLatch.await();<span class="comment">//启动后，等待countDown()，如果触发，那么说明，server需要关闭，那么main线程被唤醒，继续往下执行shutdown()方法</span></div><div class="line">        shutdown();</div><div class="line"></div><div class="line">        cnxnFactory.join();</div><div class="line">        <span class="keyword">if</span> (zkServer.canShutdown()) &#123;</div><div class="line">            zkServer.shutdown(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        <span class="comment">// warn, but generally this is ok</span></div><div class="line">        LOG.warn(<span class="string">"Server interrupted"</span>, e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (txnLog != <span class="keyword">null</span>) &#123;</div><div class="line">            txnLog.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看一下代码1，默认创建的也是一个NIO的上下文，<strong>负责处理客户端的连接</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> ServerCnxnFactory <span class="title">createFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    String serverCnxnFactoryName =</div><div class="line">        System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);</div><div class="line">    <span class="keyword">if</span> (serverCnxnFactoryName == <span class="keyword">null</span>) &#123;</div><div class="line">        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();<span class="comment">//NIOServer</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)</div><div class="line">                .getDeclaredConstructor().newInstance();</div><div class="line">        LOG.info(<span class="string">"Using &#123;&#125; as server connection factory"</span>, serverCnxnFactoryName);</div><div class="line">        <span class="keyword">return</span> serverCnxnFactory;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        IOException ioe = <span class="keyword">new</span> IOException(<span class="string">"Couldn't instantiate "</span></div><div class="line">                + serverCnxnFactoryName);</div><div class="line">        ioe.initCause(e);</div><div class="line">        <span class="keyword">throw</span> ioe;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="根据NIOServerCnxnFactory建立socket，监听客户端连接"><a href="#根据NIOServerCnxnFactory建立socket，监听客户端连接" class="headerlink" title="根据NIOServerCnxnFactory建立socket，监听客户端连接"></a>根据NIOServerCnxnFactory建立socket，监听客户端连接</h4><p>调用 cnxnFactory.configure(config.getClientPortAddress(),<br>                config.getMaxClientCnxns());</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(InetSocketAddress addr, <span class="keyword">int</span> maxcc)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    configureSaslLogin();</div><div class="line"></div><div class="line">    <span class="comment">// 把当前类作为线程</span></div><div class="line">    thread = <span class="keyword">new</span> ZooKeeperThread(<span class="keyword">this</span>, <span class="string">"NIOServerCxn.Factory:"</span> + addr);</div><div class="line">    <span class="comment">// java中线程分为两种类型：用户线程和守护线程。</span></div><div class="line">    <span class="comment">// 通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。</span></div><div class="line">    <span class="comment">// 如果不设置次属性，默认为用户线程。</span></div><div class="line">    <span class="comment">// 守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。</span></div><div class="line">    <span class="comment">// 那Java的守护线程是什么样子的呢。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出</span></div><div class="line">    <span class="comment">// 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。</span></div><div class="line">    <span class="comment">// 它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</span></div><div class="line"></div><div class="line">    <span class="comment">// 所以这里的这个线程是为了和JVM生命周期绑定，只剩下这个线程时已经没有意义了，应该关闭掉。</span></div><div class="line">    thread.setDaemon(<span class="keyword">true</span>);</div><div class="line">    maxClientCnxns = maxcc;</div><div class="line">    <span class="keyword">this</span>.ss = ServerSocketChannel.open();</div><div class="line">    ss.socket().setReuseAddress(<span class="keyword">true</span>);</div><div class="line">    LOG.info(<span class="string">"binding to port "</span> + addr);</div><div class="line">    ss.socket().bind(addr);</div><div class="line">    ss.configureBlocking(<span class="keyword">false</span>);</div><div class="line">    ss.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">//注册连接事件，监听客户端的连接</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="启动NIOServerCnxnFactory线程，接受客户端的请求"><a href="#启动NIOServerCnxnFactory线程，接受客户端的请求" class="headerlink" title="启动NIOServerCnxnFactory线程，接受客户端的请求"></a>启动NIOServerCnxnFactory线程，接受客户端的请求</h4><p>​    cnxnFactory.startup(zkServer);主要是做三件事情：<strong>启动NIOServerCnxnFactory线程、加载快照数据到内存、初始化请求处理链。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">(ZooKeeperServer zks)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</div><div class="line">    <span class="comment">// 启动线程</span></div><div class="line">    start();</div><div class="line">    <span class="comment">// 初始化zkServer</span></div><div class="line">    setZooKeeperServer(zks);</div><div class="line">    <span class="comment">// 加载数据</span></div><div class="line">    zks.startdata();</div><div class="line">    <span class="comment">// 设置请求处理器链</span></div><div class="line">    zks.startup();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>// 1.启动线程NIOServerCnxnFactory</strong>，监听客户端请求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!ss.socket().isClosed()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            selector.select(<span class="number">1000</span>);</div><div class="line">            Set&lt;SelectionKey&gt; selected;</div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                selected = selector.selectedKeys();</div><div class="line">            &#125;</div><div class="line">            ArrayList&lt;SelectionKey&gt; selectedList = <span class="keyword">new</span> ArrayList&lt;SelectionKey&gt;(</div><div class="line">                    selected);</div><div class="line">            Collections.shuffle(selectedList);</div><div class="line">            <span class="keyword">for</span> (SelectionKey k : selectedList) &#123;</div><div class="line">                <span class="keyword">if</span> ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 建立连接</span></div><div class="line">                    SocketChannel sc = ((ServerSocketChannel) k</div><div class="line">                            .channel()).accept();</div><div class="line">                    InetAddress ia = sc.socket().getInetAddress();</div><div class="line">                    <span class="keyword">int</span> cnxncount = getClientCnxnCount(ia);</div><div class="line">                    <span class="keyword">if</span> (maxClientCnxns &gt; <span class="number">0</span> &amp;&amp; cnxncount &gt;= maxClientCnxns)&#123;</div><div class="line">                        LOG.warn(<span class="string">"Too many connections from "</span> + ia</div><div class="line">                                 + <span class="string">" - max is "</span> + maxClientCnxns );</div><div class="line">                        sc.close();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        LOG.info(<span class="string">"Accepted socket connection from "</span></div><div class="line">                                 + sc.socket().getRemoteSocketAddress());</div><div class="line">                        sc.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                        SelectionKey sk = sc.register(selector,</div><div class="line">                                SelectionKey.OP_READ);</div><div class="line"></div><div class="line">                        <span class="comment">// 创建连接</span></div><div class="line">                        NIOServerCnxn cnxn = createConnection(sc, sk);</div><div class="line">                        sk.attach(cnxn);</div><div class="line">                        addCnxn(cnxn);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 接收数据,这里会间歇性的接收到客户端的ping</span></div><div class="line">                    NIOServerCnxn c = (NIOServerCnxn) k.attachment();</div><div class="line">                    <span class="comment">// 处理客户端请求</span></div><div class="line">                    c.doIO(k);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                        LOG.debug(<span class="string">"Unexpected ops in select "</span></div><div class="line">                                  + k.readyOps());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            selected.clear();</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">            LOG.warn(<span class="string">"Ignoring unexpected runtime exception"</span>, e);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            LOG.warn(<span class="string">"Ignoring exception"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    closeAll();</div><div class="line">    LOG.info(<span class="string">"NIOServerCnxn factory exited run method"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>zks.startdata()加载数据</strong></p>
</blockquote>
<p>因为我们知道，server端可能已经存在数据，那么在启动server端后，应该重放数据，把数据加载到内存中。</p>
<p>zk的数据由两个部分组成：<strong>日志和快照。</strong>  <strong>他们都是保存在磁盘中。</strong> server服务器启动时，会通过磁盘上的事务日志和快照数据文件恢复成完整的内存数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startdata</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">    <span class="comment">//check to see if zkDb is not null</span></div><div class="line">    <span class="keyword">if</span> (zkDb == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// txnLogFactory就是存储日志文件与快照的工具类，在ZooKeeperServerMain中赋值的</span></div><div class="line">        zkDb = <span class="keyword">new</span> ZKDatabase(<span class="keyword">this</span>.txnLogFactory);</div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (!zkDb.isInitialized()) &#123;<span class="comment">// 一开始为false</span></div><div class="line">        <span class="comment">// 没有初始化，加载数据</span></div><div class="line">        loadData();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span>(zkDb.isInitialized())&#123;</div><div class="line">        <span class="comment">// 已经初始化</span></div><div class="line">        setZxid(zkDb.getDataTreeLastProcessedZxid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有初始化</span></div><div class="line">        setZxid(zkDb.loadDataBase());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 找到过期的session</span></div><div class="line">    LinkedList&lt;Long&gt; deadSessions = <span class="keyword">new</span> LinkedList&lt;Long&gt;();</div><div class="line">    <span class="keyword">for</span> (Long session : zkDb.getSessions()) &#123;</div><div class="line">        <span class="keyword">if</span> (zkDb.getSessionWithTimeOuts().get(session) == <span class="keyword">null</span>) &#123;</div><div class="line">            deadSessions.add(session);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置initialized为true，表示已经初始化</span></div><div class="line">    zkDb.setDataTreeInit(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 清除过期的session</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> session : deadSessions) &#123;</div><div class="line">        killSession(session, zkDb.getDataTreeLastProcessedZxid());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>zks.startup()初始化请求处理链</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// session跟踪器</span></div><div class="line">        createSessionTracker();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 启动session跟踪器，它是一个线程</span></div><div class="line">    startSessionTracker();</div><div class="line"></div><div class="line">    <span class="comment">// setupRequestProcessors()建立请求处理器链</span></div><div class="line">    setupRequestProcessors();</div><div class="line"></div><div class="line">    registerJMX();</div><div class="line"></div><div class="line">    setState(State.RUNNING);</div><div class="line">    notifyAll();</div><div class="line">&#125;</div><div class="line"></div><div class="line">这三个请求处理器都是线程，组成一条请求链</div><div class="line">PrepRequestProcessor ———&gt;&gt; SyncRequestProcessor ———&gt;&gt; FinalRequestProcessor</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 最后一个执行的请求处理器</span></div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// 第二个执行的请求处理器，封装了下一个执行的处理器finalProcessor</span></div><div class="line">RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</div><div class="line">        finalProcessor);</div><div class="line">((SyncRequestProcessor)syncProcessor).start();</div><div class="line"></div><div class="line"><span class="comment">// 第一个执行的请求处理器，封装了下一个执行的处理器syncProcessor</span></div><div class="line">firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);</div><div class="line">((PrepRequestProcessor)firstProcessor).start();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是已经做完了，server的启动工作，已经准备好接受和处理客户端请求。</p>
<h2 id="c-doIO-k-处理客户端请求"><a href="#c-doIO-k-处理客户端请求" class="headerlink" title="c.doIO(k)处理客户端请求"></a>c.doIO(k)处理客户端请求</h2><p>这个代码在<code>org.apache.zookeeper.server.NIOServerCnxnFactory.run()</code> ，也就是之前启动的线程。</p>
<p>接下来查看<code>org.apache.zookeeper.server.NIOServerCnxn.doIO(SelectionKey)</code> 怎么处理客户端的请求</p>
<p>在doIO方法中，最终会调用 <code>readPayload();</code> 处理请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readPayload</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (incomingBuffer.remaining() != <span class="number">0</span>) &#123; <span class="comment">// have we read length bytes?</span></div><div class="line">        <span class="keyword">int</span> rc = sock.read(incomingBuffer); <span class="comment">// sock is non-blocking, so ok</span></div><div class="line">        <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(</div><div class="line">                    <span class="string">"Unable to read additional data from client sessionid 0x"</span></div><div class="line">                    + Long.toHexString(sessionId)</div><div class="line">                    + <span class="string">", likely client has closed socket"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (incomingBuffer.remaining() == <span class="number">0</span>) &#123; <span class="comment">// have we read length bytes?</span></div><div class="line">        <span class="comment">// 计数</span></div><div class="line">        packetReceived();</div><div class="line">        incomingBuffer.flip();</div><div class="line">        <span class="keyword">if</span> (!initialized) &#123;</div><div class="line">            readConnectRequest();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 已连接，读取请求</span></div><div class="line">            readRequest();</div><div class="line">        &#125;</div><div class="line">        lenBuffer.clear();</div><div class="line">        incomingBuffer = lenBuffer;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着调用 readRequest()读取请求</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">- 这里的zkServer是在执行NIOServerCnxnFactory的run()-&gt;createConnection()</span></div><div class="line"><span class="comment">- 执行构造函数初始化的</span></div><div class="line"><span class="comment">*/</span></div><div class="line">   zkServer.processPacket(<span class="keyword">this</span>, incomingBuffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用ZooKeeperServer的processPacket处理请求"><a href="#使用ZooKeeperServer的processPacket处理请求" class="headerlink" title="使用ZooKeeperServer的processPacket处理请求"></a>使用ZooKeeperServer的processPacket处理请求</h3><p>​    </p>
<p>根据OpCode操作的类型，例如create还是delete，走相应的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 例如create命令就会走到这里来</span></div><div class="line"><span class="comment">// 构建Request</span></div><div class="line">Request si = <span class="keyword">new</span> Request(cnxn, cnxn.getSessionId(), h.getXid(),</div><div class="line">h.getType(), incomingBuffer, cnxn.getAuthInfo());</div><div class="line">si.setOwner(ServerCnxn.me);</div><div class="line"></div><div class="line"><span class="comment">// 提交请求。开始进入处理链处理逻辑</span></div><div class="line">submitRequest(si);</div></pre></td></tr></table></figure>
<h3 id="根据请求处理链，处理请求"><a href="#根据请求处理链，处理请求" class="headerlink" title="根据请求处理链，处理请求"></a>根据请求处理链，处理请求</h3><h4 id="请求处理器PrepRequestProcessor"><a href="#请求处理器PrepRequestProcessor" class="headerlink" title="请求处理器PrepRequestProcessor"></a>请求处理器PrepRequestProcessor</h4><blockquote>
<p><strong>submitRequest交由请求处理器处理数据</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(Request si)</span> </span>&#123;</div><div class="line">    <span class="comment">// 请求处理器PrepRequestProcessor，主要是做一些校验工作</span></div><div class="line">    <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (state == State.INITIAL) &#123;</div><div class="line">                    wait(<span class="number">1000</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                LOG.warn(<span class="string">"Unexpected interruption"</span>, e);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span> || state != State.RUNNING) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not started"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        touch(si.cnxn);<span class="comment">//客户端和服务端session会话管理功能，验证是否过期超时等等</span></div><div class="line">        <span class="comment">// 校验请求是否合法</span></div><div class="line">        <span class="keyword">boolean</span> validpacket = Request.isValid(si.type);</div><div class="line">        <span class="keyword">if</span> (validpacket) &#123;</div><div class="line">            <span class="comment">// 执行请求处理器，交由请求处理器处理</span></div><div class="line">            firstProcessor.processRequest(si);</div><div class="line">            <span class="keyword">if</span> (si.cnxn != <span class="keyword">null</span>) &#123;</div><div class="line">                incInProcess();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            LOG.warn(<span class="string">"Received packet at server of unknown type "</span> + si.type);</div><div class="line">            <span class="keyword">new</span> UnimplementedRequestProcessor().processRequest(si);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (MissingSessionException e) &#123;</div><div class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">            LOG.debug(<span class="string">"Dropping request: "</span> + e.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</div><div class="line">        LOG.error(<span class="string">"Unable to process request:"</span> + e.getMessage(), e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着将请求放到队列中submittedRequests</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> LinkedBlockingQueue&lt;Request&gt; submittedRequests = <span class="keyword">new</span> LinkedBlockingQueue&lt;Request&gt;();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">    <span class="comment">// request.addRQRec("&gt;prep="+zks.outstandingChanges.size());</span></div><div class="line">    submittedRequests.add(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到队列我们第一反应，应该是生产者消费者模型，肯定有个线程是从队列中取数据进行处理。那么处理逻辑在那里呢？</p>
<blockquote>
<p><strong>prep处理器的run方法 - 处理队列中的请求</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Request request = submittedRequests.take();<span class="comment">//从队列中拿到请求进行处理</span></div><div class="line">            <span class="keyword">long</span> traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</div><div class="line">            <span class="keyword">if</span> (request.type == OpCode.ping) &#123;</div><div class="line">                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</div><div class="line">                ZooTrace.logRequest(LOG, traceMask, <span class="string">'P'</span>, request, <span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (Request.requestOfDeath == request) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            pRequest(request);<span class="comment">//最终走到这里</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</div><div class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> XidRolloverException) &#123;</div><div class="line">            LOG.info(e.getCause().getMessage());</div><div class="line">        &#125;</div><div class="line">        handleException(<span class="keyword">this</span>.getName(), e);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        handleException(<span class="keyword">this</span>.getName(), e);</div><div class="line">    &#125;</div><div class="line">    LOG.info(<span class="string">"PrepRequestProcessor exited loop!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着调用prep处理器的pRequest()方法处理请求</strong></p>
</blockquote>
<p><strong>他会从请求中，拿到请求的操作类型，来进行相应的逻辑。</strong>最终调用pRequest2Txn()方法或者检查session，最终调用下一个处理器继续处理请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pRequest</span><span class="params">(Request request)</span> <span class="keyword">throws</span> RequestProcessorException </span>&#123;</div><div class="line">    <span class="comment">// LOG.info("Prep&gt;&gt;&gt; cxid = " + request.cxid + " type = " +</span></div><div class="line">    <span class="comment">// request.type + " id = 0x" + Long.toHexString(request.sessionId));</span></div><div class="line">    request.hdr = <span class="keyword">null</span>;</div><div class="line">    request.txn = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">switch</span> (request.type) &#123;</div><div class="line">            <span class="keyword">case</span> OpCode.create:</div><div class="line">            CreateRequest createRequest = <span class="keyword">new</span> CreateRequest();</div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, createRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.delete:</div><div class="line">            DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest();               </div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.setData:</div><div class="line">            SetDataRequest setDataRequest = <span class="keyword">new</span> SetDataRequest();                </div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.setACL:</div><div class="line">            SetACLRequest setAclRequest = <span class="keyword">new</span> SetACLRequest();                </div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.check:</div><div class="line">            CheckVersionRequest checkRequest = <span class="keyword">new</span> CheckVersionRequest();              </div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.multi:</div><div class="line">           <span class="comment">//。。。。。省略部分代码</span></div><div class="line">            </div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">//create/close session don't require request record</span></div><div class="line">        <span class="keyword">case</span> OpCode.createSession:</div><div class="line">        <span class="keyword">case</span> OpCode.closeSession:</div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, <span class="keyword">null</span>, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"> </div><div class="line">        <span class="comment">//All the rest don't need to create a Txn - just verify session</span></div><div class="line">                <span class="comment">//也就是说如果客户端发出的请求的操作命令是如下这些，那么不进行任何事务操作，只是检查session是否过期，然后将这些请求继续转发给下一个处理器 -- 也就是sync处理器</span></div><div class="line">        <span class="keyword">case</span> OpCode.sync:</div><div class="line">        <span class="keyword">case</span> OpCode.exists:</div><div class="line">        <span class="keyword">case</span> OpCode.getData:</div><div class="line">        <span class="keyword">case</span> OpCode.getACL:</div><div class="line">        <span class="keyword">case</span> OpCode.getChildren:</div><div class="line">        <span class="keyword">case</span> OpCode.getChildren2:</div><div class="line">        <span class="keyword">case</span> OpCode.ping:</div><div class="line">        <span class="keyword">case</span> OpCode.setWatches:</div><div class="line">            zks.sessionTracker.checkSession(request.sessionId,</div><div class="line">                    request.getOwner());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            LOG.warn(<span class="string">"unknown type "</span> + request.type);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"> 。。。。。。。。<span class="comment">//省略部分代码</span></div><div class="line">    request.zxid = zks.getZxid();</div><div class="line">    nextProcessor.processRequest(request);<span class="comment">//调用下一个处理器处理请求 -- sync处理器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="处理器SyncRequestProcessor持久化（快照）操作"><a href="#处理器SyncRequestProcessor持久化（快照）操作" class="headerlink" title="处理器SyncRequestProcessor持久化（快照）操作"></a>处理器SyncRequestProcessor持久化（快照）操作</h4><blockquote>
<p><strong>接着调用sync处理器的processRequest（）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">     <span class="comment">// request.addRQRec("&gt;sync");</span></div><div class="line">     queuedRequests.add(request);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>你会发现，sync处理器也是把请求放到队列中，所以很明显他跟prep处理器一样，也是生产消费模型。最终也是用过sync处理器的run方法从queuedRequests队列中拿到请求进行处理。</p>
<p>那么我们直接看sync处理器的run方法</p>
<blockquote>
<p><strong>sync处理器run()</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> logCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// we do this in an attempt to ensure that not all of the servers</span></div><div class="line">        <span class="comment">// in the ensemble take a snapshot at the same time</span></div><div class="line">        setRandRoll(r.nextInt(snapCount/<span class="number">2</span>));</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Request si = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</div><div class="line">                si = queuedRequests.take();<span class="comment">//拿出请求进行处理</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                si = queuedRequests.poll();</div><div class="line">                <span class="keyword">if</span> (si == <span class="keyword">null</span>) &#123;</div><div class="line">                    flush(toFlush);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (si == requestOfDeath) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;<span class="comment">//将请求持久化到磁盘中</span></div><div class="line">                <span class="comment">// track the number of records written to the log</span></div><div class="line">                <span class="keyword">if</span> (zks.getZKDatabase().append(si)) &#123;</div><div class="line">                    logCount++;</div><div class="line">                    <span class="keyword">if</span> (logCount &gt; (snapCount / <span class="number">2</span> + randRoll)) &#123;</div><div class="line">                        setRandRoll(r.nextInt(snapCount/<span class="number">2</span>));</div><div class="line">                        <span class="comment">// roll the log</span></div><div class="line">                        zks.getZKDatabase().rollLog();</div><div class="line">                        <span class="comment">// take a snapshot</span></div><div class="line">                        <span class="keyword">if</span> (snapInProcess != <span class="keyword">null</span> &amp;&amp; snapInProcess.isAlive()) &#123;</div><div class="line">                            LOG.warn(<span class="string">"Too busy to snap, skipping"</span>);</div><div class="line">                         &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            snapInProcess = <span class="keyword">new</span> ZooKeeperThread(<span class="string">"Snapshot Thread"</span>) &#123;</div><div class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                        <span class="keyword">try</span> &#123;</div><div class="line">                                            zks.takeSnapshot();</div><div class="line">                                        &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">                                            LOG.warn(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;;</div><div class="line">                            snapInProcess.start();</div><div class="line">                        &#125;</div><div class="line">                        logCount = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</div><div class="line">     </div><div class="line">                    <span class="keyword">if</span> (nextProcessor != <span class="keyword">null</span>) &#123;<span class="comment">//然后将请求传给下一个处理器 -- final处理器</span></div><div class="line">                        nextProcessor.processRequest(si);</div><div class="line">                        <span class="keyword">if</span> (nextProcessor <span class="keyword">instanceof</span> Flushable) &#123;</div><div class="line">                            ((Flushable)nextProcessor).flush();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                toFlush.add(si);</div><div class="line">                <span class="keyword">if</span> (toFlush.size() &gt; <span class="number">1000</span>) &#123;</div><div class="line">                    flush(toFlush);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        handleException(<span class="keyword">this</span>.getName(), t);</div><div class="line">        running = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    LOG.info(<span class="string">"SyncRequestProcessor exited!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="处理器FinalRequestProcessor从队列中拿出数据进行内存操作"><a href="#处理器FinalRequestProcessor从队列中拿出数据进行内存操作" class="headerlink" title="处理器FinalRequestProcessor从队列中拿出数据进行内存操作"></a>处理器FinalRequestProcessor从队列中拿出数据进行内存操作</h4><p><strong>这是三个处理器里面唯一一个不是线程的处理器。</strong>也是本次处理请求中，最后一个处理器。</p>
<p>然后接着调用    public void processRequest(Request request) {}方法处理请求</p>
<blockquote>
<p><strong>processRequest()关键代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">。。。。。。。<span class="comment">//省略部分代码</span></div><div class="line">          <span class="keyword">if</span> (request.hdr != <span class="keyword">null</span>) &#123;</div><div class="line">               TxnHeader hdr = request.hdr;</div><div class="line">               Record txn = request.txn;</div><div class="line">               rc = zks.processTxn(hdr, txn);<span class="comment">//1.这段代码，就是将请求处理后，加载数据到内存中也就是 - 存储在datatree中（我们zk的数据结构就是一个树形结构，那么他在代码中的对应结构就是DataTree，每个节点是DataNode）</span></div><div class="line">            &#125;</div><div class="line">      <span class="comment">//然后根据请求的类型处理相应的逻辑代码块-- 我们这里看两个操作的代码块（create和exists）</span></div><div class="line">              <span class="keyword">case</span> OpCode.create: &#123;</div><div class="line">                lastOp = <span class="string">"CREA"</span>;</div><div class="line">                rsp = <span class="keyword">new</span> CreateResponse(rc.path);<span class="comment">//构建请求响应，返回给客户端</span></div><div class="line">                err = Code.get(rc.err);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">case</span> OpCode.exists: &#123;</div><div class="line">                lastOp = <span class="string">"EXIS"</span>;</div><div class="line">                <span class="comment">// TODO we need to figure out the security requirement for this!</span></div><div class="line">                ExistsRequest existsRequest = <span class="keyword">new</span> ExistsRequest();</div><div class="line">                ByteBufferInputStream.byteBuffer2Record(request.request,</div><div class="line">                        existsRequest);</div><div class="line">                String path = existsRequest.getPath();</div><div class="line">                <span class="keyword">if</span> (path.indexOf(<span class="string">'\0'</span>) != -<span class="number">1</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.BadArgumentsException();</div><div class="line">                &#125;</div><div class="line">                Stat stat = zks.getZKDatabase().statNode(path, existsRequest</div><div class="line">                        .getWatch() ? cnxn : <span class="keyword">null</span>);<span class="comment">//关键代码：如果客户端再请求服务端的时候，他监听了 某个节点，那么 existsRequest.getWatch() 的值肯定是true，那么如果是true，他会传入cnxn类（server端的网络处理类，通过这个类发送响应给服务端）</span></div><div class="line">                rsp = <span class="keyword">new</span> ExistsResponse(stat);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">      <span class="comment">//数据写入内存成功后，最后</span></div><div class="line"><span class="comment">// 发送命令处理完成后的结果，默认是NIOServerCnxn，执行到这里代表服务端处理请求成功，完成。</span></div><div class="line">cnxn.sendResponse(hdr, rsp, <span class="string">"response"</span>);</div></pre></td></tr></table></figure>
<h5 id="watcher监听事件机制"><a href="#watcher监听事件机制" class="headerlink" title="watcher监听事件机制"></a>watcher监听事件机制</h5><p>我们知道，服务端处理客户端发出的某个节点的监听事件的关键代码是：<code>zks.getZKDatabase().statNode(path, existsRequest .getWatch() ? cnxn : null);</code></p>
<blockquote>
<p><strong>查看ZKDatabase.statNode(String, ServerCnxn)</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">statNode</span><span class="params">(String path, ServerCnxn serverCnxn)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</div><div class="line">    <span class="keyword">return</span> dataTree.statNode(path, serverCnxn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着调用dataTree.statNode()</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">statNode</span><span class="params">(String path, Watcher watcher)</span><span class="comment">//path就是节点的路径，watcher并不是监听器，他实际上就是一个网络通信类，用户处理客户端发过来的请求，他的实现是--NIOServerCnxn</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</div><div class="line">    Stat stat = <span class="keyword">new</span> Stat();</div><div class="line">    DataNode n = nodes.get(path);</div><div class="line">    <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</div><div class="line">        dataWatches.addWatch(path, watcher);<span class="comment">//接着执行这段代码，将path和watcher存入一个中  hashmap中</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (n) &#123;</div><div class="line">        n.copyStat(stat);</div><div class="line">        <span class="keyword">return</span> stat;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>  <strong>执行dataWatches.addWatch(path, watcher);</strong></p>
</blockquote>
<p>​    org.apache.zookeeper.server.WatchManager.addWatch(String, Watcher)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addWatch</span><span class="params">(String path, Watcher watcher)</span> </span>&#123;</div><div class="line">    HashSet&lt;Watcher&gt; list = watchTable.get(path);</div><div class="line">    <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// don't waste memory if there are few watches on a node</span></div><div class="line">        <span class="comment">// rehash when the 4th entry is added, doubling size thereafter</span></div><div class="line">        <span class="comment">// seems like a good compromise</span></div><div class="line">        list = <span class="keyword">new</span> HashSet&lt;Watcher&gt;(<span class="number">4</span>);</div><div class="line">        watchTable.put(path, list);</div><div class="line">    &#125;</div><div class="line">    list.add(watcher);</div><div class="line">   <span class="comment">//在这之前，hashmap的key是path，value是watcher（servercnx）</span></div><div class="line">    HashSet&lt;String&gt; paths = watch2Paths.get(watcher);<span class="comment">//反转hashmap，key转变为watcher（servercnx），value是path</span></div><div class="line">    <span class="keyword">if</span> (paths == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// cnxns typically have many watches, so use default cap here</span></div><div class="line">        paths = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        watch2Paths.put(watcher, paths);</div><div class="line">    &#125;</div><div class="line">    paths.add(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后将构造一个两个hashmap一个未反转key-value的，一个是已经反转key和value的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable =</div><div class="line">    <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt;();</div></pre></td></tr></table></figure>
<p>提醒：<strong>我们注意这里的watch并不是我们客户端的注册的监听实现，而是ServerCnx，是server端的一个通信类，所以说客户端注册的时间监听不会在服务端实现触发逻辑！！！！！</strong></p>
<p><strong>那么什么时候从watchTable中拿数据发送呢？或者什么时候触发事件呢？</strong></p>
<p>我们先梳理一下整个流程，假设客户端调用getData(“/app”,new Watch())，那么服务端知道你会在这个app节点注册监听，那么会执行到dataWatches.addWatch()代码。</p>
<p>​    然后往watchTable存放数据，<strong>key是/app，value是servercnx。</strong></p>
<p>​    那么当下次客户端调用setData(“/app”,”213”)，设置数据时，很明显这个时候我们需要响应客户端的事件，因为在这个节点上上次客户端创建了一个监听，所以服务端需要通知客户端，app节点修改了，你注册的事件你自己要触发一下。</p>
<pre><code>那么服务端是怎么通知客户端要出发监听事件呢？
</code></pre><p> 我们接着看代码，服务端收到setDate事件后，走处理链处理请求，最终会走到final处理器，然后最终调用datatree设置内存内存数据。</p>
<p><code>org.apache.zookeeper.server.DataTree.setData(String, byte[], int, long, long)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">setData</span><span class="params">(String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, <span class="keyword">long</span> zxid,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">long</span> time)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</div><div class="line">    Stat s = <span class="keyword">new</span> Stat();</div><div class="line">    DataNode n = nodes.get(path);</div><div class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">byte</span> lastdata[] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">synchronized</span> (n) &#123;</div><div class="line">        lastdata = n.data;</div><div class="line">        n.data = data;</div><div class="line">        n.stat.setMtime(time);</div><div class="line">        n.stat.setMzxid(zxid);</div><div class="line">        n.stat.setVersion(version);</div><div class="line">        n.copyStat(s);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// now update if the path is in a quota subtree.</span></div><div class="line">    String lastPrefix;</div><div class="line">    <span class="keyword">if</span>((lastPrefix = getMaxPrefixWithQuota(path)) != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.updateBytes(lastPrefix, (data == <span class="keyword">null</span> ? <span class="number">0</span> : data.length)</div><div class="line">          - (lastdata == <span class="keyword">null</span> ? <span class="number">0</span> : lastdata.length));</div><div class="line">    &#125;</div><div class="line">    dataWatches.triggerWatch(path, EventType.NodeDataChanged);<span class="comment">//触发监听</span></div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么设置完成后，代表客户端的setdata请求，服务端处理成功，那么就需要通知客户端触发事件了。</p>
<p>最终调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> </span>&#123;</div><div class="line">    WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type,</div><div class="line">            KeeperState.SyncConnected, path);</div><div class="line">    HashSet&lt;Watcher&gt; watchers;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        watchers = watchTable.remove(path);<span class="comment">//可以看到触发一个时间，就删除一个，这个就是为什么事件只能触发一次的原因。回答上面问题1的提问</span></div><div class="line">        <span class="keyword">if</span> (watchers == <span class="keyword">null</span> || watchers.isEmpty()) &#123;</div><div class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</div><div class="line">                ZooTrace.logTraceMessage(LOG,</div><div class="line">                        ZooTrace.EVENT_DELIVERY_TRACE_MASK,</div><div class="line">                        <span class="string">"No watchers for "</span> + path);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Watcher w : watchers) &#123;</div><div class="line">            HashSet&lt;String&gt; paths = watch2Paths.get(w);</div><div class="line">            <span class="keyword">if</span> (paths != <span class="keyword">null</span>) &#123;</div><div class="line">                paths.remove(path);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (Watcher w : watchers) &#123;</div><div class="line">        <span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        w.process(e);<span class="comment">//触发监听事件</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> watchers;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用<code>org.apache.zookeeper.server.NIOServerCnxn.process(WatchedEvent)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">    ReplyHeader h = <span class="keyword">new</span> ReplyHeader(-<span class="number">1</span>, -<span class="number">1L</span>, <span class="number">0</span>);<span class="comment">//重点，发送的是xid == -1，这个参数在《sendThread.readResponse() - 读取服务端返回的信息》处理服务端响应的代码中，有个判断if (replyHdr.getXid() == -1)  判断成功，说明需要客户端执行事件。那么客户端就把事件放到waitEvenQueue中等到eventThread的run方法进行处理。</span></div><div class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</div><div class="line">        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,</div><div class="line">                                 <span class="string">"Deliver event "</span> + event + <span class="string">" to 0x"</span></div><div class="line">                                 + Long.toHexString(<span class="keyword">this</span>.sessionId)</div><div class="line">                                 + <span class="string">" through "</span> + <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Convert WatchedEvent to a type that can be sent over the wire</span></div><div class="line">    WatcherEvent e = event.getWrapper();</div><div class="line"></div><div class="line">    sendResponse(h, e, <span class="string">"notification"</span>);<span class="comment">//发送通知给客户端，请求触发事件</span></div><div class="line">    <span class="comment">//接着在客户端的sendThread.readResponse()中处理请求，然后判断xid，然后做响应触发事件逻辑</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整的请求处理链</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409153236451.png" alt="image-20200409153236451"></p>
<p>​    也就是说，处理请求的时候，会经过三个处理器，进行处理。其中sync处理器的目的就是，将请求写入磁盘日志，并熟悉快照。</p>
<p>​    接着使用最后一个处理器final，将请求写到内存（方便读请求直接获取内存数据并返回），触发监听器，返回结果给客户端，完成请求。</p>
<p>​    如果客户端监听了某个节点，那么这个时候就会收到服务端发出的事件（通过socket的方式发送一个通知给客户端），然后客户端再进行相应处理。</p>
<p>详情参见：<a href="https://blog.csdn.net/yu_kang/article/details/88573304" target="_blank" rel="external">https://blog.csdn.net/yu_kang/article/details/88573304</a></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在Zookeeper中，数据存储分为两部分：内存数据存储和磁盘数据存储。</p>
<p>客户端的写请求，必须先写入磁盘后，才写入内存中，最后返回给客户端，整个读写请求完成。</p>
<p>单机模式下，客户端的请求，通过处理链进行处理，处理链上有三个处理器。</p>
<p><strong>单机模式下，server保证了高并发的安全性，因为请求会放到队列中，然后逐渐经过处理链，逐个处理。保证了每个请求的顺序性</strong></p>
<h2 id="好的文档-1"><a href="#好的文档-1" class="headerlink" title="好的文档"></a>好的文档</h2><p><a href="https://blog.csdn.net/yu_kang/article/details/88573304" target="_blank" rel="external">https://blog.csdn.net/yu_kang/article/details/88573304</a></p>
<p><a href="https://www.jianshu.com/nb/33061765" target="_blank" rel="external">https://www.jianshu.com/nb/33061765</a> - zk专栏</p>
<p><a href="http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/" target="_blank" rel="external">http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/</a> 阿里中间件专栏</p>
<p><a href="https://yq.aliyun.com/articles/227260" target="_blank" rel="external">https://yq.aliyun.com/articles/227260</a> zk开发中遇到的坑</p>
<h1 id="单机模式-end"><a href="#单机模式-end" class="headerlink" title="########单机模式 end"></a>########单机模式 end</h1><h1 id="集群模式"><a href="#集群模式" class="headerlink" title="########集群模式"></a>########集群模式</h1><h1 id="集群模式下的服务端启动源码解析（如何保证数据一致性）"><a href="#集群模式下的服务端启动源码解析（如何保证数据一致性）" class="headerlink" title="集群模式下的服务端启动源码解析（如何保证数据一致性）"></a>集群模式下的服务端启动源码解析（如何保证数据一致性）</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>​    集群的选举，涉及到，<strong>myid（sid）、epoch（第几轮投票）、选举状态</strong>（LOOKING、FOLLOWING、LEADING、OBSERVERING）， 这三个值是很重要的。</p>
<p><strong>在集群中，一般会存在三种类型的网络通信：</strong>所以在下面讲解集群的某些类中，你会发现某些类的io通信的作用是下面三个中的一个。</p>
<ul>
<li>选举需要网络通信（多个server之间）</li>
<li>集群接受客户端请求</li>
<li>集群数据同步（learner同步leader数据）</li>
</ul>
<p>集群需要实现的功能：</p>
<ul>
<li><p>数据存储、持久化存储</p>
</li>
<li><p>数据同步流程</p>
</li>
<li><p>watcher监听怎么实现</p>
</li>
</ul>
<p><strong>所以上面这六个问题是我们在阅读源码所以带着的问题。</strong></p>
<h2 id="初始化集群配置信息"><a href="#初始化集群配置信息" class="headerlink" title="初始化集群配置信息"></a>初始化集群配置信息</h2><p>其实他跟启动单机版服务端的，初始化配置信息的操作是差不多的，为了重温只是，这里再贴出来</p>
<p>zkServer.sh文件最终会访问这个类启动服务端</p>
<blockquote>
<p><strong>1.QuorumPeerMain类源码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ZooKeeperServerMain main = <span class="keyword">new</span> ZooKeeperServerMain();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        main.initializeAndRun(args);<span class="comment">//根据配置zoo.cfg文件，解析出配置的信息</span></div><div class="line">    &#125;</div><div class="line">。。。。。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    接着调用initializeAndRun方法，然后执行里面的 config.parse()，<strong>解析zoo.cfg配置文</strong>件，最终所有配置信息，都会<strong>保存到QuorumPeerConfig类</strong>中（包括，集群所有服务器地址，以及ob服务器，以及zk数据存储的位置，以及日志存储位置等等信息）</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409113142773.png" alt="image-20200409113142773"></p>
<blockquote>
<p><strong>2.解析zoo.cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数数量</strong></p>
</blockquote>
<p><strong>那么他是怎么识别是集群模式还是单机模式，就是在解析配置文件的过程中，进行判断的。</strong></p>
<p>解析的方法，最终会调用<code>org.apache.zookeeper.server.quorum.QuorumPeerConfig.parseProperties(Properties)</code></p>
<p>里面有一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(<span class="string">"server."</span>)) &#123;<span class="comment">//判断配置文件中是否存在，server.这样的配置信息，如果有，说明是集群模式，并把配置信息放到servers的Map中，保存，需要注意，如果server是观察者，那么需要放到observers中。因为观察者不参与投票，servsers中的节点是需要参与投票的。</span></div><div class="line">                <span class="keyword">int</span> dot = key.indexOf(<span class="string">'.'</span>);</div><div class="line">                <span class="keyword">long</span> sid = Long.parseLong(key.substring(dot + <span class="number">1</span>));</div><div class="line">                String parts[] = splitWithLeadingHostname(value);</div><div class="line">                <span class="keyword">if</span> ((parts.length != <span class="number">2</span>) &amp;&amp; (parts.length != <span class="number">3</span>) &amp;&amp; (parts.length !=<span class="number">4</span>)) &#123;</div><div class="line">                    LOG.error(value</div><div class="line">                       + <span class="string">" does not have the form host:port or host:port:port "</span> +</div><div class="line">                       <span class="string">" or host:port:port:type"</span>);</div><div class="line">                &#125;</div><div class="line">                LearnerType type = <span class="keyword">null</span>;</div><div class="line">                String hostname = parts[<span class="number">0</span>];</div><div class="line">                Integer port = Integer.parseInt(parts[<span class="number">1</span>]);</div><div class="line">                Integer electionPort = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">2</span>)&#123;</div><div class="line">                	electionPort=Integer.parseInt(parts[<span class="number">2</span>]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">3</span>)&#123;</div><div class="line">                    <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">"observer"</span>)) &#123;</div><div class="line">                        type = LearnerType.OBSERVER;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">"participant"</span>)) &#123;</div><div class="line">                        type = LearnerType.PARTICIPANT;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigException(<span class="string">"Unrecognised peertype: "</span> + value);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (type == LearnerType.OBSERVER)&#123;</div><div class="line">                    observers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    servers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<p>我们往下看你会发现，一个涉及到我们经常说的，半数选举策略。 <code>quorumVerifier = new QuorumMaj(servers.size());</code>  通过<strong>servers的数量获得半数数量</strong>。这里可以看到observer 并没有参与选举数量的确定，在确定半数数量后，ob最终会加到servers中（<strong>因为他也是能够处理客户端请求的</strong>）。</p>
<pre><code>public QuorumMaj(int n){
    this.half = n/2;// 例如 13/2 == 6
}

  // Now add observers to servers, once the quorums have been
 // figured out
 servers.putAll(observers);//ob最终会加到servers中
</code></pre><p>​    同时在parseProperties方法中，还会做一些校验工作，例如集群server必须是大于2的，而且如果集群数量是2的倍数，会提示建议使用奇数个server。</p>
<p>​    </p>
<h2 id="runFromConfig-config-启动服务器"><a href="#runFromConfig-config-启动服务器" class="headerlink" title="runFromConfig(config)启动服务器"></a>runFromConfig(config)启动服务器</h2><p>初始化完成集群总体配置信息过后，那么就开始进入当前server服务器集群初始化和启动工作。</p>
<p>调用runFromConfig（）方法，QuorumPeerMain启动类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">org.apache.zookeeper.server.quorum.QuorumPeerMain.runFromConfig(QuorumPeerConfig)</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          ManagedUtil.registerLog4jMBeans();</div><div class="line">      &#125; <span class="keyword">catch</span> (JMException e) &#123;</div><div class="line">          LOG.warn(<span class="string">"Unable to register log4j JMX control"</span>, e);</div><div class="line">      &#125;</div><div class="line">  </div><div class="line">      LOG.info(<span class="string">"Starting quorum peer"</span>);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();</div><div class="line">          cnxnFactory.configure(config.getClientPortAddress(),</div><div class="line">                                config.getMaxClientCnxns());<span class="comment">//跟单节点的服务端启动一样，// 建立socket,默认是NIOServerCnxnFactory（是一个线程），管理来自客户端的连接，监听ClientPortAddress。</span></div><div class="line">          <span class="comment">//这个时候NIOServerCnxnFactory线程还未启动，因为没有调用start</span></div><div class="line"></div><div class="line">          quorumPeer = getQuorumPeer();</div><div class="line"></div><div class="line">          quorumPeer.setQuorumPeers(config.getServers());</div><div class="line">          quorumPeer.setTxnFactory(<span class="keyword">new</span> FileTxnSnapLog(</div><div class="line">                  <span class="keyword">new</span> File(config.getDataLogDir()),</div><div class="line">                  <span class="keyword">new</span> File(config.getDataDir())));</div><div class="line">          quorumPeer.setElectionType(config.getElectionAlg());</div><div class="line">          quorumPeer.setMyid(config.getServerId());</div><div class="line">          quorumPeer.setTickTime(config.getTickTime());</div><div class="line">          quorumPeer.setInitLimit(config.getInitLimit());</div><div class="line">          quorumPeer.setSyncLimit(config.getSyncLimit());</div><div class="line">          quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());</div><div class="line">          quorumPeer.setCnxnFactory(cnxnFactory);</div><div class="line">          quorumPeer.setQuorumVerifier(config.getQuorumVerifier());</div><div class="line">          quorumPeer.setClientPortAddress(config.getClientPortAddress());</div><div class="line">          quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());</div><div class="line">          quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());</div><div class="line">          quorumPeer.setZKDatabase(<span class="keyword">new</span> ZKDatabase(quorumPeer.getTxnFactory()));</div><div class="line">          quorumPeer.setLearnerType(config.getPeerType());<span class="comment">//设置当前server的状态，默认设置的是learner状态中的PARTICIPANT（参与者）。learner一共有两种状态（PARTICIPANT，OBSERVER）</span></div><div class="line">          quorumPeer.setSyncEnabled(config.getSyncEnabled());</div><div class="line"></div><div class="line">          <span class="comment">// sets quorum sasl authentication configurations</span></div><div class="line">          quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);</div><div class="line">          <span class="keyword">if</span>(quorumPeer.isQuorumSaslAuthEnabled())&#123;</div><div class="line">              quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);</div><div class="line">              quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);</div><div class="line">              quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);</div><div class="line">              quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);</div><div class="line">              quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);</div><div class="line">          quorumPeer.initialize();</div><div class="line"></div><div class="line">          quorumPeer.start();<span class="comment">//启动server服务器，做初始化工作。需要注意，这里只是启动服务器做初始化工作，例如选举leader、数据同步等等操作，并不是马上就能接受客户端请求。具体逻辑在QuorumPeer的start()方法中。</span></div><div class="line">          quorumPeer.join();<span class="comment">//等待quorumPeer线程执行完毕，那么当前服务器退出。</span></div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">          <span class="comment">// warn, but generally this is ok</span></div><div class="line">          LOG.warn(<span class="string">"Quorum Peer interrupted"</span>, e);</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​    接着创建一个QuorumPeer类(是一个线程)，保存当前server的配置信息（实际上就是用QuorumPeerConfig将部分配置信息赋值给QuorumPeer）。<strong>接着启动QuorumPeer.start().</strong></p>
<blockquote>
<p> <strong>quorumPeer.start()</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    loadDataBase();<span class="comment">//首先加载本地数据（根据快照和日志文件，重放数据到内存中），保持数据一致性关键</span></div><div class="line">    cnxnFactory.start();  <span class="comment">//启动NIOServerCnxnFactory线程（上面创建的）      </span></div><div class="line">    startLeaderElection();<span class="comment">//确定选举leader的策略，实际上有四种策略，但是其他三种都是过时的，目前只有FastLeaderElection策略才能够使用</span></div><div class="line">    <span class="keyword">super</span>.start();<span class="comment">//启动线程quorumPeer，执行run方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="loadDataBase-重放数据到服务器内存"><a href="#loadDataBase-重放数据到服务器内存" class="headerlink" title="loadDataBase()重放数据到服务器内存"></a>loadDataBase()重放数据到服务器内存</h3><p>这个在上面的单机版服务的server说过了，类似的，这里就不再说了。</p>
<h3 id="cnxnFactory-start-初始化启动NIOServerCnxnFactory线程"><a href="#cnxnFactory-start-初始化启动NIOServerCnxnFactory线程" class="headerlink" title="cnxnFactory.start()初始化启动NIOServerCnxnFactory线程"></a>cnxnFactory.start()初始化启动NIOServerCnxnFactory线程</h3><p> <strong>cnxnFactory.start()，启动NIOServerCnxnFactory线程，处理客户端请求（也就是说处理客户端请求逻辑在这里）</strong> </p>
<p>​    最终会去执行NIOServerCnxnFactory的run方法，在while循环中，获取客户端请求。如果nio监听到读写事件，那么就调用doIO进行处理请求。</p>
<p>​    <strong>特别注意：</strong>doIO在处理请求的时候，如果server的状态并不是 State.RUNNING，那么就会抛出异常<code>throw new IOException(&quot;ZooKeeperServer not running&quot;);</code></p>
<p>​    <strong>这个时候说明集群并没有准备好，那么不处理任何请求。</strong></p>
<p>​    <strong>！！！！那么此刻很明显当前server肯定不是RUNNING状态，因为没有在这之前没有看到任何代码将当前服务器启动并设置状态为RUNNING，所以代码运行到这里，服务器是不能接受客户端请求的，就算接受了也会抛异常（从逻辑上此时server也不可能响应客户端请求，因为当前server还没有确定自己的状态，是leader还是follower还是observer，数据是否是最新的？等等之类的问题，那么他此刻肯定不能响应客户端请求）！！！！！！！！！！</strong></p>
<p>​    <strong>总而言之，就是监听2181端口，接口客户端请求。</strong></p>
<p>这方法的代码，主要的是就是讲述我们的 <strong>集群接受客户端请求</strong> 通信的内容了。</p>
<h3 id="startLeaderElection（）确定选举策略和先投自己一票"><a href="#startLeaderElection（）确定选举策略和先投自己一票" class="headerlink" title="startLeaderElection（）确定选举策略和先投自己一票"></a>startLeaderElection（）确定选举策略和先投自己一票</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//myid不用说了，就是我们自己配置的。getLastLoggedZxid：获取当前server最新的zxid，getCurrentEpoch（）获取当前服务器目前是在第几轮（在哪个朝代，是哪个leader领导的）</span></div><div class="line">		currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());<span class="comment">//你会发现这里的开始就先构建一个投票信息。表示你要投自己一票。CurrentEpoch的意思是，当前是第几轮投票。（这三个参数是在选举leader中是需要做比较的）</span></div><div class="line">	&#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">		RuntimeException re = <span class="keyword">new</span> RuntimeException(e.getMessage());</div><div class="line">		re.setStackTrace(e.getStackTrace());</div><div class="line">		<span class="keyword">throw</span> re;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//getView()返回的是，我们在zoo.cfg中配置的集群server列表（包括observer）</span></div><div class="line">    <span class="keyword">for</span> (QuorumServer p : getView().values()) &#123;<span class="comment">//通过myid，获取当前server的ip</span></div><div class="line">        <span class="keyword">if</span> (p.id == myid) &#123;</div><div class="line">            myQuorumAddr = p.addr;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (myQuorumAddr == <span class="keyword">null</span>) &#123;<span class="comment">//如果地址为空，那么说明当前服务器不在集群中，那么启动失败。</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"My id "</span> + myid + <span class="string">" not in the peer list"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;<span class="comment">//选举策略，默认是3，这个值的赋值是在QuorumPeerMain.runFromConfig()的方法中配置。也就是说，我们可以通过在zoo.cfg中配置electionType的值确定不通的选举策略。</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            udpSocket = <span class="keyword">new</span> DatagramSocket(myQuorumAddr.getPort());</div><div class="line">            responder = <span class="keyword">new</span> ResponderThread();</div><div class="line">            responder.start();</div><div class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);<span class="comment">//根据选举策略标志位获取选举策略，实际上除了FastLeaderElection这种策略，其他的都失效了。所以这里默认创建FastLeaderElection选举策略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p> <strong>createElectionAlgorithm(electionType)</strong></p>
</blockquote>
<p>创建选举策略，只有case等于3的策略才能使用，其他的都已经失效了，<strong>建立投票监听</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span></span>&#123;</div><div class="line">    Election le=<span class="keyword">null</span>;</div><div class="line">            </div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></div><div class="line">    <span class="keyword">switch</span> (electionAlgorithm) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        le = <span class="keyword">new</span> LeaderElection(<span class="keyword">this</span>);<span class="comment">//已经失效，不能使用</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>);<span class="comment">//已经失效，不能使用</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>, <span class="keyword">true</span>);<span class="comment">//已经失效，不能使用</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//只能使用</span></div><div class="line">        qcm = createCnxnManager();</div><div class="line">        QuorumCnxManager.Listener listener = qcm.listener;</div><div class="line">        <span class="keyword">if</span>(listener != <span class="keyword">null</span>)&#123;</div><div class="line">            listener.start();</div><div class="line">            <span class="comment">//FastLeaderElection</span></div><div class="line">            le = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            LOG.error(<span class="string">"Null listener when initializing cnx manager"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> le;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到他创建了FastLeaderElection选举算法，但是在那里创建了其他服务器的投票监听呢？</p>
<blockquote>
<p><strong>（1）createCnxnManager()方法，最终创建QuorumCnxManager类。 - 创建投票监听listener</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// visible for testing</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuorumCnxManager</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> mySid,</span></span></div><div class="line"><span class="function"><span class="params">                        Map&lt;Long,QuorumPeer.QuorumServer&gt; view,</span></span></div><div class="line"><span class="function"><span class="params">                        QuorumAuthServer authServer,</span></span></div><div class="line"><span class="function"><span class="params">                        QuorumAuthLearner authLearner,</span></span></div><div class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> socketTimeout,</span></span></div><div class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> listenOnAllIPs,</span></span></div><div class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> quorumCnxnThreadsSize,</span></span></div><div class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> quorumSaslAuthEnabled,</span></span></div><div class="line"><span class="function"><span class="params">                        ConcurrentHashMap&lt;Long, SendWorker&gt; senderWorkerMap)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.senderWorkerMap = senderWorkerMap;<span class="comment">//针对要发送投票信息给服务器数量，创建map，保存相应数量的SendWorker线程，每个线程都负责发送投票信息给服务器</span></div><div class="line"></div><div class="line">    <span class="keyword">this</span>.recvQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Message&gt;(RECV_CAPACITY);<span class="comment">//保存收到的投票信息</span></div><div class="line">    <span class="keyword">this</span>.queueSendMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, ArrayBlockingQueue&lt;ByteBuffer&gt;&gt;();<span class="comment">//保存要发送给每台服务器的数据，senderWorkerMap就是从这里取数据发送</span></div><div class="line">    <span class="keyword">this</span>.lastMessageSent = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, ByteBuffer&gt;();<span class="comment">//最近一次发送的数据</span></div><div class="line">    String cnxToValue = System.getProperty(<span class="string">"zookeeper.cnxTimeout"</span>);</div><div class="line">    <span class="keyword">if</span>(cnxToValue != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.cnxTO = Integer.parseInt(cnxToValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.mySid = mySid;</div><div class="line">    <span class="keyword">this</span>.socketTimeout = socketTimeout;</div><div class="line">    <span class="keyword">this</span>.view = view;</div><div class="line">    <span class="keyword">this</span>.listenOnAllIPs = listenOnAllIPs;</div><div class="line"></div><div class="line">    initializeAuth(mySid, authServer, authLearner, quorumCnxnThreadsSize,</div><div class="line">            quorumSaslAuthEnabled);</div><div class="line"></div><div class="line">    <span class="comment">// Starts listener thread that waits for connection requests </span></div><div class="line">    listener = <span class="keyword">new</span> Listener();<span class="comment">//很关键这个listnner，建立连接接受其他服务端的投票请求</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    换言之，这个类主要创建两个map去负责发送数据，其中一个map是发送线程map，另一个map是保存线程要发送的数据。创建一个队列来接受数据。</p>
<blockquote>
<p><strong>（1.1）new Listener() - 创建投票监听</strong></p>
</blockquote>
<p>​    实际上是创建一个线程，但是这个listenner什么时候启动呢？<strong>在createElectionAlgorithm方法中 执行了listener.start()启动</strong>，然后执行rlistener的run方法，run方法中创建一个<strong>原生的ServerSocket，接受其他server端的投票请求。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> numRetries = <span class="number">0</span>;</div><div class="line">    InetSocketAddress addr;</div><div class="line">    <span class="keyword">while</span>((!shutdown) &amp;&amp; (numRetries &lt; <span class="number">3</span>))&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ss = <span class="keyword">new</span> ServerSocket();<span class="comment">//为什么不用NIO，而是用了阻塞的bio呢？因为集群中投票的节点不会太多，所以没有关系</span></div><div class="line">            ss.setReuseAddress(<span class="keyword">true</span>);</div><div class="line">            <span class="keyword">if</span> (listenOnAllIPs) &#123;</div><div class="line">                <span class="keyword">int</span> port = view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid)</div><div class="line">                    .electionAddr.getPort();</div><div class="line">                addr = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                addr = view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid)</div><div class="line">                    .electionAddr;</div><div class="line">            &#125;</div><div class="line">            LOG.info(<span class="string">"My election bind port: "</span> + addr.toString());</div><div class="line">            setName(view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid)</div><div class="line">                    .electionAddr.toString());</div><div class="line">            ss.bind(addr);<span class="comment">//绑定的addr地址，是选举地址，也就是当前服务器的选举地址。也就是监听localhost:3887。</span></div><div class="line">            <span class="comment">//server.1=localhost:2887:3887</span></div><div class="line">            <span class="keyword">while</span> (!shutdown) &#123;<span class="comment">//无线遍历，处理来自其他server的投票信息</span></div><div class="line">                    Socket client = ss.accept();</div><div class="line">                    setSockOpts(client);</div><div class="line">                    LOG.info(<span class="string">"Received connection request "</span></div><div class="line">                            + client.getRemoteSocketAddress());</div><div class="line"></div><div class="line">                    <span class="comment">// Receive and handle the connection request</span></div><div class="line">                    <span class="comment">// asynchronously if the quorum sasl authentication is</span></div><div class="line">                    <span class="comment">// enabled. This is required because sasl server</span></div><div class="line">                    <span class="comment">// authentication process may take few seconds to finish,</span></div><div class="line">                    <span class="comment">// this may delay next peer connection requests.</span></div><div class="line">                    <span class="keyword">if</span> (quorumSaslAuthEnabled) &#123;</div><div class="line">                        receiveConnectionAsync(client);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        receiveConnection(client);<span class="comment">//处理收到的请求，最终调用handleConnection处理请求</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    numRetries = <span class="number">0</span>;</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>handleConnection，新建两个线程发送自己的投票数据和接受其他服务器的投票数据</strong></p>
</blockquote>
<p><strong>也就是新建 SendWorker 和 RecvWorker 线程。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleConnection</span><span class="params">(Socket sock, DataInputStream din)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Long sid = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// Read server id</span></div><div class="line">        sid = din.readLong();</div><div class="line">        <span class="keyword">if</span> (sid &lt; <span class="number">0</span>) &#123; <span class="comment">// this is not a server id but a protocol version (see ZOOKEEPER-1633)</span></div><div class="line">            sid = din.readLong();</div><div class="line"></div><div class="line">            <span class="comment">// next comes the #bytes in the remainder of the message</span></div><div class="line">            <span class="comment">// note that 0 bytes is fine (old servers)</span></div><div class="line">            <span class="keyword">int</span> num_remaining_bytes = din.readInt();</div><div class="line">            <span class="keyword">if</span> (num_remaining_bytes &lt; <span class="number">0</span> || num_remaining_bytes &gt; maxBuffer) &#123;</div><div class="line">                LOG.error(<span class="string">"Unreasonable buffer length: &#123;&#125;"</span>, num_remaining_bytes);</div><div class="line">                closeSocket(sock);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[num_remaining_bytes];</div><div class="line"></div><div class="line">            <span class="comment">// remove the remainder of the message from din</span></div><div class="line">            <span class="keyword">int</span> num_read = din.read(b);</div><div class="line">            <span class="keyword">if</span> (num_read != num_remaining_bytes) &#123;</div><div class="line">                LOG.error(<span class="string">"Read only "</span> + num_read + <span class="string">" bytes out of "</span> + num_remaining_bytes + <span class="string">" sent by server "</span> + sid);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sid == QuorumPeer.OBSERVER_ID) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line"><span class="comment">             * Choose identifier at random. We need a value to identify</span></div><div class="line"><span class="comment">             * the connection.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            sid = observerCounter.getAndDecrement();</div><div class="line">            LOG.info(<span class="string">"Setting arbitrary identifier to observer: "</span> + sid);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        closeSocket(sock);</div><div class="line">        LOG.warn(<span class="string">"Exception reading or writing challenge: "</span> + e.toString());</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// do authenticating learner</span></div><div class="line">    LOG.debug(<span class="string">"Authenticating learner server.id: &#123;&#125;"</span>, sid);</div><div class="line">    authServer.authenticate(sock, din);</div><div class="line"></div><div class="line">    <span class="comment">//If wins the challenge, then close the new connection.</span></div><div class="line">    <span class="keyword">if</span> (sid &lt; <span class="keyword">this</span>.mySid) &#123;<span class="comment">//</span></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * This replica might still believe that the connection to sid is</span></div><div class="line"><span class="comment">         * up, so we have to shut down the workers before trying to open a</span></div><div class="line"><span class="comment">         * new connection.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        SendWorker sw = senderWorkerMap.get(sid);</div><div class="line">        <span class="keyword">if</span> (sw != <span class="keyword">null</span>) &#123;</div><div class="line">            sw.finish();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Now we start a new connection</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        LOG.debug(<span class="string">"Create new connection to server: "</span> + sid);</div><div class="line">        closeSocket(sock);</div><div class="line">        connectOne(sid);</div><div class="line"></div><div class="line">        <span class="comment">// Otherwise start worker threads to receive data.</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//为上面创建的senderWorkerMap和queueSendMap赋值，同时启动SendWorker发送投票信息的同时，启动一个相应的RecvWorker线程接受请求。也即是为每一台server都创建一条发送和接受的专线。假设有三个sever，那么就需要三条专线，其中三个SendWorker和三个RecvWorker。</span></div><div class="line">        SendWorker sw = <span class="keyword">new</span> SendWorker(sock, sid);</div><div class="line">        RecvWorker rw = <span class="keyword">new</span> RecvWorker(sock, din, sid, sw);</div><div class="line">        sw.setRecv(rw);</div><div class="line"></div><div class="line">        SendWorker vsw = senderWorkerMap.get(sid);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(vsw != <span class="keyword">null</span>)</div><div class="line">            vsw.finish();</div><div class="line">        </div><div class="line">        senderWorkerMap.put(sid, sw);<span class="comment">//保存数据</span></div><div class="line">        queueSendMap.putIfAbsent(sid, <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(SEND_CAPACITY));<span class="comment">//保存数据</span></div><div class="line">        </div><div class="line">        sw.start();<span class="comment">//启动sendWorker线程，从sendqueue中拿出自己要投票给其他服务器的数据，进行发送</span></div><div class="line">        <span class="comment">//那么queueSendMap的数据是打哪儿来的呢？参加下面的《1.1sendNotifications()方法》</span></div><div class="line">        rw.start();<span class="comment">//启动recvWorker线程，获取其他服务器的投票数据</span></div><div class="line">        <span class="comment">//那么RecvWorker是负责接受其他服务器的投票数据，然后放到LinkedBlockingQueue&lt;Notification&gt; recvqueue;中，那么这些数据什么时候使用呢？在哪里使用嗯？  参见后面的super.start()调用run方法中，在执行  sendNotifications();之后的逻辑，也即是下面的《1.2处理接受到其他服务端的投票数据》</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>​    （1）你会发现这个方法，只是启动了其他服务器向自己投票的监听，和初始化了一个FastLeaderElection选举策略。</p>
<p>​    （2）<strong>listener通过新建两个线程来负责发送自己的投票信息和接受其他服务器的投票信息。</strong></p>
<p>需要注意的是：假设有a,b,c三台服务器，那么a向b,c发送投票数据，要分别为b，c服务器分别创建一对线程（SendWorker和RecvWorker），也就是一共创建两对线程，也即是两个SendWorker和两个RecvWorker。并不是b，c服务器公用一对SendWorker和RecvWorker。</p>
<p>  保证了a与其他服务器，都有一对单独线程处理发送投票和接受投票。</p>
<p>​       <strong>也就是说，执行到这里，发送自己票据和接受其他服务器票据的服务已经启动（现在就等待往sendQueue中添加数据和从recvQueue中拿输出处理了）。</strong></p>
<p>流程图：</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-2020041210123330920.png" alt="image-20200413200707940"></p>
<p>​    <strong>本方法并没有真正leader选举的代码逻辑。</strong>   那么leader选举的逻辑在那里实现呢？请往下看</p>
<h3 id="super-start-–-根据选定策略执行leader选举-投票代码"><a href="#super-start-–-根据选定策略执行leader选举-投票代码" class="headerlink" title="super.start() – 根据选定策略执行leader选举-投票代码"></a>super.start() – 根据选定策略执行leader选举-投票代码</h3><p>​    真正的leader投票，在 super.start();启动之后，判断当前server的节点状态，如果是LOKING，那么说明需要进入leader选举。</p>
<blockquote>
<p><strong>选举整体思路</strong></p>
</blockquote>
<p>​    那么选举leader是根据什么条件选择呢？<strong>主要是三个：事务id（也就是zxid，即是比较哪台server的数据是最新的）、myid、epoch</strong></p>
<p>​    <strong>首先比较的是epoch，这里假设epoch相等。那么接着比较zxid，也就是比较那台数据最新。如果zxid一样，那么就比较myid的大小。</strong></p>
<p>​    例如有三台server，他们的zxid和myid信息如下（<strong>假设epoch相等</strong>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A:zxid=1,myid=1,epoch=1  B:zxid=2,myid=2,epoch=1   C:zxid=2,myid=3 ,epoch=1    一共三台server，半数是1。那么最少有两台server启动才能确定leader</div></pre></td></tr></table></figure>
<p>A先启动，发现，<strong>没有过半数，则继续LOKING</strong>。紧接着B启动，半数原则达到，然后开始选举。</p>
<p><strong>首先他们都会各自投自己一票</strong>，然后把信息发给对方。<strong>假设他们吧投票信息都放到一个map中，key是zxid。</strong></p>
<p>此时，A：{<a，1>}，B：{<b，2>}。然后把投票信息发给对方。</b，2></a，1></p>
<p>​    此时，A：{<a，1>，<b，2>}，B：{<b，2>，<a，1>}。A服务器开始判断zxid大小，发现B的zxid更大，那么就会把投自己一票的那一票给丢弃，换成投给B，此时<strong>A：{<a，1>，<b，2>} —&gt;  A：{<b，2>，<b，2>}</b，2></b，2></b，2></a，1></strong></a，1></b，2></b，2></a，1></p>
<p>​    然后A把投票结果发给B，也会把，A的那票给失效，此时<strong>B：{<b，2>，<a，1>} —&gt;  A：{<b，2>，<b，2>}</b，2></b，2></a，1></b，2></strong></p>
<p>​    最终确定B当选leader。</p>
<p><strong>那么如果zxid一样，那么就要重新根据myid投票，投票过程是一样的。</strong></p>
<p><strong>领导选举的，关键代码在QuorumPeer线程的run方法。</strong></p>
<blockquote>
<p><strong>源码分析</strong></p>
</blockquote>
<p>​    查看QuorumPeer的run方法：</p>
<p>首席服务器启动是，他的服务状态肯定是<strong>LOOKING</strong>。因为默认QuorumPeer默认<code>private ServerState state = ServerState.LOOKING;</code>.</p>
<p><strong>所以进入case LOOKING的代码逻辑。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> (getPeerState()) &#123;</div><div class="line">         <span class="keyword">case</span> LOOKING:<span class="comment">//如果服务器状态是loking，那么说明需要领导选举</span></div><div class="line">         </div><div class="line">           setBCVote(<span class="keyword">null</span>);</div><div class="line">        <span class="comment">//默认当前选的是自己为leader，但是随着选举的逻辑进行，可能currentVote的值就不是自己了</span></div><div class="line">           setCurrentVote(makeLEStrategy().lookForLeader());<span class="comment">//投票关键代码</span></div><div class="line">         。。。。。。省略部分代码</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>查看FastLeaderElection.lookForLeader()确定选举细节</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">            。。。。。。。。。</div><div class="line"></div><div class="line">            <span class="comment">//收到的投票，就是投票箱的概念</span></div><div class="line">            HashMap&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</div><div class="line">            <span class="comment">//发出去的投票</span></div><div class="line">            HashMap&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> notTimeout = finalizeWait;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;<span class="comment">//没选举一轮，那么epoch就会自增1</span></div><div class="line">                logicalclock.incrementAndGet();<span class="comment">//原子long类型，增加逻辑时钟，就是epoch</span></div><div class="line">                <span class="comment">//更新选举提议，myid  zxid  epoch，这里面的信息也就是自己的myid，zxid，和currentEpoch。 </span></div><div class="line">                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            LOG.info(<span class="string">"New election. My id =  "</span> + self.getId() +</div><div class="line">                    <span class="string">", proposed zxid=0x"</span> + Long.toHexString(proposedZxid));</div><div class="line">            <span class="comment">//（1）发送投票提议给所有的节点，需要注意，也会发送给自己.只会发送给需要参与投票的节点服务器，也即是//server.type == LearnerType.，不包括observer节点</span></div><div class="line">            sendNotifications();</div><div class="line"></div><div class="line">            <span class="comment">//（2）发送完自己的提议，那么开始处理收到的票据。</span></div><div class="line">        </div><div class="line">            <span class="comment">//如果还是是looking状态，我们会一直去和其他节点交互信息，直到选举出leader</span></div><div class="line">            <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</div><div class="line">                    (!stop))&#123;</div><div class="line">        </div><div class="line">                <span class="comment">//从接收队列中拿到投票信息，拿到其他server的投票信息。</span></div><div class="line">                <span class="comment">//疑问？？</span></div><div class="line">                <span class="comment">//recvQueue中的是数据是哪里来的呢？我们还记得在startLeaderElection()方法中创建的listener中创建的RecvWorker线程么？</span></div><div class="line">                <span class="comment">//就是通过这个线程去接受其他服务端的投票，然后放到recvQueue中。</span></div><div class="line">                Notification n = recvqueue.poll(notTimeout,</div><div class="line">                        TimeUnit.MILLISECONDS);<span class="comment">//然后从队列中取出一个票据</span></div><div class="line"></div><div class="line">                <span class="comment">/*</span></div><div class="line"><span class="comment">                 * Sends more notifications if haven't received enough.</span></div><div class="line"><span class="comment">                 * Otherwise processes new notification.</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keyword">if</span>(n == <span class="keyword">null</span>)&#123;<span class="comment">//如果取出的票据为空，那么说明没有其他服务器发送过来他们的票据</span></div><div class="line">                    <span class="keyword">if</span>(manager.haveDelivered())&#123;  <span class="comment">//检查所有的队列是否为空</span></div><div class="line">                        sendNotifications();        <span class="comment">//如果为空发送通知</span></div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        manager.connectAll();  <span class="comment">//如果没有投递出去，可能是其他server还没有启动，尝试连接</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">/*</span></div><div class="line"><span class="comment">                     * Exponential backoff</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">                    <span class="keyword">int</span> tmpTimeOut = notTimeout*<span class="number">2</span>;</div><div class="line">                    notTimeout = (tmpTimeOut &lt; maxNotificationInterval?</div><div class="line">                            tmpTimeOut : maxNotificationInterval);</div><div class="line">                    LOG.info(<span class="string">"Notification time out: "</span> + notTimeout);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//判断收到的投票的sid,</span></div><div class="line">                <span class="comment">//这里判断的是收到的sid是不是属于当前集群内的</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">switch</span> (n.state) &#123; <span class="comment">//判断当前票据状态状态 - 因为是选举阶段，那么票据肯定是LOOKING状态</span></div><div class="line">                    <span class="keyword">case</span> LOOKING:</div><div class="line">                      </div><div class="line">                        <span class="comment">//收到的票据中的epoch是不是比当前选举的epoch要大，如果大那么代表是新一轮选举</span></div><div class="line">                        <span class="comment">//那就说明，自己现在的投票轮数不是最新的，那么需要更新为最新，然后再参与投票。例如别人都已经是第三轮投票了，你现在还是第二轮。</span></div><div class="line">                        <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;</div><div class="line">                            logicalclock.set(n.electionEpoch);  <span class="comment">//更新当前epoch</span></div><div class="line">                            recvset.clear();  <span class="comment">//情况收到的投票</span></div><div class="line">                            <span class="comment">//进行投票</span></div><div class="line"></div><div class="line">                            <span class="comment">/*</span></div><div class="line"><span class="comment">                            totalOrderPredicate方法逻辑</span></div><div class="line"><span class="comment">                             * We return true if one of the following three cases hold:</span></div><div class="line"><span class="comment">                             * 1- New epoch is higher</span></div><div class="line"><span class="comment">                             * 收到的epoch大于当前的epoch 胜出选举</span></div><div class="line"><span class="comment">                             * 2- New epoch is the same as current epoch, but new zxid is higher</span></div><div class="line"><span class="comment">                             * 如果收到的epoch等于当前epoch,那么收到的zxid大于当前zxid胜出选举</span></div><div class="line"><span class="comment">                             * 3- New epoch is the same as current epoch, new zxid is the same</span></div><div class="line"><span class="comment">                             *  as current zxid, but server id is higher.</span></div><div class="line"><span class="comment">                             * 如果收到的epoch等于当前epoch，zxid等于当前zxid,</span></div><div class="line"><span class="comment">                             * 那么收到的myid大于当前myid的胜出选举</span></div><div class="line"><span class="comment">                             */</span></div><div class="line">                            <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                    getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</div><div class="line">                                updateProposal(n.leader, n.zxid, n.peerEpoch); <span class="comment">//把胜出的消息更新到投票提议中</span></div><div class="line">                            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果收到消息没有胜出，那么选择当前的消息更新到投票提议中</span></div><div class="line">                                updateProposal(getInitId(),</div><div class="line">                                        getInitLastLoggedZxid(),</div><div class="line">                                        getPeerEpoch());</div><div class="line">                            &#125;</div><div class="line">                            sendNotifications();  <span class="comment">//发送投票消息</span></div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;  <span class="comment">//如果收到的逻辑时钟小，那么表示这个投票无效</span></div><div class="line">                            <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">                                LOG.debug(<span class="string">"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x"</span></div><div class="line">                                        + Long.toHexString(n.electionEpoch)</div><div class="line">                                        + <span class="string">", logicalclock=0x"</span> + Long.toHexString(logicalclock.get()));</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                            <span class="comment">//如果收到的逻辑时钟相等，则去对比myid 、zxid、epoch</span></div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                proposedLeader, proposedZxid, proposedEpoch)) &#123;</div><div class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                            sendNotifications();</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">                            LOG.debug(<span class="string">"Adding vote: from="</span> + n.sid +</div><div class="line">                                    <span class="string">", proposed leader="</span> + n.leader +</div><div class="line">                                    <span class="string">", proposed zxid=0x"</span> + Long.toHexString(n.zxid) +</div><div class="line">                                    <span class="string">", proposed election epoch=0x"</span> + Long.toHexString(n.electionEpoch));</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="comment">//把投票结果存到本地，用来做最终判断</span></div><div class="line">                        recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</div><div class="line"></div><div class="line">                        <span class="comment">//判断选举是否结束，默认算法过半同意</span></div><div class="line">                        <span class="keyword">if</span> (termPredicate(recvset,</div><div class="line">                                <span class="keyword">new</span> Vote(proposedLeader, proposedZxid,</div><div class="line">                                        logicalclock.get(), proposedEpoch))) &#123;</div><div class="line"></div><div class="line">                            <span class="comment">// Verify if there is any change in the proposed leader</span></div><div class="line">                            <span class="keyword">while</span>((n = recvqueue.poll(finalizeWait,</div><div class="line">                                    TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>)&#123;</div><div class="line">                                <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                        proposedLeader, proposedZxid, proposedEpoch))&#123;</div><div class="line">                                    recvqueue.put(n);<span class="comment">//获得最新的记过</span></div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</div><div class="line">                                self.setPeerState((proposedLeader == self.getId()) ?</div><div class="line">                                        ServerState.LEADING: learningState());</div><div class="line"></div><div class="line">                                Vote endVote = <span class="keyword">new</span> Vote(proposedLeader,</div><div class="line">                                        proposedZxid, proposedEpoch);</div><div class="line">                                leaveInstance(endVote);</div><div class="line">                                <span class="keyword">return</span> endVote;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> OBSERVING:  <span class="comment">//如果是</span></div><div class="line">                        LOG.debug(<span class="string">"Notification from observer: "</span> + n.sid);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> FOLLOWING:</div><div class="line">                    <span class="keyword">case</span> LEADING:</div><div class="line">                        <span class="comment">/*</span></div><div class="line"><span class="comment">                         * Consider all notifications from the same epoch</span></div><div class="line"><span class="comment">                         * together.</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        <span class="keyword">if</span>(n.electionEpoch == logicalclock.get())&#123;</div><div class="line">                            recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</div><div class="line">                            <span class="keyword">if</span>(termPredicate(recvset, <span class="keyword">new</span> Vote(n.leader,</div><div class="line">                                            n.zxid, n.electionEpoch, n.peerEpoch, n.state))</div><div class="line">                                            &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</div><div class="line">                                self.setPeerState((n.leader == self.getId()) ?</div><div class="line">                                        ServerState.LEADING: learningState());</div><div class="line"></div><div class="line">                                Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                                leaveInstance(endVote);</div><div class="line">                                <span class="keyword">return</span> endVote;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="comment">/*</span></div><div class="line"><span class="comment">                         * Before joining an established ensemble, verify that</span></div><div class="line"><span class="comment">                         * a majority are following the same leader.</span></div><div class="line"><span class="comment">                         * Only peer epoch is used to check that the votes come</span></div><div class="line"><span class="comment">                         * from the same ensemble. This is because there is at</span></div><div class="line"><span class="comment">                         * least one corner case in which the ensemble can be</span></div><div class="line"><span class="comment">                         * created with inconsistent zxid and election epoch</span></div><div class="line"><span class="comment">                         * info. However, given that only one ensemble can be</span></div><div class="line"><span class="comment">                         * running at a single point in time and that each </span></div><div class="line"><span class="comment">                         * epoch is used only once, using only the epoch to </span></div><div class="line"><span class="comment">                         * compare the votes is sufficient.</span></div><div class="line"><span class="comment">                         * </span></div><div class="line"><span class="comment">                         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.leader, </div><div class="line">                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));</div><div class="line">                        <span class="keyword">if</span> (termPredicate(outofelection, <span class="keyword">new</span> Vote(n.leader,</div><div class="line">                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state))</div><div class="line">                                &amp;&amp; checkLeader(outofelection, n.leader, IGNOREVALUE)) &#123;</div><div class="line">                            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                                logicalclock.set(n.electionEpoch);</div><div class="line">                                self.setPeerState((n.leader == self.getId()) ?</div><div class="line">                                        ServerState.LEADING: learningState());</div><div class="line">                            &#125;</div><div class="line">                            Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                            leaveInstance(endVote);</div><div class="line">                            <span class="keyword">return</span> endVote;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">default</span>:</div><div class="line">                        LOG.warn(<span class="string">"Notification state unrecoginized: "</span> + n.state</div><div class="line">                              + <span class="string">" (n.state), "</span> + n.sid + <span class="string">" (n.sid)"</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!validVoter(n.leader)) &#123;</div><div class="line">                        LOG.warn(<span class="string">"Ignoring notification for non-cluster member sid &#123;&#125; from sid &#123;&#125;"</span>, n.leader, n.sid);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!validVoter(n.sid)) &#123;</div><div class="line">                        LOG.warn(<span class="string">"Ignoring notification for sid &#123;&#125; from non-quorum member sid &#123;&#125;"</span>, n.leader, n.sid);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span>(self.jmxLeaderElectionBean != <span class="keyword">null</span>)&#123;</div><div class="line">                    MBeanRegistry.getInstance().unregister(</div><div class="line">                            self.jmxLeaderElectionBean);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOG.warn(<span class="string">"Failed to unregister with JMX"</span>, e);</div><div class="line">            &#125;</div><div class="line">            self.jmxLeaderElectionBean = <span class="keyword">null</span>;</div><div class="line">            LOG.debug(<span class="string">"Number of connection processing threads: &#123;&#125;"</span>,</div><div class="line">                    manager.getConnectionThreadCount());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="1-1sendNotifications自己的投票提议给其他server-保存需要投票的数据到sendqueue中"><a href="#1-1sendNotifications自己的投票提议给其他server-保存需要投票的数据到sendqueue中" class="headerlink" title="1.1sendNotifications自己的投票提议给其他server - 保存需要投票的数据到sendqueue中"></a>1.1sendNotifications自己的投票提议给其他server - 保存需要投票的数据到sendqueue中</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Send notifications to all peers upon a change in our vote</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNotifications</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (QuorumServer server : self.getVotingView().values()) &#123;</div><div class="line">        <span class="keyword">long</span> sid = server.id;</div><div class="line"></div><div class="line">        ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</div><div class="line">                proposedLeader,<span class="comment">//当前server的myid</span></div><div class="line">                proposedZxid,<span class="comment">//当前server的zxid</span></div><div class="line">                logicalclock.get(),<span class="comment">//epoch,当前发起提议的epoch</span></div><div class="line">                QuorumPeer.ServerState.LOOKING,<span class="comment">//当前server的状态，肯定looking，因为是选举</span></div><div class="line">                sid,<span class="comment">//当前server的zxid</span></div><div class="line">                proposedEpoch);<span class="comment">//当前票据的epoch，默认是currentEpoch。有可能这个跟上面的 logicalclock.get()获取的值不同。假设当前服务器是刚启动的，那么logicalclock是刚初始化，则 logicalclock.get()等于1。可能服务器砸启动之前就已经参加过几轮的选举，假设currentepoch的值是4.那么此时就不一样。</span></div><div class="line">        <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">            LOG.debug(<span class="string">"Sending Notification: "</span> + proposedLeader + <span class="string">" (n.leader), 0x"</span>  +</div><div class="line">                  Long.toHexString(proposedZxid) + <span class="string">" (n.zxid), 0x"</span> + Long.toHexString(logicalclock.get())  +</div><div class="line">                  <span class="string">" (n.round), "</span> + sid + <span class="string">" (recipient), "</span> + self.getId() +</div><div class="line">                  <span class="string">" (myid), 0x"</span> + Long.toHexString(proposedEpoch) + <span class="string">" (n.peerEpoch)"</span>);</div><div class="line">        &#125;</div><div class="line">        sendqueue.offer(notmsg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    最后把消息放到LinkedBlockingQueue<tosend> sendqueue; 中。<strong>但是什么时候发送呢？</strong>看到阻塞队列我们肯定想到生产者和消费者模式，那么也就是说，肯定有一个线程在实时的去读取sendqueue中的队列，然后进行发送。</tosend></p>
<p>​    <strong>在那里取得sendqueue中自己的票据进行发送呢？</strong> 答案是：<strong>WorkerSender线程。</strong></p>
<p>​     <strong>是在startLeaderElection()方法中创建的listener中创建的WorkerSender线程。在那个时候，WorkerSender线程已经启动，并开始执行从sendqueue队列中取出自己要发给其他服务器的票据。</strong></p>
<p>​    那么代码的执行逻辑走到 – &gt; sendNotifications（）方法之后，也就是上面的run方法（）的 sendNotifications（）方法之后。</p>
<h4 id="1-2处理接受到其他服务端的投票数据-确定最终leader"><a href="#1-2处理接受到其他服务端的投票数据-确定最终leader" class="headerlink" title="1.2处理接受到其他服务端的投票数据 - 确定最终leader"></a>1.2处理接受到其他服务端的投票数据 - 确定最终leader</h4><p>​    首先我们要知道收到的投票数据，是放在recvQueue中的。</p>
<p>​    那么recvQueue中的数据，是打哪儿来的？是在startLeaderElection()方法中创建的listener中创建的RecvWorker线程接受后放进去的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">        <span class="comment">//如果还是是looking状态，我们会一直去和其他节点交互信息，直到选举出leader</span></div><div class="line"><span class="comment">//while循环知道直到确定leader</span></div><div class="line">        <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</div><div class="line">                (!stop))&#123;</div><div class="line">    </div><div class="line">            <span class="comment">//从接收队列中拿到投票信息，拿到其他server的投票信息。</span></div><div class="line">            <span class="comment">//疑问？？</span></div><div class="line">            <span class="comment">//recvQueue中的是数据是哪里来的呢？我们还记得在startLeaderElection()方法中创建的listener中创建的RecvWorker线程么？</span></div><div class="line">            <span class="comment">//就是通过这个线程去接受其他服务端的投票，然后放到recvQueue中。</span></div><div class="line">            Notification n = recvqueue.poll(notTimeout,</div><div class="line">                    TimeUnit.MILLISECONDS);</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(n == <span class="keyword">null</span>)&#123;<span class="comment">//这里为空，说明，目前没有收到其他服务器发送过来的投票数据</span></div><div class="line">                <span class="keyword">if</span>(manager.haveDelivered())&#123;  <span class="comment">//检查所有的队列是否为空</span></div><div class="line">                    sendNotifications();        <span class="comment">//如果为空发送通知</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    manager.connectAll();  <span class="comment">//如果没有投递出去，可能是其他server还没有启动，尝试连接</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">/*</span></div><div class="line"><span class="comment">                 * Exponential backoff</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keyword">int</span> tmpTimeOut = notTimeout*<span class="number">2</span>;</div><div class="line">                notTimeout = (tmpTimeOut &lt; maxNotificationInterval?</div><div class="line">                        tmpTimeOut : maxNotificationInterval);</div><div class="line">                LOG.info(<span class="string">"Notification time out: "</span> + notTimeout);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//判断收到的投票的sid,</span></div><div class="line">            <span class="comment">//这里判断的是收到的sid是不是属于当前集群内的</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123;</div><div class="line">  </div><div class="line">                <span class="keyword">switch</span> (n.state) &#123;<span class="comment">//判断当前票据状态状态 - 因为是选举阶段，那么票据肯定是LOOKING状态</span></div><div class="line">                <span class="keyword">case</span> LOOKING:</div><div class="line">               </div><div class="line">                    <span class="comment">//收到其他服务的投票的epoch是不是比当前选举的epoch要大，如果大那么代表是新一轮选举</span></div><div class="line">                    <span class="comment">//那就说明，自己现在的投票轮数不是最新的，那么需要更新为最新，然后再参与投票。例如别人都已经是第三轮投票了，你现在还是第二轮。</span></div><div class="line">                    <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;</div><div class="line">                        logicalclock.set(n.electionEpoch);  <span class="comment">//更新自己的epoch为当前最新的epoch</span></div><div class="line">                        recvset.clear();  <span class="comment">//清空收到的投票</span></div><div class="line">                        <span class="comment">//进行投票</span></div><div class="line"></div><div class="line">                        <span class="comment">/*</span></div><div class="line"><span class="comment">                        totalOrderPredicate方法逻辑</span></div><div class="line"><span class="comment">                    </span></div><div class="line"><span class="comment">                         * 1.收到的epoch大于当前的epoch 胜出选举</span></div><div class="line"><span class="comment">                         * 2.如果收到的epoch等于当前epoch,那么收到的zxid大于当前zxid胜出选举</span></div><div class="line"><span class="comment">                         * 3.如果收到的epoch等于当前epoch，zxid等于当前zxid,</span></div><div class="line"><span class="comment">                         * 4.那么收到的myid大于当前myid的胜出选举</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</div><div class="line">                            <span class="comment">//Proposal默认就是当前服务器的myid、zxid、epoche。</span></div><div class="line">                            <span class="comment">//但是如果跟其他服务器发送过来的票据相比，比对没有胜出，那么就说明，我不能当选leader，胜出的票据代表的服务获得当选leader的机会，那么我就要自己放弃对自己的投票，投那台服务器一票</span></div><div class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch); <span class="comment">//把胜出的消息更新到投票提议中</span></div><div class="line">                        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果收到消息没有胜出，那么选择当前的消息（有可能是自己的，也有可能是上一次比对胜出的）更新到投票提议中</span></div><div class="line">                            updateProposal(getInitId(),</div><div class="line">                                    getInitLastLoggedZxid(),</div><div class="line">                                    getPeerEpoch());</div><div class="line">                        &#125;<span class="comment">//也就是说这段代码的作用就是，决定自己要给谁投一票。也有可能是给自己投一票。</span></div><div class="line">                        sendNotifications();  <span class="comment">//发送最新的投票消息，开始下一次循环的判断</span></div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;  <span class="comment">//如果收到的逻辑时钟（epoch）小，那么表示这个投票无效。</span></div><div class="line">                        <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">                            LOG.debug(<span class="string">"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x"</span></div><div class="line">                                    + Long.toHexString(n.electionEpoch)</div><div class="line">                                    + <span class="string">", logicalclock=0x"</span> + Long.toHexString(logicalclock.get()));</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                        <span class="comment">//如果收到的逻辑时钟epoch相等，则去对比myid 、zxid、epoch</span></div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                            proposedLeader, proposedZxid, proposedEpoch)) &#123;</div><div class="line">                        updateProposal(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                        sendNotifications();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">                        LOG.debug(<span class="string">"Adding vote: from="</span> + n.sid +</div><div class="line">                                <span class="string">", proposed leader="</span> + n.leader +</div><div class="line">                                <span class="string">", proposed zxid=0x"</span> + Long.toHexString(n.zxid) +</div><div class="line">                                <span class="string">", proposed election epoch=0x"</span> + Long.toHexString(n.electionEpoch));</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">//把对方发送过来的票据存到本地，用来做最终判断</span></div><div class="line">                    recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</div><div class="line"></div><div class="line">                    <span class="comment">//判断选举是否结束，默认算法过半同意 - 最终判断</span></div><div class="line">                    <span class="keyword">if</span> (termPredicate(recvset,</div><div class="line">                            <span class="keyword">new</span> Vote(proposedLeader, proposedZxid,</div><div class="line">                                    logicalclock.get(), proposedEpoch))) &#123;</div><div class="line"></div><div class="line">                        <span class="comment">// Verify if there is any change in the proposed leader</span></div><div class="line">                        <span class="keyword">while</span>((n = recvqueue.poll(finalizeWait,</div><div class="line">                                TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>)&#123;</div><div class="line">                            <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                    proposedLeader, proposedZxid, proposedEpoch))&#123;</div><div class="line">                                recvqueue.put(n);<span class="comment">//获得最新的记过</span></div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="comment">/*</span></div><div class="line"><span class="comment">                         * This predicate is true once we don't read any new</span></div><div class="line"><span class="comment">                         * relevant message from the reception queue</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</div><div class="line">                            self.setPeerState((proposedLeader == self.getId()) ?</div><div class="line">                                    ServerState.LEADING: learningState());</div><div class="line"></div><div class="line">                            Vote endVote = <span class="keyword">new</span> Vote(proposedLeader,</div><div class="line">                                    proposedZxid, proposedEpoch);</div><div class="line">                            leaveInstance(endVote);</div><div class="line">                            <span class="keyword">return</span> endVote;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> OBSERVING:  <span class="comment">//如果是</span></div><div class="line">                    LOG.debug(<span class="string">"Notification from observer: "</span> + n.sid);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> FOLLOWING:</div><div class="line">                <span class="keyword">case</span> LEADING:</div><div class="line">                    <span class="comment">/*</span></div><div class="line"><span class="comment">                     * Consider all notifications from the same epoch</span></div><div class="line"><span class="comment">                     * together.</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">                    <span class="keyword">if</span>(n.electionEpoch == logicalclock.get())&#123;</div><div class="line">                        recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</div><div class="line">                        <span class="keyword">if</span>(termPredicate(recvset, <span class="keyword">new</span> Vote(n.leader,</div><div class="line">                                        n.zxid, n.electionEpoch, n.peerEpoch, n.state))</div><div class="line">                                        &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</div><div class="line">                            self.setPeerState((n.leader == self.getId()) ?</div><div class="line">                                    ServerState.LEADING: learningState());</div><div class="line"></div><div class="line">                            Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                            leaveInstance(endVote);</div><div class="line">                            <span class="keyword">return</span> endVote;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">         </div><div class="line">                    outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.leader, </div><div class="line">                            IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));</div><div class="line">                    <span class="keyword">if</span> (termPredicate(outofelection, <span class="keyword">new</span> Vote(n.leader,</div><div class="line">                            IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state))</div><div class="line">                            &amp;&amp; checkLeader(outofelection, n.leader, IGNOREVALUE)) &#123;</div><div class="line">                        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                            logicalclock.set(n.electionEpoch);</div><div class="line">                            self.setPeerState((n.leader == self.getId()) ?</div><div class="line">                                    ServerState.LEADING: learningState());</div><div class="line">                        &#125;</div><div class="line">                        Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                        leaveInstance(endVote);</div><div class="line">                        <span class="keyword">return</span> endVote;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    LOG.warn(<span class="string">"Notification state unrecoginized: "</span> + n.state</div><div class="line">                          + <span class="string">" (n.state), "</span> + n.sid + <span class="string">" (n.sid)"</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!validVoter(n.leader)) &#123;</div><div class="line">                    LOG.warn(<span class="string">"Ignoring notification for non-cluster member sid &#123;&#125; from sid &#123;&#125;"</span>, n.leader, n.sid);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!validVoter(n.sid)) &#123;</div><div class="line">                    LOG.warn(<span class="string">"Ignoring notification for sid &#123;&#125; from non-quorum member sid &#123;&#125;"</span>, n.leader, n.sid);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>通过上面的决策，我们就可以得出leader是那台服务器。</p>
<p>参考：<a href="https://blog.csdn.net/u010994966/article/details/95937323" target="_blank" rel="external">https://blog.csdn.net/u010994966/article/details/95937323</a></p>
<h3 id="如果集群中，某台server挂掉，那么怎么重新进行选举？"><a href="#如果集群中，某台server挂掉，那么怎么重新进行选举？" class="headerlink" title="如果集群中，某台server挂掉，那么怎么重新进行选举？"></a>如果集群中，某台server挂掉，那么怎么重新进行选举？</h3><p>org.apache.zookeeper.server.quorum.QuorumPeer.run()</p>
<p>首先挂掉，分两种情况：follower挂掉、leader挂掉。</p>
<p>​    首先，如果是leader挂掉怎么重新选举？把自己状态设置为loking，重新选举。此时follower同步leader数据会报异常。</p>
<p>​    如果是follower挂掉，怎么判断是否需要选举? leader会循环去判断，去ping所有的follower，判断是否有超过半数的follower已经ping不通，如果是，就会shutdown自己，然后把自己状态设置为loking，重新选举。</p>
<h3 id="新加入的服务器怎么进行选举？怎么知道哪台是leader"><a href="#新加入的服务器怎么进行选举？怎么知道哪台是leader" class="headerlink" title="新加入的服务器怎么进行选举？怎么知道哪台是leader"></a>新加入的服务器怎么进行选举？怎么知道哪台是leader</h3><p>我们知道新机器的状态肯定是looking。</p>
<p>首先，如果在加入之前，集群中已经选出了leader，那么还是会走投票流程，然后确定leader（并不是重新选举，此时的投票只是为了让新加入的机器，确认哪台是leader）</p>
<h3 id="leader选举总结"><a href="#leader选举总结" class="headerlink" title="leader选举总结"></a>leader选举总结</h3><p>​    在选举过程中，每台机器都会相互发送一个投票数据（Vote<myid，zxid，epoch>），如果是首轮leader 选举，那么epoch是1，每次投票epoch都会自增1.</myid，zxid，epoch></p>
<p>​    怎么决定哪个server当leader 呢？会根据vote的三个参数进行判断。</p>
<p>​        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1.首先比较epoch：</div><div class="line">	收到的epoch大于当前的epoch 胜出选举</div><div class="line">2.epoch相等比较zxid：数据最新者胜出</div><div class="line">	如果收到的epoch等于当前epoch,那么收到的zxid大于当前zxid胜出选举</div><div class="line">3.zxid相等，比较myid：</div><div class="line">	如果收到的epoch等于当前epoch，zxid等于当前zxid,</div><div class="line">	那么收到的myid大于当前myid的胜出选举</div></pre></td></tr></table></figure>
<p>​    举个例子，假设集群中有三台机器，那么需要至少启动两台才能够完成leader选举。这里为了方便说明，我就假设只启动两台，来看他们是怎么投票的。</p>
<p>​    </p>
<table>
<thead>
<tr>
<th>server<myid,zxid,epoch></myid,zxid,epoch></th>
<th>是否启动</th>
</tr>
</thead>
<tbody>
<tr>
<td>a<1,1,1></1,1,1></td>
<td>是</td>
</tr>
<tr>
<td>b<2,1,1></2,1,1></td>
<td>是</td>
</tr>
<tr>
<td>c<3,1,1></3,1,1></td>
<td>否</td>
</tr>
</tbody>
</table>
<p>​    因为是新集群，所以他们的数据都是一致的，所以zxid都是1。因为是第一轮投票，所以epoch是1.</p>
<p>​    a服务器启动，因为是LOOKING状态，那么就需要走选举leader流程，那么<strong>默认投自己一票</strong>，给其他server发送投票信息 <strong>vote<1,1,1></1,1,1></strong>，并监听其他服务器发送给自己的投票信息。</p>
<p>​    b服务器启动，因为是LOOKING状态，那么就需要走选举leader流程，那么<strong>默认投自己一票</strong>，给其他server发送投票信息 <strong>vote<2,1,1></2,1,1></strong>，并监听其他服务器发送给自己的投票信息。此时收到a服务器的投票信息<strong>vote<1,1,1></1,1,1></strong>，开始比较投票的信息，<strong>此时一共有两个投票</strong>。那么因为epoch和zxid都是相等的，那么myid大的获胜，此时b服务胜出。所以b服务器丢弃a服务器的投票信息，还是投自己一票。给其他server发送投票信息 <strong>vote<2,1,1></2,1,1></strong>。<strong>b服务器第一轮投票结束。</strong>开始第二轮</p>
<p>  a服务器此时收到b服务器的投票信息<strong>vote<2,1,1></2,1,1></strong>，开始比较投票的信息，<strong>此时一共有两个投票</strong>。那么因为epoch和zxid都是相等的，那么myid大的获胜，此时b服务胜出。所以<strong>a服务器丢弃自己服务器的投票信息</strong>，改投b服务器一票。给其他server发送投票信息 <strong>vote<2,1,1></2,1,1></strong>。<strong>a服务器第一轮投票结束。</strong>开始第二轮</p>
<p><strong>接着进行第二轮投票，此时epoch递增为2。</strong></p>
<p>​    同理a服务器向b发送投票信息。<strong>vote<2,1,1></2,1,1></strong>，那么b服务器收到之后，检测，发现对于<strong>自己的被选的票数已经大于半数</strong>，所以b服务器升级为leader。</p>
<p>​    a服务器收到的b服务器发送的投票信息，<strong>vote<2,1,1></2,1,1></strong>，检测，发现对于<strong>b服务器被选的票数已经大于半数</strong>，所以确定b服务器升级为leader。，那么a服务器设置为follower。</p>
<p> 接着开始同步集群数据，所有learner都向leader同步数据。（<strong>此时集群还没有启动，还不能接受客户端请求</strong>）</p>
<p><strong>数据同步成功后，所有服务器，各自调用zkserver.start（）启动服务。开始接受处理客户端的请求。</strong></p>
<p>整个流程图：</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200413205835549.png" alt="image-20200413205835549"></p>
<h2 id="怎么保证数据一致性（已经确定leader）"><a href="#怎么保证数据一致性（已经确定leader）" class="headerlink" title="怎么保证数据一致性（已经确定leader）"></a>怎么保证数据一致性（已经确定leader）</h2><p><strong>首先我们要明确一点，那就是此时，整个集群各台服务器的角色已经确定好了。接下来就是learner和leader数据同步</strong></p>
<p>看到这个问题，我们首先考虑一下，什么时候会发生数据不一致？</p>
<ul>
<li>一台新服务器加入集群。这台服务器是没有数据的。</li>
<li>原先存在集群中的服务器，突然挂掉了。数据不是最新的</li>
<li>原先存在集群中的服务器，正在写数据（事务日志已经写了），突然挂掉了。数据不是最新的</li>
</ul>
<p>​    <strong>上面这三种情况，在重启服务器后，都会向leader请求同步数据，保持数据一致性，在这期间，他们不接受任何请求。（刚启动的服务器，状态都是LOOKING，然后发起投票，从而获得现在哪台是leader，然后跟leader同步数据 –  注意这里的投票并不是重新选举leader，而是让重启的服务器确定哪台是leader）</strong></p>
<h3 id="执行loadDataBase加载本地快照数据到内存"><a href="#执行loadDataBase加载本地快照数据到内存" class="headerlink" title="执行loadDataBase加载本地快照数据到内存"></a>执行loadDataBase加载本地快照数据到内存</h3><p>实际上就是通过 <code>loadDataBase();</code> 进行再服务器启动的时候，通过日志快照重放数据到内存。</p>
<p>我们知道服务器启动的时候，会启动线程：<strong>quorumPeer.start()</strong> 它里面的代码就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    loadDataBase();<span class="comment">//加载快照数据到内存，重点讲</span></div><div class="line">    cnxnFactory.start();      <span class="comment">//  </span></div><div class="line">    startLeaderElection();</div><div class="line">    <span class="keyword">super</span>.start();<span class="comment">//重点讲 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着调用 zkDb.loadDataBase();</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">loadDataBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">long</span> zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);</div><div class="line">    initialized = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> zxid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * this function restores the server </span></div><div class="line"><span class="comment"> * database after reading from the </span></div><div class="line"><span class="comment"> * snapshots and transaction logs</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> dt the datatree to be restored</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> sessions the sessions to be restored</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> listener the playback listener to run on the </span></div><div class="line"><span class="comment"> * database restoration</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> the highest zxid restored</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">restore</span><span class="params">(DataTree dt, Map&lt;Long, Integer&gt; sessions, </span></span></div><div class="line"><span class="function"><span class="params">        PlayBackListener listener)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    snapLog.deserialize(dt, sessions);</div><div class="line">    <span class="keyword">return</span> fastForwardFromEdits(dt, sessions, listener);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>调用fastForwardFromEdits()重放日志快照数据到内存</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fastForwardFromEdits</span><span class="params">(DataTree dt, Map&lt;Long, Integer&gt; sessions,</span></span></div><div class="line"><span class="function"><span class="params">                                 PlayBackListener listener)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    FileTxnLog txnLog = <span class="keyword">new</span> FileTxnLog(dataDir);<span class="comment">//获取快照日志</span></div><div class="line">    TxnIterator itr = txnLog.read(dt.lastProcessedZxid+<span class="number">1</span>);<span class="comment">//从最新一次事务</span></div><div class="line">    <span class="keyword">long</span> highestZxid = dt.lastProcessedZxid;</div><div class="line">    TxnHeader hdr;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">// iterator points to </span></div><div class="line">            <span class="comment">// the first valid txn when initialized</span></div><div class="line">            hdr = itr.getHeader();</div><div class="line">            <span class="keyword">if</span> (hdr == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//empty logs </span></div><div class="line">                <span class="keyword">return</span> dt.lastProcessedZxid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (hdr.getZxid() &lt; highestZxid &amp;&amp; highestZxid != <span class="number">0</span>) &#123;</div><div class="line">                LOG.error(<span class="string">"&#123;&#125;(higestZxid) &gt; &#123;&#125;(next log) for type &#123;&#125;"</span>,</div><div class="line">                        <span class="keyword">new</span> Object[] &#123; highestZxid, hdr.getZxid(),</div><div class="line">                                hdr.getType() &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                highestZxid = hdr.getZxid();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                processTransaction(hdr,dt,sessions, itr.getTxn());<span class="comment">//更新数据到内存中</span></div><div class="line">            &#125; <span class="keyword">catch</span>(KeeperException.NoNodeException e) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to process transaction type: "</span> +</div><div class="line">                     hdr.getType() + <span class="string">" error: "</span> + e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">            listener.onTxnLoaded(hdr, itr.getTxn());</div><div class="line">            <span class="keyword">if</span> (!itr.next()) </div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (itr != <span class="keyword">null</span>) &#123;</div><div class="line">            itr.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> highestZxid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="启动quorumPeer线程执行run方法"><a href="#启动quorumPeer线程执行run方法" class="headerlink" title="启动quorumPeer线程执行run方法"></a>启动quorumPeer线程执行run方法</h3><p>​    通过上面的领导选举学习，我们知道QuorumPeer的run方法，核心的内容包括，<strong>领导选举。</strong>首先根据启动服务器的状态（LOOKING, FOLLOWING, LEADING, OBSERVING;）走相应的逻辑。</p>
<p><strong>那么只有确定了leader，我们才能够往下了解follower/observer跟leader的通信过程。</strong></p>
<p>通信的目的，<strong>就是为了实时同步leader的最新数据。</strong>  <strong>不然上面的loadDataBase只是加载本地的快照信息，可能不是目前集群中最新的数据</strong></p>
<h4 id="leader为每一个learner开启线程接受请求。"><a href="#leader为每一个learner开启线程接受请求。" class="headerlink" title="leader为每一个learner开启线程接受请求。"></a>leader为每一个learner开启线程接受请求。</h4><p>​    假设通过领导选举成功，当前服务器是leader，那么他就会执行。<strong>QuorumPeer的run方法的LEADER代码块。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> LEADING:</div><div class="line">    LOG.info(<span class="string">"LEADING"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        setLeader(makeLeader(logFactory));</div><div class="line">        leader.lead();<span class="comment">//执行lead方法</span></div><div class="line">        setLeader(<span class="keyword">null</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        LOG.warn(<span class="string">"Unexpected exception"</span>,e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (leader != <span class="keyword">null</span>) &#123;</div><div class="line">            leader.shutdown(<span class="string">"Forcing shutdown"</span>);</div><div class="line">            setLeader(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        setPeerState(ServerState.LOOKING);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>lead()方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lead</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">           。。。。。</div><div class="line">        <span class="comment">// Start thread that waits for connection requests from </span></div><div class="line">        <span class="comment">// new followers.</span></div><div class="line">        cnxAcceptor = <span class="keyword">new</span> LearnerCnxAcceptor();<span class="comment">//为每一个learner开启一个处理线程</span></div><div class="line">        cnxAcceptor.start();<span class="comment">//启动LearnerCnxAcceptor线程</span></div><div class="line">        。。。。。。忽略部分代码</div></pre></td></tr></table></figure>
<p><strong>（1）LearnerCnxAcceptor的run方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (!stop) &#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                Socket s = ss.accept();<span class="comment">//阻塞等待learner的连接，这里使用的是bio的方式</span></div><div class="line">                <span class="comment">// start with the initLimit, once the ack is processed</span></div><div class="line">                <span class="comment">// in LearnerHandler switch to the syncLimit</span></div><div class="line">                s.setSoTimeout(self.tickTime * self.initLimit);</div><div class="line">                s.setTcpNoDelay(nodelay);</div><div class="line">                BufferedInputStream is = <span class="keyword">new</span> BufferedInputStream(</div><div class="line">                        s.getInputStream());</div><div class="line">                LearnerHandler fh = <span class="keyword">new</span> LearnerHandler(s, is, Leader.<span class="keyword">this</span>);<span class="comment">//learner连接后，新建LearnerHandler线程处理连接 - 也就是我们上面所说的，为每一个learner的请求创建一个单独的线程处理</span></div><div class="line">                fh.start();</div></pre></td></tr></table></figure>
<p><strong>（2）查看LearnerHandler的run方法</strong></p>
<h4 id="learner请求leader"><a href="#learner请求leader" class="headerlink" title="learner请求leader"></a>learner请求leader</h4><p>同理，当前服务器如果是follower或者observer，那么也会走。<strong>QuorumPeer的run方法的follower/observer代码块。</strong></p>
<p>实际上，observer的代码块跟follower的代码块执行的逻辑差不多，那么我们这里只看一下follower的代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> FOLLOWING:</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        LOG.info(<span class="string">"FOLLOWING"</span>);</div><div class="line">        setFollower(makeFollower(logFactory));</div><div class="line">        follower.followLeader();<span class="comment">//关键代码</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        LOG.warn(<span class="string">"Unexpected exception"</span>,e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        follower.shutdown();</div><div class="line">        setFollower(<span class="keyword">null</span>);</div><div class="line">        setPeerState(ServerState.LOOKING);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>follower.followLeader()请求leader</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    。。。。。。</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        QuorumServer leaderServer = findLeader();<span class="comment">//首先找到leander相关的信息，方便后面创建连接    </span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectToLeader(leaderServer.addr, leaderServer.hostname);<span class="comment">//建立跟leader的连接</span></div><div class="line">            <span class="keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);<span class="comment">//这里会向leader发送数据</span></div><div class="line">            。。。。。。。。。。。</div></pre></td></tr></table></figure>
<h4 id="开始同步数据"><a href="#开始同步数据" class="headerlink" title="开始同步数据"></a>开始同步数据</h4><p>经过上面的leader跟learner的连接和设置目前最大投票版本号，接下来就需要开始进行数据同步。</p>
<h5 id="leader怎么处理"><a href="#leader怎么处理" class="headerlink" title="leader怎么处理"></a>leader怎么处理</h5><p>首先我们知道，<strong>所有的learner的数据肯定要以leader的为主</strong>。如果learner的数据多了（事务id比leader的大），那么leader会发送消息让learner回滚数据。</p>
<p>​    那么如果learner的数据不是最新的（zxid事务id比leader小）</p>
<ul>
<li><p>​    第一种情况， learner是刚加入集群的，<strong>什么数据都没有</strong>，那么怎么同步leader的数据呢？</p>
<ul>
<li><p>首先，leader发送他自己的快照给learner，但是leader的快照可能不是最新的，因为我们知道快照是每隔一部分client的写请求就打一次，并不是每次请求都打。所以leader仅仅只是发送他自己的快照远远不够，那么我们这个时候就想，能不能发leader已经收到的所有更新请求日志呢？也一并发给learner。</p>
</li>
<li><p>那么learner一共收到两份东西，一份是：<strong>leader快照、一份是更新日志。</strong></p>
</li>
<li><p><strong>这样，learner就可以根据快照和操作日志，同步数据。</strong></p>
</li>
<li><p>疑问？那么快照我们知道在dataDir目录下，但是操作日志在哪里呢？我们还记得服务端处理client请求时经过的处理链，最后一个final处理器，他的org.apache.zookeeper.server.FinalRequestProcessor.processRequest(Request)处理方法中，有一段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">   <span class="comment">// do not add non quorum packets to the queue.</span></div><div class="line">        <span class="keyword">if</span> (Request.isQuorum(request.type)) &#123;</div><div class="line">            zks.getZKDatabase().addCommittedProposal(request);</div><div class="line">        &#125;</div><div class="line">会把所有的请求都保存到 <span class="keyword">protected</span> LinkedList&lt;Proposal&gt; committedLog = <span class="keyword">new</span> LinkedList&lt;Proposal&gt;();中。</div><div class="line">    所以committedLog就是我们需要找的更新日志</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第二种情况，learner是有数据的，但是数据不是最新的（zxid事务id比leader小）。</p>
<ul>
<li>那么这种情况，很明显就不需要发送leader快照了，我们只需要发送learner跟leader差异的部分，即可。例如learner当前zxid是20，但是leader的zxid是50，那么我们只需要从leader发送21-50的部分操作日志给learner即可。</li>
</ul>
</li>
</ul>
<p>我们接下来看同步数据代码的区域：org.apache.zookeeper.server.quorum.LearnerHandler.run()。也是在leader为每个learner分配的处理连接的线程中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">            <span class="comment">/* the default to send to the follower */</span></div><div class="line">            <span class="keyword">int</span> packetToSend = Leader.SNAP;<span class="comment">//默认传送leader快照 </span></div><div class="line">            <span class="keyword">long</span> zxidToSend = <span class="number">0</span>;</div><div class="line">            <span class="keyword">long</span> leaderLastZxid = <span class="number">0</span>;</div><div class="line">            <span class="comment">/** the packets that the follower needs to get updates from **/</span></div><div class="line">            <span class="keyword">long</span> updates = peerLastZxid;        </div><div class="line"><span class="comment">/* we are sending the diff check if we have proposals in memory to be able to </span></div><div class="line"><span class="comment">         * send a diff to the </span></div><div class="line"><span class="comment">         */</span> </div><div class="line">        ReentrantReadWriteLock lock = leader.zk.getZKDatabase().getLogLock();</div><div class="line">        ReadLock rl = lock.readLock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            rl.lock();        </div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> maxCommittedLog = leader.zk.getZKDatabase().getmaxCommittedLog();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> minCommittedLog = leader.zk.getZKDatabase().getminCommittedLog();</div><div class="line">            LOG.info(<span class="string">"Synchronizing with Follower sid: "</span> + sid</div><div class="line">                    +<span class="string">" maxCommittedLog=0x"</span>+Long.toHexString(maxCommittedLog)</div><div class="line">                    +<span class="string">" minCommittedLog=0x"</span>+Long.toHexString(minCommittedLog)</div><div class="line">                    +<span class="string">" peerLastZxid=0x"</span>+Long.toHexString(peerLastZxid));</div><div class="line"></div><div class="line">            LinkedList&lt;Proposal&gt; proposals leader.zk.getZKDatabase().getCommittedLog();<span class="comment">//可以看到会去获取final处理器中保存的已经提交的操作日志</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (peerLastZxid == leader.zk.getZKDatabase().getDataTreeLastProcessedZxid()) &#123;<span class="comment">//如果learner跟leader的事务id一致，那么说明数据一致，不需要同步</span></div><div class="line">                <span class="comment">// Follower is already sync with us, send empty diff</span></div><div class="line">                LOG.info(<span class="string">"leader and follower are in sync, zxid=0x&#123;&#125;"</span>,</div><div class="line">                        Long.toHexString(peerLastZxid));</div><div class="line">                packetToSend = Leader.DIFF;</div><div class="line">                zxidToSend = peerLastZxid;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proposals.size() != <span class="number">0</span>) &#123;<span class="comment">//说明当前服务器</span></div><div class="line">                LOG.debug(<span class="string">"proposal size is &#123;&#125;"</span>, proposals.size());</div><div class="line">                <span class="keyword">if</span> ((maxCommittedLog &gt;= peerLastZxid)</div><div class="line">                        &amp;&amp; (minCommittedLog &lt;= peerLastZxid)) &#123;</div><div class="line">                    LOG.debug(<span class="string">"Sending proposals to follower"</span>);</div><div class="line"></div><div class="line">                    <span class="comment">// as we look through proposals, this variable keeps track of previous</span></div><div class="line">                    <span class="comment">// proposal Id.</span></div><div class="line">                    <span class="keyword">long</span> prevProposalZxid = minCommittedLog;</div><div class="line"></div><div class="line">                    <span class="comment">// Keep track of whether we are about to send the first packet.</span></div><div class="line">                    <span class="comment">// Before sending the first packet, we have to tell the learner</span></div><div class="line">                    <span class="comment">// whether to expect a trunc or a diff</span></div><div class="line">                    <span class="keyword">boolean</span> firstPacket=<span class="keyword">true</span>;</div><div class="line"></div><div class="line">                    <span class="comment">// If we are here, we can use committedLog to sync with</span></div><div class="line">                    <span class="comment">// follower. Then we only need to decide whether to</span></div><div class="line">                    <span class="comment">// send trunc or not</span></div><div class="line">                    packetToSend = Leader.DIFF;</div><div class="line">                    zxidToSend = maxCommittedLog;</div><div class="line"></div><div class="line">                    <span class="keyword">for</span> (Proposal propose: proposals) &#123;</div><div class="line">                        <span class="comment">// skip the proposals the peer already has</span></div><div class="line">                        <span class="keyword">if</span> (propose.packet.getZxid() &lt;= peerLastZxid) &#123;</div><div class="line">                            prevProposalZxid = propose.packet.getZxid();</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="comment">// If we are sending the first packet, figure out whether to trunc</span></div><div class="line">                            <span class="comment">// in case the follower has some proposals that the leader doesn't</span></div><div class="line">                            <span class="keyword">if</span> (firstPacket) &#123;</div><div class="line">                                firstPacket = <span class="keyword">false</span>;</div><div class="line">                                <span class="comment">// Does the peer have some proposals that the leader hasn't seen yet</span></div><div class="line">                                <span class="keyword">if</span> (prevProposalZxid &lt; peerLastZxid) &#123;</div><div class="line">                                    <span class="comment">// send a trunc message before sending the diff</span></div><div class="line">                                    packetToSend = Leader.TRUNC;                                        </div><div class="line">                                    zxidToSend = prevProposalZxid;</div><div class="line">                                    updates = zxidToSend;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            queuePacket(propose.packet);</div><div class="line">                            QuorumPacket qcommit = <span class="keyword">new</span> QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),</div><div class="line">                                    <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                            queuePacket(qcommit);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid &gt; maxCommittedLog) &#123;<span class="comment">//如果learner的事务id大于leader的事务id，那么发送回滚删除命令给learner</span></div><div class="line">                    LOG.debug(<span class="string">"Sending TRUNC to follower zxidToSend=0x&#123;&#125; updates=0x&#123;&#125;"</span>,</div><div class="line">                            Long.toHexString(maxCommittedLog),</div><div class="line">                            Long.toHexString(updates));</div><div class="line"></div><div class="line">                    packetToSend = Leader.TRUNC;</div><div class="line">                    zxidToSend = maxCommittedLog;</div><div class="line">                    updates = zxidToSend;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    LOG.warn(<span class="string">"Unhandled proposal scenario"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// just let the state transfer happen</span></div><div class="line">                LOG.debug(<span class="string">"proposals is empty"</span>);</div><div class="line">            &#125;               </div><div class="line"></div><div class="line">            LOG.info(<span class="string">"Sending "</span> + Leader.getPacketType(packetToSend));</div><div class="line">            leaderLastZxid = leader.startForwarding(<span class="keyword">this</span>, updates);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            rl.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">。。。。。</div><div class="line">                <span class="comment">// Start sending packets</span></div><div class="line">            <span class="keyword">new</span> Thread() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    Thread.currentThread().setName(</div><div class="line">                            <span class="string">"Sender-"</span> + sock.getRemoteSocketAddress());</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        sendPackets();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        LOG.warn(<span class="string">"Unexpected interruption"</span>,e);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;.start();<span class="comment">//开始发送数据给learner</span></div></pre></td></tr></table></figure>
<p>经过上面的操作，leader把跟learner差异的数据发送给了learner，那么learner怎么处理呢？</p>
<h5 id="learner怎么处理"><a href="#learner怎么处理" class="headerlink" title="learner怎么处理"></a>learner怎么处理</h5><p>会在followLeader()方法中调用org.apache.zookeeper.server.quorum.Learner.syncWithLeader(long)。进行数据同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">根据    leader发送的qp.getType() 类型，处理相应的逻辑</div><div class="line"><span class="keyword">synchronized</span> (zk) &#123;</div><div class="line">        <span class="keyword">if</span> (qp.getType() == Leader.DIFF) &#123;</div><div class="line">            LOG.info(<span class="string">"Getting a diff from the leader 0x&#123;&#125;"</span>, Long.toHexString(qp.getZxid()));</div><div class="line">            snapshotNeeded = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (qp.getType() == Leader.SNAP) &#123;</div><div class="line">        。。。。。。</div></pre></td></tr></table></figure>
<h5 id="leader在哪里处理learner转发client的写请求？"><a href="#leader在哪里处理learner转发client的写请求？" class="headerlink" title="leader在哪里处理learner转发client的写请求？"></a>leader在哪里处理learner转发client的写请求？</h5><p>我们知道learner对于client客户端而言，如果发送更新请求，那么learner是会把写请求发送给leader进行处理的。</p>
<p>​    那么leader在哪里处理learner发送过来的更新请求呢？就在Learnerhandler的run方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> Leader.REQUEST:                    </div><div class="line">    bb = ByteBuffer.wrap(qp.getData());</div><div class="line">    sessionId = bb.getLong();</div><div class="line">    cxid = bb.getInt();</div><div class="line">    type = bb.getInt();</div><div class="line">    bb = bb.slice();</div><div class="line">    Request si;</div><div class="line">    <span class="keyword">if</span>(type == OpCode.sync)&#123;</div><div class="line">        si = <span class="keyword">new</span> LearnerSyncRequest(<span class="keyword">this</span>, sessionId, cxid, type, bb, qp.getAuthinfo());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        si = <span class="keyword">new</span> Request(<span class="keyword">null</span>, sessionId, cxid, type, bb, qp.getAuthinfo());</div><div class="line">    &#125;</div><div class="line">    si.setOwner(<span class="keyword">this</span>);</div><div class="line">    leader.zk.submitRequest(si);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<h1 id="集群模式-end"><a href="#集群模式-end" class="headerlink" title="########集群模式 end"></a>########集群模式 end</h1><h1 id="zk实现分布式锁和分布式配置中心"><a href="#zk实现分布式锁和分布式配置中心" class="headerlink" title="zk实现分布式锁和分布式配置中心"></a>zk实现分布式锁和分布式配置中心</h1><h2 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h2><p>实际上实现分布式锁的方式有两种：</p>
<ul>
<li>​    使用类似lock的规则，多个客户端同时去创建一个临时节点，创建成功者则代表他获得锁，否则就监听节点的删除操作（代表释放锁），如果节点被删除那么<strong>会通知所有客户端</strong>再去创建同样的临时节点，同理创建成功则获取锁。以此类推。<ul>
<li>那么这种方式的好处就是实现非常简单，但是坏处就是容易发生惊群效应。锁被释放时，都会去通知所有监听该节点的客户端，然后所有客户端同时请求zk创建节点以求获取锁。那么这样对于zk而言就会造成没有必要的请求（虽然zk服务端也会把请求放到队列中一个一个的处理的，但是能够处理成功的也就只有一个，后面的创建节点都会失败。）</li>
</ul>
</li>
<li>多个客户端同时创建多个临时顺序节点，序号最小的获取锁。然后次小的序号监听当前序号的释放。以此类推。那么只要锁被释放那么监听该节点的客户端 收到事件然后获取锁。<ul>
<li>这样就解决了第一种实现方式的弊端。使用这种方式，每次都只通知比他序号小的那个节点获取锁。不用通知所有客户端。</li>
<li>他的思路就相当于juc包里面，lock或者synchronized的实现，每次都尝试获取锁–也就是判断自己创建的节点是不是序号最小的（类似于Lock的trylock方法），如果不是那么就监听比他小的那个节点的释放（类似于Lock的，tryLock失败后，那么阻塞，加入aqs阻塞队列等待唤醒）（而且在juc中每次都会从aqs阻塞队列中获取队列首节点获取锁类似于zk 的当前节点被删除后，那么就通知他的后一个节点获取锁）</li>
<li>也就是说，这种方式的实现，类似于Lock公平锁模式的实现。</li>
</ul>
</li>
</ul>
<p><strong>zk 的什么特性保证了分布式锁的实现呢：</strong></p>
<ul>
<li><p>​    监听机制</p>
</li>
<li><p>​    相同目录下节点名称不能相同</p>
</li>
<li><p>​    临时顺序节点</p>
</li>
<li><p>​    关于更新请求统一逐个交由leader进行处理，其他learner只能读不能处理写请求。</p>
</li>
<li>​    数据的顺序一致性</li>
</ul>
<p>​    <strong>下面就粗略的实现了分布式锁的代码，但是并没有保证线程安全。只是个参考，重要的是实现的思路，因为在真是开发中，我们肯定使用的是已经封装好的，一般不会自己写。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.zookeeper.kingge;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.EventType;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</div><div class="line"><span class="comment">//可以看到整体的思路是模仿了juc中Lock的实现。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKLock</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> String connectString = <span class="string">"localhost:2181,localhost:2182"</span>;<span class="comment">//zk集群地址</span></div><div class="line">	<span class="keyword">private</span> ZooKeeper client = <span class="keyword">null</span>;<span class="comment">//zk客户端</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String  PARENT_PATH = <span class="string">"/lock"</span>;<span class="comment">//我们在这个节点下面创建临时顺序节点</span></div><div class="line">	</div><div class="line">	<span class="keyword">private</span>  String createNodeName;<span class="comment">//创建节点名称</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">initZKClient</span><span class="params">()</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>( client == <span class="keyword">null</span> )</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				client = <span class="keyword">new</span> ZooKeeper(connectString, <span class="number">2000</span>, <span class="keyword">new</span> Watcher() &#123;</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">						System.out.println( <span class="string">"zk默认监听器收到事件："</span>+ event  );</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">				Stat exists = client.exists(PARENT_PATH, <span class="keyword">false</span>);</div><div class="line">				<span class="keyword">if</span>( exists == <span class="keyword">null</span> ) &#123;<span class="comment">//说明父节点不存在，则需要创建</span></div><div class="line">					client.create(PARENT_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], </div><div class="line">							ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(tryLock()) &#123;</div><div class="line">			System.out.println( <span class="string">"成功获取锁"</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</div><div class="line">		String nodeName =  PARENT_PATH+<span class="string">"/zk_"</span>;<span class="comment">//创建子节点路径</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//创建节点</span></div><div class="line">			 createNodeName = client.create(nodeName, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], </div><div class="line">					ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<span class="comment">//这里返回的是创建节点的全路径，例如/lock/zk_0</span></div><div class="line">			<span class="comment">//判断当前节点是否是最小节点</span></div><div class="line">			List&lt;String&gt; children = client.getChildren(PARENT_PATH, <span class="keyword">false</span>);<span class="comment">//这里返回的节点类型是 zk_0,zk_1,zk_2</span></div><div class="line">			Collections.sort(children);</div><div class="line">			String minNodeName = children.get(<span class="number">0</span>);<span class="comment">//获得最小的节点名称</span></div><div class="line">			<span class="comment">//比较节点</span></div><div class="line">			<span class="keyword">if</span>( createNodeName.equals(PARENT_PATH+<span class="string">"/"</span>+minNodeName) ) &#123;</div><div class="line">				System.out.println(  createNodeName +<span class="string">" 是最小节点，成功获取锁"</span> );</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//说明当前创建的节点是最小节点，那么获取锁</span></div><div class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//否则，监听比他小的节点</span></div><div class="line">				<span class="comment">//获取当前节点在children中下标位置</span></div><div class="line">				String substring = createNodeName.substring(createNodeName.lastIndexOf(<span class="string">"/"</span>)+<span class="number">1</span>);<span class="comment">//实际上就是截取出类似于，zk_0这样的字符串</span></div><div class="line">				<span class="keyword">int</span> indexOf = children.indexOf(substring);</div><div class="line">				<span class="comment">//获取他前一个节点</span></div><div class="line">				String preNode = children.get(indexOf-<span class="number">1</span>);</div><div class="line">				<span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">				<span class="comment">//然后监听该节点是否存在</span></div><div class="line">				client.exists(PARENT_PATH+<span class="string">"/"</span>+preNode, <span class="keyword">new</span> Watcher() &#123;</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">						<span class="keyword">if</span>( Event.EventType.NodeDeleted.equals(event.getType()) ) &#123;<span class="comment">//节点删除，那么说明当前节点可以获取锁</span></div><div class="line">							System.out.println( createNodeName + <span class="string">"，开始获取锁"</span> );</div><div class="line">							countDownLatch.countDown();</div><div class="line">						&#125;  </div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">				System.out.println(  createNodeName +<span class="string">"，节点等待锁中。。。"</span> );</div><div class="line">				countDownLatch.await();<span class="comment">//阻塞等待，当前节点获取锁。不阻塞的话当前方法执行完毕就直接返回了，上面监听判断获取锁的代码就不会生效了。</span></div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125; </div><div class="line">			</div><div class="line">		&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//其实这一步不用实现，因为临时节点，断开连接后自动会删除节点。但是为了代码逻辑的完整性，这里还是手动删除一下节点</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			client.delete(createNodeName, -<span class="number">1</span>);<span class="comment">//这里的-1是版本号，表示在删除节点的时候不需要检查版本号。因为zk在进行删除操作的时候</span></div><div class="line">			<span class="comment">//会检查客户端发送过来的版本号跟服务端节点的版本号是否一致，如果是才能删除，否则删除失败。</span></div><div class="line">			createNodeName = <span class="string">""</span>;</div><div class="line">			client.close();</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ZKLock zkLock = <span class="keyword">new</span> ZKLock();</div><div class="line">		zkLock.initZKClient();</div><div class="line">		zkLock.tryLock();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h2><p>​    目的就是，统一管理所有服务器的配置信息，这样我们只需要在配置中心修改后，所有服务器自动同步修改后的配置信息。（是不是马上就想到了监听）</p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.zookeeper.kingge;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCache;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.RetryNTimes;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConfig</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String connectString = <span class="string">"localhost:2181,localhost:2182"</span>;<span class="comment">//zk集群地址</span></div><div class="line">	<span class="keyword">private</span> Map&lt;String,String&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//配置信息的缓存</span></div><div class="line">	<span class="keyword">private</span> CuratorFramework client;<span class="comment">//这里使用的是curator框架创建zk客户端</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String  PARENT_PATH = <span class="string">"/config"</span>;<span class="comment">//存放配置信息的根节点</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.client = CuratorFrameworkFactory.newClient(connectString, <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">1000</span>));</div><div class="line">		client.start();</div><div class="line">		</div><div class="line">		init();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//初始化所有配置项的信息到本地缓存</span></div><div class="line">			List&lt;String&gt; forPath = client.getChildren().forPath(PARENT_PATH);</div><div class="line">			 <span class="keyword">for</span> (String name : forPath) &#123;</div><div class="line">				 <span class="comment">//根据路径获取，每个节点的配置信息</span></div><div class="line">				String value = <span class="keyword">new</span> String( client.getData().forPath(PARENT_PATH + <span class="string">"/"</span> + name) );</div><div class="line">				cache.put(name, value);</div><div class="line">			&#125;</div><div class="line">			 </div><div class="line">			 <span class="comment">//同时监听在PARENT_PATH目录下面所有孩子的</span></div><div class="line">			 <span class="comment">//新增，删除，修改操作。如果发生了以上三个事件，那么就需要在监听器中同步更新cache配置信息</span></div><div class="line">			 PathChildrenCache watcher = <span class="keyword">new</span> PathChildrenCache(client, PARENT_PATH, <span class="keyword">true</span>);</div><div class="line">			 watcher.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">					</div><div class="line">					String path = event.getData().getPath();<span class="comment">//获得节点的全路径 例如/config/zk1</span></div><div class="line">					<span class="keyword">if</span>( path.startsWith(PARENT_PATH) ) &#123;<span class="comment">//表示如果事件是发生在PARENT_PATH下面的节点之上，才会执行下面逻辑。</span></div><div class="line">							String key = path.replace(PARENT_PATH+<span class="string">"/"</span>, <span class="string">""</span>);<span class="comment">//也就是抽取出节点的后缀路径 -- /config/zk1 ---》 zk1</span></div><div class="line">							<span class="keyword">if</span>( PathChildrenCacheEvent.Type.CHILD_ADDED.equals(event.getType()) ) &#123;<span class="comment">//新增了子节点</span></div><div class="line">								System.out.println( <span class="string">"触发了 CHILD_ADDED 事件"</span> );</div><div class="line">								cache.put(key, <span class="keyword">new</span> String(event.getData().getData()));</div><div class="line">							&#125;</div><div class="line">							<span class="keyword">if</span>( PathChildrenCacheEvent.Type.CHILD_UPDATED.equals(event.getType()) ) &#123;<span class="comment">//修改了子节点</span></div><div class="line">								System.out.println( <span class="string">"触发了 CHILD_UPDATED 事件"</span> );</div><div class="line">								cache.put(key, <span class="keyword">new</span> String(event.getData().getData()));</div><div class="line">							&#125;</div><div class="line">							<span class="keyword">if</span>( PathChildrenCacheEvent.Type.CHILD_REMOVED.equals(event.getType()) ) &#123;<span class="comment">//删除了子节点</span></div><div class="line">								System.out.println( <span class="string">"触发了 CHILD_REMOVED 事件"</span> );</div><div class="line">								cache.remove(key);</div><div class="line">							&#125;</div><div class="line">					&#125;</div><div class="line">					</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">			 watcher.start();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">saveNodeConfig</span><span class="params">(String name,String value)</span> </span>&#123;<span class="comment">//存放配置信息到某个节点</span></div><div class="line">		String lookPath = PARENT_PATH + <span class="string">"/"</span> + name;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Stat forPath = client.checkExists().forPath(lookPath);</div><div class="line">			<span class="keyword">if</span>( forPath == <span class="keyword">null</span> ) &#123;<span class="comment">//不存在则创建节点，并保存配置信息</span></div><div class="line">				client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(lookPath,value.getBytes());</div><div class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//节点存在则更新值</span></div><div class="line">				client.setData().forPath(lookPath,value.getBytes());</div><div class="line">			&#125;</div><div class="line">			cache.put(name, value);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getNodeConfig</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> cache.get(name);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		ZKConfig config = <span class="keyword">new</span> ZKConfig();</div><div class="line">		config.saveNodeConfig(<span class="string">"erukaServers"</span>, <span class="string">"192.168.1.1,192.168.1.2"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">			System.out.println( <span class="string">"获取配置信息："</span>+config.getNodeConfig(<span class="string">"erukaServers"</span>) );</div><div class="line">			System.out.println( config.cache );</div><div class="line">			TimeUnit.SECONDS.sleep(<span class="number">5</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>实际上他跟配置中心的实现也是一样的</p>
<h1 id="！！！！！疑问！！！！！！！！！！！"><a href="#！！！！！疑问！！！！！！！！！！！" class="headerlink" title="！！！！！疑问！！！！！！！！！！！"></a>！！！！！疑问！！！！！！！！！！！</h1><blockquote>
<p>​    <strong>上面说加入OB服务器，虽然不参与投票，那么zk转化为AP，那么假设ob服务器启动后，怎么同步leader的数据？？？？怎么保证数据一致性？</strong></p>
</blockquote>
<p> <strong>答案：不会，learner启动后，必须跟leader同步数据完成后，才会调用 zk.startup()启动服务，接受客户端请求。</strong></p>
<blockquote>
<p>​    <strong>如果某个节点，没有同步数据，那么客户端会不会读到不是最新的数据（假设有5台机器，其中三台写入数据成功，那么就认为整个更新操作成功。也就是说，客户端的读请求会不会发送到这两台未同步最新数据的server 上？）</strong></p>
</blockquote>
<p> <strong>答案：可能会读到旧数据，因为此时，这两台可能还没有进入同步leader数据的逻辑，那么这个时候刚好客户端发来请求，那么就会访问到旧数据。所以zk是保证在一定时间范围内数据是一致性的-是弱一致性</strong></p>
<p>​    </p>
<blockquote>
<p><strong>为什么leader跟follower的通讯用的是bio而不是nio？（leader.lead（）方法，可以看到leader为每一个learner的交互使用bio且都new了一个线程）</strong></p>
</blockquote>
<p>暂无答案</p>
<blockquote>
<p><strong>数据同步过程中，集群能够接受请求么？代码哪里证明？</strong></p>
</blockquote>
<p>   答案：在进行了数据同步之后，我们发现这个时候server还只是初始化状态，state并不是Running。</p>
<p>Leader.lead()方法中会调用  startZkServer();启动服务无，设置无服务状态为Running，并设置处理链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startZkServer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Update lastCommitted and Db's zxid to a value representing the new epoch</span></div><div class="line">    lastCommitted = zk.getZxid();</div><div class="line">    LOG.info(<span class="string">"Have quorum of supporters, sids: [ "</span></div><div class="line">            + getSidSetString(newLeaderProposal.ackSet)</div><div class="line">            + <span class="string">" ]; starting up and setting last processed zxid: 0x&#123;&#125;"</span>,</div><div class="line">            Long.toHexString(zk.getZxid()));</div><div class="line">    zk.startup();<span class="comment">//启动服务，开始接受请求</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Update the election vote here to ensure that all members of the</span></div><div class="line"><span class="comment">     * ensemble report the same vote to new servers that start up and</span></div><div class="line"><span class="comment">     * send leader election notifications to the ensemble.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    self.updateElectionVote(getEpoch());</div><div class="line"></div><div class="line">    zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());</div><div class="line">&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) &#123;</div><div class="line">            createSessionTracker();</div><div class="line">        &#125;</div><div class="line">        startSessionTracker();</div><div class="line">        setupRequestProcessors();<span class="comment">//关键初始化处理链中的三个处理器</span></div><div class="line">        registerJMX();</div><div class="line">        setState(State.RUNNING);<span class="comment">//关键，设置服务状态为运行状态，开始受理client业务</span></div><div class="line">        notifyAll();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>那么在learner中呢？</strong></p>
<p>逻辑也是如此。    follower.followLeader() – &gt; syncWithLeader（）</p>
<p>同步完leader数据后，马上启动。关键代码在syncWithLeader方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    zk.startup();<span class="comment">//跟leader一样，最终也是会调用</span></div><div class="line">    </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) &#123;</div><div class="line">        createSessionTracker();</div><div class="line">    &#125;</div><div class="line">    startSessionTracker();</div><div class="line">    setupRequestProcessors();</div><div class="line"></div><div class="line">    registerJMX();</div><div class="line"></div><div class="line">    setState(State.RUNNING);</div><div class="line">    notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    <strong>所以，确保了，在leader跟learner同步数据完成后，整个集群才能够启动使用，否则在这期间是不会客户端业务的。保证了数据一致性。（而且只有这个时候，才能够初始化处理链，处理请求并把服务器状态标志位RUNning）</strong></p>
<blockquote>
<p><strong>集群的处理链跟单机模式的处理链有何不同</strong></p>
</blockquote>
<p>​    我们知道单机模式下，server端是通过PrepRequestProcessor -》SyncRequestProcessor-》FinalRequestProcessor 这三个处理链进行处理客户端请求的。</p>
<p>​    那么集群模式下，也是这三个处理器么？答案：<strong>不是一样的，有些许区别。</strong></p>
<p>​    因为leader、follower、observer对服务端（ZooKeeperServer）的实现都是不一样的，分别是LeaderZooKeeperServer，FollowerZooKeeperServer、ObserverZooKeeperServer，他们对 setupRequestProcessors()初始化处理链的实现都不同。</p>
<p><strong>原生ZooKeeperServer的setupRequestProcessors（）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line">    RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</div><div class="line">            finalProcessor);</div><div class="line">    ((SyncRequestProcessor)syncProcessor).start();</div><div class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);</div><div class="line">    ((PrepRequestProcessor)firstProcessor).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>LeaderZooKeeperServer的setupRequestProcessors（）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line">    RequestProcessor toBeAppliedProcessor = <span class="keyword">new</span> Leader.ToBeAppliedRequestProcessor(</div><div class="line">            finalProcessor, getLeader().toBeApplied);</div><div class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(toBeAppliedProcessor,</div><div class="line">            Long.toString(getServerId()), <span class="keyword">false</span>,</div><div class="line">            getZooKeeperServerListener());</div><div class="line">    commitProcessor.start();</div><div class="line">    ProposalRequestProcessor proposalProcessor = <span class="keyword">new</span> ProposalRequestProcessor(<span class="keyword">this</span>,</div><div class="line">            commitProcessor);</div><div class="line">    proposalProcessor.initialize();</div><div class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, proposalProcessor);</div><div class="line">    ((PrepRequestProcessor)firstProcessor).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proposalProcessor：作用是发起投票请求的。因为集群模式下，更新操作需要投票。</p>
<p>​    prep处理收到请求，然后使用proposal处理器，向learner发送操作提议，如果learner半数相应，那么说明可以提交数据，那么接着执行commit处理器，向learner发送提交数据请求。</p>
<p>​    执行commit处理器时，<strong>会阻塞</strong>，等待learner的ack确认（learner在自己服务器持久化成功后，发送ack请求），learner发送ack确认后，leader被唤醒，表示本次更新操作半数learner已经更新成功，继续执行接下来的处理器，leader最后执行final处理器持久化数据。</p>
<p><strong>FollowerZooKeeperServer的setupRequestProcessors（）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(finalProcessor,</div><div class="line">            Long.toString(getServerId()), <span class="keyword">true</span>,</div><div class="line">            getZooKeeperServerListener());</div><div class="line">    commitProcessor.start();</div><div class="line">    firstProcessor = <span class="keyword">new</span> FollowerRequestProcessor(<span class="keyword">this</span>, commitProcessor);</div><div class="line">    ((FollowerRequestProcessor) firstProcessor).start();</div><div class="line">    syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</div><div class="line">            <span class="keyword">new</span> SendAckRequestProcessor((Learner)getFollower()));</div><div class="line">    syncProcessor.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>ObserverZooKeeperServer的setupRequestProcessors（）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;      </div><div class="line">    <span class="comment">// We might consider changing the processor behaviour of </span></div><div class="line">    <span class="comment">// Observers to, for example, remove the disk sync requirements.</span></div><div class="line">    <span class="comment">// Currently, they behave almost exactly the same as followers.</span></div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(finalProcessor,</div><div class="line">            Long.toString(getServerId()), <span class="keyword">true</span>,</div><div class="line">            getZooKeeperServerListener());</div><div class="line">    commitProcessor.start();</div><div class="line">    firstProcessor = <span class="keyword">new</span> ObserverRequestProcessor(<span class="keyword">this</span>, commitProcessor);</div><div class="line">    ((ObserverRequestProcessor) firstProcessor).start();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Observer should write to disk, so that the it won't request</span></div><div class="line"><span class="comment">     * too old txn from the leader which may lead to getting an entire</span></div><div class="line"><span class="comment">     * snapshot.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * However, this may degrade performance as it has to write to disk</span></div><div class="line"><span class="comment">     * and do periodic snapshot which may double the memory requirements</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">if</span> (syncRequestProcessorEnabled) &#123;</div><div class="line">        syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>, <span class="keyword">null</span>);</div><div class="line">        syncProcessor.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>压测一下zk的常用接口</strong></p>
</blockquote>
<p>例如压测一下新增节点操作，看是否存在相同节点创建等等问题。</p>
<h1 id="zk的zxid"><a href="#zk的zxid" class="headerlink" title="zk的zxid"></a>zk的zxid</h1><p>   zxid：事务id。</p>
<p>​    我们知道在数据同步和leader选举中，server的zxid是至关重要的，因为他表示这当前数据提交事务id，那么也就意味着， 他越大数据就越新，那么他成为leader的机会应该更大。</p>
<p>​    <strong>zxid是一个64位的数字，高32位表示epoch（也就是，当前是第几轮的投票，每次有新的leader都会加1），低32位表示递增的序号（日志文件序号）。</strong></p>
<p>​    我们在zk的存储目录中可以看到，生成的日志文件1000000001就是递增的序号，表示这是第一轮中产生的1号日志文件。其中currentEpoch表示当前是第几轮（<strong>新增一轮就表示有新的leader产生</strong>）。acceptedEpoch表示已经接受过的第几轮，一般而言，currentEpoch和acceptedEpoch是一样的。</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200413110859408.png" alt="image-20200413110859408"></p>
<p>​    既然每一轮都表示新的leader选出，那么就会对应着新的日志文件，然后根据低32位递增该轮的日志文件。保证了每轮都会有相应的日志（这样数据看起来就很清晰，知道这个日志文件是那一轮产生的，也方便数据同步的时候leader和learner的数据同步。leader只需要发送learner缺少的第几轮的日志即可，不需要发送之前旧轮数的数据。）</p>
<p>总而言之，<strong>新的leader会创建新的epoch（表示这是属于我的领导）</strong>。</p>
<h1 id="zk保证了高并发的安全性"><a href="#zk保证了高并发的安全性" class="headerlink" title="zk保证了高并发的安全性"></a>zk保证了高并发的安全性</h1><p>​    </p>
<p>​    我们知道，客户端的所有更新请求（cud，增删改），都是转发到leader服务器（无论单机模式还是集群模式），leader服务器对于请求，都会 放到一个队列中，逐个进行处理。</p>
<p>​    </p>
<h1 id="zk是不是强一致性？是顺序一致性"><a href="#zk是不是强一致性？是顺序一致性" class="headerlink" title="zk是不是强一致性？是顺序一致性"></a>zk是不是强一致性？是顺序一致性</h1><p>​    首先理解一下强一致性的概念：要成功就一起成功，不允许存在不成功，数据必须是一致的。</p>
<p>​    很明显zk不是强一致性。zk的机制是过半提交成功，那么就认为整个更新请求是成功，此时其他没有成功ack的server是存在数据不一致的。（<strong>如果上面阐述了zk是强一致性，那么是有歧义的，望周知</strong>）</p>
<p>​    </p>
<p>那么zk是不是最终一致性呢？也不是。</p>
<p>zookeeper是<strong>顺序一致性</strong>。</p>
<h2 id="什么叫顺序一致性："><a href="#什么叫顺序一致性：" class="headerlink" title="什么叫顺序一致性："></a>什么叫顺序一致性：</h2><p>假设有一个Zookeeper集群（N&gt;=3，N为奇数），那么只有一个Leader（通过FastLeaderElection选主策略选取），所有的写操作（客户端请求Leader或Follower的写操作）都由Leader统一处理，Follower虽然对外提供读写，但写操作会提交到Leader，由Leader和Follower共同保证同一个Follower请求的顺序性，Leader会为每个请求生成一个zxid（高32位是epoch，用来标识leader选举周期，每次一个leader被选出来，都会有一个新的epoch，标识当前属于哪个leader的统治时期，低32位用于递增计数）</p>
<p>针对同一个Follower A提交的写请求request1、request2，某些Follower虽然可能不能在请求提交成功后立即看到（也就是强一致性），但经过自身与Leader之间的同步后，这些Follower在看到这两个请求时，一定是先看到request1，然后再看到request2，两个请求之间不会乱序，即顺序一致性。</p>
<p>画个图</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200413115911137.png" alt="image-20200413115911137"></p>
<p>​    也就是说，如果在B1读到的x是1，那么C0读到肯定也是1，那么B2肯定也是1。不会存在说，B1读到的是1，然后之后发生了回滚C0读到的x变成了0，那么这样就不满足顺序一致性。</p>
<p>​    也就是说在，时间轴上的操作，都是有顺序的。数据都是一致的，不会存在朝令夕改。</p>
<p><strong>那么在zk中，使用队列和zxid保证了顺序一致性。</strong></p>
<p>​    但是说是这么说，zk真的能够保证顺序一致性么？<strong>并不能！！！在多台客户端请求的时候并不能保证顺序一致性（也就是说可能在同步数据过程中，B1读到的x是1，但是C0读到的是0。因为存在网络延迟的原因，可能C0读到的是某一台learner还没有执行leader的commit操作，数据不是最新的）</strong></p>
<p>​    <strong>但是同一台客户端发出的请求读取到的数据肯定是一直的。例如客户端B，B2请求leader获取x数据这个时候，因为leader已经持久化诗句完毕，返回x是1。但是接着客户端B发出B3请求再次获取x数据的时候，请求到的是集群集群中的learner，那么因为这个时候这台learner还未完成数据的同步，那么此时B3请求获取到的x是0。但是客户端拿到x=0时会直接丢弃，因为他发现这个数据的zxid比上次最近获取的zxid还小，他认为不是最新的。</strong></p>
<p>我们可以看官方的解释：</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200413143508887.png" alt="image-20200413143508887"></p>
<p>​    <strong>他自己说了，zk无法保证在某个时刻，每一台zk服务，在两台客户端去连接的时候，能够获取到相同的数据。那么如果想让两个客户端读到相同的值，他提供了sync()函数帮助我们实现这个功能</strong></p>
<p>也就是说，客户端B在获取某个节点数据之前，先调用sync方法，然后再去获取数据。这样就能够保证客户端B跟客户端A读到的值是一样的。</p>
<p>官方文档：<a href="http://zookeeper.apache.org/doc/r3.5.5/zookeeperProgrammers.html#ch_zkGuarantees" target="_blank" rel="external">http://zookeeper.apache.org/doc/r3.5.5/zookeeperProgrammers.html#ch_zkGuarantees</a></p>
<h1 id="zk涉及到的java基础知识"><a href="#zk涉及到的java基础知识" class="headerlink" title="zk涉及到的java基础知识"></a>zk涉及到的java基础知识</h1><blockquote>
<p><strong>首先并发编程的wait和notify</strong></p>
</blockquote>
<p>在客户端发送请求给服务端后，会监听packet的请求是否处理完成，调用wait()阻塞等待返回。直到服务端处理完成，唤醒notify</p>
<blockquote>
<p><strong>队列相关知识</strong></p>
</blockquote>
<p>你会发现zk的客户端还是服务端，都充斥着各种队列，例如客户端发送的请求，都会封装到outgoingqueue队列中逐个处理。</p>
<p>服务端在处理请求的时候，会从队列中逐个拿出，然后传递给处理链，每个处理链中的处理器，都会有自己的队列，处理完成后，都会放到自己的队列中，然后交给下一个处理器处理（一共三个处理器，pre、sync、final）</p>
<blockquote>
<p><strong>juc的countdownlatch</strong></p>
</blockquote>
<p>​    服务端在启动的时候，就是利用了countdownlatch的机制，通过cd.await()实现了服务的挂起，直到cd.countdown()，那就说明server需要退出，然后才能继续处理cd.await()之后的代码，完成关闭server的后继工作。</p>
<blockquote>
<p><strong>生产者和消费者</strong></p>
<p><strong>责任链模式</strong></p>
</blockquote>
<p>我们知道不管是单机版本server还是集群版本，他们最终处理请求都是会经过一条处理链进行处理请求。</p>
<h1 id="zk源码构建"><a href="#zk源码构建" class="headerlink" title="zk源码构建"></a><strong>zk源码构建</strong></h1><h2 id="安装ANT"><a href="#安装ANT" class="headerlink" title="安装ANT"></a><strong>安装ANT</strong></h2><ul>
<li><strong><a href="https://link.jianshu.com?t=https%3A%2F%2Fant.apache.org%2Fbindownload.cgi" target="_blank" rel="external">下载ant</a>,地址：<a href="https://link.jianshu.com?t=https%3A%2F%2Fant.apache.org%2Fbindownload.cgi" target="_blank" rel="external">https://ant.apache.org/bindownload.cgi</a></strong></li>
<li><strong>下载后解压ant到硬盘目录，设置环境变量：</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>变量</strong></th>
<th style="text-align:center"><strong>值</strong></th>
<th style="text-align:center"><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ANT_HOME</strong></td>
<td style="text-align:center"><strong>D:\apache-ant-1.10.2</strong></td>
<td style="text-align:center"><strong>新建变量</strong></td>
</tr>
<tr>
<td><strong>Path</strong></td>
<td style="text-align:center"><strong>;%ANT_HOME%\bin</strong></td>
<td style="text-align:center"><strong>没有就新建变量，有则在内容后追加</strong></td>
</tr>
<tr>
<td><strong>CLASSPATH</strong></td>
<td style="text-align:center"><strong>;%ANT_HOME%\lib</strong></td>
<td style="text-align:center"><strong>没有就新建变量，有则在内容后追加</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>验证ant是否安装成功</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">H:\zookeeper-vip1&gt;ant  -version</div><div class="line">Apache Ant(TM) version 1.10.7 compiled on September 1 2019</div></pre></td></tr></table></figure>
<h2 id="下载zk源码"><a href="#下载zk源码" class="headerlink" title="下载zk源码"></a><strong>下载zk源码</strong></h2><p> <strong>3.下载Zookeeper源码</strong></p>
<p>   <strong>下载地址： <a href="https://github.com/apache/zookeeper" target="_blank" rel="external">https://github.com/apache/zookeeper</a></strong></p>
<p><strong>本次选用的是Zookeeper 3.4.14版本。</strong></p>
<p><strong><img src="/2020/02/02/zookeeper源码解析/image-20200408115045686.png" alt="image-20200408115045686"></strong></p>
<p><strong>下载zip，然后解压</strong></p>
<h2 id="使用ant将Zookeeper源码编译成Eclipse工程"><a href="#使用ant将Zookeeper源码编译成Eclipse工程" class="headerlink" title="使用ant将Zookeeper源码编译成Eclipse工程"></a><strong>使用ant将Zookeeper源码编译成Eclipse工程</strong></h2><ul>
<li><strong>使用：ant eclipse命令</strong></li>
</ul>
<p><strong>进入解压zk的根目录，使用ant eclipse 命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ ant eclipse</div><div class="line">Buildfile: E:\workspace\git\zookeeper\build.xml</div><div class="line"></div><div class="line">ant-eclipse-download:</div><div class="line">      [get] Getting: http://downloads.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2</div><div class="line">      [get] To: E:\workspace\git\zookeeper\src\java\ant-eclipse-1.0.bin.tar.bz2</div><div class="line">      [get] http://downloads.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2 moved to https://nchc.dl.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2</div><div class="line"></div><div class="line">BUILD FAILED</div><div class="line">E:\workspace\git\zookeeper\build.xml:1730: Redirection detected from http to https. Protocol switch unsafe, not allowed.</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>1.下载ant-eclipse-1.0.bin.tar.bz2失败，将源码build.xml中的</strong><br> <strong>get src=”[<a href="http://downloads.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2" target="_blank" rel="external">http://downloads.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2</a>]” 替换成如下地址</strong><br> <strong>get src=”[<a href="http://ufpr.dl.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2" target="_blank" rel="external">http://ufpr.dl.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2</a>]”</strong><br> <strong>2.再次执行ant eclipse命令，等待时间有点长，等编译结束后即可导入eclipse中</strong></p>
</blockquote>
<p><strong>如果再次执行ant eclipse命令，还是报上面的错误，那么需要把ant-eclipse-1.0.bin.tar.bz2单独下载下来</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">解决方案：</div><div class="line">　　1、在浏览器中打开http://ufpr.dl.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2，并下载对应的文件</div><div class="line">　　2、将文件copy 到 zookeeper源目录zookeeper-server/src/main/resources中</div><div class="line">　　3、打开build.xml文件，找到需要下载的地方注释掉即可</div></pre></td></tr></table></figure>
<p><strong><img src="/2020/02/02/zookeeper源码解析/image-20200408115408050.png" alt="image-20200408115408050"></strong></p>
<p><strong>再次输入命令ant eclipse，看到如下图所示，表示编译成功：</strong></p>
<p><strong><img src="/2020/02/02/zookeeper源码解析/image-20200408141112408.png" alt="image-20200408141112408"></strong></p>
<h2 id="导入到eclipse中"><a href="#导入到eclipse中" class="headerlink" title="导入到eclipse中"></a>导入到eclipse中</h2><p>可能会提示Version类实现的Info接口不存在：<a href="https://www.dazhuanlan.com/2019/12/24/5e01b9f7e4fe0/" target="_blank" rel="external">https://www.dazhuanlan.com/2019/12/24/5e01b9f7e4fe0/</a></p>
<h2 id="启动server或client"><a href="#启动server或client" class="headerlink" title="启动server或client"></a>启动server或client</h2><p><a href="https://blog.csdn.net/chinaCsdnV2/article/details/81049686" target="_blank" rel="external">https://blog.csdn.net/chinaCsdnV2/article/details/81049686</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;zk集群角色&quot;&gt;&lt;a href=&quot;#zk集群角色&quot; class=&quot;headerlink&quot; title=&quot;zk集群角色&quot;&gt;&lt;/a&gt;zk集群角色&lt;/h1&gt;&lt;p&gt;leader：负责进行投票的发起和决议，最终更新状态。&lt;/p&gt;
&lt;p&gt;follower：用于接收客户请求，并
    
    </summary>
    
      <category term="zookeeper" scheme="http://kingge.top/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://kingge.top/tags/zookeeper/"/>
    
      <category term="zk源码，顺序一致性" scheme="http://kingge.top/tags/zk%E6%BA%90%E7%A0%81%EF%BC%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ深入理解-源码分析</title>
    <link href="http://kingge.top/2019/12/03/RocketMQ-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://kingge.top/2019/12/03/RocketMQ-深入理解/</id>
    <published>2019-12-03T14:21:59.000Z</published>
    <updated>2020-05-09T09:08:09.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-高级功能"><a href="#1-高级功能" class="headerlink" title="1. 高级功能"></a>1. 高级功能</h1><h2 id="1-1-消息存储"><a href="#1-1-消息存储" class="headerlink" title="1.1 消息存储"></a>1.1 消息存储</h2><p>分布式队列因为有高可靠性的要求，所以数据要进行持久化存储。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/消息存储方式.png" alt=""></p>
<ol>
<li>消息生成者发送消息</li>
<li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li>
<li>返回ACK给生产者</li>
<li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li>
<li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li>
<li>MQ删除消息</li>
</ol>
<h3 id="1-1-1-存储介质"><a href="#1-1-1-存储介质" class="headerlink" title="1.1.1 存储介质"></a>1.1.1 存储介质</h3><ul>
<li>关系型数据库DB</li>
</ul>
<p>Apache下开源的另外一款MQ—ActiveMQ（默认采用的KahaDB做消息存储）可选用JDBC的方式来做消息持久化，通过简单的xml配置信息即可实现JDBC消息存储。由于，普通关系型数据库（如Mysql）在单表数据量达到千万级别的情况下，其IO读写性能往往会出现瓶颈。在可靠性方面，该种方案非常依赖DB，如果一旦DB出现故障，则MQ的消息就无法落盘存储会导致线上故障</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/MySQL.png" alt=""></p>
<ul>
<li><p>文件系统</p>
<p>目前业界较为常用的几款产品（RocketMQ/Kafka/RabbitMQ）均采用的是消息刷盘至所部署虚拟机/物理机的文件系统来做持久化（刷盘一般可以分为<strong>异步刷盘和同步刷盘</strong>两种模式）。消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。除非部署MQ机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/磁盘.png" alt=""></p>
</li>
</ul>
<p>###1.1.2 性能对比</p>
<p>文件系统&gt;关系型数据库DB</p>
<h3 id="1-1-3-消息的存储和发送"><a href="#1-1-3-消息的存储和发送" class="headerlink" title="1.1.3 消息的存储和发送"></a>1.1.3 消息的存储和发送</h3><h4 id="1）消息存储"><a href="#1）消息存储" class="headerlink" title="1）消息存储"></a>1）消息存储</h4><p>磁盘如果使用得当，磁盘的速度完全可以匹配上网络 的数据传输速度。目前的高性能磁盘，顺序写速度可以达到600MB/s， 超过了一般网卡的传输速度。但是磁盘随机写的速度只有大概100KB/s，和顺序写的性能相差6000倍！因为有如此巨大的速度差别，好的消息队列系统会比普通的消息队列系统速度快多个数量级。RocketMQ的消息用顺序写,保证了消息存储的速度。</p>
<p>####2）消息发送</p>
<p>Linux操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及这两种形态的切换，免不了进行数据复制。</p>
<p>一台服务器 把本机磁盘文件的内容发送到客户端，一般分为两个步骤：</p>
<p>1）read；读取本地文件内容； </p>
<p>2）write；将读取的内容通过网络发送出去。</p>
<p>这两个看似简单的操作，实际进行了4 次数据复制，分别是：</p>
<ol>
<li>从磁盘复制数据到内核态内存；</li>
<li>从内核态内存复 制到用户态内存；</li>
<li>然后从用户态 内存复制到网络驱动的内核态内存；</li>
<li>最后是从网络驱动的内核态内存复 制到网卡中进行传输。</li>
</ol>
<p><img src="/2019/12/03/RocketMQ-深入理解/文件操作和网络操作.png" alt=""><strong>通过使用mmap的方式，可以省去向用户态的内存复制</strong>，提高速度。这种机制在Java中是通过MappedByteBuffer实现的</p>
<p>RocketMQ充分利用了上述特性，也就是所谓的“零拷贝”技术，提高消息存盘和网络发送的速度。</p>
<blockquote>
<p>这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了</p>
</blockquote>
<h3 id="1-1-4-消息存储结构"><a href="#1-1-4-消息存储结构" class="headerlink" title="1.1.4 消息存储结构"></a>1.1.4 消息存储结构</h3><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成 的，消息真正的物理存储文件是CommitLog，ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址。每 个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/消息存储结构.png" alt=""></p>
<ul>
<li>CommitLog：存储消息的元数据<ul>
<li><img src="/2019/12/03/RocketMQ-深入理解/image-20200423102218864.png" alt="image-20200423102218864"></li>
<li>可以看到CommitLog日志文件的大小确实是1G</li>
</ul>
</li>
</ul>
<ul>
<li><p>ConsumerQueue：存储消息在CommitLog的索引</p>
<ul>
<li><p>保证了如何在CommitLog中快速找到消息，提升查询效率</p>
</li>
<li><p><img src="/2019/12/03/RocketMQ-深入理解/image-20200423102755205.png" alt="image-20200423102755205"></p>
</li>
<li><p>可以看到，这个目录是保存了所有topic在，CommitLog中的索引。</p>
</li>
<li><p>那么每个topic目录下面，有对应的队列文件夹。保存了当前topic一共有几个队列，队列在commitlog中的位置</p>
</li>
<li><p>举个例子，生产者发送消息，那么就会在ConsumerQueue目录下创建一个文件夹TopicTest，然后里面保存有topic对应的队列。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,<span class="string">"TagA"</span> ,</div><div class="line">    (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</div><div class="line">);</div><div class="line">SendResult sendResult = producer.send(msg);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/12/03/RocketMQ-深入理解/image-20200423115014725.png" alt="image-20200423115014725"></p>
</li>
</ul>
<ul>
<li><p>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</p>
<ul>
<li>他的作用实际上跟consumerqueue一样，只不过是提供了另一种查询方式在CommitLog中查询消息</li>
</ul>
</li>
</ul>
<h3 id="1-1-5-刷盘机制"><a href="#1-1-5-刷盘机制" class="headerlink" title="1.1.5 刷盘机制"></a>1.1.5 刷盘机制</h3><p>​    RocketMQ的消息是<strong>存储到磁盘上</strong>的，这样既能保证断电后恢复， 又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时 候，有两种写磁盘方式，分布式同步刷盘和异步刷盘。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/同步刷盘和异步刷盘.png" alt=""></p>
<h4 id="1）同步刷盘"><a href="#1）同步刷盘" class="headerlink" title="1）同步刷盘"></a>1）同步刷盘</h4><p>​    在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</p>
<h4 id="2）异步刷盘"><a href="#2）异步刷盘" class="headerlink" title="2）异步刷盘"></a>2）异步刷盘</h4><p>​    在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p>
<p>####3）配置</p>
<p><strong>同步刷盘还是异步刷盘，都是通过Broker配置文件里的flushDiskType 参数设置的，这个参数被配置成SYNC_FLUSH、ASYNC_FLUSH中的 一个。</strong></p>
<h2 id="1-2-高可用性机制"><a href="#1-2-高可用性机制" class="headerlink" title="1.2 高可用性机制"></a>1.2 高可用性机制</h2><p><img src="/2019/12/03/RocketMQ-深入理解/RocketMQ角色.jpg" alt=""></p>
<p>RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的。</p>
<p>Master和Slave的区别：在Broker的配置文件中，参数 brokerId的值为0表明这个Broker是Master，大于0表明这个Broker是 Slave，同时brokerRole参数也会说明这个Broker是Master还是Slave。</p>
<p>Master角色的Broker<strong>支持读和写</strong>，Slave角色的Broker<strong>仅支持读</strong>，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。</p>
<h3 id="1-2-1-消息消费高可用"><a href="#1-2-1-消息消费高可用" class="headerlink" title="1.2.1 消息消费高可用"></a>1.2.1 消息消费高可用</h3><p>​    在Consumer的配置文件中，并不需要设置是从Master读还是从Slave 读，当Master不可用或者繁忙的时候（<strong>也就是说，默认先从master进行读消息</strong>），Consumer会被自动切换到从Slave 读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。</p>
<h3 id="1-2-2-消息发送高可用"><a href="#1-2-2-消息发送高可用" class="headerlink" title="1.2.2 消息发送高可用"></a>1.2.2 消息发送高可用</h3><p>​    在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可 用后，其他组的Master仍然可用，Producer仍然可以发送消息。 RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足， 需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文 件，用新的配置文件启动Broker。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/消息发送高可用设计.jpg" alt=""></p>
<h3 id="1-2-3-消息主从复制"><a href="#1-2-3-消息主从复制" class="headerlink" title="1.2.3 消息主从复制"></a>1.2.3 消息主从复制</h3><p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p>
<p>####1）同步复制</p>
<p>同步复制方式是等Master和Slave均写 成功后才反馈给客户端写成功状态；</p>
<p>在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入 延迟，降低系统吞吐量。</p>
<p>####2）异步复制 </p>
<p>异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。</p>
<p>在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失；</p>
<p>####3）配置</p>
<p>同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个。</p>
<p>####4）总结</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/复制刷盘.png" alt=""></p>
<p>实际应用中要结合业务场景，合理设置刷盘方式和主从复制方式， 尤其是SYNC_FLUSH方式，由于频繁地触发磁盘写动作，会明显降低 性能。通常情况下，应该把Master和Save配置成ASYNC_FLUSH的刷盘 方式，主从之间配置成SYNC_MASTER的复制方式，这样即使有一台 机器出故障，仍然能保证数据不丢，是个不错的选择。</p>
<h2 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h2><h3 id="1-3-1-Producer负载均衡"><a href="#1-3-1-Producer负载均衡" class="headerlink" title="1.3.1 Producer负载均衡"></a>1.3.1 Producer负载均衡</h3><p>Producer端，每个实例在发消息的时候，默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下，如下图：</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/producer负载均衡.png" alt=""></p>
<p>​    图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 broker1-Queue 0，然后第二条消息发送至 broker1-Queue 1，第三条消息发送到broker1-Queue 2，第四条消息发送到broker2-Queue 0，第五条消息发送到broker2-Queue 1，第六条消息发送到broker2-Queue 2，第七条消息发送到broker1-Queue 0.。。。。以此类推，轮循的方式发送消息。</p>
<h3 id="1-3-2-Consumer负载均衡"><a href="#1-3-2-Consumer负载均衡" class="headerlink" title="1.3.2 Consumer负载均衡"></a>1.3.2 Consumer负载均衡</h3><h4 id="1）集群模式"><a href="#1）集群模式" class="headerlink" title="1）集群模式"></a>1）集群模式</h4><p>在集群消费模式下，每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可。RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条message queue。</p>
<p>而每当实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照queue的数量和实例的数量平均分配queue给每个实例。</p>
<p>默认的分配算法是AllocateMessageQueueAveragely，如下图：</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/consumer负载均衡.png" alt=""></p>
<p>​    还有另外一种平均的算法是AllocateMessageQueueAveragelyByCircle，也是平均分摊每一条queue，只是以环状轮流分queue的形式，如下图：</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/consumer负载均衡2.png" alt=""></p>
<p>需要注意的是，集群模式下，queue都是只允许分配只一个实例，这是由于如果多个实例同时消费一个queue的消息，由于拉取哪些消息是consumer主动控制的，那样会导致同一个消息在不同的实例下被消费多次，所以算法上都是一个queue只分给一个consumer实例，一个consumer实例可以允许同时分到不同的queue。</p>
<p>通过增加consumer实例去分摊queue的消费，可以起到水平扩展的消费能力的作用。而有实例下线的时候，会重新触发负载均衡，这时候原来分配到的queue将分配到其他实例上继续消费。</p>
<p><strong>但是如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。（例如上面的图，如果再多一个消费者，那么就多余了。因为总共才六个queue，三个消费者刚好各自消费一个queue。再多一个消费者那么就无法分摊了）</strong></p>
<p>####2）广播模式</p>
<p>由于广播模式下要求一条消息需要投递到<strong>一个消费组下面所有的消费者实例</strong>，所以也就没有消息被分摊消费的说法。</p>
<p>在实现上，其中一个不同就是在consumer分配queue的时候，所有consumer都分到所有的queue。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/consumer负载均衡3.png" alt=""></p>
<h2 id="1-4-消息重试"><a href="#1-4-消息重试" class="headerlink" title="1.4 消息重试"></a>1.4 消息重试</h2><h3 id="1-4-1-顺序消息的重试-无线重试"><a href="#1-4-1-顺序消息的重试-无线重试" class="headerlink" title="1.4.1 顺序消息的重试  -无线重试"></a>1.4.1 顺序消息的重试  -无线重试</h3><p>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况。因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</p>
<p><strong>为什么顺序消息会无线重试呢？因为你的意图rmq已经知晓？设么意思呢？顺序消息代表着后面的消息依赖前面消息，所以为了保证业务的完整性，需要顺序执行。</strong></p>
<p><strong>所以前一个消息无法执行成功，那么我就死等。</strong></p>
<h3 id="1-4-2-无序消息的重试-次数重试"><a href="#1-4-2-无序消息的重试-次数重试" class="headerlink" title="1.4.2 无序消息的重试 - 次数重试"></a>1.4.2 无序消息的重试 - 次数重试</h3><p>对于无序消息（<strong>普通、定时、延时、事务消息</strong>），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p>
<p><strong>无序消息的重试只针对集群消费方式生效</strong>；广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息。</p>
<h4 id="1）重试次数"><a href="#1）重试次数" class="headerlink" title="1）重试次数"></a>1）重试次数</h4><p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">第几次重试</th>
<th style="text-align:center">与上次重试的间隔时间</th>
<th style="text-align:center">第几次重试</th>
<th style="text-align:center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10 秒</td>
<td style="text-align:center">9</td>
<td style="text-align:center">7 分钟</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">30 秒</td>
<td style="text-align:center">10</td>
<td style="text-align:center">8 分钟</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1 分钟</td>
<td style="text-align:center">11</td>
<td style="text-align:center">9 分钟</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2 分钟</td>
<td style="text-align:center">12</td>
<td style="text-align:center">10 分钟</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">3 分钟</td>
<td style="text-align:center">13</td>
<td style="text-align:center">20 分钟</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">4 分钟</td>
<td style="text-align:center">14</td>
<td style="text-align:center">30 分钟</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">5 分钟</td>
<td style="text-align:center">15</td>
<td style="text-align:center">1 小时</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">6 分钟</td>
<td style="text-align:center">16</td>
<td style="text-align:center">2 小时</td>
</tr>
</tbody>
</table>
<p>如果消息重试 16 次后仍然失败，消息将不再投递。如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递。</p>
<p>​    <strong>这个时候，消息会被记录到死信队列。</strong></p>
<p><strong>注意：</strong> <strong>一条消息无论重试多少次，这些重试消息的 Message ID 不会改变</strong>。</p>
<h4 id="2）配置方式"><a href="#2）配置方式" class="headerlink" title="2）配置方式"></a>2）配置方式</h4><p><strong>消费失败后，重试配置方式</strong></p>
<p>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置（三种方式任选一种）：</p>
<ul>
<li>返回 Action.ReconsumeLater （推荐）</li>
<li>返回 Null</li>
<li>抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</div><div class="line">        <span class="comment">//处理消息</span></div><div class="line">        doConsumeMessage(message);</div><div class="line">        <span class="comment">//方式1：返回 Action.ReconsumeLater，消息将重试</span></div><div class="line">        <span class="keyword">return</span> Action.ReconsumeLater;</div><div class="line">        <span class="comment">//方式2：返回 null，消息将重试</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//方式3：直接抛出异常， 消息将重试</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Consumer Message exceotion"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>消费失败后，不重试配置方式</strong></p>
<p>集群消费方式下，消息失败后期望消息不重试，需要捕获<strong>消费逻辑中可能抛出的异常</strong>，最终返回 Action.CommitMessage，此后这条消息将不会再重试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            doConsumeMessage(message);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="comment">//捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span></div><div class="line">            <span class="keyword">return</span> Action.CommitMessage;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//消息处理正常，直接返回 Action.CommitMessage;</span></div><div class="line">        <span class="keyword">return</span> Action.CommitMessage;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>自定义消息最大重试次数</strong></p>
<p>消息队列 RocketMQ 允许 Consumer 启动的时候设置最大重试次数，重试时间间隔将按照如下策略：</p>
<ul>
<li>最大重试次数小于等于 16 次，则重试时间间隔同上表描述。</li>
<li>最大重试次数大于 16 次，超过 16 次的重试时间间隔均为每次 2 小时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Properties properties = <span class="keyword">new</span> Properties();</div><div class="line"><span class="comment">//配置对应 Group ID 的最大消息重试次数为 20 次</span></div><div class="line">properties.put(PropertyKeyConst.MaxReconsumeTimes,<span class="string">"20"</span>);</div><div class="line">Consumer consumer =ONSFactory.createConsumer(properties);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>消息最大重试次数的设置对相同 Group ID 下的所有 Consumer 实例有效。</li>
<li>如果只对相同 Group ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效。</li>
<li>配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置</li>
</ul>
<p><strong>获取消息重试次数</strong></p>
<p>消费者收到消息后，可按照如下方式获取消息的重试次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</div><div class="line">        <span class="comment">//获取消息的重试次数</span></div><div class="line">        System.out.println(message.getReconsumeTimes());</div><div class="line">        <span class="keyword">return</span> Action.CommitMessage;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-5-死信队列"><a href="#1-5-死信队列" class="headerlink" title="1.5 死信队列"></a>1.5 死信队列</h2><p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</p>
<h3 id="1-5-1-死信特性"><a href="#1-5-1-死信特性" class="headerlink" title="1.5.1 死信特性"></a>1.5.1 死信特性</h3><p>死信消息具有以下特性</p>
<ul>
<li>不会再被消费者正常消费。</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。</li>
</ul>
<p>死信队列具有以下特性：</p>
<ul>
<li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li>
</ul>
<h3 id="1-5-2-查看死信信息"><a href="#1-5-2-查看死信信息" class="headerlink" title="1.5.2 查看死信信息"></a>1.5.2 查看死信信息</h3><ol>
<li>在控制台查询出现死信队列的主题信息</li>
</ol>
<p><img src="/2019/12/03/RocketMQ-深入理解/死信队列主题.png" alt=""></p>
<ol>
<li>在消息界面根据主题查询死信消息</li>
</ol>
<p><img src="/2019/12/03/RocketMQ-深入理解/死信队列主题2.png" alt=""></p>
<ol>
<li>选择重新发送消息</li>
</ol>
<p>一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要您对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次。</p>
<h2 id="1-6-消费幂等"><a href="#1-6-消费幂等" class="headerlink" title="1.6 消费幂等"></a>1.6 消费幂等</h2><p>消息队列 RocketMQ 消费者在接收到消息以后，有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。</p>
<h3 id="1-6-1-消费幂等的必要性"><a href="#1-6-1-消费幂等的必要性" class="headerlink" title="1.6.1 消费幂等的必要性"></a>1.6.1 消费幂等的必要性</h3><p>在互联网应用中，尤其在网络不稳定的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p>
<ul>
<li><p>发送时消息重复</p>
<p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p>投递时消息重复</p>
<p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p>负载均衡时消息重复（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</p>
<p>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p>
</li>
</ul>
<h3 id="1-6-2-处理方式"><a href="#1-6-2-处理方式" class="headerlink" title="1.6.2 处理方式"></a>1.6.2 处理方式</h3><p><strong>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key （例如订单id，支付id等等业务id）进行设置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Message message = <span class="keyword">new</span> Message();</div><div class="line">message.setKey(<span class="string">"ORDERID_100"</span>);</div><div class="line">SendResult sendResult = producer.send(message);</div></pre></td></tr></table></figure>
<p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">consumer.subscribe(<span class="string">"ons_test"</span>, <span class="string">"*"</span>, <span class="keyword">new</span> MessageListener() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</div><div class="line">        String key = message.getKey()</div><div class="line">        <span class="comment">// 根据业务唯一标识的 key 做幂等处理</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h1><h2 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h2><p>依赖工具</p>
<ul>
<li>JDK ：1.8+</li>
<li>Maven</li>
<li>IntelliJ IDEA</li>
</ul>
<h3 id="2-1-1-源码拉取"><a href="#2-1-1-源码拉取" class="headerlink" title="2.1.1 源码拉取"></a>2.1.1 源码拉取</h3><p>从官方仓库 <a href="https://github.com/apache/rocketmq" target="_blank" rel="external">https://github.com/apache/rocketmq</a> <code>clone</code>或者<code>download</code>源码。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/源码1.png" alt=""></p>
<p><strong>源码目录结构：</strong></p>
<ul>
<li><p>broker: broker 模块（broke 启动进程） </p>
</li>
<li><p>client ：消息客户端，包含消息生产者、消息消费者相关类 </p>
</li>
<li>common ：公共包 </li>
<li>dev ：开发者信息（非源代码） </li>
<li>distribution ：部署实例文件夹（非源代码） </li>
<li>example: RocketMQ 例代码 </li>
<li><p>filter ：消息过滤相关基础类</p>
</li>
<li><p>filtersrv：消息过滤服务器实现相关类（Filter启动进程）</p>
</li>
<li>logappender：日志实现相关类</li>
<li>namesrv：NameServer实现相关类（NameServer启动进程）</li>
<li>openmessageing：消息开放标准</li>
<li>remoting：远程通信模块，给予Netty</li>
<li>srcutil：服务工具类</li>
<li>store：消息存储实现相关类</li>
<li>style：checkstyle相关实现</li>
<li>test：测试相关类</li>
<li>tools：工具类，监控命令相关实现类</li>
</ul>
<p>###2.1.2 导入IDEA</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/源码2.png" alt=""></p>
<p><strong>执行安装</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">clean install -Dmaven.test.skip=<span class="literal">true</span></div></pre></td></tr></table></figure>
<h3 id="2-1-3-调试"><a href="#2-1-3-调试" class="headerlink" title="2.1.3 调试"></a>2.1.3 调试</h3><p>在rocketqm根路径创建<code>conf</code>配置文件夹,从<code>distribution</code>拷贝<code>broker.conf</code>和<code>logback_broker.xml</code>和<code>logback_namesrv.xml</code></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/源码6.png" alt=""></p>
<h4 id="1）启动NameServer"><a href="#1）启动NameServer" class="headerlink" title="1）启动NameServer"></a>1）启动NameServer</h4><ul>
<li>展开namesrv模块，右键NamesrvStartup.java</li>
</ul>
<p><img src="/2019/12/03/RocketMQ-深入理解/源码3.png" alt=""></p>
<ul>
<li>配置<strong>ROCKETMQ_HOME</strong></li>
</ul>
<p><img src="/2019/12/03/RocketMQ-深入理解/源码4.png" alt=""></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/源码5.png" alt=""></p>
<ul>
<li><p><strong>ROCKETMQ_HOME等于导入idea的源码的根路径</strong></p>
</li>
<li><p>重新启动</p>
<p>控制台打印结果</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">The Name Server boot success. serializeType=JSON</div></pre></td></tr></table></figure>
<h4 id="2）启动Broker"><a href="#2）启动Broker" class="headerlink" title="2）启动Broker"></a>2）启动Broker</h4><ul>
<li><code>broker.conf</code>配置文件内容 - <strong>broker.conf就是我们在上面创建的conf文件夹下的文件</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">brokerClusterName = DefaultCluster</div><div class="line">brokerName = broker-a</div><div class="line">brokerId = 0</div><div class="line"># namesrvAddr地址</div><div class="line">namesrvAddr=127.0.0.1:9876</div><div class="line">deleteWhen = 04</div><div class="line">fileReservedTime = 48</div><div class="line">brokerRole = ASYNC_MASTER</div><div class="line">flushDiskType = ASYNC_FLUSH</div><div class="line">autoCreateTopicEnable=true</div><div class="line"></div><div class="line"># 存储路径</div><div class="line">storePathRootDir=E:\\RocketMQ\\data\\rocketmq\\dataDir</div><div class="line"># commitLog路径</div><div class="line">storePathCommitLog=E:\\RocketMQ\\data\\rocketmq\\dataDir\\commitlog</div><div class="line"># 消息队列存储路径</div><div class="line">storePathConsumeQueue=E:\\RocketMQ\\data\\rocketmq\\dataDir\\consumequeue</div><div class="line"># 消息索引存储路径</div><div class="line">storePathIndex=E:\\RocketMQ\\data\\rocketmq\\dataDir\\index</div><div class="line"># checkpoint文件路径</div><div class="line">storeCheckpoint=E:\\RocketMQ\\data\\rocketmq\\dataDir\\checkpoint</div><div class="line"># abort文件存储路径</div><div class="line">abortFile=E:\\RocketMQ\\data\\rocketmq\\dataDir\\abort</div></pre></td></tr></table></figure>
<ul>
<li>创建数据文件夹<code>dataDir</code></li>
<li>启动<code>BrokerStartup</code>,配置<code>broker.conf</code>和<code>ROCKETMQ_HOME</code></li>
</ul>
<p><img src="/2019/12/03/RocketMQ-深入理解/源码7.png" alt=""></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/源码8.png" alt=""></p>
<p>####3）发送消息</p>
<ul>
<li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li>
<li>指定Namesrv地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</div><div class="line">producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>运行<code>main</code>方法，发送消息</li>
</ul>
<h4 id="4）消费消息"><a href="#4）消费消息" class="headerlink" title="4）消费消息"></a>4）消费消息</h4><ul>
<li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li>
<li>指定Namesrv地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</div><div class="line">consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</div></pre></td></tr></table></figure>
<ul>
<li>运行<code>main</code>方法，消费消息</li>
</ul>
<h2 id="2-2-NameServer"><a href="#2-2-NameServer" class="headerlink" title="2.2 NameServer"></a>2.2 NameServer</h2><h3 id="2-2-1-架构设计"><a href="#2-2-1-架构设计" class="headerlink" title="2.2.1 架构设计"></a>2.2.1 架构设计</h3><p>消息中间件的设计思路一般是基于<strong>主题订阅发布的机制</strong>，消息生产者（Producer）发送某一个主题到消息服务器，<strong>消息服务器负责将消息持久化存储</strong>，消息消费者（Consumer）订阅该兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送到消费者（Push模式）或者消费者主动向消息服务器拉去（Pull模式），从而实现消息生产者与消息消费者解耦。为了避免消息服务器的单点故障导致的整个系统瘫痪，通常会部署多台消息服务器共同承担消息的存储。那消息生产者如何知道消息要发送到哪台消息服务器呢？如果某一台消息服务器宕机了，那么消息生产者如何在不重启服务情况下感知呢？</p>
<p>NameServer就是为了解决以上问题设计的。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/RocketMQ角色.jpg" alt=""></p>
<p>​    Broker消息服务器在启动的时向所有NameServer注册，消息生产者（Producer）在发送消息时之前先从NameServer获取Broker服务器地址列表，然后根据负载均衡算法从列表中选择一台服务器进行发送。<strong>NameServer与每台Broker保持长连接，并间隔30S检测Broker是否存活</strong>，如果检测到Broker宕机，则从路由注册表中删除。但是路由变化<strong>不会马上通知消息生产者（也就是他不会主动通知producer或者consumer）</strong>。这样设计的目的是为了降低NameServer实现的复杂度，在消息发送端提供容错机制保证消息发送的可用性。</p>
<p>NameServer本身的高可用是通过部署多台NameServer来实现，但彼此之间不通讯，也就是NameServer服务器之间在某一个时刻的数据并不完全相同，但这对消息发送并不会造成任何影响，这也是NameServer设计的一个亮点，总之，RocketMQ设计追求简单高效。</p>
<h3 id="2-2-2-启动流程"><a href="#2-2-2-启动流程" class="headerlink" title="2.2.2 启动流程"></a>2.2.2 启动流程</h3><p><img src="/2019/12/03/RocketMQ-深入理解/NameServer启动流程.png" alt=""></p>
<p>启动类：<code>org.apache.rocketmq.namesrv.NamesrvStartup</code></p>
<p><strong>下面所有流程都是分析org.apache.rocketmq.namesrv.NamesrvStartup#start的方法。</strong></p>
<p>####步骤一 - 创建NamesrvController</p>
<p>解析配置文件，填充NameServerConfig、NettyServerConfig属性值，并创建NamesrvController</p>
<p><strong><em>代码：NamesrvController#createNamesrvController</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//创建NamesrvConfig</span></div><div class="line"><span class="keyword">final</span> NamesrvConfig namesrvConfig = <span class="keyword">new</span> NamesrvConfig();</div><div class="line"><span class="comment">//创建NettyServerConfig，处理其他服务器的请求</span></div><div class="line"><span class="keyword">final</span> NettyServerConfig nettyServerConfig = <span class="keyword">new</span> NettyServerConfig();</div><div class="line"><span class="comment">//设置启动端口号，监听来自其他服务器的请求--例如生产者，消费者，broker</span></div><div class="line">nettyServerConfig.setListenPort(<span class="number">9876</span>);</div><div class="line"><span class="comment">//解析启动-c参数</span></div><div class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">'c'</span>)) &#123;</div><div class="line">    String file = commandLine.getOptionValue(<span class="string">'c'</span>);</div><div class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</div><div class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">        properties = <span class="keyword">new</span> Properties();</div><div class="line">        properties.load(in);</div><div class="line">        MixAll.properties2Object(properties, namesrvConfig);</div><div class="line">        MixAll.properties2Object(properties, nettyServerConfig);</div><div class="line"></div><div class="line">        namesrvConfig.setConfigStorePath(file);</div><div class="line"></div><div class="line">        System.out.printf(<span class="string">"load config properties file OK, %s%n"</span>, file);</div><div class="line">        in.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//解析启动-p参数</span></div><div class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">'p'</span>)) &#123;</div><div class="line">    InternalLogger console = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);</div><div class="line">    MixAll.printObjectProperties(console, namesrvConfig);</div><div class="line">    MixAll.printObjectProperties(console, nettyServerConfig);</div><div class="line">    System.exit(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//将启动参数填充到namesrvConfig,nettyServerConfig</span></div><div class="line">MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);</div><div class="line"></div><div class="line"><span class="comment">//创建NameServerController</span></div><div class="line"><span class="keyword">final</span> NamesrvController controller = <span class="keyword">new</span> NamesrvController(namesrvConfig, nettyServerConfig);</div></pre></td></tr></table></figure>
<p><u><strong>NamesrvConfig属性</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));</div><div class="line"><span class="keyword">private</span> String kvConfigPath = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"namesrv"</span> + File.separator + <span class="string">"kvConfig.json"</span>;</div><div class="line"><span class="keyword">private</span> String configStorePath = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"namesrv"</span> + File.separator + <span class="string">"namesrv.properties"</span>;</div><div class="line"><span class="keyword">private</span> String productEnvName = <span class="string">"center"</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clusterTest = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> orderMessageEnable = <span class="keyword">false</span>;</div></pre></td></tr></table></figure>
<p><strong>rocketmqHome：</strong>rocketmq主目录</p>
<p><strong>kvConfig：</strong>NameServer存储KV配置属性的持久化路径</p>
<p><strong>configStorePath：</strong>nameServer默认配置文件路径</p>
<p><strong>orderMessageEnable：</strong>是否支持顺序消息</p>
<p><u><strong>NettyServerConfig属性</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> listenPort = <span class="number">8888</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverWorkerThreads = <span class="number">8</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverCallbackExecutorThreads = <span class="number">0</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSelectorThreads = <span class="number">3</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverOnewaySemaphoreValue = <span class="number">256</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverAsyncSemaphoreValue = <span class="number">64</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverChannelMaxIdleTimeSeconds = <span class="number">120</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketSndBufSize = NettySystemConfig.socketSndbufSize;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> serverPooledByteBufAllocatorEnable = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useEpollNativeSelector = <span class="keyword">false</span>;</div></pre></td></tr></table></figure>
<p><strong>listenPort：</strong>NameServer监听端口，该值默认会被初始化为9876<br><strong>serverWorkerThreads：</strong>Netty业务线程池线程个数<br><strong>serverCallbackExecutorThreads：</strong>Netty public任务线程池线程个数，Netty网络设计，根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等。如果该业务类型未注册线程池，则由public线程池执行。<br><strong>serverSelectorThreads：</strong>IO线程池个数，主要是NameServer、Broker端解析请求、返回相应的线程个数，这类线程主要是处理网路请求的，解析请求包，然后转发到各个业务线程池完成具体的操作，然后将结果返回给调用方;<br><strong>serverOnewaySemaphoreValue：</strong>send oneway消息请求并发读（Broker端参数）;<br><strong>serverAsyncSemaphoreValue：</strong>异步消息发送最大并发度;<br><strong>serverChannelMaxIdleTimeSeconds ：</strong>网络连接最大的空闲时间，默认120s。<br><strong>serverSocketSndBufSize：</strong>网络socket发送缓冲区大小。<br><strong>serverSocketRcvBufSize：</strong> 网络接收端缓存区大小。<br><strong>serverPooledByteBufAllocatorEnable：</strong>ByteBuffer是否开启缓存;<br><strong>useEpollNativeSelector：</strong>是否启用Epoll IO模型。</p>
<h4 id="步骤二，初始化namesrvcontroller"><a href="#步骤二，初始化namesrvcontroller" class="headerlink" title="步骤二，初始化namesrvcontroller"></a>步骤二，初始化namesrvcontroller</h4><p>​    上面第一步创建完NamesrvController，接着调用<code>start(controller);</code> ，在start方法内部调用<code>boolean initResult = controller.initialize();</code>启动初始化工作。</p>
<p>​    根据启动属性创建NamesrvController实例，并初始化该实例。NameServerController实例为NameServer核心控制器</p>
<p><strong><em>代码：NamesrvController#initialize</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//加载KV配置</span></div><div class="line">    <span class="keyword">this</span>.kvConfigManager.load();</div><div class="line">	<span class="comment">//创建NettyServer网络处理对象</span></div><div class="line">    <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</div><div class="line">	<span class="comment">//开启定时任务:延迟五秒启动，然后每隔10s扫描一次brokerLiveTable（这个map保存了broker的路由信息）,移除不活跃的Broker</span></div><div class="line">    <span class="comment">//那么在哪里保存了broker 的信息呢？在下面的路由管理中的几个hashmap中会讲到。</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">this</span>.remotingExecutor =</div><div class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"RemotingExecutorThread_"</span>));</div><div class="line">    <span class="keyword">this</span>.registerProcessor();</div><div class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">	<span class="comment">//开启定时任务:每隔10min打印一次KV配置</span></div><div class="line">	<span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="步骤三-启动NamesrvController"><a href="#步骤三-启动NamesrvController" class="headerlink" title="步骤三 启动NamesrvController"></a>步骤三 启动NamesrvController</h4><p>在JVM进程关闭之前，先将线程池关闭，及时释放资源</p>
<p><strong><em>代码：NamesrvStartup#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//注册JVM钩子函数代码</span></div><div class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShutdownHookThread(log, <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//释放资源</span></div><div class="line">        controller.shutdown();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<h3 id="2-2-3-路由管理"><a href="#2-2-3-路由管理" class="headerlink" title="2.2.3 路由管理"></a>2.2.3 路由管理</h3><p>​    NameServer的主要作用是为消息的生产者和消息消费者提供关于<strong>主题Topic的路由信息</strong>，那么NameServer需要存储路由的基础信息，还要管理Broker节点，包括路由注册、路由删除等。</p>
<h4 id="2-2-3-1-路由元信息"><a href="#2-2-3-1-路由元信息" class="headerlink" title="2.2.3.1 路由元信息"></a>2.2.3.1 路由元信息</h4><p><strong><em>代码：RouteInfoManager</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</div></pre></td></tr></table></figure>
<p><img src="/2019/12/03/RocketMQ-深入理解/路由实体图.png" alt=""></p>
<p><strong>topicQueueTable：</strong>Topic消息队列路由信息，消息发送时根据路由表进行负载均衡，<strong>保存了主题跟broker的映射关系。</strong></p>
<p><strong>brokerAddrTable：</strong>Broker基础信息，包括brokerName、所属集群名称、主备Broker地址。<strong>保存了broker所在的服务器地址信息</strong></p>
<p><strong>clusterAddrTable：</strong>Broker集群信息，存储集群中所有Broker名称</p>
<p><strong>brokerLiveTable：</strong>Broker状态信息，NameServer每次收到心跳包是会替换该信息，每十秒就检查一下这个map中所有broker的存货情况。</p>
<p><strong>filterServerTable：</strong>Broker上的FilterServer列表，用于类模式消息过滤。</p>
<blockquote>
<p>RocketMQ基于定于发布机制，一个Topic拥有多个消息队列，一个Broker为每一个主题创建4个读队列和4个写队列。多个Broker组成一个集群，集群由brokername相同的多台Broker组成Master-Slave架构，brokerId为0代表Master，大于0为Slave。BrokerLiveInfo中的lastUpdateTimestamp存储上次收到Broker心跳包的时间。</p>
</blockquote>
<p><img src="/2019/12/03/RocketMQ-深入理解/实体数据实例.png" alt=""></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/实体数据实例2.png" alt=""></p>
<h4 id="2-2-3-2-路由注册"><a href="#2-2-3-2-路由注册" class="headerlink" title="2.2.3.2 路由注册"></a>2.2.3.2 路由注册</h4><p>#####1）broker发送心跳包 </p>
<p><img src="/2019/12/03/RocketMQ-深入理解/路由注册.png" alt=""></p>
<p>​    RocketMQ路由注册是<strong>通过Broker与NameServer的心跳功能实现的</strong>。Broker启动时向集群中所有的NameServer发送心跳信息，<strong>每隔30s向集群中所有NameServer发送心跳包</strong>，NameServer收到心跳包时会更新<strong>brokerLiveTable缓存中BrokerLiveInfo的lastUpdataTimeStamp信息</strong>，然后NameServer每隔10s扫描brokerLiveTable，如果连续120S没有收到心跳包，NameServer将移除Broker的路由信息同时关闭Socket连接。</p>
<p>首先查看Broker启动源码</p>
<p><strong><em>代码：org.apache.rocketmq.broker.BrokerStartup#main</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    start(createBrokerController(args));<span class="comment">//你会发现他跟namesrv启动一样，首先创建brokerController</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BrokerController <span class="title">createBrokerController</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">             。。。。。。。</div><div class="line">            <span class="keyword">final</span> BrokerConfig brokerConfig = <span class="keyword">new</span> BrokerConfig();<span class="comment">//获取解析启动broker，配置的配置信息</span></div><div class="line">            <span class="keyword">final</span> NettyServerConfig nettyServerConfig = <span class="keyword">new</span> NettyServerConfig();<span class="comment">//这个server主要是用来处理producer的请求</span></div><div class="line">            <span class="keyword">final</span> NettyClientConfig nettyClientConfig = <span class="keyword">new</span> NettyClientConfig();<span class="comment">//这个server是用来上报自己的状态给namesrv</span></div><div class="line">            。。。。</div><div class="line">                   nettyServerConfig.setListenPort(<span class="number">10911</span>);<span class="comment">//设置默认监听的端口号，生产者就是通过往这个端口发送数据到broker</span></div><div class="line">        。。。。</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：BrokerController#start -</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//注册Broker信息</span></div><div class="line"><span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line"><span class="comment">//每隔30s上报Broker信息到NameServer</span></div><div class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            log.error(<span class="string">"registerBrokerAll Exception"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), </div><div class="line">                                                  TimeUnit.MILLISECONDS);</div></pre></td></tr></table></figure>
<p><strong><em>代码：BrokerOuterAPI#registerBrokerAll</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//获得nameServer地址信息</span></div><div class="line">List&lt;String&gt; nameServerAddressList = <span class="keyword">this</span>.remotingClient.getNameServerAddressList();</div><div class="line"><span class="comment">//遍历所有nameserver列表</span></div><div class="line"><span class="keyword">if</span> (nameServerAddressList != <span class="keyword">null</span> &amp;&amp; nameServerAddressList.size() &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">    <span class="comment">//封装请求头</span></div><div class="line">    <span class="keyword">final</span> RegisterBrokerRequestHeader requestHeader = <span class="keyword">new</span> RegisterBrokerRequestHeader();</div><div class="line">    requestHeader.setBrokerAddr(brokerAddr);</div><div class="line">    requestHeader.setBrokerId(brokerId);</div><div class="line">    requestHeader.setBrokerName(brokerName);</div><div class="line">    requestHeader.setClusterName(clusterName);</div><div class="line">    requestHeader.setHaServerAddr(haServerAddr);</div><div class="line">    requestHeader.setCompressed(compressed);</div><div class="line">	<span class="comment">//封装请求体</span></div><div class="line">    RegisterBrokerBody requestBody = <span class="keyword">new</span> RegisterBrokerBody();</div><div class="line">    requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper);</div><div class="line">    requestBody.setFilterServerList(filterServerList);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = requestBody.encode(compressed);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bodyCrc32 = UtilAll.crc32(body);</div><div class="line">    requestHeader.setBodyCrc32(bodyCrc32);</div><div class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(nameServerAddressList.size());<span class="comment">//使用countDownLatch等待上报完毕</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String namesrvAddr : nameServerAddressList) &#123;<span class="comment">//如果配置了namesrv集群，那么开启线程分别上报broker 信息</span></div><div class="line">        brokerOuterExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//分别向NameServer注册</span></div><div class="line">                    RegisterBrokerResult result = registerBroker(namesrvAddr,oneway, timeoutMills,requestHeader,body);</div><div class="line">                    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">                        registerBrokerResultList.add(result);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    log.info(<span class="string">"register broker[&#123;&#125;]to name server &#123;&#125; OK"</span>, brokerId, namesrvAddr);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    log.warn(<span class="string">"registerBroker Exception, &#123;&#125;"</span>, namesrvAddr, e);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    countDownLatch.countDown();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：BrokerOutAPI#registerBroker</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (oneway) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">this</span>.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);</div><div class="line">    &#125; <span class="keyword">catch</span> (RemotingTooMuchRequestException e) &#123;</div><div class="line">        <span class="comment">// Ignore</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">RemotingCommand response = <span class="keyword">this</span>.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);</div></pre></td></tr></table></figure>
<h5 id="2）namesrv-处理心跳包"><a href="#2）namesrv-处理心跳包" class="headerlink" title="2）namesrv 处理心跳包"></a>2）namesrv 处理心跳包</h5><p><img src="/2019/12/03/RocketMQ-深入理解/NameServer处理路由注册.png" alt=""></p>
<p><code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor</code>网路处理类解析请求类型，如果请求类型是为<strong><em>REGISTER_BROKER</em></strong>，则将请求转发到<code>RouteInfoManager#regiesterBroker</code></p>
<p><strong>可以看到在维护这几个保存路由信息的map时，是加锁的。保证了并发的安全性</strong></p>
<p><strong><em>代码：DefaultRequestProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//因为DefaultRequestProcessor的processRequest方法，是处理所有的客户端请求，那么请求可能是生产者获取路由信息，也有可能是broker向namesrv注册信息，所以需要</span></div><div class="line"><span class="comment">//根据请求类型判断是注册Broker信息</span></div><div class="line"><span class="keyword">case</span> RequestCode.REGISTER_BROKER:</div><div class="line">	Version brokerVersion = MQVersion.value2Version(request.getVersion());</div><div class="line">	<span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</div><div class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.registerBrokerWithFilterServer(ctx, request);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//注册Broker信息</span></div><div class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.registerBroker(ctx, request);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultRequestProcessor#registerBroker</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RegisterBrokerResult result = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().registerBroker(</div><div class="line">    requestHeader.getClusterName(),</div><div class="line">    requestHeader.getBrokerAddr(),</div><div class="line">    requestHeader.getBrokerName(),</div><div class="line">    requestHeader.getBrokerId(),</div><div class="line">    requestHeader.getHaServerAddr(),</div><div class="line">    topicConfigWrapper,</div><div class="line">    <span class="keyword">null</span>,</div><div class="line">    ctx.channel()</div><div class="line">);</div></pre></td></tr></table></figure>
<p><strong><em>代码：RouteInfoManager#registerBroker</em></strong></p>
<p>维护路由信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//加锁</span></div><div class="line"><span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</div><div class="line"><span class="comment">//维护clusterAddrTable</span></div><div class="line">Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</div><div class="line">    brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">    <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</div><div class="line">&#125;</div><div class="line">brokerNames.add(brokerName);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//维护brokerAddrTable</span></div><div class="line">BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</div><div class="line"><span class="comment">//第一次注册,则创建brokerData</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</div><div class="line">    registerFirst = <span class="keyword">true</span>;</div><div class="line">    brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</div><div class="line">    <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</div><div class="line">&#125;</div><div class="line"><span class="comment">//非第一次注册,更新Broker</span></div><div class="line">Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</div><div class="line">Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</div><div class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">    Entry&lt;Long, String&gt; item = it.next();</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</div><div class="line">        it.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</div><div class="line">registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//维护topicQueueTable</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || </div><div class="line">        registerFirst) &#123;</div><div class="line">        ConcurrentMap&lt;String, TopicConfig&gt; tcTable = topicConfigWrapper.getTopicConfigTable();</div><div class="line">        <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</div><div class="line">                <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：RouteInfoManager#createAndUpdateQueueData</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndUpdateQueueData</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> TopicConfig topicConfig)</span> </span>&#123;</div><div class="line">    <span class="comment">//创建QueueData</span></div><div class="line">	QueueData queueData = <span class="keyword">new</span> QueueData();</div><div class="line">	queueData.setBrokerName(brokerName);</div><div class="line">	queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());</div><div class="line">	queueData.setReadQueueNums(topicConfig.getReadQueueNums());</div><div class="line">	queueData.setPerm(topicConfig.getPerm());</div><div class="line">	queueData.setTopicSynFlag(topicConfig.getTopicSysFlag());</div><div class="line">	<span class="comment">//获得topicQueueTable中队列集合</span></div><div class="line">	List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topicConfig.getTopicName());</div><div class="line">    <span class="comment">//topicQueueTable为空,则直接添加queueData到队列集合</span></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == queueDataList) &#123;</div><div class="line">	    queueDataList = <span class="keyword">new</span> LinkedList&lt;QueueData&gt;();</div><div class="line">	    queueDataList.add(queueData);</div><div class="line">	    <span class="keyword">this</span>.topicQueueTable.put(topicConfig.getTopicName(), queueDataList);</div><div class="line">	    log.info(<span class="string">"new topic registered, &#123;&#125; &#123;&#125;"</span>, topicConfig.getTopicName(), queueData);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//判断是否是新的队列</span></div><div class="line">	    <span class="keyword">boolean</span> addNewOne = <span class="keyword">true</span>;</div><div class="line">	    Iterator&lt;QueueData&gt; it = queueDataList.iterator();</div><div class="line">	    <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">	        QueueData qd = it.next();</div><div class="line">            <span class="comment">//如果brokerName相同,代表不是新的队列</span></div><div class="line">	        <span class="keyword">if</span> (qd.getBrokerName().equals(brokerName)) &#123;</div><div class="line">	            <span class="keyword">if</span> (qd.equals(queueData)) &#123;</div><div class="line">	                addNewOne = <span class="keyword">false</span>;</div><div class="line">	        &#125; <span class="keyword">else</span> &#123;</div><div class="line">	                    log.info(<span class="string">"topic changed, &#123;&#125; OLD: &#123;&#125; NEW: &#123;&#125;"</span>, topicConfig.getTopicName(), qd,</div><div class="line">	                        queueData);</div><div class="line">	                    it.remove();</div><div class="line">	                &#125;</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">		<span class="comment">//如果是新的队列,则添加队列到queueDataList</span></div><div class="line">        <span class="keyword">if</span> (addNewOne) &#123;</div><div class="line">            queueDataList.add(queueData);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//维护brokerLiveTable</span></div><div class="line">BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,<span class="keyword">new</span> BrokerLiveInfo(</div><div class="line">    System.currentTimeMillis(),</div><div class="line">    topicConfigWrapper.getDataVersion(),</div><div class="line">    channel,</div><div class="line">    haServerAddr));</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//维护filterServerList</span></div><div class="line"><span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</div><div class="line">        <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</div><div class="line">    String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</div><div class="line">    <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</div><div class="line">        BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</div><div class="line">        <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</div><div class="line">            result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</div><div class="line">            result.setMasterAddr(masterAddr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-3-3-namesrv路由删除"><a href="#2-2-3-3-namesrv路由删除" class="headerlink" title="2.2.3.3  namesrv路由删除"></a>2.2.3.3  namesrv路由删除</h4><p>​    <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">**RocketMQ有两个触发点来删除路由信息**：</div><div class="line"></div><div class="line">* NameServer定期扫描brokerLiveTable检测上次心跳包与当前系统的时间差，如果时间超过120s，则需要移除broker。</div><div class="line">* Broker在正常关闭的情况下，会执行unregisterBroker指令</div><div class="line"></div><div class="line">这两种方式路由删除的方法都是一样的，就是从相关路由表中删除与该broker相关的信息。</div><div class="line"></div><div class="line">![](rocketmq总结/路由删除.png)</div><div class="line"></div><div class="line">***代码：NamesrvController#initialize***</div><div class="line"></div><div class="line">```java</div><div class="line">//每隔10s扫描一次为活跃Broker</div><div class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        NamesrvController.this.routeInfoManager.scanNotActiveBroker();</div><div class="line">    &#125;</div><div class="line">&#125;, 5, 10, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p><strong><em>代码：RouteInfoManager#scanNotActiveBroker</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanNotActiveBroker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//获得brokerLiveTable</span></div><div class="line">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="keyword">this</span>.brokerLiveTable.entrySet().iterator();</div><div class="line">    <span class="comment">//遍历brokerLiveTable</span></div><div class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</div><div class="line">        <span class="keyword">long</span> last = next.getValue().getLastUpdateTimestamp();</div><div class="line">        <span class="comment">//如果收到心跳包的时间距当时时间是否超过120s</span></div><div class="line">        <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</div><div class="line">            <span class="comment">//关闭连接</span></div><div class="line">            RemotingUtil.closeChannel(next.getValue().getChannel());</div><div class="line">            <span class="comment">//移除broker</span></div><div class="line">            it.remove();</div><div class="line">            <span class="comment">//维护路由表</span></div><div class="line">            <span class="keyword">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：RouteInfoManager#onChannelDestroy</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//申请写锁,根据brokerAddress从brokerLiveTable和filterServerTable移除</span></div><div class="line"><span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</div><div class="line"><span class="keyword">this</span>.brokerLiveTable.remove(brokerAddrFound);</div><div class="line"><span class="keyword">this</span>.filterServerTable.remove(brokerAddrFound);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//维护brokerAddrTable</span></div><div class="line">String brokerNameFound = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">boolean</span> removeBrokerName = <span class="keyword">false</span>;</div><div class="line">Iterator&lt;Entry&lt;String, BrokerData&gt;&gt; itBrokerAddrTable =<span class="keyword">this</span>.brokerAddrTable.entrySet().iterator();</div><div class="line"><span class="comment">//遍历brokerAddrTable</span></div><div class="line"><span class="keyword">while</span> (itBrokerAddrTable.hasNext() &amp;&amp; (<span class="keyword">null</span> == brokerNameFound)) &#123;</div><div class="line">    BrokerData brokerData = itBrokerAddrTable.next().getValue();</div><div class="line">    <span class="comment">//遍历broker地址</span></div><div class="line">    Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerData.getBrokerAddrs().entrySet().iterator();</div><div class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">        Entry&lt;Long, String&gt; entry = it.next();</div><div class="line">        Long brokerId = entry.getKey();</div><div class="line">        String brokerAddr = entry.getValue();</div><div class="line">        <span class="comment">//根据broker地址移除brokerAddr</span></div><div class="line">        <span class="keyword">if</span> (brokerAddr.equals(brokerAddrFound)) &#123;</div><div class="line">            brokerNameFound = brokerData.getBrokerName();</div><div class="line">            it.remove();</div><div class="line">            log.info(<span class="string">"remove brokerAddr[&#123;&#125;, &#123;&#125;] from brokerAddrTable, because channel destroyed"</span>,</div><div class="line">                brokerId, brokerAddr);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//如果当前主题只包含待移除的broker,则移除该topic</span></div><div class="line">    <span class="keyword">if</span> (brokerData.getBrokerAddrs().isEmpty()) &#123;</div><div class="line">        removeBrokerName = <span class="keyword">true</span>;</div><div class="line">        itBrokerAddrTable.remove();</div><div class="line">        log.info(<span class="string">"remove brokerName[&#123;&#125;] from brokerAddrTable, because channel destroyed"</span>,</div><div class="line">            brokerData.getBrokerName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//维护clusterAddrTable</span></div><div class="line"><span class="keyword">if</span> (brokerNameFound != <span class="keyword">null</span> &amp;&amp; removeBrokerName) &#123;</div><div class="line">    Iterator&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = <span class="keyword">this</span>.clusterAddrTable.entrySet().iterator();</div><div class="line">    <span class="comment">//遍历clusterAddrTable</span></div><div class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">        Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();</div><div class="line">        <span class="comment">//获得集群名称</span></div><div class="line">        String clusterName = entry.getKey();</div><div class="line">        <span class="comment">//获得集群中brokerName集合</span></div><div class="line">        Set&lt;String&gt; brokerNames = entry.getValue();</div><div class="line">        <span class="comment">//从brokerNames中移除brokerNameFound</span></div><div class="line">        <span class="keyword">boolean</span> removed = brokerNames.remove(brokerNameFound);</div><div class="line">        <span class="keyword">if</span> (removed) &#123;</div><div class="line">            log.info(<span class="string">"remove brokerName[&#123;&#125;], clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed"</span>,</div><div class="line">                brokerNameFound, clusterName);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (brokerNames.isEmpty()) &#123;</div><div class="line">                log.info(<span class="string">"remove the clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed and no broker in this cluster"</span>,</div><div class="line">                    clusterName);</div><div class="line">                <span class="comment">//如果集群中不包含任何broker,则移除该集群</span></div><div class="line">                it.remove();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//维护topicQueueTable队列</span></div><div class="line"><span class="keyword">if</span> (removeBrokerName) &#123;</div><div class="line">    <span class="comment">//遍历topicQueueTable</span></div><div class="line">    Iterator&lt;Entry&lt;String, List&lt;QueueData&gt;&gt;&gt; itTopicQueueTable =</div><div class="line">        <span class="keyword">this</span>.topicQueueTable.entrySet().iterator();</div><div class="line">    <span class="keyword">while</span> (itTopicQueueTable.hasNext()) &#123;</div><div class="line">        Entry&lt;String, List&lt;QueueData&gt;&gt; entry = itTopicQueueTable.next();</div><div class="line">        <span class="comment">//主题名称</span></div><div class="line">        String topic = entry.getKey();</div><div class="line">        <span class="comment">//队列集合</span></div><div class="line">        List&lt;QueueData&gt; queueDataList = entry.getValue();</div><div class="line">		<span class="comment">//遍历该主题队列</span></div><div class="line">        Iterator&lt;QueueData&gt; itQueueData = queueDataList.iterator();</div><div class="line">        <span class="keyword">while</span> (itQueueData.hasNext()) &#123;</div><div class="line">            <span class="comment">//从队列中移除为活跃broker信息</span></div><div class="line">            QueueData queueData = itQueueData.next();</div><div class="line">            <span class="keyword">if</span> (queueData.getBrokerName().equals(brokerNameFound)) &#123;</div><div class="line">                itQueueData.remove();</div><div class="line">                log.info(<span class="string">"remove topic[&#123;&#125; &#123;&#125;], from topicQueueTable, because channel destroyed"</span>,</div><div class="line">                    topic, queueData);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">		<span class="comment">//如果该topic的队列为空,则移除该topic</span></div><div class="line">        <span class="keyword">if</span> (queueDataList.isEmpty()) &#123;</div><div class="line">            itTopicQueueTable.remove();</div><div class="line">            log.info(<span class="string">"remove topic[&#123;&#125;] all queue, from topicQueueTable, because channel destroyed"</span>,</div><div class="line">                topic);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//释放写锁</span></div><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">this</span>.lock.writeLock().unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>总结：也就是说，除非是broker 通知namesrv我要下线了，然后namesrv就把跟broker 的长连接给关闭了。否则namesrv就每隔十秒检查brokerLiveTable是否存在过期未发送心跳的broker，然后再清除失效broker。</strong></p>
<h4 id="2-2-3-4-路由发现"><a href="#2-2-3-4-路由发现" class="headerlink" title="2.2.3.4 路由发现"></a>2.2.3.4 路由发现</h4><p>​    <strong>RocketMQ路由发现是非实时的</strong>，当Topic路由出现变化后，<strong>NameServer不会主动推送给客户端</strong>，而是由<strong>客户端定时拉取主题最新的路由</strong>。</p>
<p>​    <strong>namesrv 通过DefaultRequestProcessor类来处理，客户端请求路由信息。</strong></p>
<p>​    <strong>这个类我们在之前的namesrv处理心跳包中也讲过，也是通过这个类来处理broker的心跳包。</strong></p>
<p>当<code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor#processRequest</code>收到请求时，判断请求类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> (request.getCode()) &#123;</div><div class="line">  ........</div><div class="line">    <span class="keyword">case</span> RequestCode.GET_ROUTEINTO_BY_TOPIC:<span class="comment">//如果类型是这个，那么表明是来自客户端获取路由信息的请求。</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getRouteInfoByTopic(ctx, request);<span class="comment">//调用getRouteInfoByTopic处理请求</span></div><div class="line">   .......</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultRequestProcessor#getRouteInfoByTopic</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span></div><div class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</div><div class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</div><div class="line">    <span class="keyword">final</span> GetRouteInfoRequestHeader requestHeader =</div><div class="line">        (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);</div><div class="line">	<span class="comment">//调用RouteInfoManager的方法,从路由表topicQueueTable、brokerAddrTable、filterServerTable中分别填充TopicRouteData的List&lt;QueueData&gt;、List&lt;BrokerData&gt;、filterServer</span></div><div class="line">    TopicRouteData topicRouteData = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</div><div class="line">	<span class="comment">//如果找到主题对应你的路由信息并且该主题为顺序消息，则从NameServer KVConfig中获取关于顺序消息相关的配置填充路由信息</span></div><div class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</div><div class="line">            String orderTopicConf =</div><div class="line">                <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</div><div class="line">                    requestHeader.getTopic());</div><div class="line">            topicRouteData.setOrderTopicConf(orderTopicConf);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">byte</span>[] content = topicRouteData.encode();</div><div class="line">        response.setBody(content);</div><div class="line">        response.setCode(ResponseCode.SUCCESS);</div><div class="line">        response.setRemark(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    response.setCode(ResponseCode.TOPIC_NOT_EXIST);</div><div class="line">    response.setRemark(<span class="string">"No topic route info in name server for the topic: "</span> + requestHeader.getTopic()</div><div class="line">        + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4 小结"></a>2.2.4 小结</h3><p><img src="/2019/12/03/RocketMQ-深入理解/NameServer小结.png" alt=""></p>
<h2 id="2-3-Producer"><a href="#2-3-Producer" class="headerlink" title="2.3 Producer"></a>2.3 Producer</h2><p>消息生产者的代码都在client模块中，相对于RocketMQ来讲，消息生产者就是客户端，也是消息的提供者。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/DefaultMQProducer类图.png" alt=""></p>
<p>###2.3.1 方法和属性</p>
<p>####1）主要方法介绍</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/MQAdmin.png" alt=""></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//创建主题</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTopic</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String newTopic, <span class="keyword">final</span> <span class="keyword">int</span> queueNum)</span> <span class="keyword">throws</span> MQClientException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//根据时间戳从队列中查找消息偏移量</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">searchOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span></span></div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//查找消息队列中最大的偏移量</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">maxOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//查找消息队列中最小的偏移量</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">minOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span></span></div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//根据偏移量查找消息</span></div><div class="line"><span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(<span class="keyword">final</span> String offsetMsgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException,</span></div><div class="line"><span class="function">        InterruptedException, MQClientException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//根据条件查找消息</span></div><div class="line"><span class="function">QueryResult <span class="title">queryMessage</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> maxNum, <span class="keyword">final</span> <span class="keyword">long</span> begin,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> end)</span> <span class="keyword">throws</span> MQClientException, InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//根据消息ID和主题查找消息</span></div><div class="line"><span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(String topic,String msgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/12/03/RocketMQ-深入理解/MQProducer.png" alt=""></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//启动</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//关闭</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//查找该主题下所有消息</span></div><div class="line"><span class="function">List&lt;MessageQueue&gt; <span class="title">fetchPublishMessageQueues</span><span class="params">(<span class="keyword">final</span> String topic)</span> <span class="keyword">throws</span> MQClientException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//同步发送消息</span></div><div class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException,</span></div><div class="line"><span class="function">        InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//同步超时发送消息</span></div><div class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException,</span></div><div class="line"><span class="function">        RemotingException, MQBrokerException, InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//异步发送消息</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException,</span></div><div class="line"><span class="function">        RemotingException, InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//异步超时发送消息</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//发送单向消息</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(<span class="keyword">final</span> Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException,</span></div><div class="line"><span class="function">    InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//选择指定队列同步发送消息</span></div><div class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException,</span></div><div class="line"><span class="function">    RemotingException, MQBrokerException, InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//选择指定队列异步发送消息</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> SendCallback sendCallback)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//选择指定队列单项发送消息</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException,</span></div><div class="line"><span class="function">    RemotingException, InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//批量发送消息</span></div><div class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException,InterruptedException</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>####2）属性介绍</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/DefaultMQProducer属性.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">producerGroup：生产者所属组</div><div class="line">createTopicKey：默认Topic</div><div class="line">defaultTopicQueueNums：默认主题在每一个Broker队列数量</div><div class="line">sendMsgTimeout：发送消息默认超时时间，默认<span class="number">3</span>s</div><div class="line">compressMsgBodyOverHowmuch：消息体超过该值则启用压缩，默认<span class="number">4</span>k</div><div class="line">retryTimesWhenSendFailed：同步方式发送消息重试次数，默认为<span class="number">2</span>，总共执行<span class="number">3</span>次</div><div class="line">retryTimesWhenSendAsyncFailed：异步方法发送消息重试次数，默认为<span class="number">2</span></div><div class="line">retryAnotherBrokerWhenNotStoreOK：消息重试时选择另外一个Broker时，是否不等待存储结果就返回，默认为<span class="keyword">false</span></div><div class="line">maxMessageSize：允许发送的最大消息长度，默认为<span class="number">4</span>M</div></pre></td></tr></table></figure>
<h3 id="2-3-2-启动流程"><a href="#2-3-2-启动流程" class="headerlink" title="2.3.2 启动流程"></a>2.3.2 启动流程</h3><p><img src="/2019/12/03/RocketMQ-深入理解/生产者启动流程.png" alt=""></p>
<p><strong><em>代码：DefaultMQProducerImpl#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//检查生产者组名是否满足要求，不能为空，不能跟系统默认组名一致等等校验</span></div><div class="line"><span class="keyword">this</span>.checkConfig();</div><div class="line"><span class="comment">//更改当前instanceName为进程ID</span></div><div class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</div><div class="line">    <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</div><div class="line">&#125;</div><div class="line"><span class="comment">//获得MQ客户端实例</span></div><div class="line"><span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</div></pre></td></tr></table></figure>
<blockquote>
<p>整个JVM中只存在一个MQClientManager实例，维护一个MQClientInstance缓存表</p>
<p>ConcurrentMap<string *="" clientid="" ,="" mqclientinstance=""> factoryTable = new ConcurrentHashMap<string,mqclientinstance>();</string,mqclientinstance></string></p>
<p>同一个clientId只会创建一个MQClientInstance。</p>
<p>MQClientInstance封装了RocketMQ网络处理API，是消息生产者和消息消费者与NameServer、Broker打交道的网络通道</p>
</blockquote>
<p><strong><em>代码：MQClientManager#getAndCreateMQClientInstance</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MQClientInstance <span class="title">getAndCreateMQClientInstance</span><span class="params">(<span class="keyword">final</span> ClientConfig clientConfig, </span></span></div><div class="line"><span class="function"><span class="params">                                                     RPCHook rpcHook)</span> </span>&#123;</div><div class="line">    <span class="comment">//构建客户端ID</span></div><div class="line">    String clientId = clientConfig.buildMQClientId();</div><div class="line">    <span class="comment">//根据客户端ID或者客户端实例</span></div><div class="line">    MQClientInstance instance = <span class="keyword">this</span>.factoryTable.get(clientId);</div><div class="line">    <span class="comment">//实例如果为空就创建新的实例,并添加到实例表中</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</div><div class="line">        instance =</div><div class="line">            <span class="keyword">new</span> MQClientInstance(clientConfig.cloneClientConfig(),</div><div class="line">                <span class="keyword">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</div><div class="line">        MQClientInstance prev = <span class="keyword">this</span>.factoryTable.putIfAbsent(clientId, instance);</div><div class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">            instance = prev;</div><div class="line">            log.warn(<span class="string">"Returned Previous MQClientInstance for clientId:[&#123;&#125;]"</span>, clientId);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            log.info(<span class="string">"Created new MQClientInstance for clientId:[&#123;&#125;]"</span>, clientId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//注册当前生产者到到MQClientInstance管理中,方便后续调用网路请求</span></div><div class="line"><span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</div><div class="line"><span class="keyword">if</span> (!registerOK) &#123;</div><div class="line">    <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</div><div class="line">        + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</div><div class="line">        <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//启动生产者</span></div><div class="line"><span class="keyword">if</span> (startFactory) &#123;</div><div class="line">    mQClientFactory.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-3-消息发送"><a href="#2-3-3-消息发送" class="headerlink" title="2.3.3 消息发送"></a>2.3.3 消息发送</h3><p><img src="/2019/12/03/RocketMQ-深入理解/消息发送.png" alt=""></p>
<p><strong><em>代码：DefaultMQProducerImpl#send(Message msg)</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//发送消息</span></div><div class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> send(msg, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#send(Message msg,long timeout)</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//发送消息,默认超时时间为3s</span></div><div class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg,<span class="keyword">long</span> timeout)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="keyword">null</span>, timeout);<span class="comment">//同步发送</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#sendDefaultImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//校验消息</span></div><div class="line">Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</div></pre></td></tr></table></figure>
<p>####1）验证消息</p>
<p><strong><em>代码：Validators#checkMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMessage</span><span class="params">(Message msg, DefaultMQProducer defaultMQProducer)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> MQClientException </span>&#123;</div><div class="line">    <span class="comment">//判断是否为空</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message is null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 校验主题</span></div><div class="line">    Validators.checkTopic(msg.getTopic());</div><div class="line">		</div><div class="line">    <span class="comment">// 校验消息体</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg.getBody()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message body is null"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == msg.getBody().length) &#123;<span class="comment">//消息体没有内容，那么报异常</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message body length is zero"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (msg.getBody().length &gt; defaultMQProducer.getMaxMessageSize()) &#123;<span class="comment">//判断消息体大小是否超过4M</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL,</div><div class="line">            <span class="string">"the message body size over max value, MAX: "</span> + defaultMQProducer.getMaxMessageSize());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####2）查找路由</p>
<p><strong><em>代码：DefaultMQProducerImpl#tryToFindTopicPublishInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</div><div class="line">    <span class="comment">//从缓存中获得主题的路由信息</span></div><div class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</div><div class="line">    <span class="comment">//路由信息为空,则从NameServer获取路由</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</div><div class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</div><div class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);<span class="comment">//请求namesrv获取路由信息</span></div><div class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</div><div class="line">        <span class="keyword">return</span> topicPublishInfo;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//如果未找到当前主题的路由信息,则用默认主题继续查找</span></div><div class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</div><div class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</div><div class="line">        <span class="keyword">return</span> topicPublishInfo;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2019/12/03/RocketMQ-深入理解/Topic路由信息.png" alt=""></p>
<p><strong><em>代码：TopicPublishInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPublishInfo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> orderTopic = <span class="keyword">false</span>;	<span class="comment">//是否是顺序消息</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> haveTopicRouterInfo = <span class="keyword">false</span>; </div><div class="line">    <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();	<span class="comment">//该主题消息队列</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadLocalIndex sendWhichQueue = <span class="keyword">new</span> ThreadLocalIndex();<span class="comment">//每选择一次消息队列,该值+1</span></div><div class="line">    <span class="keyword">private</span> TopicRouteData topicRouteData;<span class="comment">//关联Topic路由元信息</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TopicRouteData topicRouteData;</div><div class="line"><span class="comment">//使用默认主题从NameServer获取路由信息</span></div><div class="line"><span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</div><div class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</div><div class="line">        <span class="number">1000</span> * <span class="number">3</span>);</div><div class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</div><div class="line">            <span class="keyword">int</span> queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</div><div class="line">            data.setReadQueueNums(queueNums);</div><div class="line">            data.setWriteQueueNums(queueNums);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//使用指定主题从NameServer获取路由信息</span></div><div class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//从namesrv拿到最新路由信息后，接着判断本地路由信息是否需要更改，如果本地路由不是最新，则更新本地路由</span></div><div class="line">TopicRouteData old = <span class="keyword">this</span>.topicRouteTable.get(topic);</div><div class="line"><span class="keyword">boolean</span> changed = topicRouteDataIsChange(old, topicRouteData);</div><div class="line"><span class="keyword">if</span> (!changed) &#123;</div><div class="line">    changed = <span class="keyword">this</span>.isNeedUpdateTopicRouteInfo(topic);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    log.info(<span class="string">"the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]"</span>, topic, old, topicRouteData);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (changed) &#123;</div><div class="line">    <span class="comment">//将topicRouteData转换为发布队列</span></div><div class="line">    TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</div><div class="line">    publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</div><div class="line">    <span class="comment">//遍历生产</span></div><div class="line">    Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</div><div class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">        Entry&lt;String, MQProducerInner&gt; entry = it.next();</div><div class="line">        MQProducerInner impl = entry.getValue();</div><div class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//生产者不为空时,更新publishInfo信息</span></div><div class="line">            impl.updateTopicPublishInfo(topic, publishInfo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#topicRouteData2TopicPublishInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">，然后开始执行发送消息到<span class="function">brokerpublic <span class="keyword">static</span> TopicPublishInfo <span class="title">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> </span>&#123;</div><div class="line">    	<span class="comment">//创建TopicPublishInfo对象</span></div><div class="line">        TopicPublishInfo info = <span class="keyword">new</span> TopicPublishInfo();</div><div class="line">    	<span class="comment">//关联topicRoute</span></div><div class="line">        info.setTopicRouteData(route);</div><div class="line">    	<span class="comment">//顺序消息,更新TopicPublishInfo</span></div><div class="line">        <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="keyword">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</div><div class="line">            String[] brokers = route.getOrderTopicConf().split(<span class="string">";"</span>);</div><div class="line">            <span class="keyword">for</span> (String broker : brokers) &#123;</div><div class="line">                String[] item = broker.split(<span class="string">":"</span>);</div><div class="line">                <span class="keyword">int</span> nums = Integer.parseInt(item[<span class="number">1</span>]);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</div><div class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, item[<span class="number">0</span>], i);</div><div class="line">                    info.getMessageQueueList().add(mq);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            info.setOrderTopic(<span class="keyword">true</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//非顺序消息更新TopicPublishInfo</span></div><div class="line">            List&lt;QueueData&gt; qds = route.getQueueDatas();</div><div class="line">            Collections.sort(qds);</div><div class="line">            <span class="comment">//遍历topic队列信息</span></div><div class="line">            <span class="keyword">for</span> (QueueData qd : qds) &#123;</div><div class="line">                <span class="comment">//是否是写队列</span></div><div class="line">                <span class="keyword">if</span> (PermName.isWriteable(qd.getPerm())) &#123;</div><div class="line">                    BrokerData brokerData = <span class="keyword">null</span>;</div><div class="line">                    <span class="comment">//遍历写队列Broker</span></div><div class="line">                    <span class="keyword">for</span> (BrokerData bd : route.getBrokerDatas()) &#123;</div><div class="line">                        <span class="comment">//根据名称获得读队列对应的Broker</span></div><div class="line">                        <span class="keyword">if</span> (bd.getBrokerName().equals(qd.getBrokerName())) &#123;</div><div class="line">                        brokerData = bd;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">				<span class="comment">//封装TopicPublishInfo写队列</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qd.getWriteQueueNums(); i++) &#123;</div><div class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, qd.getBrokerName(), i);</div><div class="line">                    info.getMessageQueueList().add(mq);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        info.setOrderTopic(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//返回TopicPublishInfo对象，然后开始选择队列发送消息</span></div><div class="line">    <span class="keyword">return</span> info;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3）选择队列"><a href="#3）选择队列" class="headerlink" title="3）选择队列"></a>3）选择队列</h4><ul>
<li>默认不启用Broker故障延迟机制</li>
</ul>
<p><strong><em>代码：TopicPublishInfo#selectOneMessageQueue(lastBrokerName)</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</div><div class="line">    <span class="comment">//第一次选择队列</span></div><div class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> selectOneMessageQueue();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//sendWhichQueue</span></div><div class="line">        <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</div><div class="line">        <span class="comment">//遍历消息队列集合</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</div><div class="line">            <span class="comment">//sendWhichQueue自增后取模</span></div><div class="line">            <span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</div><div class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</div><div class="line">                pos = <span class="number">0</span>;</div><div class="line">            <span class="comment">//规避上次Broker队列</span></div><div class="line">            MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</div><div class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</div><div class="line">                <span class="keyword">return</span> mq;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果以上情况都不满足,返回sendWhichQueue取模后的队列</span></div><div class="line">        <span class="keyword">return</span> selectOneMessageQueue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：TopicPublishInfo#selectOneMessageQueue()</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//第一次选择队列</span></div><div class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//sendWhichQueue自增</span></div><div class="line">    <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</div><div class="line">    <span class="comment">//对队列大小取模</span></div><div class="line">    <span class="keyword">int</span> pos = Math.abs(index) % <span class="keyword">this</span>.messageQueueList.size();</div><div class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</div><div class="line">        pos = <span class="number">0</span>;</div><div class="line">    <span class="comment">//返回对应的队列</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.messageQueueList.get(pos);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>启用Broker故障延迟机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;<span class="comment">//上一次发送消息的lastBrokerName</span></div><div class="line">    <span class="comment">//Broker故障延迟机制</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//对sendWhichQueue自增</span></div><div class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</div><div class="line">            <span class="comment">//对消息队列轮询获取一个队列</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</div><div class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</div><div class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</div><div class="line">                    pos = <span class="number">0</span>;</div><div class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</div><div class="line">                <span class="comment">//验证该队列是否可用，latencyFaultTolerance中维护了一个map，里面保存了曾经发送失败的brokername</span></div><div class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</div><div class="line">                    <span class="comment">//可用</span></div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</div><div class="line">                        <span class="keyword">return</span> mq;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">			<span class="comment">//从规避的Broker中选择一个可用的Broker</span></div><div class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</div><div class="line">            <span class="comment">//获得Broker的写队列集合</span></div><div class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</div><div class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">//获得一个队列,指定broker和队列ID并返回</span></div><div class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</div><div class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</div><div class="line">                    mq.setBrokerName(notBestBroker);</div><div class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> mq;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                latencyFaultTolerance.remove(notBestBroker);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2019/12/03/RocketMQ-深入理解/Broker故障延迟机制核心类.png" alt=""></p>
<ul>
<li>延迟机制接口规范</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LatencyFaultTolerance</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//更新失败条目</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> T name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span></span>;</div><div class="line">	<span class="comment">//判断Broker是否可用</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">(<span class="keyword">final</span> T name)</span></span>;</div><div class="line">	<span class="comment">//移除Fault条目</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> T name)</span></span>;</div><div class="line">	<span class="comment">//尝试从规避的Broker中选择一个可用的Broker</span></div><div class="line">    <span class="function">T <span class="title">pickOneAtLeast</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>FaultItem：失败条目</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FaultItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">FaultItem</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//条目唯一键,这里为brokerName</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">//本次消息发送延迟</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> currentLatency;</div><div class="line">    <span class="comment">//故障规避开始时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTimestamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>消息失败策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQFaultStrategy</span> </span>&#123;</div><div class="line">   <span class="comment">//根据currentLatency本地消息发送延迟,从latencyMax尾部向前找到第一个比currentLatency小的索引,如果没有找到,返回0</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</div><div class="line">    <span class="comment">//根据这个索引从notAvailableDuration取出对应的时间,在该时长内,Broker设置为不可用</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u><strong><em>原理分析</em></strong></u></p>
<p><strong><em>代码：DefaultMQProducerImpl#sendDefaultImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, </div><div class="line">                                 mq, </div><div class="line">                                 communicationMode, </div><div class="line">                                 sendCallback, </div><div class="line">                                 topicPublishInfo, </div><div class="line">                                 timeout - costTime);</div><div class="line">endTimestamp = System.currentTimeMillis();</div><div class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<p>如果上述发送过程出现异常，则调用<code>DefaultMQProducerImpl#updateFaultItem</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</div><div class="line">    <span class="comment">//参数一：broker名称</span></div><div class="line">    <span class="comment">//参数二:本次消息发送延迟时间</span></div><div class="line">    <span class="comment">//参数三:是否隔离</span></div><div class="line">    <span class="keyword">this</span>.mqFaultStrategy.updateFaultItem(brokerName, currentLatency, isolation);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MQFaultStrategy#updateFaultItem</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</div><div class="line">        <span class="comment">//计算broker规避的时长</span></div><div class="line">        <span class="keyword">long</span> duration = computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</div><div class="line">        <span class="comment">//更新该FaultItem规避时长</span></div><div class="line">        <span class="keyword">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MQFaultStrategy#computeNotAvailableDuration</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentLatency)</span> </span>&#123;</div><div class="line">    <span class="comment">//遍历latencyMax</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = latencyMax.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">//找到第一个比currentLatency的latencyMax值</span></div><div class="line">        <span class="keyword">if</span> (currentLatency &gt;= latencyMax[i])</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.notAvailableDuration[i];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//没有找到则返回0</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：LatencyFaultToleranceImpl#updateFaultItem</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span> </span>&#123;</div><div class="line">    <span class="comment">//获得原FaultItem</span></div><div class="line">    FaultItem old = <span class="keyword">this</span>.faultItemTable.get(name);</div><div class="line">    <span class="comment">//为空新建faultItem对象,设置规避时长和开始时间</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == old) &#123;</div><div class="line">        <span class="keyword">final</span> FaultItem faultItem = <span class="keyword">new</span> FaultItem(name);</div><div class="line">        faultItem.setCurrentLatency(currentLatency);</div><div class="line">        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</div><div class="line"></div><div class="line">        old = <span class="keyword">this</span>.faultItemTable.putIfAbsent(name, faultItem);</div><div class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</div><div class="line">            old.setCurrentLatency(currentLatency);</div><div class="line">            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//更新规避时长和开始时间</span></div><div class="line">        old.setCurrentLatency(currentLatency);</div><div class="line">        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####4）发送消息</p>
<p>消息发送API核心入口<strong><em>DefaultMQProducerImpl#sendKernelImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Message msg,	//待发送消息</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue mq,	//消息发送队列</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> CommunicationMode communicationMode,		//消息发送内模式</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SendCallback sendCallback,	pp	//异步消息回调函数</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,	//主题路由信息</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeout	//超时时间</span></span></div><div class="line"><span class="function"><span class="params">    )</span></span></div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#sendKernelImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//获得broker网络地址信息</span></div><div class="line">String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</div><div class="line">    <span class="comment">//没有找到从NameServer更新broker网络地址信息</span></div><div class="line">    tryToFindTopicPublishInfo(mq.getTopic());</div><div class="line">    brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//为消息分类唯一ID</span></div><div class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</div><div class="line">    MessageClientIDSetter.setUniqID(msg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> topicWithNamespace = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace()) &#123;</div><div class="line">    msg.setInstanceId(<span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace());</div><div class="line">    topicWithNamespace = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//消息大小超过4K,启用消息压缩</span></div><div class="line"><span class="keyword">int</span> sysFlag = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> msgBodyCompressed = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</div><div class="line">    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</div><div class="line">    msgBodyCompressed = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果是事务消息,设置消息标记MessageSysFlag.TRANSACTION_PREPARED_TYPE</span></div><div class="line"><span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class="line"><span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</div><div class="line">    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//如果注册了消息发送钩子函数,在执行消息发送前的增强逻辑</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">    context = <span class="keyword">new</span> SendMessageContext();</div><div class="line">    context.setProducer(<span class="keyword">this</span>);</div><div class="line">    context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</div><div class="line">    context.setCommunicationMode(communicationMode);</div><div class="line">    context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</div><div class="line">    context.setBrokerAddr(brokerAddr);</div><div class="line">    context.setMessage(msg);</div><div class="line">    context.setMq(mq);</div><div class="line">    context.setNamespace(<span class="keyword">this</span>.defaultMQProducer.getNamespace());</div><div class="line">    String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class="line">    <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">"true"</span>)) &#123;</div><div class="line">        context.setMsgType(MessageType.Trans_Msg_Half);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (msg.getProperty(<span class="string">"__STARTDELIVERTIME"</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</div><div class="line">        context.setMsgType(MessageType.Delay_Msg);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.executeSendMessageHookBefore(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：SendMessageHook</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SendMessageHook</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">hookName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageBefore</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageAfter</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducerImpl#sendKernelImpl</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//构建消息发送请求包</span></div><div class="line">SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</div><div class="line"><span class="comment">//生产者组</span></div><div class="line">requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</div><div class="line"><span class="comment">//主题</span></div><div class="line">requestHeader.setTopic(msg.getTopic());</div><div class="line"><span class="comment">//默认创建主题Key</span></div><div class="line">requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</div><div class="line"><span class="comment">//该主题在单个Broker默认队列树</span></div><div class="line">requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</div><div class="line"><span class="comment">//队列ID</span></div><div class="line">requestHeader.setQueueId(mq.getQueueId());</div><div class="line"><span class="comment">//消息系统标记</span></div><div class="line">requestHeader.setSysFlag(sysFlag);</div><div class="line"><span class="comment">//消息发送时间</span></div><div class="line">requestHeader.setBornTimestamp(System.currentTimeMillis());</div><div class="line"><span class="comment">//消息标记</span></div><div class="line">requestHeader.setFlag(msg.getFlag());</div><div class="line"><span class="comment">//消息扩展信息</span></div><div class="line">requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class="line"><span class="comment">//消息重试次数</span></div><div class="line">requestHeader.setReconsumeTimes(<span class="number">0</span>);</div><div class="line">requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</div><div class="line"><span class="comment">//是否是批量消息等</span></div><div class="line">requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</div><div class="line"><span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class="line">    String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</div><div class="line">    <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</div><div class="line">        requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</div><div class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</div><div class="line">    <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</div><div class="line">        requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</div><div class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> ASYNC:		<span class="comment">//异步发送</span></div><div class="line">    Message tmpMessage = msg;</div><div class="line">    <span class="keyword">boolean</span> messageCloned = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (msgBodyCompressed) &#123;</div><div class="line">        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></div><div class="line">        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></div><div class="line">        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></div><div class="line">        tmpMessage = MessageAccessor.cloneMessage(msg);</div><div class="line">        messageCloned = <span class="keyword">true</span>;</div><div class="line">        msg.setBody(prevBody);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (topicWithNamespace) &#123;</div><div class="line">        <span class="keyword">if</span> (!messageCloned) &#123;</div><div class="line">            tmpMessage = MessageAccessor.cloneMessage(msg);</div><div class="line">            messageCloned = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), </div><div class="line">                                                    <span class="keyword">this</span>.defaultMQProducer.getNamespace()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">		<span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;</div><div class="line">		<span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</div><div class="line">		    <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</div><div class="line">		&#125;</div><div class="line">		sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</div><div class="line">        			brokerAddr,</div><div class="line">        			mq.getBrokerName(),</div><div class="line">        			tmpMessage,</div><div class="line">        			requestHeader,</div><div class="line">        			timeout - costTimeAsync,</div><div class="line">        			communicationMode,</div><div class="line">        			sendCallback,</div><div class="line">        			topicPublishInfo,</div><div class="line">        			<span class="keyword">this</span>.mQClientFactory,</div><div class="line">        			<span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</div><div class="line">        			context,</div><div class="line">        			<span class="keyword">this</span>);</div><div class="line">    	<span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> ONEWAY:</div><div class="line"><span class="keyword">case</span> SYNC:		<span class="comment">//同步发送</span></div><div class="line">    <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</div><div class="line">        <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</div><div class="line">        &#125;</div><div class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</div><div class="line">            brokerAddr,</div><div class="line">            mq.getBrokerName(),</div><div class="line">            msg,</div><div class="line">            requestHeader,</div><div class="line">            timeout - costTimeSync,</div><div class="line">            communicationMode,</div><div class="line">            context,</div><div class="line">            <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//如果注册了钩子函数,则发送完毕后执行钩子函数</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">    context.setSendResult(sendResult);</div><div class="line">    <span class="keyword">this</span>.executeSendMessageHookAfter(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-4-批量消息发送"><a href="#2-3-4-批量消息发送" class="headerlink" title="2.3.4 批量消息发送"></a>2.3.4 批量消息发送</h3><p><img src="/2019/12/03/RocketMQ-深入理解/发送批量消息.png" alt=""></p>
<p>批量消息发送是将同一个主题的多条消息一起打包发送到消息服务端，减少网络调用次数，提高网络传输效率。当然，并不是在同一批次中发送的消息数量越多越好，其判断依据是单条消息的长度，如果单条消息内容比较长，则打包多条消息发送会影响其他线程发送消息的响应时间，并且单批次消息总长度不能超过DefaultMQProducer#maxMessageSize。</p>
<p>批量消息发送要解决的问题是如何将这些消息编码以便服务端能够正确解码出每条消息的消息内容。</p>
<p><strong><em>代码：DefaultMQProducer#send</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Collection&lt;Message&gt; msgs)</span> </span></div><div class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</div><div class="line">    <span class="comment">//压缩消息集合成一条消息,然后发送出去</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(batch(msgs));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMQProducer#batch</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> MessageBatch <span class="title">batch</span><span class="params">(Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</div><div class="line">    MessageBatch msgBatch;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//将集合消息封装到MessageBatch</span></div><div class="line">        msgBatch = MessageBatch.generateFromList(msgs);</div><div class="line">        <span class="comment">//遍历消息集合,检查消息合法性,设置消息ID,设置Topic</span></div><div class="line">        <span class="keyword">for</span> (Message message : msgBatch) &#123;</div><div class="line">            Validators.checkMessage(message, <span class="keyword">this</span>);</div><div class="line">            MessageClientIDSetter.setUniqID(message);</div><div class="line">            message.setTopic(withNamespace(message.getTopic()));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//压缩消息,设置消息body</span></div><div class="line">        msgBatch.setBody(msgBatch.encode());</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"Failed to initiate the MessageBatch"</span>, e);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置msgBatch的topic</span></div><div class="line">    msgBatch.setTopic(withNamespace(msgBatch.getTopic()));</div><div class="line">    <span class="keyword">return</span> msgBatch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-4-消息存储"><a href="#2-4-消息存储" class="headerlink" title="2.4 消息存储"></a>2.4 消息存储</h2><p>###2.4.1 消息存储核心类</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/DefaultMessageStore.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageStoreConfig messageStoreConfig;	<span class="comment">//消息配置属性</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CommitLog commitLog;		<span class="comment">//CommitLog文件存储的实现类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, ConcurrentMap&lt;Integer<span class="comment">/* queueId */</span>, ConsumeQueue&gt;&gt; consumeQueueTable;	<span class="comment">//消息队列存储缓存表,按照消息主题分组</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlushConsumeQueueService flushConsumeQueueService;	<span class="comment">//消息队列文件刷盘线程</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanCommitLogService cleanCommitLogService;	<span class="comment">//清除CommitLog文件服务</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanConsumeQueueService cleanConsumeQueueService;	<span class="comment">//清除ConsumerQueue队列文件服务</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> IndexService indexService;	<span class="comment">//索引实现类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;	<span class="comment">//MappedFile分配服务</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReputMessageService reputMessageService;<span class="comment">//CommitLog消息分发,根据CommitLog文件构建ConsumerQueue、IndexFile文件</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HAService haService;	<span class="comment">//存储HA机制</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduleMessageService scheduleMessageService;	<span class="comment">//消息服务调度线程</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> StoreStatsService storeStatsService;	<span class="comment">//消息存储服务</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransientStorePool transientStorePool;	<span class="comment">//消息堆外内存缓存</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerStatsManager brokerStatsManager;	<span class="comment">//Broker状态管理器</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageArrivingListener messageArrivingListener;	<span class="comment">//消息拉取长轮询模式消息达到监听器</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerConfig brokerConfig;	<span class="comment">//Broker配置类</span></div><div class="line"><span class="keyword">private</span> StoreCheckpoint storeCheckpoint;	<span class="comment">//文件刷盘监测点</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;CommitLogDispatcher&gt; dispatcherList;	<span class="comment">//CommitLog文件转发请求</span></div></pre></td></tr></table></figure>
<h3 id="2-4-2-消息存储流程"><a href="#2-4-2-消息存储流程" class="headerlink" title="2.4.2 消息存储流程"></a>2.4.2 消息存储流程</h3><p><img src="/2019/12/03/RocketMQ-深入理解/消息存储流程.png" alt=""></p>
<p><strong><em>消息存储入口：DefaultMessageStore#putMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断Broker角色如果是从节点,则无需写入</span></div><div class="line"><span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</div><div class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</div><div class="line">        <span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</div><div class="line">            log.warn(<span class="string">"message store is slave mode, so putMessage is forbidden "</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//判断当前写入状态如果是正在写入,则不能继续</span></div><div class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isWriteable()) &#123;</div><div class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.printTimes.set(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//判断消息主题长度是否超过最大限制</span></div><div class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</div><div class="line">    log.warn(<span class="string">"putMessage message topic length too long "</span> + msg.getTopic().length());</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//判断消息属性长度是否超过限制</span></div><div class="line"><span class="keyword">if</span> (msg.getPropertiesString() != <span class="keyword">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</div><div class="line">    log.warn(<span class="string">"putMessage message properties length too long "</span> + msg.getPropertiesString().length());</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//判断系统PageCache缓存去是否占用</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将消息写入CommitLog文件</span></div><div class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</div></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#putMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//记录消息存储时间</span></div><div class="line">msg.setStoreTimestamp(beginLockTimestamp);</div><div class="line"></div><div class="line"><span class="comment">//判断如果mappedFile如果为空或者已满,创建新的mappedFile文件</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</div><div class="line">    mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); </div><div class="line">&#125;</div><div class="line"><span class="comment">//如果创建失败,直接返回</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</div><div class="line">    log.error(<span class="string">"create mapped file1 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</div><div class="line">    beginTimeInLock = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//写入消息到mappedFile中</span></div><div class="line">result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</div></pre></td></tr></table></figure>
<p><strong><em>代码：MappedFile#appendMessagesInner</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//获得文件的写入指针</span></div><div class="line"><span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</div><div class="line"></div><div class="line"><span class="comment">//如果指针大于文件大小则直接返回</span></div><div class="line"><span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</div><div class="line">    <span class="comment">//通过writeBuffer.slice()创建一个与MappedFile共享的内存区,并设置position为当前指针</span></div><div class="line">    ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</div><div class="line">    byteBuffer.position(currentPos);</div><div class="line">    AppendMessageResult result = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</div><div class="line">       	<span class="comment">//通过回调方法写入</span></div><div class="line">        result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</div><div class="line">        result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</div><div class="line">    <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#doAppend</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//文件写入位置</span></div><div class="line"><span class="keyword">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</div><div class="line"><span class="comment">//设置消息ID</span></div><div class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</div><div class="line">String msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</div><div class="line"></div><div class="line"><span class="comment">//获得该消息在消息队列中的偏移量</span></div><div class="line">keyBuilder.setLength(<span class="number">0</span>);</div><div class="line">keyBuilder.append(msgInner.getTopic());</div><div class="line">keyBuilder.append(<span class="string">'-'</span>);</div><div class="line">keyBuilder.append(msgInner.getQueueId());</div><div class="line">String key = keyBuilder.toString();</div><div class="line">Long queueOffset = CommitLog.<span class="keyword">this</span>.topicQueueTable.get(key);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == queueOffset) &#123;</div><div class="line">    queueOffset = <span class="number">0L</span>;</div><div class="line">    CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, queueOffset);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获得消息属性长度</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] propertiesData =msgInner.getPropertiesString() == <span class="keyword">null</span> ? <span class="keyword">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> propertiesLength = propertiesData == <span class="keyword">null</span> ? <span class="number">0</span> : propertiesData.length;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</div><div class="line">    log.warn(<span class="string">"putMessage message properties length too long. length=&#123;&#125;"</span>, propertiesData.length);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获得消息主题大小</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> topicLength = topicData.length;</div><div class="line"></div><div class="line"><span class="comment">//获得消息体大小</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> bodyLength = msgInner.getBody() == <span class="keyword">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</div><div class="line"><span class="comment">//计算消息总长度</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</div></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#calMsgLength</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calMsgLength</span><span class="params">(<span class="keyword">int</span> bodyLength, <span class="keyword">int</span> topicLength, <span class="keyword">int</span> propertiesLength)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> msgLen = <span class="number">4</span> <span class="comment">//TOTALSIZE</span></div><div class="line">        + <span class="number">4</span> <span class="comment">//MAGICCODE  </span></div><div class="line">        + <span class="number">4</span> <span class="comment">//BODYCRC</span></div><div class="line">        + <span class="number">4</span> <span class="comment">//QUEUEID</span></div><div class="line">        + <span class="number">4</span> <span class="comment">//FLAG</span></div><div class="line">        + <span class="number">8</span> <span class="comment">//QUEUEOFFSET</span></div><div class="line">        + <span class="number">8</span> <span class="comment">//PHYSICALOFFSET</span></div><div class="line">        + <span class="number">4</span> <span class="comment">//SYSFLAG</span></div><div class="line">        + <span class="number">8</span> <span class="comment">//BORNTIMESTAMP</span></div><div class="line">        + <span class="number">8</span> <span class="comment">//BORNHOST</span></div><div class="line">        + <span class="number">8</span> <span class="comment">//STORETIMESTAMP</span></div><div class="line">        + <span class="number">8</span> <span class="comment">//STOREHOSTADDRESS</span></div><div class="line">        + <span class="number">4</span> <span class="comment">//RECONSUMETIMES</span></div><div class="line">        + <span class="number">8</span> <span class="comment">//Prepared Transaction Offset</span></div><div class="line">        + <span class="number">4</span> + (bodyLength &gt; <span class="number">0</span> ? bodyLength : <span class="number">0</span>) <span class="comment">//BODY</span></div><div class="line">        + <span class="number">1</span> + topicLength <span class="comment">//TOPIC</span></div><div class="line">        + <span class="number">2</span> + (propertiesLength &gt; <span class="number">0</span> ? propertiesLength : <span class="number">0</span>) <span class="comment">//propertiesLength</span></div><div class="line">        + <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> msgLen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#doAppend</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//消息长度不能超过4M</span></div><div class="line"><span class="keyword">if</span> (msgLen &gt; <span class="keyword">this</span>.maxMessageSize) &#123;</div><div class="line">    CommitLog.log.warn(<span class="string">"message size exceeded, msg total size: "</span> + msgLen + <span class="string">", msg body size: "</span> + bodyLength</div><div class="line">        + <span class="string">", maxMessageSize: "</span> + <span class="keyword">this</span>.maxMessageSize);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//消息是如果没有足够的存储空间则新创建CommitLog文件</span></div><div class="line"><span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</div><div class="line">    <span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</div><div class="line">    <span class="comment">// 1 TOTALSIZE</span></div><div class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</div><div class="line">    <span class="comment">// 2 MAGICCODE</span></div><div class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</div><div class="line">    <span class="comment">// 3 The remaining space may be any value</span></div><div class="line">    <span class="comment">// Here the length of the specially set maxBlank</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</div><div class="line">    byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</div><div class="line">        queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将消息存储到ByteBuffer中,返回AppendMessageResult</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</div><div class="line"><span class="comment">// Write messages to the queue buffer</span></div><div class="line">byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</div><div class="line">AppendMessageResult result = <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, </div><div class="line">                                                     msgLen, msgId,msgInner.getStoreTimestamp(), </div><div class="line">                                                     queueOffset, </div><div class="line">                                                     CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() </div><div class="line">                                                     -beginTimeMills);</div><div class="line"><span class="keyword">switch</span> (tranType) &#123;</div><div class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class="line">        <span class="comment">//更新消息队列偏移量</span></div><div class="line">        CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, ++queueOffset);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog#putMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//释放锁</span></div><div class="line">putMessageLock.unlock();</div><div class="line"><span class="comment">//刷盘</span></div><div class="line">handleDiskFlush(result, putMessageResult, msg);</div><div class="line"><span class="comment">//执行HA主从同步</span></div><div class="line">handleHA(result, putMessageResult, msg);</div></pre></td></tr></table></figure>
<h3 id="2-4-3-存储文件"><a href="#2-4-3-存储文件" class="headerlink" title="2.4.3 存储文件"></a>2.4.3 存储文件</h3><p><img src="/2019/12/03/RocketMQ-深入理解/存储文件.png" alt=""></p>
<ul>
<li>commitLog：消息存储目录</li>
<li>config：运行期间一些配置信息</li>
<li>consumerqueue：消息消费队列存储目录</li>
<li>index：消息索引文件存储目录</li>
<li>abort：如果存在改文件寿命Broker非正常关闭</li>
<li>checkpoint：文件检查点，存储CommitLog文件最后一次刷盘时间戳、consumerquueue最后一次刷盘时间，index索引文件最后一次刷盘时间戳。</li>
</ul>
<h3 id="2-4-4-存储文件内存映射"><a href="#2-4-4-存储文件内存映射" class="headerlink" title="2.4.4 存储文件内存映射"></a>2.4.4 存储文件内存映射</h3><p>​    RocketMQ通过使用内存映射文件提高IO访问性能，无论是CommitLog、ConsumerQueue还是IndexFile，单个文件都被设计为固定长度，如果一个文件写满以后再创建一个新文件，文件名就为该文件第一条消息对应的全局物理偏移量。</p>
<p>####1）MappedFileQueue - 等同于commitlog</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/MappedFileQueue.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String storePath;	<span class="comment">//存储目录</span></div><div class="line"><span class="keyword">int</span> mappedFileSize;	<span class="comment">// 单个文件大小，默认1G</span></div><div class="line">CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles;	<span class="comment">//MappedFile文件集合</span></div><div class="line">AllocateMappedFileService allocateMappedFileService;	<span class="comment">//创建MapFile服务类</span></div><div class="line"><span class="keyword">long</span> flushedWhere = <span class="number">0</span>;		<span class="comment">//当前刷盘指针</span></div><div class="line"><span class="keyword">long</span> committedWhere = <span class="number">0</span>;	<span class="comment">//当前数据提交指针,内存中ByteBuffer当前的写指针,该值大于等于flushWhere</span></div></pre></td></tr></table></figure>
<ul>
<li></li>
<li>根据存储时间查询MappedFile</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getMappedFileByTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span> </span>&#123;</div><div class="line">    Object[] mfs = <span class="keyword">this</span>.copyMappedFiles(<span class="number">0</span>);</div><div class="line">	</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mfs)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//遍历MappedFile文件数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mfs.length; i++) &#123;</div><div class="line">        MappedFile mappedFile = (MappedFile) mfs[i];</div><div class="line">        <span class="comment">//MappedFile文件的最后修改时间大于指定时间戳则返回该文件</span></div><div class="line">        <span class="keyword">if</span> (mappedFile.getLastModifiedTimestamp() &gt;= timestamp) &#123;</div><div class="line">            <span class="keyword">return</span> mappedFile;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (MappedFile) mfs[mfs.length - <span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>根据消息偏移量offset查找MappedFile</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">boolean</span> returnFirstOnNotFound)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//获得第一个MappedFile文件</span></div><div class="line">        MappedFile firstMappedFile = <span class="keyword">this</span>.getFirstMappedFile();</div><div class="line">        <span class="comment">//获得最后一个MappedFile文件</span></div><div class="line">        MappedFile lastMappedFile = <span class="keyword">this</span>.getLastMappedFile();</div><div class="line">        <span class="comment">//第一个文件和最后一个文件均不为空,则进行处理</span></div><div class="line">        <span class="keyword">if</span> (firstMappedFile != <span class="keyword">null</span> &amp;&amp; lastMappedFile != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (offset &lt; firstMappedFile.getFileFromOffset() || </div><div class="line">                offset &gt;= lastMappedFile.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize) &#123;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//获得文件索引</span></div><div class="line">                <span class="keyword">int</span> index = (<span class="keyword">int</span>) ((offset / <span class="keyword">this</span>.mappedFileSize) </div><div class="line">                                   - (firstMappedFile.getFileFromOffset() / <span class="keyword">this</span>.mappedFileSize));</div><div class="line">                MappedFile targetFile = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//根据索引返回目标文件</span></div><div class="line">                    targetFile = <span class="keyword">this</span>.mappedFiles.get(index);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (targetFile != <span class="keyword">null</span> &amp;&amp; offset &gt;= targetFile.getFileFromOffset()</div><div class="line">                    &amp;&amp; offset &lt; targetFile.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize) &#123;</div><div class="line">                    <span class="keyword">return</span> targetFile;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (MappedFile tmpMappedFile : <span class="keyword">this</span>.mappedFiles) &#123;</div><div class="line">                    <span class="keyword">if</span> (offset &gt;= tmpMappedFile.getFileFromOffset()</div><div class="line">                        &amp;&amp; offset &lt; tmpMappedFile.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize) &#123;</div><div class="line">                        <span class="keyword">return</span> tmpMappedFile;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (returnFirstOnNotFound) &#123;</div><div class="line">                <span class="keyword">return</span> firstMappedFile;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        log.error(<span class="string">"findMappedFileByOffset Exception"</span>, e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取存储文件最小偏移量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMinOffset</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.mappedFiles.get(<span class="number">0</span>).getFileFromOffset();</div><div class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">            <span class="comment">//continue;</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            log.error(<span class="string">"getMinOffset has exception."</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取存储文件最大偏移量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxOffset</span><span class="params">()</span> </span>&#123;</div><div class="line">    MappedFile mappedFile = getLastMappedFile();</div><div class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getReadPosition();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>返回存储文件当前写指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxWrotePosition</span><span class="params">()</span> </span>&#123;</div><div class="line">    MappedFile mappedFile = getLastMappedFile();</div><div class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getWrotePosition();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####2）MappedFile</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/MappedFile.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> OS_PAGE_SIZE = <span class="number">1024</span> * <span class="number">4</span>;		<span class="comment">//操作系统每页大小,默认4K</span></div><div class="line">AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);	<span class="comment">//当前JVM实例中MappedFile虚拟内存</span></div><div class="line">AtomicInteger TOTAL_MAPPED_FILES = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);	<span class="comment">//当前JVM实例中MappedFile对象个数</span></div><div class="line">AtomicInteger wrotePosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);	<span class="comment">//当前文件的写指针</span></div><div class="line">AtomicInteger committedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);	<span class="comment">//当前文件的提交指针</span></div><div class="line">AtomicInteger flushedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);	<span class="comment">//刷写到磁盘指针</span></div><div class="line"><span class="keyword">int</span> fileSize;	<span class="comment">//文件大小</span></div><div class="line">FileChannel fileChannel;	<span class="comment">//文件通道	</span></div><div class="line">ByteBuffer writeBuffer = <span class="keyword">null</span>;	<span class="comment">//堆外内存ByteBuffer</span></div><div class="line">TransientStorePool transientStorePool = <span class="keyword">null</span>;	<span class="comment">//堆外内存池</span></div><div class="line">String fileName;	<span class="comment">//文件名称</span></div><div class="line"><span class="keyword">long</span> fileFromOffset;	<span class="comment">//该文件的处理偏移量</span></div><div class="line">File file;	<span class="comment">//物理文件</span></div><div class="line">MappedByteBuffer mappedByteBuffer;	<span class="comment">//物理文件对应的内存映射Buffer</span></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>;	<span class="comment">//文件最后一次内容写入时间</span></div><div class="line"><span class="keyword">boolean</span> firstCreateInQueue = <span class="keyword">false</span>;	<span class="comment">//是否是MappedFileQueue队列中第一个文件</span></div></pre></td></tr></table></figure>
<p><strong><em>MappedFile初始化</em></strong></p>
<ul>
<li>未开启<code>transientStorePoolEnable</code>。<code>transientStorePoolEnable=true</code>为<code>true</code>表示数据先存储到堆外内存，然后通过<code>Commit</code>线程将数据提交到内存映射Buffer中，再通过<code>Flush</code>线程将内存映射<code>Buffer</code>中数据持久化磁盘。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.fileName = fileName;</div><div class="line">    <span class="keyword">this</span>.fileSize = fileSize;</div><div class="line">    <span class="keyword">this</span>.file = <span class="keyword">new</span> File(fileName);</div><div class="line">    <span class="keyword">this</span>.fileFromOffset = Long.parseLong(<span class="keyword">this</span>.file.getName());</div><div class="line">    <span class="keyword">boolean</span> ok = <span class="keyword">false</span>;</div><div class="line">	</div><div class="line">    ensureDirOK(<span class="keyword">this</span>.file.getParent());</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">this</span>.fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.file, <span class="string">"rw"</span>).getChannel();</div><div class="line">        <span class="keyword">this</span>.mappedByteBuffer = <span class="keyword">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</div><div class="line">        TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);</div><div class="line">        TOTAL_MAPPED_FILES.incrementAndGet();</div><div class="line">        ok = <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        log.error(<span class="string">"create file channel "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        log.error(<span class="string">"map file "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!ok &amp;&amp; <span class="keyword">this</span>.fileChannel != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.fileChannel.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开启<code>transientStorePoolEnable</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    init(fileName, fileSize);</div><div class="line">    <span class="keyword">this</span>.writeBuffer = transientStorePool.borrowBuffer();	<span class="comment">//初始化writeBuffer</span></div><div class="line">    <span class="keyword">this</span>.transientStorePool = transientStorePool;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>MappedFile提交</em></strong></p>
<p>提交数据到FileChannel，commitLeastPages为本次提交最小的页数，如果待提交数据不满commitLeastPages，则不执行本次提交操作。如果writeBuffer如果为空，直接返回writePosition指针，无需执行commit操作，表名commit操作主体是writeBuffer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.wrotePosition.get();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断是否满足提交条件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToCommit(commitLeastPages)) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</div><div class="line">            commit0(commitLeastPages);</div><div class="line">            <span class="keyword">this</span>.release();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            log.warn(<span class="string">"in commit, hold failed, commit offset = "</span> + <span class="keyword">this</span>.committedPosition.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 所有数据提交后,清空缓冲区</span></div><div class="line">    <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.transientStorePool != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.fileSize == <span class="keyword">this</span>.committedPosition.get()) &#123;</div><div class="line">        <span class="keyword">this</span>.transientStorePool.returnBuffer(writeBuffer);</div><div class="line">        <span class="keyword">this</span>.writeBuffer = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.committedPosition.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>MappedFile#isAbleToCommit</em></strong></p>
<p>判断是否执行commit操作，如果文件已满返回true；如果commitLeastpages大于0，则比较writePosition与上一次提交的指针commitPosition的差值，除以OS_PAGE_SIZE得到当前脏页的数量，如果大于commitLeastPages则返回true，如果commitLeastpages小于0表示只要存在脏页就提交。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAbleToCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</div><div class="line">    <span class="comment">//已经刷盘指针</span></div><div class="line">    <span class="keyword">int</span> flush = <span class="keyword">this</span>.committedPosition.get();</div><div class="line">    <span class="comment">//文件写指针</span></div><div class="line">    <span class="keyword">int</span> write = <span class="keyword">this</span>.wrotePosition.get();</div><div class="line">	<span class="comment">//写满刷盘</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (commitLeastPages &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//文件内容达到commitLeastPages页数,则刷盘</span></div><div class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> write &gt; flush;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>MappedFile#commit0</em></strong></p>
<p>具体提交的实现，首先创建WriteBuffer区共享缓存区，然后将新创建的position回退到上一次提交的位置（commitPosition），设置limit为wrotePosition（当前最大有效数据指针），然后把commitPosition到wrotePosition的数据写入到FileChannel中，然后更新committedPosition指针为wrotePosition。commit的作用就是将MappedFile的writeBuffer中数据提交到文件通道FileChannel中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commit0</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</div><div class="line">    <span class="comment">//写指针</span></div><div class="line">    <span class="keyword">int</span> writePos = <span class="keyword">this</span>.wrotePosition.get();</div><div class="line">    <span class="comment">//上次提交指针</span></div><div class="line">    <span class="keyword">int</span> lastCommittedPosition = <span class="keyword">this</span>.committedPosition.get();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (writePos - <span class="keyword">this</span>.committedPosition.get() &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//复制共享内存区域</span></div><div class="line">            ByteBuffer byteBuffer = writeBuffer.slice();</div><div class="line">            <span class="comment">//设置提交位置是上次提交位置</span></div><div class="line">            byteBuffer.position(lastCommittedPosition);</div><div class="line">            <span class="comment">//最大提交数量</span></div><div class="line">            byteBuffer.limit(writePos);</div><div class="line">            <span class="comment">//设置fileChannel位置为上次提交位置</span></div><div class="line">            <span class="keyword">this</span>.fileChannel.position(lastCommittedPosition);</div><div class="line">            <span class="comment">//将lastCommittedPosition到writePos的数据复制到FileChannel中</span></div><div class="line">            <span class="keyword">this</span>.fileChannel.write(byteBuffer);</div><div class="line">            <span class="comment">//重置提交位置</span></div><div class="line">            <span class="keyword">this</span>.committedPosition.set(writePos);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            log.error(<span class="string">"Error occurred when commit data to FileChannel."</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>MappedFile#flush</em></strong></p>
<p>刷写磁盘，直接调用MappedByteBuffer或fileChannel的force方法将内存中的数据持久化到磁盘，那么flushedPosition应该等于MappedByteBuffer中的写指针；如果writeBuffer不为空，则flushPosition应该等于上一次的commit指针；因为上一次提交的数据就是进入到MappedByteBuffer中的数据；如果writeBuffer为空，数据时直接进入到MappedByteBuffer，wrotePosition代表的是MappedByteBuffer中的指针，故设置flushPosition为wrotePosition。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/flush.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</div><div class="line">    <span class="comment">//数据达到刷盘条件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToFlush(flushLeastPages)) &#123;</div><div class="line">        <span class="comment">//加锁，同步刷盘</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</div><div class="line">            <span class="comment">//获得读指针</span></div><div class="line">            <span class="keyword">int</span> value = getReadPosition();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//数据从writeBuffer提交数据到fileChannel再刷新到磁盘</span></div><div class="line">                <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//从mmap刷新数据到磁盘</span></div><div class="line">                    <span class="keyword">this</span>.mappedByteBuffer.force();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                log.error(<span class="string">"Error occurred when force data to disk."</span>, e);</div><div class="line">            &#125;</div><div class="line">			<span class="comment">//更新刷盘位置</span></div><div class="line">            <span class="keyword">this</span>.flushedPosition.set(value);</div><div class="line">            <span class="keyword">this</span>.release();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            log.warn(<span class="string">"in flush, hold failed, flush offset = "</span> + <span class="keyword">this</span>.flushedPosition.get());</div><div class="line">            <span class="keyword">this</span>.flushedPosition.set(getReadPosition());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getFlushedPosition();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>MappedFile#getReadPosition</em></strong></p>
<p>获取当前文件最大可读指针。如果writeBuffer为空，则直接返回当前的写指针；如果writeBuffer不为空，则返回上一次提交的指针。在MappedFile设置中,只有提交了的数据（写入到MappedByteBuffer或FileChannel中的数据）才是安全的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getReadPosition</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//如果writeBuffer为空,刷盘的位置就是应该等于上次commit的位置,如果为空则为mmap的写指针</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writeBuffer == <span class="keyword">null</span> ? <span class="keyword">this</span>.wrotePosition.get() : <span class="keyword">this</span>.committedPosition.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>MappedFile#selectMappedBuffer</em></strong></p>
<p>查找pos到当前最大可读之间的数据，由于在整个写入期间都未曾改MappedByteBuffer的指针，如果mappedByteBuffer.slice()方法返回的共享缓存区空间为整个MappedFile，然后通过设置ByteBuffer的position为待查找的值，读取字节长度当前可读最大长度，最终返回的ByteBuffer的limit为size。整个共享缓存区的容量为（MappedFile#fileSize-pos）。故在操作SelectMappedBufferResult不能对包含在里面的ByteBuffer调用filp方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">selectMappedBuffer</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</div><div class="line">    <span class="comment">//获得最大可读指针</span></div><div class="line">    <span class="keyword">int</span> readPosition = getReadPosition();</div><div class="line">    <span class="comment">//pos小于最大可读指针,并且大于0</span></div><div class="line">    <span class="keyword">if</span> (pos &lt; readPosition &amp;&amp; pos &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</div><div class="line">            <span class="comment">//复制mappedByteBuffer读共享区</span></div><div class="line">            ByteBuffer byteBuffer = <span class="keyword">this</span>.mappedByteBuffer.slice();</div><div class="line">            <span class="comment">//设置读指针位置</span></div><div class="line">            byteBuffer.position(pos);</div><div class="line">            <span class="comment">//获得可读范围</span></div><div class="line">            <span class="keyword">int</span> size = readPosition - pos;</div><div class="line">            <span class="comment">//设置最大刻度范围</span></div><div class="line">            ByteBuffer byteBufferNew = byteBuffer.slice();</div><div class="line">            byteBufferNew.limit(size);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelectMappedBufferResult(<span class="keyword">this</span>.fileFromOffset + pos, byteBufferNew, size, <span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>MappedFile#shutdown</em></strong></p>
<p>MappedFile文件销毁的实现方法为public boolean destory(long intervalForcibly)，intervalForcibly表示拒绝被销毁的最大存活时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> intervalForcibly)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.available) &#123;</div><div class="line">        <span class="comment">//关闭MapedFile</span></div><div class="line">        <span class="keyword">this</span>.available = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//设置当前关闭时间戳</span></div><div class="line">        <span class="keyword">this</span>.firstShutdownTimestamp = System.currentTimeMillis();</div><div class="line">        <span class="comment">//释放资源</span></div><div class="line">        <span class="keyword">this</span>.release();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getRefCount() &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((System.currentTimeMillis() - <span class="keyword">this</span>.firstShutdownTimestamp) &gt;= intervalForcibly) &#123;</div><div class="line">            <span class="keyword">this</span>.refCount.set(-<span class="number">1000</span> - <span class="keyword">this</span>.getRefCount());</div><div class="line">            <span class="keyword">this</span>.release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3）TransientStorePool"><a href="#3）TransientStorePool" class="headerlink" title="3）TransientStorePool"></a>3）TransientStorePool</h4><p>短暂的存储池。RocketMQ单独创建一个MappedByteBuffer内存缓存池，用来临时存储数据，数据先写入该内存映射中，然后由commit线程定时将数据从该内存复制到与目标物理文件对应的内存映射中。RocketMQ引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/TransientStorePool.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;		<span class="comment">//availableBuffers个数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fileSize;		<span class="comment">//每隔ByteBuffer大小</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; availableBuffers;	<span class="comment">//ByteBuffer容器。双端队列</span></div></pre></td></tr></table></figure>
<p><strong><em>初始化</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//创建poolSize个堆外内存</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</div><div class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(fileSize);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> address = ((DirectBuffer) byteBuffer).address();</div><div class="line">        Pointer pointer = <span class="keyword">new</span> Pointer(address);</div><div class="line">        <span class="comment">//使用com.sun.jna.Library类库将该批内存锁定,避免被置换到交换区,提高存储性能</span></div><div class="line">        LibC.INSTANCE.mlock(pointer, <span class="keyword">new</span> NativeLong(fileSize));</div><div class="line"></div><div class="line">        availableBuffers.offer(byteBuffer);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-4-5-实时更新消息消费队列与索引文件"><a href="#2-4-5-实时更新消息消费队列与索引文件" class="headerlink" title="2.4.5 实时更新消息消费队列与索引文件"></a>2.4.5 实时更新消息消费队列与索引文件</h3><p>消息消费队文件、消息属性索引文件都是基于CommitLog文件构建的，当消息生产者提交的消息存储在CommitLog文件中，ConsumerQueue、IndexFile需要及时更新，否则消息无法及时被消费，根据消息属性查找消息也会出现较大延迟。RocketMQ通过开启一个线程ReputMessageService来准实时转发CommitLog文件更新事件，相应的任务处理器根据转发的消息及时更新ConsumerQueue、IndexFile文件。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/消息存储结构.png" alt=""></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/构建消息消费队列和索引文件.png" alt=""></p>
<p><strong><em>代码：DefaultMessageStore：start</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//设置CommitLog内存中最大偏移量</span></div><div class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</div><div class="line"><span class="comment">//启动</span></div><div class="line"><span class="keyword">this</span>.reputMessageService.start();</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore：run</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</div><div class="line">	<span class="comment">//每隔1毫秒就继续尝试推送消息到消息消费队列和索引文件</span></div><div class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1</span>);</div><div class="line">            <span class="keyword">this</span>.doReput();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore：deReput</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//从result中循环遍历消息,一次读一条,创建DispatherRequest对象。</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</div><div class="line">	DispatchRequest dispatchRequest =                               DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">	<span class="keyword">int</span> size = dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</div><div class="line">	    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">	        DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>DispatchRequest</em></strong></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/DispatchRequest.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String topic; <span class="comment">//消息主题名称</span></div><div class="line"><span class="keyword">int</span> queueId;  <span class="comment">//消息队列ID</span></div><div class="line"><span class="keyword">long</span> commitLogOffset;	<span class="comment">//消息物理偏移量</span></div><div class="line"><span class="keyword">int</span> msgSize;	<span class="comment">//消息长度</span></div><div class="line"><span class="keyword">long</span> tagsCode;	<span class="comment">//消息过滤tag hashCode</span></div><div class="line"><span class="keyword">long</span> storeTimestamp;	<span class="comment">//消息存储时间戳</span></div><div class="line"><span class="keyword">long</span> consumeQueueOffset;	<span class="comment">//消息队列偏移量</span></div><div class="line">String keys;	<span class="comment">//消息索引key</span></div><div class="line"><span class="keyword">boolean</span> success;	<span class="comment">//是否成功解析到完整的消息</span></div><div class="line">String uniqKey;	<span class="comment">//消息唯一键</span></div><div class="line"><span class="keyword">int</span> sysFlag;	<span class="comment">//消息系统标记</span></div><div class="line"><span class="keyword">long</span> preparedTransactionOffset;	<span class="comment">//消息预处理事务偏移量</span></div><div class="line">Map&lt;String, String&gt; propertiesMap;	<span class="comment">//消息属性</span></div><div class="line"><span class="keyword">byte</span>[] bitMap;	<span class="comment">//位图</span></div></pre></td></tr></table></figure>
<h4 id="1）转发到ConsumerQueue"><a href="#1）转发到ConsumerQueue" class="headerlink" title="1）转发到ConsumerQueue"></a>1）转发到ConsumerQueue</h4><p><img src="/2019/12/03/RocketMQ-深入理解/消息分发到消息消费队列.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</div><div class="line">        <span class="keyword">switch</span> (tranType) &#123;</div><div class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class="line">                <span class="comment">//消息分发</span></div><div class="line">                DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#putMessagePositionInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> </span>&#123;</div><div class="line">    <span class="comment">//获得消费队列</span></div><div class="line">    ConsumeQueue cq = <span class="keyword">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</div><div class="line">    <span class="comment">//消费队列分发消息</span></div><div class="line">    cq.putMessagePositionInfoWrapper(dispatchRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#putMessagePositionInfo</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//依次将消息偏移量、消息长度、tag写入到ByteBuffer中</span></div><div class="line"><span class="keyword">this</span>.byteBufferIndex.flip();</div><div class="line"><span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</div><div class="line"><span class="keyword">this</span>.byteBufferIndex.putLong(offset);</div><div class="line"><span class="keyword">this</span>.byteBufferIndex.putInt(size);</div><div class="line"><span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</div><div class="line"><span class="comment">//获得内存映射文件</span></div><div class="line">MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</div><div class="line"><span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//将消息追加到内存映射文件,异步输盘</span></div><div class="line">    <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2）转发到Index"><a href="#2）转发到Index" class="headerlink" title="2）转发到Index"></a>2）转发到Index</h4><p><img src="/2019/12/03/RocketMQ-深入理解/消息分发到索引文件.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</div><div class="line">            DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#buildIndex</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(DispatchRequest req)</span> </span>&#123;</div><div class="line">    <span class="comment">//获得索引文件</span></div><div class="line">    IndexFile indexFile = retryGetAndCreateIndexFile();</div><div class="line">    <span class="keyword">if</span> (indexFile != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//获得文件最大物理偏移量</span></div><div class="line">        <span class="keyword">long</span> endPhyOffset = indexFile.getEndPhyOffset();</div><div class="line">        DispatchRequest msg = req;</div><div class="line">        String topic = msg.getTopic();</div><div class="line">        String keys = msg.getKeys();</div><div class="line">        <span class="comment">//如果该消息的物理偏移量小于索引文件中的最大物理偏移量,则说明是重复数据,忽略本次索引构建</span></div><div class="line">        <span class="keyword">if</span> (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</div><div class="line">        <span class="keyword">switch</span> (tranType) &#123;</div><div class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">		</div><div class="line">        <span class="comment">//如果消息ID不为空,则添加到Hash索引中</span></div><div class="line">        <span class="keyword">if</span> (req.getUniqKey() != <span class="keyword">null</span>) &#123;</div><div class="line">            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</div><div class="line">            <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">		<span class="comment">//构建索引key,RocketMQ支持为同一个消息建立多个索引,多个索引键空格隔开.</span></div><div class="line">        <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</div><div class="line">                String key = keyset[i];</div><div class="line">                <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    indexFile = putKey(indexFile, msg, buildKey(topic, key));</div><div class="line">                    <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        log.error(<span class="string">"build index error, stop building index"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-4-6-消息队列和索引文件恢复"><a href="#2-4-6-消息队列和索引文件恢复" class="headerlink" title="2.4.6 消息队列和索引文件恢复"></a>2.4.6 消息队列和索引文件恢复</h3><p>由于RocketMQ存储首先将消息全量存储在CommitLog文件中，然后异步生成转发任务更新ConsumerQueue和Index文件。如果消息成功存储到CommitLog文件中，转发任务未成功执行，此时消息服务器Broker由于某个愿意宕机，导致CommitLog、ConsumerQueue、IndexFile文件数据不一致。如果不加以人工修复的话，会有一部分消息即便在CommitLog中文件中存在，但由于没有转发到ConsumerQueue，这部分消息将永远复发被消费者消费。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/文件恢复总体流程.png" alt=""></p>
<p>####1）存储文件加载</p>
<p><strong><em>代码：DefaultMessageStore#load</em></strong></p>
<p>判断上一次是否异常退出。实现机制是Broker在启动时创建abort文件，在退出时通过JVM钩子函数删除abort文件。如果下次启动时存在abort文件。说明Broker时异常退出的，CommitLog与ConsumerQueue数据有可能不一致，需要进行修复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断临时文件是否存在</span></div><div class="line"><span class="keyword">boolean</span> lastExitOK = !<span class="keyword">this</span>.isTempFileExist();</div><div class="line"><span class="comment">//根据临时文件判断当前Broker是否异常退出</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTempFileExist</span><span class="params">()</span> </span>&#123;</div><div class="line">    String fileName = StorePathConfigHelper</div><div class="line">        .getAbortFile(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir());</div><div class="line">    File file = <span class="keyword">new</span> File(fileName);</div><div class="line">    <span class="keyword">return</span> file.exists();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#load</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//加载延时队列</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != scheduleMessageService) &#123;</div><div class="line">    result = result &amp;&amp; <span class="keyword">this</span>.scheduleMessageService.load();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 加载CommitLog文件</span></div><div class="line">result = result &amp;&amp; <span class="keyword">this</span>.commitLog.load();</div><div class="line"></div><div class="line"><span class="comment">// 加载消费队列文件</span></div><div class="line">result = result &amp;&amp; <span class="keyword">this</span>.loadConsumeQueue();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (result) &#123;</div><div class="line">	<span class="comment">//加载存储监测点,监测点主要记录CommitLog文件、ConsumerQueue文件、Index索引文件的刷盘点</span></div><div class="line">    <span class="keyword">this</span>.storeCheckpoint =<span class="keyword">new</span> StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</div><div class="line">	<span class="comment">//加载index文件</span></div><div class="line">    <span class="keyword">this</span>.indexService.load(lastExitOK);</div><div class="line">	<span class="comment">//根据Broker是否异常退出,执行不同的恢复策略</span></div><div class="line">    <span class="keyword">this</span>.recover(lastExitOK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MappedFileQueue#load</em></strong></p>
<p>加载CommitLog到映射文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//指向CommitLog文件目录</span></div><div class="line">File dir = <span class="keyword">new</span> File(<span class="keyword">this</span>.storePath);</div><div class="line"><span class="comment">//获得文件数组</span></div><div class="line">File[] files = dir.listFiles();</div><div class="line"><span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// 文件排序</span></div><div class="line">    Arrays.sort(files);</div><div class="line">    <span class="comment">//遍历文件</span></div><div class="line">    <span class="keyword">for</span> (File file : files) &#123;</div><div class="line">		<span class="comment">//如果文件大小和配置文件不一致,退出</span></div><div class="line">        <span class="keyword">if</span> (file.length() != <span class="keyword">this</span>.mappedFileSize) &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//创建映射文件</span></div><div class="line">            MappedFile mappedFile = <span class="keyword">new</span> MappedFile(file.getPath(), mappedFileSize);</div><div class="line">            mappedFile.setWrotePosition(<span class="keyword">this</span>.mappedFileSize);</div><div class="line">            mappedFile.setFlushedPosition(<span class="keyword">this</span>.mappedFileSize);</div><div class="line">            mappedFile.setCommittedPosition(<span class="keyword">this</span>.mappedFileSize);</div><div class="line">            <span class="comment">//将映射文件添加到队列</span></div><div class="line">            <span class="keyword">this</span>.mappedFiles.add(mappedFile);</div><div class="line">            log.info(<span class="string">"load "</span> + file.getPath() + <span class="string">" OK"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            log.error(<span class="string">"load file "</span> + file + <span class="string">" error"</span>, e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#loadConsumeQueue</em></strong></p>
<p>加载消息消费队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//执行消费队列目录</span></div><div class="line">File dirLogic = <span class="keyword">new</span> File(StorePathConfigHelper.getStorePathConsumeQueue(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</div><div class="line"><span class="comment">//遍历消费队列目录</span></div><div class="line">File[] fileTopicList = dirLogic.listFiles();</div><div class="line"><span class="keyword">if</span> (fileTopicList != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (File fileTopic : fileTopicList) &#123;</div><div class="line">        <span class="comment">//获得子目录名称,即topic名称</span></div><div class="line">        String topic = fileTopic.getName();</div><div class="line">		<span class="comment">//遍历子目录下的消费队列文件</span></div><div class="line">        File[] fileQueueIdList = fileTopic.listFiles();</div><div class="line">        <span class="keyword">if</span> (fileQueueIdList != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//遍历文件</span></div><div class="line">            <span class="keyword">for</span> (File fileQueueId : fileQueueIdList) &#123;</div><div class="line">                <span class="comment">//文件名称即队列ID</span></div><div class="line">                <span class="keyword">int</span> queueId;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    queueId = Integer.parseInt(fileQueueId.getName());</div><div class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//创建消费队列并加载到内存</span></div><div class="line">                ConsumeQueue logic = <span class="keyword">new</span> ConsumeQueue(</div><div class="line">                    topic,</div><div class="line">                    queueId,</div><div class="line">                    StorePathConfigHelper.getStorePathConsumeQueue(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()),</div><div class="line">            <span class="keyword">this</span>.getMessageStoreConfig().getMapedFileSizeConsumeQueue(),</div><div class="line">                    <span class="keyword">this</span>);</div><div class="line">                <span class="keyword">this</span>.putConsumeQueue(topic, queueId, logic);</div><div class="line">                <span class="keyword">if</span> (!logic.load()) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">log.info(<span class="string">"load logics queue all over, OK"</span>);</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
<p><strong><em>代码：IndexService#load</em></strong></p>
<p>加载索引文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</div><div class="line">    <span class="comment">//索引文件目录</span></div><div class="line">    File dir = <span class="keyword">new</span> File(<span class="keyword">this</span>.storePath);</div><div class="line">    <span class="comment">//遍历索引文件</span></div><div class="line">    File[] files = dir.listFiles();</div><div class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//文件排序</span></div><div class="line">        Arrays.sort(files);</div><div class="line">        <span class="comment">//遍历文件</span></div><div class="line">        <span class="keyword">for</span> (File file : files) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//加载索引文件</span></div><div class="line">                IndexFile f = <span class="keyword">new</span> IndexFile(file.getPath(), <span class="keyword">this</span>.hashSlotNum, <span class="keyword">this</span>.indexNum, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">                f.load();</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!lastExitOK) &#123;</div><div class="line">                    <span class="comment">//索引文件上次的刷盘时间小于该索引文件的消息时间戳,该文件将立即删除</span></div><div class="line">                    <span class="keyword">if</span> (f.getEndTimestamp() &gt; <span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint()</div><div class="line">                        .getIndexMsgTimestamp()) &#123;</div><div class="line">                        f.destroy(<span class="number">0</span>);</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">				<span class="comment">//将索引文件添加到队列</span></div><div class="line">                log.info(<span class="string">"load index file OK, "</span> + f.getFileName());</div><div class="line">                <span class="keyword">this</span>.indexFileList.add(f);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                log.error(<span class="string">"load file &#123;&#125; error"</span>, file, e);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</div><div class="line">                log.error(<span class="string">"load file &#123;&#125; error"</span>, file, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#recover</em></strong></p>
<p>文件恢复，根据Broker是否正常退出执行不同的恢复策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</div><div class="line">    <span class="comment">//获得最大的物理便宜消费队列</span></div><div class="line">    <span class="keyword">long</span> maxPhyOffsetOfConsumeQueue = <span class="keyword">this</span>.recoverConsumeQueue();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (lastExitOK) &#123;</div><div class="line">        <span class="comment">//正常恢复</span></div><div class="line">        <span class="keyword">this</span>.commitLog.recoverNormally(maxPhyOffsetOfConsumeQueue);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//异常恢复</span></div><div class="line">        <span class="keyword">this</span>.commitLog.recoverAbnormally(maxPhyOffsetOfConsumeQueue);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//在CommitLog中保存每个消息消费队列当前的存储逻辑偏移量</span></div><div class="line">    <span class="keyword">this</span>.recoverTopicQueueTable();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#recoverTopicQueueTable</em></strong></p>
<p>恢复ConsumerQueue后，将在CommitLog实例中保存每隔消息队列当前的存储逻辑偏移量，这也是消息中不仅存储主题、消息队列ID、还存储了消息队列的关键所在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTopicQueueTable</span><span class="params">()</span> </span>&#123;</div><div class="line">    HashMap&lt;String<span class="comment">/* topic-queueid */</span>, Long<span class="comment">/* offset */</span>&gt; table = <span class="keyword">new</span> HashMap&lt;String, Long&gt;(<span class="number">1024</span>);</div><div class="line">    <span class="comment">//CommitLog最小偏移量</span></div><div class="line">    <span class="keyword">long</span> minPhyOffset = <span class="keyword">this</span>.commitLog.getMinOffset();</div><div class="line">    <span class="comment">//遍历消费队列,将消费队列保存在CommitLog中</span></div><div class="line">    <span class="keyword">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : <span class="keyword">this</span>.consumeQueueTable.values()) &#123;</div><div class="line">        <span class="keyword">for</span> (ConsumeQueue logic : maps.values()) &#123;</div><div class="line">            String key = logic.getTopic() + <span class="string">"-"</span> + logic.getQueueId();</div><div class="line">            table.put(key, logic.getMaxOffsetInQueue());</div><div class="line">            logic.correctMinOffset(minPhyOffset);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.commitLog.setTopicQueueTable(table);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####2）正常恢复</p>
<p><strong><em>代码：CommitLog#recoverNormally</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverNormally</span><span class="params">(<span class="keyword">long</span> maxPhyOffsetOfConsumeQueue)</span> </span>&#123;</div><div class="line">	</div><div class="line">    <span class="keyword">final</span> List&lt;MappedFile&gt; mappedFiles = <span class="keyword">this</span>.mappedFileQueue.getMappedFiles();</div><div class="line">    <span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</div><div class="line">         <span class="comment">//Broker正常停止再重启时,从倒数第三个开始恢复,如果不足3个文件,则从第一个文件开始恢复。</span></div><div class="line">        <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">3</span>;</div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</div><div class="line">            index = <span class="number">0</span>;</div><div class="line">        MappedFile mappedFile = mappedFiles.get(index);</div><div class="line">        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();</div><div class="line">        <span class="keyword">long</span> processOffset = mappedFile.getFileFromOffset();</div><div class="line">        <span class="comment">//代表当前已校验通过的offset</span></div><div class="line">        <span class="keyword">long</span> mappedFileOffset = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">//查找消息</span></div><div class="line">            DispatchRequest dispatchRequest = <span class="keyword">this</span>.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);</div><div class="line">            <span class="comment">//消息长度</span></div><div class="line">            <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</div><div class="line">           	<span class="comment">//查找结果为true,并且消息长度大于0,表示消息正确.mappedFileOffset向前移动本消息长度</span></div><div class="line">            <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">                mappedFileOffset += size;</div><div class="line">            &#125;</div><div class="line">			<span class="comment">//如果查找结果为true且消息长度等于0,表示已到该文件末尾,如果还有下一个文件,则重置processOffset和MappedFileOffset重复查找下一个文件,否则跳出循环。</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size == <span class="number">0</span>) &#123;</div><div class="line">              index++;</div><div class="line">              <span class="keyword">if</span> (index &gt;= mappedFiles.size()) &#123;</div><div class="line">                  <span class="comment">// Current branch can not happen</span></div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">//取出每个文件</span></div><div class="line">                  mappedFile = mappedFiles.get(index);</div><div class="line">                  byteBuffer = mappedFile.sliceByteBuffer();</div><div class="line">                  processOffset = mappedFile.getFileFromOffset();</div><div class="line">                  mappedFileOffset = <span class="number">0</span>;</div><div class="line">                  </div><div class="line">          		&#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 查找结果为false，表明该文件未填满所有消息，跳出循环，结束循环</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</div><div class="line">                log.info(<span class="string">"recover physics file end, "</span> + mappedFile.getFileName());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">		<span class="comment">//更新MappedFileQueue的flushedWhere和committedWhere指针</span></div><div class="line">        processOffset += mappedFileOffset;</div><div class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</div><div class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</div><div class="line">        <span class="comment">//删除offset之后的所有文件</span></div><div class="line">        <span class="keyword">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</div><div class="line"></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (maxPhyOffsetOfConsumeQueue &gt;= processOffset) &#123;</div><div class="line">            <span class="keyword">this</span>.defaultMessageStore.truncateDirtyLogicFiles(processOffset);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</div><div class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</div><div class="line">        <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MappedFileQueue#truncateDirtyFiles</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">truncateDirtyFiles</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</div><div class="line">    List&lt;MappedFile&gt; willRemoveFiles = <span class="keyword">new</span> ArrayList&lt;MappedFile&gt;();</div><div class="line">	<span class="comment">//遍历目录下文件</span></div><div class="line">    <span class="keyword">for</span> (MappedFile file : <span class="keyword">this</span>.mappedFiles) &#123;</div><div class="line">        <span class="comment">//文件尾部的偏移量</span></div><div class="line">        <span class="keyword">long</span> fileTailOffset = file.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize;</div><div class="line">        <span class="comment">//文件尾部的偏移量大于offset</span></div><div class="line">        <span class="keyword">if</span> (fileTailOffset &gt; offset) &#123;</div><div class="line">            <span class="comment">//offset大于文件的起始偏移量</span></div><div class="line">            <span class="keyword">if</span> (offset &gt;= file.getFileFromOffset()) &#123;</div><div class="line">                <span class="comment">//更新wrotePosition、committedPosition、flushedPosistion</span></div><div class="line">                file.setWrotePosition((<span class="keyword">int</span>) (offset % <span class="keyword">this</span>.mappedFileSize));</div><div class="line">                file.setCommittedPosition((<span class="keyword">int</span>) (offset % <span class="keyword">this</span>.mappedFileSize));</div><div class="line">                file.setFlushedPosition((<span class="keyword">int</span>) (offset % <span class="keyword">this</span>.mappedFileSize));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//offset小于文件的起始偏移量,说明该文件是有效文件后面创建的,释放mappedFile占用内存,删除文件</span></div><div class="line">                file.destroy(<span class="number">1000</span>);</div><div class="line">                willRemoveFiles.add(file);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.deleteExpiredFile(willRemoveFiles);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####3）异常恢复</p>
<p>Broker异常停止文件恢复的实现为CommitLog#recoverAbnormally。异常文件恢复步骤与正常停止文件恢复流程基本相同，其主要差别有两个。首先，正常停止默认从倒数第三个文件开始进行恢复，而异常停止则需要从最后一个文件往前走，找到第一个消息存储正常的文件。其次，如果CommitLog目录没有消息文件，如果消息消费队列目录下存在文件，则需要销毁。</p>
<p><strong><em>代码：CommitLog#recoverAbnormally</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</div><div class="line">    <span class="comment">// Looking beginning to recover from which file</span></div><div class="line">    <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">1</span>;</div><div class="line">    MappedFile mappedFile = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span>; index--) &#123;</div><div class="line">        mappedFile = mappedFiles.get(index);</div><div class="line">        <span class="comment">//判断消息文件是否是一个正确的文件</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isMappedFileMatchedRecover(mappedFile)) &#123;</div><div class="line">            log.info(<span class="string">"recover from this mapped file "</span> + mappedFile.getFileName());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//根据索引取出mappedFile文件</span></div><div class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">        index = <span class="number">0</span>;</div><div class="line">        mappedFile = mappedFiles.get(index);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//...验证消息的合法性,并将消息转发到消息消费队列和索引文件</span></div><div class="line">       </div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//未找到mappedFile,重置flushWhere、committedWhere都为0，销毁消息队列文件</span></div><div class="line">    <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</div><div class="line">    <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</div><div class="line">    <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-4-7-刷盘机制"><a href="#2-4-7-刷盘机制" class="headerlink" title="2.4.7 刷盘机制"></a>2.4.7 刷盘机制</h3><p>RocketMQ的存储是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘。</p>
<h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h4><p>消息追加到内存后，立即将数据刷写到磁盘文件</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/同步刷盘流程.png" alt=""></p>
<p><strong><em>代码：CommitLog#handleDiskFlush</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//刷盘服务</span></div><div class="line"><span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</div><div class="line"><span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</div><div class="line">    <span class="comment">//封装刷盘请求</span></div><div class="line">    GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</div><div class="line">    <span class="comment">//提交刷盘请求</span></div><div class="line">    service.putRequest(request);</div><div class="line">    <span class="comment">//线程阻塞5秒，等待刷盘结束</span></div><div class="line">    <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</div><div class="line">    <span class="keyword">if</span> (!flushOK) &#123;</div><div class="line">        putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong><em>GroupCommitRequest</em></strong></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/GroupCommitRequest.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">long</span> nextOffset;	<span class="comment">//刷盘点偏移量</span></div><div class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);	<span class="comment">//倒计树锁存器</span></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;	<span class="comment">//刷盘结果;默认为false</span></div></pre></td></tr></table></figure>
<p><strong><em>代码：GroupCommitService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//线程等待10ms</span></div><div class="line">            <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</div><div class="line">            <span class="comment">//执行提交</span></div><div class="line">            <span class="keyword">this</span>.doCommit();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：GroupCommitService#doCommit</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</div><div class="line">            <span class="comment">//遍历requestsRead</span></div><div class="line">            <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</div><div class="line">                <span class="comment">// There may be a message in the next file, so a maximum of</span></div><div class="line">                <span class="comment">// two times the flush</span></div><div class="line">                <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</div><div class="line">                    flushOK = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</div><div class="line">					<span class="comment">//刷盘</span></div><div class="line">                    <span class="keyword">if</span> (!flushOK) &#123;</div><div class="line">                        CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">				<span class="comment">//唤醒发送消息客户端</span></div><div class="line">                req.wakeupCustomer(flushOK);</div><div class="line">            &#125;</div><div class="line">			</div><div class="line">            <span class="comment">//更新刷盘监测点</span></div><div class="line">            <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</div><div class="line">            <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;               CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</div><div class="line">            &#125;</div><div class="line">			</div><div class="line">            <span class="keyword">this</span>.requestsRead.clear();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Because of individual messages is set to not sync flush, it</span></div><div class="line">            <span class="comment">// will come to this process</span></div><div class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><p>在消息追加到内存后，立即返回给消息发送端。如果开启transientStorePoolEnable，RocketMQ会单独申请一个与目标物理文件（commitLog）同样大小的堆外内存，该堆外内存将使用内存锁定，确保不会被置换到虚拟内存中去，消息首先追加到堆外内存，然后提交到物理文件的内存映射中，然后刷写到磁盘。如果未开启transientStorePoolEnable，消息直接追加到物理文件直接映射文件中，然后刷写到磁盘中。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/异步刷盘流程.png" alt=""></p>
<p>开启transientStorePoolEnable后异步刷盘步骤:</p>
<ol>
<li>将消息直接追加到ByteBuffer（堆外内存）</li>
<li>CommitRealTimeService线程每隔200ms将ByteBuffer新追加内容提交到MappedByteBuffer中</li>
<li>MappedByteBuffer在内存中追加提交的内容，wrotePosition指针向后移动</li>
<li>commit操作成功返回，将committedPosition位置恢复</li>
<li>FlushRealTimeService线程默认每500ms将MappedByteBuffer中新追加的内存刷写到磁盘</li>
</ol>
<p><strong><em>代码：CommitLog$CommitRealTimeService#run</em></strong></p>
<p>提交线程工作机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//间隔时间,默认200ms</span></div><div class="line"><span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();</div><div class="line"></div><div class="line"><span class="comment">//一次提交的至少页数</span></div><div class="line"><span class="keyword">int</span> commitDataLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();</div><div class="line"></div><div class="line"><span class="comment">//两次真实提交的最大间隔,默认200ms</span></div><div class="line"><span class="keyword">int</span> commitDataThoroughInterval =</div><div class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();</div><div class="line"></div><div class="line"><span class="comment">//上次提交间隔超过commitDataThoroughInterval,则忽略提交commitDataThoroughInterval参数,直接提交</span></div><div class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</div><div class="line"><span class="keyword">if</span> (begin &gt;= (<span class="keyword">this</span>.lastCommitTimestamp + commitDataThoroughInterval)) &#123;</div><div class="line">    <span class="keyword">this</span>.lastCommitTimestamp = begin;</div><div class="line">    commitDataLeastPages = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//执行提交操作,将待提交数据提交到物理文件的内存映射区</span></div><div class="line"><span class="keyword">boolean</span> result = CommitLog.<span class="keyword">this</span>.mappedFileQueue.commit(commitDataLeastPages);</div><div class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line"><span class="keyword">if</span> (!result) &#123;</div><div class="line">    <span class="keyword">this</span>.lastCommitTimestamp = end; <span class="comment">// result = false means some data committed.</span></div><div class="line">    <span class="comment">//now wake up flush thread.</span></div><div class="line">    <span class="comment">//唤醒刷盘线程</span></div><div class="line">    flushCommitLogService.wakeup();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (end - begin &gt; <span class="number">500</span>) &#123;</div><div class="line">    log.info(<span class="string">"Commit data to file costs &#123;&#125; ms"</span>, end - begin);</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.waitForRunning(interval);</div></pre></td></tr></table></figure>
<p><strong><em>代码：CommitLog$FlushRealTimeService#run</em></strong></p>
<p>刷盘线程工作机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//表示await方法等待,默认false</span></div><div class="line"><span class="keyword">boolean</span> flushCommitLogTimed = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</div><div class="line"><span class="comment">//线程执行时间间隔</span></div><div class="line"><span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</div><div class="line"><span class="comment">//一次刷写任务至少包含页数</span></div><div class="line"><span class="keyword">int</span> flushPhysicQueueLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</div><div class="line"><span class="comment">//两次真实刷写任务最大间隔</span></div><div class="line"><span class="keyword">int</span> flushPhysicQueueThoroughInterval =</div><div class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</div><div class="line">...</div><div class="line"><span class="comment">//距离上次提交间隔超过flushPhysicQueueThoroughInterval,则本次刷盘任务将忽略flushPhysicQueueLeastPages,直接提交</span></div><div class="line"><span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</div><div class="line"><span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="keyword">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</div><div class="line">    <span class="keyword">this</span>.lastFlushTimestamp = currentTimeMillis;</div><div class="line">    flushPhysicQueueLeastPages = <span class="number">0</span>;</div><div class="line">    printFlushProgress = (printTimes++ % <span class="number">10</span>) == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="comment">//执行一次刷盘前,先等待指定时间间隔</span></div><div class="line"><span class="keyword">if</span> (flushCommitLogTimed) &#123;</div><div class="line">    Thread.sleep(interval);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.waitForRunning(interval);</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</div><div class="line"><span class="comment">//刷写磁盘</span></div><div class="line">CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</div><div class="line"><span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</div><div class="line"><span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">//更新存储监测点文件的时间戳</span></div><div class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</div></pre></td></tr></table></figure>
<h3 id="2-4-8-过期文件删除机制"><a href="#2-4-8-过期文件删除机制" class="headerlink" title="2.4.8 过期文件删除机制"></a>2.4.8 过期文件删除机制</h3><p>由于RocketMQ操作CommitLog、ConsumerQueue文件是基于内存映射机制并在启动的时候回加载CommitLog、ConsumerQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久存储在消息服务器上，所以要引入一种机制来删除已过期的文件。RocketMQ顺序写CommitLog、ConsumerQueue文件，所有写操作全部落在最后一个CommitLog或者ConsumerQueue文件上，之前的文件在下一个文件创建后将不会再被更新。RocketMQ清除过期文件的方法时：如果当前文件在在一定时间间隔内没有再次被消费，则认为是过期文件，可以被删除，RocketMQ不会关注这个文件上的消息是否全部被消费。默认每个文件的过期时间为72小时，通过在Broker配置文件中设置fileReservedTime来改变过期时间，单位为小时。</p>
<p><strong><em>代码：DefaultMessageStore#addScheduleTask</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addScheduleTask</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//每隔10s调度一次清除文件</span></div><div class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            DefaultMessageStore.<span class="keyword">this</span>.cleanFilesPeriodically();</div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="number">1000</span> * <span class="number">60</span>, <span class="keyword">this</span>.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#cleanFilesPeriodically</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanFilesPeriodically</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//清除存储文件</span></div><div class="line">    <span class="keyword">this</span>.cleanCommitLogService.run();</div><div class="line">    <span class="comment">//清除消息消费队列文件</span></div><div class="line">    <span class="keyword">this</span>.cleanConsumeQueueService.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#deleteExpiredFiles</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteExpiredFiles</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//删除的数量</span></div><div class="line">    <span class="keyword">int</span> deleteCount = <span class="number">0</span>;</div><div class="line">    <span class="comment">//文件保留的时间</span></div><div class="line">    <span class="keyword">long</span> fileReservedTime = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getFileReservedTime();</div><div class="line">    <span class="comment">//删除物理文件的间隔</span></div><div class="line">    <span class="keyword">int</span> deletePhysicFilesInterval = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDeleteCommitLogFilesInterval();</div><div class="line">    <span class="comment">//线程被占用,第一次拒绝删除后能保留的最大时间,超过该时间,文件将被强制删除</span></div><div class="line">    <span class="keyword">int</span> destroyMapedFileIntervalForcibly = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly();</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> timeup = <span class="keyword">this</span>.isTimeToDelete();</div><div class="line"><span class="keyword">boolean</span> spacefull = <span class="keyword">this</span>.isSpaceToDelete();</div><div class="line"><span class="keyword">boolean</span> manualDelete = <span class="keyword">this</span>.manualDeleteFileSeveralTimes &gt; <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (timeup || spacefull || manualDelete) &#123;</div><div class="line">	...执行删除逻辑</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    ...无作为</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除文件操作的条件</p>
<ol>
<li>指定删除文件的时间点，RocketMQ通过deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认4点</li>
<li>磁盘空间如果不充足，删除过期文件</li>
<li>预留，手工触发。</li>
</ol>
<p><strong><em>代码：CleanCommitLogService#isSpaceToDelete</em></strong></p>
<p>当磁盘空间不足时执行删除过期文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSpaceToDelete</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//磁盘分区的最大使用量</span></div><div class="line">    <span class="keyword">double</span> ratio = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDiskMaxUsedSpaceRatio() / <span class="number">100.0</span>;</div><div class="line">	<span class="comment">//是否需要立即执行删除过期文件操作</span></div><div class="line">    cleanImmediately = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        String storePathPhysic = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getStorePathCommitLog();</div><div class="line">        <span class="comment">//当前CommitLog目录所在的磁盘分区的磁盘使用率</span></div><div class="line">        <span class="keyword">double</span> physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);</div><div class="line">        <span class="comment">//diskSpaceWarningLevelRatio:磁盘使用率警告阈值,默认0.90</span></div><div class="line">        <span class="keyword">if</span> (physicRatio &gt; diskSpaceWarningLevelRatio) &#123;</div><div class="line">            <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskFull();</div><div class="line">            <span class="keyword">if</span> (diskok) &#123;</div><div class="line">                DefaultMessageStore.log.error(<span class="string">"physic disk maybe full soon "</span> + physicRatio + <span class="string">", so mark disk full"</span>);</div><div class="line">            &#125;</div><div class="line">			<span class="comment">//diskSpaceCleanForciblyRatio:强制清除阈值,默认0.85</span></div><div class="line">            cleanImmediately = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (physicRatio &gt; diskSpaceCleanForciblyRatio) &#123;</div><div class="line">            cleanImmediately = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskOK();</div><div class="line">            <span class="keyword">if</span> (!diskok) &#123;</div><div class="line">            DefaultMessageStore.log.info(<span class="string">"physic disk space OK "</span> + physicRatio + <span class="string">", so mark disk ok"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (physicRatio &lt; <span class="number">0</span> || physicRatio &gt; ratio) &#123;</div><div class="line">        DefaultMessageStore.log.info(<span class="string">"physic disk maybe full soon, so reclaim space, "</span> + physicRatio);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MappedFileQueue#deleteExpiredFileByTime</em></strong></p>
<p>执行文件销毁和删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mfsLength; i++) &#123;</div><div class="line">    <span class="comment">//遍历每隔文件</span></div><div class="line">    MappedFile mappedFile = (MappedFile) mfs[i];</div><div class="line">    <span class="comment">//计算文件存活时间</span></div><div class="line">    <span class="keyword">long</span> liveMaxTimestamp = mappedFile.getLastModifiedTimestamp() + expiredTime;</div><div class="line">    <span class="comment">//如果超过72小时,执行文件删除</span></div><div class="line">    <span class="keyword">if</span> (System.currentTimeMillis() &gt;= liveMaxTimestamp || cleanImmediately) &#123;</div><div class="line">        <span class="keyword">if</span> (mappedFile.destroy(intervalForcibly)) &#123;</div><div class="line">            files.add(mappedFile);</div><div class="line">            deleteCount++;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (files.size() &gt;= DELETE_FILES_BATCH_MAX) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (deleteFilesInterval &gt; <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) &lt; mfsLength) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(deleteFilesInterval);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//avoid deleting files in the middle</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-4-9-小结"><a href="#2-4-9-小结" class="headerlink" title="2.4.9 小结"></a>2.4.9 小结</h3><p>RocketMQ的存储文件包括消息文件（Commitlog）、消息消费队列文件（ConsumerQueue）、Hash索引文件（IndexFile）、监测点文件（checkPoint）、abort（关闭异常文件）。单个消息存储文件、消息消费队列文件、Hash索引文件长度固定以便使用内存映射机制进行文件的读写操作。RocketMQ组织文件以文件的起始偏移量来命令文件，这样根据偏移量能快速定位到真实的物理文件。RocketMQ基于内存映射文件机制提供了同步刷盘和异步刷盘两种机制，异步刷盘是指在消息存储时先追加到内存映射文件，然后启动专门的刷盘线程定时将内存中的文件数据刷写到磁盘。</p>
<p>CommitLog，消息存储文件，RocketMQ为了保证消息发送的高吞吐量，采用单一文件存储所有主题消息，保证消息存储是完全的顺序写，但这样给文件读取带来了不便，为此RocketMQ为了方便消息消费构建了消息消费队列文件，基于主题与队列进行组织，同时RocketMQ为消息实现了Hash索引，可以为消息设置索引键，根据所以能够快速从CommitLog文件中检索消息。</p>
<p>当消息达到CommitLog后，会通过ReputMessageService线程接近实时地将消息转发给消息消费队列文件与索引文件。为了安全起见，RocketMQ引入abort文件，记录Broker的停机是否是正常关闭还是异常关闭，在重启Broker时为了保证CommitLog文件，消息消费队列文件与Hash索引文件的正确性，分别采用不同策略来恢复文件。</p>
<p>RocketMQ不会永久存储消息文件、消息消费队列文件，而是启动文件过期机制并在磁盘空间不足或者默认凌晨4点删除过期文件，文件保存72小时并且在删除文件时并不会判断该消息文件上的消息是否被消费。</p>
<h2 id="2-5-Consumer"><a href="#2-5-Consumer" class="headerlink" title="2.5 Consumer"></a>2.5 Consumer</h2><h3 id="2-5-1-消息消费概述"><a href="#2-5-1-消息消费概述" class="headerlink" title="2.5.1 消息消费概述"></a>2.5.1 消息消费概述</h3><p>​    消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费者组可订阅多个主题，<strong>消费组之间有集群模式和广播模式两种消费模式</strong>。集群模式，主题下的同一条消息只允许被其中一个消费者消费。广播模式，主题下的同一条消息，将被集群内的所有消费者消费一次。消息服务器与消费者之间的消息传递也有两种模式：推模式、拉模式。所谓的拉模式，是消费端主动拉起拉消息请求，而推模式是消息达到消息服务器后，推送给消息消费者。RocketMQ消息推模式的实现基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务。</p>
<p>集群模式下，多个消费者如何对消息队列进行负载呢？消息队列负载机制遵循一个通用思想：一个消息队列同一个时间只允许被一个消费者消费，一个消费者可以消费多个消息队列。</p>
<p><strong>RocketMQ支持局部顺序消息消费，也就是保证同一个消息队列上的消息顺序消费。不支持消息全局顺序消费，如果要实现某一个主题的全局顺序消费，可以将该主题的队列数设置为1，牺牲高可用性。</strong></p>
<p>###2.5.2 消息消费初探</p>
<p><strong><u>消息推送模式</u></strong></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/消息推送.png" alt=""></p>
<p><strong><u>消息消费重要方法</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span>：发送消息确认</span></div><div class="line"><span class="function">Set&lt;MessageQueue&gt; <span class="title">fetchSubscribeMessageQueues</span><span class="params">(<span class="keyword">final</span> String topic)</span> :获取消费者对主题分配了那些消息队列</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerConcurrently messageListener)</span>：注册并发事件监听器</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerOrderly messageListener)</span>：注册顺序消息事件监听器</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String subExpression)</span>：基于主题订阅消息，消息过滤使用表达式</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String fullClassName,<span class="keyword">final</span> String filterClassSource)</span>：基于主题订阅消息，消息过滤使用类模式</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> MessageSelector selector)</span> ：订阅消息，并指定队列选择器</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="keyword">final</span> String topic)</span>：取消消息订阅</span></div></pre></td></tr></table></figure>
<p><strong><u>DefaultMQPushConsumer</u></strong></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/DefaultMQPushConsumer.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//消费者组</span></div><div class="line"><span class="keyword">private</span> String consumerGroup;	</div><div class="line"><span class="comment">//消息消费模式</span></div><div class="line"><span class="keyword">private</span> MessageModel messageModel = MessageModel.CLUSTERING;	</div><div class="line"><span class="comment">//指定消费开始偏移量（最大偏移量、最小偏移量、启动时间戳）开始消费</span></div><div class="line"><span class="keyword">private</span> ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</div><div class="line"><span class="comment">//集群模式下的消息队列负载策略</span></div><div class="line"><span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</div><div class="line"><span class="comment">//订阅信息</span></div><div class="line"><span class="keyword">private</span> Map&lt;String <span class="comment">/* topic */</span>, String <span class="comment">/* sub expression */</span>&gt; subscription = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line"><span class="comment">//消息业务监听器</span></div><div class="line"><span class="keyword">private</span> MessageListener messageListener;</div><div class="line"><span class="comment">//消息消费进度存储器</span></div><div class="line"><span class="keyword">private</span> OffsetStore offsetStore;</div><div class="line"><span class="comment">//消费者最小线程数量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMin = <span class="number">20</span>;</div><div class="line"><span class="comment">//消费者最大线程数量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMax = <span class="number">20</span>;</div><div class="line"><span class="comment">//并发消息消费时处理队列最大跨度</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeConcurrentlyMaxSpan = <span class="number">2000</span>;</div><div class="line"><span class="comment">//每1000次流控后打印流控日志</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> pullThresholdForQueue = <span class="number">1000</span>;</div><div class="line"><span class="comment">//推模式下任务间隔时间</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> pullInterval = <span class="number">0</span>;</div><div class="line"><span class="comment">//推模式下任务拉取的条数,默认32条</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> pullBatchSize = <span class="number">32</span>;</div><div class="line"><span class="comment">//每次传入MessageListener#consumerMessage中消息的数量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeMessageBatchMaxSize = <span class="number">1</span>;</div><div class="line"><span class="comment">//是否每次拉取消息都订阅消息</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> postSubscriptionWhenPull = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//消息重试次数,-1代表16次</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxReconsumeTimes = -<span class="number">1</span>;</div><div class="line"><span class="comment">//消息消费超时时间</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> consumeTimeout = <span class="number">15</span>;</div></pre></td></tr></table></figure>
<h3 id="2-5-3-消费者启动流程"><a href="#2-5-3-消费者启动流程" class="headerlink" title="2.5.3 消费者启动流程"></a>2.5.3 消费者启动流程</h3><p><img src="/2019/12/03/RocketMQ-深入理解/消息消费启动流程.png" alt=""></p>
<p><strong><em>代码：DefaultMQPushConsumerImpl#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</div><div class="line">        <span class="keyword">case</span> CREATE_JUST:</div><div class="line">            </div><div class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</div><div class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</div><div class="line">			<span class="comment">//检查消息者是否合法</span></div><div class="line">            <span class="keyword">this</span>.checkConfig();</div><div class="line">			<span class="comment">//构建主题订阅信息</span></div><div class="line">            <span class="keyword">this</span>.copySubscription();</div><div class="line">			<span class="comment">//设置消费者客户端实例名称为进程ID</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</div><div class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</div><div class="line">            &#125;</div><div class="line">			<span class="comment">//创建MQClient实例</span></div><div class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</div><div class="line">			<span class="comment">//构建rebalanceImpl</span></div><div class="line">            <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</div><div class="line">            <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</div><div class="line">            <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</div><div class="line">            <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactor</div><div class="line">            <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</div><div class="line">                mQClientFactory,</div><div class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</div><div class="line">            <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookLis</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">           		<span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</div><div class="line">               </div><div class="line">           	  		  <span class="keyword">case</span> BROADCASTING:	 <span class="comment">//消息消费广播模式,将消费进度保存在本地</span></div><div class="line">           	       		 <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</div><div class="line">           	            <span class="keyword">break</span>;</div><div class="line">           	        <span class="keyword">case</span> CLUSTERING:	<span class="comment">//消息消费集群模式,将消费进度保存在远端Broker</span></div><div class="line">           	            <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</div><div class="line">           	            <span class="keyword">break</span>;</div><div class="line">           	        <span class="keyword">default</span>:</div><div class="line">           	            <span class="keyword">break</span>;</div><div class="line">           	    &#125;</div><div class="line">           	    <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</div><div class="line">           	&#125;</div><div class="line">            <span class="keyword">this</span>.offsetStore.load</div><div class="line">            <span class="comment">//创建顺序消息消费服务</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</div><div class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">this</span>.consumeMessageService =</div><div class="line">                    <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</div><div class="line">                <span class="comment">//创建并发消息消费服务</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</div><div class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">this</span>.consumeMessageService =</div><div class="line">                    <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//消息消费服务启动</span></div><div class="line">            <span class="keyword">this</span>.consumeMessageService.start();</div><div class="line">            <span class="comment">//注册消费者实例</span></div><div class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (!registerOK) &#123;</div><div class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</div><div class="line">                <span class="keyword">this</span>.consumeMessageService.shutdown();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</div><div class="line">                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</div><div class="line">                    <span class="keyword">null</span>);</div><div class="line">            <span class="comment">//启动消费者客户端</span></div><div class="line">            mQClientFactory.start();</div><div class="line">            log.info(<span class="string">"the consumer [&#123;&#125;] start OK."</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</div><div class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">            <span class="keyword">case</span> START_FAILED:</div><div class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The PushConsumer service state not OK, maybe started once, "</span></div><div class="line">                + <span class="keyword">this</span>.serviceState</div><div class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</div><div class="line">                <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</div><div class="line">    <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</div><div class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</div><div class="line">    <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-5-4-消息拉取"><a href="#2-5-4-消息拉取" class="headerlink" title="2.5.4 消息拉取"></a>2.5.4 消息拉取</h3><p>消息消费模式有两种模式：广播模式与集群模式。广播模式比较简单，每一个消费者需要拉取订阅主题下所有队列的消息。本文重点讲解集群模式。在集群模式下，同一个消费者组内有多个消息消费者，同一个主题存在多个消费队列，消费者通过负载均衡的方式消费消息。</p>
<p>消息队列负载均衡，通常的作法是一个消息队列在同一个时间只允许被一个消费消费者消费，一个消息消费者可以同时消费多个消息队列。</p>
<h4 id="1）PullMessageService实现机制"><a href="#1）PullMessageService实现机制" class="headerlink" title="1）PullMessageService实现机制"></a>1）PullMessageService实现机制</h4><p>从MQClientInstance的启动流程中可以看出，RocketMQ使用一个单独的线程PullMessageService来负责消息的拉取。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/pullMessageService实现机制.png" alt=""></p>
<p><strong><em>代码：PullMessageService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</div><div class="line">	<span class="comment">//循环拉取消息</span></div><div class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//从请求队列中获取拉取消息请求</span></div><div class="line">            PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</div><div class="line">            <span class="comment">//拉取消息</span></div><div class="line">            <span class="keyword">this</span>.pullMessage(pullRequest);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            log.error(<span class="string">"Pull Message Service Run Method exception"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u><strong>PullRequest</strong></u></p>
<p><img src="/2019/12/03/RocketMQ-深入理解/PullRequest.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> String consumerGroup;	<span class="comment">//消费者组</span></div><div class="line"><span class="keyword">private</span> MessageQueue messageQueue;	<span class="comment">//待拉取消息队列</span></div><div class="line"><span class="keyword">private</span> ProcessQueue processQueue;	<span class="comment">//消息处理队列</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> nextOffset;	<span class="comment">//待拉取的MessageQueue偏移量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> lockedFirst = <span class="keyword">false</span>;	<span class="comment">//是否被锁定</span></div></pre></td></tr></table></figure>
<p><strong><em>代码：PullMessageService#pullMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class="line">    <span class="comment">//获得消费者实例</span></div><div class="line">    <span class="keyword">final</span> MQConsumerInner consumer = <span class="keyword">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</div><div class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//强转为推送模式消费者 - 所以说，拉取方式本质上就是push模式的封装</span></div><div class="line">        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</div><div class="line">        <span class="comment">//推送消息</span></div><div class="line">        impl.pullMessage(pullRequest);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        log.warn(<span class="string">"No matched consumer for the PullRequest &#123;&#125;, drop it"</span>, pullRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####2）ProcessQueue实现机制</p>
<p>ProcessQueue是MessageQueue在消费端的重现、快照。PullMessageService从消息服务器默认每次拉取32条消息，按照消息的队列偏移量顺序存放在ProcessQueue中，PullMessageService然后将消息提交到消费者消费线程池，消息成功消费后从ProcessQueue中移除。</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/ProcessQueue.png" alt=""></p>
<p><strong><u>属性</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//消息容器</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</div><div class="line"><span class="comment">//读写锁</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lockTreeMap = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"><span class="comment">//ProcessQueue总消息树</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong msgCount = <span class="keyword">new</span> AtomicLong();</div><div class="line"><span class="comment">//ProcessQueue队列最大偏移量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> queueOffsetMax = <span class="number">0L</span>;</div><div class="line"><span class="comment">//当前ProcessQueue是否被丢弃</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> dropped = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//上一次拉取时间戳</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPullTimestamp = System.currentTimeMillis();</div><div class="line"><span class="comment">//上一次消费时间戳</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastConsumeTimestamp = System.currentTimeMillis();</div></pre></td></tr></table></figure>
<p><strong><u>方法</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//移除消费超时消息</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredMsg</span><span class="params">(DefaultMQPushConsumer pushConsumer)</span></span></div><div class="line"><span class="function"><span class="comment">//添加消息</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span></div><div class="line"><span class="function"><span class="comment">//获取消息最大间隔</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxSpan</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="comment">//移除消息</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span></div><div class="line"><span class="function"><span class="comment">//将consumingMsgOrderlyTreeMap中消息重新放在msgTreeMap,并清空consumingMsgOrderlyTreeMap   </span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span></div><div class="line"><span class="function"><span class="comment">//将consumingMsgOrderlyTreeMap消息清除,表示成功处理该批消息</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">commit</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="comment">//重新处理该批消息</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMessageToCosumeAgain</span><span class="params">(List&lt;MessageExt&gt; msgs)</span> </span></div><div class="line"><span class="function"><span class="comment">//从processQueue中取出batchSize条消息</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageExt&gt; <span class="title">takeMessags</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> batchSize)</span></span></div></pre></td></tr></table></figure>
<h4 id="3）消息拉取基本流程"><a href="#3）消息拉取基本流程" class="headerlink" title="3）消息拉取基本流程"></a>3）消息拉取基本流程</h4><p>#####1.客户端发起拉取请求</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/消息拉取基本流程.png" alt=""></p>
<p><strong><em>代码：DefaultMQPushConsumerImpl#pullMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class="line">    <span class="comment">//从pullRequest获得ProcessQueue</span></div><div class="line">    <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</div><div class="line">    <span class="comment">//如果处理队列被丢弃,直接返回</span></div><div class="line">    <span class="keyword">if</span> (processQueue.isDropped()) &#123;</div><div class="line">        log.info(<span class="string">"the pull request[&#123;&#125;] is dropped."</span>, pullRequest.toString());</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//如果处理队列未被丢弃,更新时间戳</span></div><div class="line">    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">this</span>.makeSureStateOK();</div><div class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</div><div class="line">        log.warn(<span class="string">"pullMessage exception, consumer state not ok"</span>, e);</div><div class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//如果处理队列被挂起,延迟1s后再执行</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPause()) &#123;</div><div class="line">        log.warn(<span class="string">"consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getInstanceName(), <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</div><div class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//获得最大待处理消息数量</span></div><div class="line">	<span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</div><div class="line">    <span class="comment">//获得最大待处理消息大小</span></div><div class="line">	<span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</div><div class="line">	<span class="comment">//从数量进行流控</span></div><div class="line">	<span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</div><div class="line">	    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</div><div class="line">	    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</div><div class="line">	        log.warn(</div><div class="line">	            <span class="string">"the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;"</span>,</div><div class="line">	            <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//从消息大小进行流控</span></div><div class="line">	<span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</div><div class="line">	    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</div><div class="line">	    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</div><div class="line">	        log.warn(</div><div class="line">	            <span class="string">"the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;"</span>,</div><div class="line">	            <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    	<span class="comment">//获得订阅信息</span></div><div class="line">		 <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</div><div class="line">    	<span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</div><div class="line">    	    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class="line">    	    log.warn(<span class="string">"find the consumer's subscription failed, &#123;&#125;"</span>, pullRequest);</div><div class="line">    	    <span class="keyword">return</span>;</div><div class="line">		<span class="comment">//与服务端交互,获取消息</span></div><div class="line">	    <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</div><div class="line">	    pullRequest.getMessageQueue(),</div><div class="line">	    subExpression,</div><div class="line">	    subscriptionData.getExpressionType(),</div><div class="line">	    subscriptionData.getSubVersion(),</div><div class="line">	    pullRequest.getNextOffset(),</div><div class="line">	    <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(),</div><div class="line">	    sysFlag,</div><div class="line">	    commitOffsetValue,</div><div class="line">	    BROKER_SUSPEND_MAX_TIME_MILLIS,</div><div class="line">	    CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</div><div class="line">	    CommunicationMode.ASYNC,</div><div class="line">	    pullCallback</div><div class="line">	);</div><div class="line">            </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####2.消息服务端Broker组装消息</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/消息服务端Broker组装消息.png" alt=""></p>
<p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//构建消息过滤器</span></div><div class="line">MessageFilter messageFilter;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</div><div class="line">    messageFilter = <span class="keyword">new</span> ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,</div><div class="line">        <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    messageFilter = <span class="keyword">new</span> ExpressionMessageFilter(subscriptionData, consumerFilterData,</div><div class="line">        <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用MessageStore.getMessage查找消息</span></div><div class="line"><span class="keyword">final</span> GetMessageResult getMessageResult =</div><div class="line">    <span class="keyword">this</span>.brokerController.getMessageStore().getMessage(</div><div class="line">    				requestHeader.getConsumerGroup(), <span class="comment">//消费组名称								</span></div><div class="line">    				requestHeader.getTopic(),	<span class="comment">//主题名称</span></div><div class="line">        			requestHeader.getQueueId(), <span class="comment">//队列ID</span></div><div class="line">    				requestHeader.getQueueOffset(), 	<span class="comment">//待拉取偏移量</span></div><div class="line">    				requestHeader.getMaxMsgNums(), 	<span class="comment">//最大拉取消息条数</span></div><div class="line">    				messageFilter	<span class="comment">//消息过滤器</span></div><div class="line">    		);</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore#getMessage</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</div><div class="line"><span class="keyword">long</span> nextBeginOffset = offset;	<span class="comment">//查找下一次队列偏移量</span></div><div class="line"><span class="keyword">long</span> minOffset = <span class="number">0</span>;		<span class="comment">//当前消息队列最小偏移量</span></div><div class="line"><span class="keyword">long</span> maxOffset = <span class="number">0</span>;		<span class="comment">//当前消息队列最大偏移量</span></div><div class="line">GetMessageResult getResult = <span class="keyword">new</span> GetMessageResult();</div><div class="line"><span class="keyword">final</span> <span class="keyword">long</span> maxOffsetPy = <span class="keyword">this</span>.commitLog.getMaxOffset();	<span class="comment">//当前commitLog最大偏移量</span></div><div class="line"><span class="comment">//根据主题名称和队列编号获取消息消费队列</span></div><div class="line">ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</div><div class="line"></div><div class="line">...</div><div class="line">minOffset = consumeQueue.getMinOffsetInQueue();</div><div class="line">maxOffset = consumeQueue.getMaxOffsetInQueue();</div><div class="line"><span class="comment">//消息偏移量异常情况校对下一次拉取偏移量</span></div><div class="line"><span class="keyword">if</span> (maxOffset == <span class="number">0</span>) &#123;	<span class="comment">//表示当前消息队列中没有消息</span></div><div class="line">    status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</div><div class="line">    nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; minOffset) &#123;	<span class="comment">//待拉取消息的偏移量小于队列的其实偏移量</span></div><div class="line">    status = GetMessageStatus.OFFSET_TOO_SMALL;</div><div class="line">    nextBeginOffset = nextOffsetCorrection(offset, minOffset);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset == maxOffset) &#123;	<span class="comment">//待拉取偏移量为队列最大偏移量</span></div><div class="line">    status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</div><div class="line">    nextBeginOffset = nextOffsetCorrection(offset, offset);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; maxOffset) &#123;	<span class="comment">//偏移量越界</span></div><div class="line">    status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == minOffset) &#123;</div><div class="line">        nextBeginOffset = nextOffsetCorrection(offset, minOffset);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="comment">//根据偏移量从CommitLog中拉取32条消息</span></div><div class="line">SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</div></pre></td></tr></table></figure>
<p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//根据拉取结果填充responseHeader</span></div><div class="line">response.setRemark(getMessageResult.getStatus().name());</div><div class="line">responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</div><div class="line">responseHeader.setMinOffset(getMessageResult.getMinOffset());</div><div class="line">responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</div><div class="line"></div><div class="line"><span class="comment">//判断如果存在主从同步慢,设置下一次拉取任务的ID为主节点</span></div><div class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</div><div class="line">    <span class="keyword">case</span> ASYNC_MASTER:</div><div class="line">    <span class="keyword">case</span> SYNC_MASTER:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> SLAVE:</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</div><div class="line">            response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class="line">            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="comment">//GetMessageResult与Response的Code转换</span></div><div class="line"><span class="keyword">switch</span> (getMessageResult.getStatus()) &#123;</div><div class="line">    <span class="keyword">case</span> FOUND:			<span class="comment">//成功</span></div><div class="line">        response.setCode(ResponseCode.SUCCESS);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MESSAGE_WAS_REMOVING:	<span class="comment">//消息存放在下一个commitLog中</span></div><div class="line">        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);	<span class="comment">//消息重试</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> NO_MATCHED_LOGIC_QUEUE:	<span class="comment">//未找到队列</span></div><div class="line">    <span class="keyword">case</span> NO_MESSAGE_IN_QUEUE:	<span class="comment">//队列中未包含消息</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> != requestHeader.getQueueOffset()) &#123;</div><div class="line">            response.setCode(ResponseCode.PULL_OFFSET_MOVED);</div><div class="line">            requestHeader.getQueueOffset(),</div><div class="line">            getMessageResult.getNextBeginOffset(),</div><div class="line">            requestHeader.getTopic(),</div><div class="line">            requestHeader.getQueueId(),</div><div class="line">            requestHeader.getConsumerGroup()</div><div class="line">            );</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            response.setCode(ResponseCode.PULL_NOT_FOUND);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> NO_MATCHED_MESSAGE:	<span class="comment">//未找到消息</span></div><div class="line">        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> OFFSET_FOUND_NULL:	<span class="comment">//消息物理偏移量为空</span></div><div class="line">        response.setCode(ResponseCode.PULL_NOT_FOUND);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> OFFSET_OVERFLOW_BADLY:	<span class="comment">//offset越界</span></div><div class="line">        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</div><div class="line">        <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></div><div class="line">        log.info(<span class="string">"the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;"</span>,</div><div class="line">                requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> OFFSET_OVERFLOW_ONE:	<span class="comment">//offset在队列中未找到</span></div><div class="line">        response.setCode(ResponseCode.PULL_NOT_FOUND);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> OFFSET_TOO_SMALL:	<span class="comment">//offset未在队列中</span></div><div class="line">        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</div><div class="line">        requestHeader.getConsumerGroup(), </div><div class="line">        requestHeader.getTopic(), </div><div class="line">        requestHeader.getQueueOffset(),</div><div class="line">        getMessageResult.getMinOffset(), channel.remoteAddress());</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="comment">//如果CommitLog标记可用,并且当前Broker为主节点,则更新消息消费进度</span></div><div class="line"><span class="keyword">boolean</span> storeOffsetEnable = brokerAllowSuspend;</div><div class="line">storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</div><div class="line">storeOffsetEnable = storeOffsetEnable</div><div class="line">    &amp;&amp; <span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</div><div class="line"><span class="keyword">if</span> (storeOffsetEnable) &#123;</div><div class="line">    <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</div><div class="line">        requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####3.消息拉取客户端处理消息</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/消息拉取客户端处理消息.png" alt=""></p>
<p><strong><em>代码：MQClientAPIImpl#processPullResponse</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> PullResult <span class="title">processPullResponse</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> RemotingCommand response)</span> <span class="keyword">throws</span> MQBrokerException, RemotingCommandException </span>&#123;</div><div class="line">    PullStatus pullStatus = PullStatus.NO_NEW_MSG;</div><div class="line">   	<span class="comment">//判断响应结果</span></div><div class="line">    <span class="keyword">switch</span> (response.getCode()) &#123;</div><div class="line">        <span class="keyword">case</span> ResponseCode.SUCCESS:</div><div class="line">            pullStatus = PullStatus.FOUND;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</div><div class="line">            pullStatus = PullStatus.NO_NEW_MSG;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</div><div class="line">            pullStatus = PullStatus.NO_MATCHED_MSG;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</div><div class="line">            pullStatus = PullStatus.OFFSET_ILLEGAL;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQBrokerException(response.getCode(), response.getRemark());</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//解码响应头</span></div><div class="line">    PullMessageResponseHeader responseHeader =</div><div class="line">        (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader.class);</div><div class="line">	<span class="comment">//封装PullResultExt返回</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),</div><div class="line">        responseHeader.getMaxOffset(), <span class="keyword">null</span>, responseHeader.getSuggestWhichBrokerId(), response.getBody());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u><strong>PullResult类</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullStatus pullStatus;	<span class="comment">//拉取结果</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> nextBeginOffset;	<span class="comment">//下次拉取偏移量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> minOffset;	<span class="comment">//消息队列最小偏移量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxOffset;	<span class="comment">//消息队列最大偏移量</span></div><div class="line"><span class="keyword">private</span> List&lt;MessageExt&gt; msgFoundList;	<span class="comment">//拉取的消息列表</span></div></pre></td></tr></table></figure>
<p><img src="/2019/12/03/RocketMQ-深入理解/PullStatus.png" alt=""></p>
<p><strong><em>代码：DefaultMQPushConsumerImpl$PullCallback#OnSuccess</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//将拉取到的消息存入processQueue</span></div><div class="line"><span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</div><div class="line"><span class="comment">//将processQueue提交到consumeMessageService中供消费者消费</span></div><div class="line">DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</div><div class="line">    pullResult.getMsgFoundList(),</div><div class="line">    processQueue,</div><div class="line">    pullRequest.getMessageQueue(),</div><div class="line">    dispatchToConsume);</div><div class="line"><span class="comment">//如果pullInterval大于0,则等待pullInterval毫秒后将pullRequest对象放入到PullMessageService中的pullRequestQueue队列中</span></div><div class="line"><span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</div><div class="line">    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</div><div class="line">        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-消息拉取总结"><a href="#4-消息拉取总结" class="headerlink" title="4.消息拉取总结"></a>4.消息拉取总结</h5><p><img src="/2019/12/03/RocketMQ-深入理解/消息拉取流程总结.png" alt=""></p>
<h4 id="4）消息拉取长轮询机制分析"><a href="#4）消息拉取长轮询机制分析" class="headerlink" title="4）消息拉取长轮询机制分析"></a>4）消息拉取长轮询机制分析</h4><p>RocketMQ未真正实现消息推模式，而是消费者主动向消息服务器拉取消息，RocketMQ推模式是循环向消息服务端发起消息拉取请求，如果消息消费者向RocketMQ拉取消息时，消息未到达消费队列时，如果不启用长轮询机制，则会在服务端等待shortPollingTimeMills时间后（挂起）再去判断消息是否已经到达指定消息队列，如果消息仍未到达则提示拉取消息客户端PULL—NOT—FOUND（消息不存在）；如果开启长轮询模式，RocketMQ一方面会每隔5s轮询检查一次消息是否可达，同时一有消息达到后立马通知挂起线程再次验证消息是否是自己感兴趣的消息，如果是则从CommitLog文件中提取消息返回给消息拉取客户端，否则直到挂起超时，超时时间由消息拉取方在消息拉取是封装在请求参数中，PUSH模式为15s，PULL模式通过DefaultMQPullConsumer#setBrokerSuspendMaxTimeMillis设置。RocketMQ通过在Broker客户端配置longPollingEnable为true来开启长轮询模式。</p>
<p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//当没有拉取到消息时，通过长轮询方式继续拉取消息</span></div><div class="line"><span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</div><div class="line">    <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</div><div class="line">        <span class="keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</div><div class="line">            pollingTimeMills = <span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String topic = requestHeader.getTopic();</div><div class="line">        <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</div><div class="line">        <span class="keyword">int</span> queueId = requestHeader.getQueueId();</div><div class="line">        <span class="comment">//构建拉取请求对象</span></div><div class="line">        PullRequest pullRequest = <span class="keyword">new</span> PullRequest(request, channel, pollingTimeMills,</div><div class="line">            <span class="keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</div><div class="line">        <span class="comment">//处理拉取请求</span></div><div class="line">        <span class="keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</div><div class="line">        response = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong><u>PullRequestHoldService方式实现长轮询</u></strong></p>
<p><strong><em>代码：PullRequestHoldService#suspendPullRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//将拉取消息请求，放置在ManyPullRequest集合中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspendPullRequest</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class="line">    String key = <span class="keyword">this</span>.buildKey(topic, queueId);</div><div class="line">    ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mpr) &#123;</div><div class="line">        mpr = <span class="keyword">new</span> ManyPullRequest();</div><div class="line">        ManyPullRequest prev = <span class="keyword">this</span>.pullRequestTable.putIfAbsent(key, mpr);</div><div class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">            mpr = prev;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mpr.addPullRequest(pullRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：PullRequestHoldService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"&#123;&#125; service started"</span>, <span class="keyword">this</span>.getServiceName());</div><div class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//如果开启长轮询每隔5秒判断消息是否到达</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</div><div class="line">                <span class="keyword">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//没有开启长轮询,每隔1s再次尝试</span></div><div class="line">              <span class="keyword">this</span>.waitForRunning(<span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.systemClock.now();</div><div class="line">            <span class="keyword">this</span>.checkHoldRequest();</div><div class="line">            <span class="keyword">long</span> costTime = <span class="keyword">this</span>.systemClock.now() - beginLockTimestamp;</div><div class="line">            <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</div><div class="line">                log.info(<span class="string">"[NOTIFYME] check hold request cost &#123;&#125; ms."</span>, costTime);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    log.info(<span class="string">"&#123;&#125; service end"</span>, <span class="keyword">this</span>.getServiceName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：PullRequestHoldService#checkHoldRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//遍历拉取任务</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkHoldRequest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (String key : <span class="keyword">this</span>.pullRequestTable.keySet()) &#123;</div><div class="line">        String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</div><div class="line">        <span class="keyword">if</span> (<span class="number">2</span> == kArray.length) &#123;</div><div class="line">            String topic = kArray[<span class="number">0</span>];</div><div class="line">            <span class="keyword">int</span> queueId = Integer.parseInt(kArray[<span class="number">1</span>]);</div><div class="line">            <span class="comment">//获得消息偏移量</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//通知有消息达到</span></div><div class="line">                <span class="keyword">this</span>.notifyMessageArriving(topic, queueId, offset);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                log.error(<span class="string">"check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;"</span>, topic, queueId, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：PullRequestHoldService#notifyMessageArriving</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//如果拉取消息偏移大于请求偏移量,如果消息匹配调用executeRequestWhenWakeup处理消息</span></div><div class="line"><span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</div><div class="line">    <span class="keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</div><div class="line">        <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</div><div class="line">    <span class="comment">// match by bit map, need eval again when properties is not null.</span></div><div class="line">    <span class="keyword">if</span> (match &amp;&amp; properties != <span class="keyword">null</span>) &#123;</div><div class="line">        match = request.getMessageFilter().isMatchedByCommitLog(<span class="keyword">null</span>, properties);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (match) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</div><div class="line">                request.getRequestCommand());</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            log.error(<span class="string">"execute request when wakeup failed."</span>, e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果过期时间超时,则不继续等待将直接返回给客户端消息未找到</span></div><div class="line"><span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</div><div class="line">            request.getRequestCommand());</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        log.error(<span class="string">"execute request when wakeup failed."</span>, e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果开启了长轮询机制，PullRequestHoldService会每隔5s被唤醒去尝试检测是否有新的消息的到来才给客户端响应，或者直到超时才给客户端进行响应，消息实时性比较差，为了避免这种情况，RocketMQ引入另外一种机制：当消息到达时唤醒挂起线程触发一次检查。</p>
<p><strong><u>DefaultMessageStore$ReputMessageService机制</u></strong></p>
<p><strong><em>代码：DefaultMessageStore#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//长轮询入口</span></div><div class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</div><div class="line"><span class="keyword">this</span>.reputMessageService.start();</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore$ReputMessageService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1</span>);</div><div class="line">            <span class="comment">//长轮询核心逻辑代码入口</span></div><div class="line">            <span class="keyword">this</span>.doReput();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：DefaultMessageStore$ReputMessageService#deReput</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//当新消息达到是,进行通知监听器进行处理</span></div><div class="line"><span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</div><div class="line">    &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</div><div class="line">    DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</div><div class="line">        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</div><div class="line">        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</div><div class="line">        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：NotifyMessageArrivingListener#arriving</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arriving</span><span class="params">(String topic, <span class="keyword">int</span> queueId, <span class="keyword">long</span> logicOffset, <span class="keyword">long</span> tagsCode,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">long</span> msgStoreTime, <span class="keyword">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.pullRequestHoldService.notifyMessageArriving(topic, queueId, logicOffset, tagsCode,</div><div class="line">        msgStoreTime, filterBitMap, properties);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-5-5-消息队列负载与重新分布机制"><a href="#2-5-5-消息队列负载与重新分布机制" class="headerlink" title="2.5.5 消息队列负载与重新分布机制"></a>2.5.5 消息队列负载与重新分布机制</h3><p>RocketMQ消息队列重新分配是由RebalanceService线程来实现。一个MQClientInstance持有一个RebalanceService实现，并随着MQClientInstance的启动而启动。</p>
<p><strong><em>代码：RebalanceService#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</div><div class="line">	<span class="comment">//RebalanceService线程默认每隔20s执行一次mqClientFactory.doRebalance方法</span></div><div class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</div><div class="line">        <span class="keyword">this</span>.waitForRunning(waitInterval);</div><div class="line">        <span class="keyword">this</span>.mqClientFactory.doRebalance();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：MQClientInstance#doRebalance</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//MQClientInstance遍历以注册的消费者,对消费者执行doRebalance()方法</span></div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="keyword">this</span>.consumerTable.entrySet()) &#123;</div><div class="line">        MQConsumerInner impl = entry.getValue();</div><div class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                impl.doRebalance();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                log.error(<span class="string">"doRebalance exception"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：RebalanceImpl#doRebalance</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//遍历订阅消息对每个主题的订阅的队列进行重新负载</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</div><div class="line">    Map&lt;String, SubscriptionData&gt; subTable = <span class="keyword">this</span>.getSubscriptionInner();</div><div class="line">    <span class="keyword">if</span> (subTable != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</div><div class="line">            <span class="keyword">final</span> String topic = entry.getKey();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.rebalanceByTopic(topic, isOrder);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class="line">                    log.warn(<span class="string">"rebalanceByTopic Exception"</span>, e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.truncateMessageQueueNotMyTopic();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：RebalanceImpl#rebalanceByTopic</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//从主题订阅消息缓存表中获取主题的队列信息</span></div><div class="line">Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</div><div class="line"><span class="comment">//查找该主题订阅组所有的消费者ID</span></div><div class="line">List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</div><div class="line"></div><div class="line"><span class="comment">//给消费者重新分配队列</span></div><div class="line"><span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</div><div class="line">    List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</div><div class="line">    mqAll.addAll(mqSet);</div><div class="line"></div><div class="line">    Collections.sort(mqAll);</div><div class="line">    Collections.sort(cidAll);</div><div class="line"></div><div class="line">    AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</div><div class="line"></div><div class="line">    List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        allocateResult = strategy.allocate(</div><div class="line">            <span class="keyword">this</span>.consumerGroup,</div><div class="line">            <span class="keyword">this</span>.mQClientFactory.getClientId(),</div><div class="line">            mqAll,</div><div class="line">            cidAll);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        log.error(<span class="string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),</div><div class="line">            e);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>RocketMQ默认提供5中负载均衡分配算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AllocateMessageQueueAveragely:平均分配</div><div class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</div><div class="line">分配如下:</div><div class="line">c1:q1,q2,q3</div><div class="line">c2:q4,q5,a6</div><div class="line">c3:q7,q8</div><div class="line">AllocateMessageQueueAveragelyByCircle:平均轮询分配</div><div class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</div><div class="line">分配如下:</div><div class="line">c1:q1,q4,q7</div><div class="line">c2:q2,q5,a8</div><div class="line">c3:q3,q6</div></pre></td></tr></table></figure>
<p>注意：消息队列的分配遵循一个消费者可以分配到多个队列，但同一个消息队列只会分配给一个消费者，故如果出现消费者个数大于消息队列数量，则有些消费者无法消费消息。</p>
<h3 id="2-5-6-消息消费过程"><a href="#2-5-6-消息消费过程" class="headerlink" title="2.5.6 消息消费过程"></a>2.5.6 消息消费过程</h3><p>PullMessageService负责对消息队列进行消息拉取，从远端服务器拉取消息后将消息存储ProcessQueue消息队列处理队列中，然后调用ConsumeMessageService#submitConsumeRequest方法进行消息消费，使用线程池来消费消息，确保了消息拉取与消息消费的解耦。ConsumeMessageService支持顺序消息和并发消息，核心类图如下：</p>
<p><img src="/2019/12/03/RocketMQ-深入理解/ConsumeMessageService.png" alt=""></p>
<p><strong><u>并发消息消费</u></strong></p>
<p><strong><em>代码：ConsumeMessageConcurrentlyService#submitConsumeRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//消息批次单次</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</div><div class="line"><span class="comment">//msgs.size()默认最多为32条。</span></div><div class="line"><span class="comment">//如果msgs.size()小于consumeBatchSize,则直接将拉取到的消息放入到consumeRequest,然后将consumeRequest提交到消费者线程池中</span></div><div class="line"><span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</div><div class="line">    ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</div><div class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line">        <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</div><div class="line">    &#125;</div><div class="line">&#125;<span class="keyword">else</span>&#123;	<span class="comment">//如果拉取的消息条数大于consumeBatchSize,则对拉取消息进行分页</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</div><div class="line">   		    List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</div><div class="line">   		    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</div><div class="line">   		        <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</div><div class="line">   		            msgThis.add(msgs.get(total));</div><div class="line">   		        &#125; <span class="keyword">else</span> &#123;</div><div class="line">   		            <span class="keyword">break</span>;</div><div class="line">   		        &#125;</div><div class="line">   		</div><div class="line">   		    ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</div><div class="line">   		    <span class="keyword">try</span> &#123;</div><div class="line">   		        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</div><div class="line">   		    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line">   		        <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</div><div class="line">   		            msgThis.add(msgs.get(total));</div><div class="line">   		 </div><div class="line">   		        <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</div><div class="line">   		    &#125;</div><div class="line">   		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：ConsumeMessageConcurrentlyService$ConsumeRequest#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//检查processQueue的dropped,如果为true,则停止该队列消费。</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</div><div class="line">    log.info(<span class="string">"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;"</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"><span class="comment">//执行消息处理的钩子函数</span></div><div class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</div><div class="line">    consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</div><div class="line">    consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</div><div class="line">    consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</div><div class="line">    consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</div><div class="line">    consumeMessageContext.setMq(messageQueue);</div><div class="line">    consumeMessageContext.setMsgList(msgs);</div><div class="line">    consumeMessageContext.setSuccess(<span class="keyword">false</span>);</div><div class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="comment">//调用应用程序消息监听器的consumeMessage方法,进入到具体的消息消费业务处理逻辑</span></div><div class="line">status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</div><div class="line"></div><div class="line"><span class="comment">//执行消息处理后的钩子函数</span></div><div class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</div><div class="line">    consumeMessageContext.setStatus(status.toString());</div><div class="line">    consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</div><div class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-5-7-定时消息机制"><a href="#2-5-7-定时消息机制" class="headerlink" title="2.5.7 定时消息机制"></a>2.5.7 定时消息机制</h3><p>定时消息是消息发送到Broker后，并不立即被消费者消费而是要等到特定的时间后才能被消费，RocketMQ并不支持任意的时间精度，如果要支持任意时间精度定时调度，不可避免地需要在Broker层做消息排序，再加上持久化方面的考量，将不可避免的带来巨大的性能消耗，所以RocketMQ只支持特定级别的延迟消息。消息延迟级别在Broker端通过messageDelayLevel配置，默认为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，delayLevel=1表示延迟消息1s,delayLevel=2表示延迟5s,依次类推。</p>
<p>RocketMQ定时消息实现类为ScheduleMessageService，该类在DefaultMessageStore中创建。通过在DefaultMessageStore中调用load方法加载该类并调用start方法启动。</p>
<p><strong><em>代码：ScheduleMessageService#load</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//加载延迟消息消费进度的加载与delayLevelTable的构造。延迟消息的进度默认存储路径为/store/config/delayOffset.json</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> result = <span class="keyword">super</span>.load();</div><div class="line">    result = result &amp;&amp; <span class="keyword">this</span>.parseDelayLevel();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：ScheduleMessageService#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//遍历延迟队列创建定时任务,遍历延迟级别，根据延迟级别level从offsetTable中获取消费队列的消费进度。如果不存在，则使用0</span></div><div class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="keyword">this</span>.delayLevelTable.entrySet()) &#123;</div><div class="line">    Integer level = entry.getKey();</div><div class="line">    Long timeDelay = entry.getValue();</div><div class="line">    Long offset = <span class="keyword">this</span>.offsetTable.get(level);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</div><div class="line">        offset = <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (timeDelay != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//每隔10s持久化一次延迟队列的消息消费进度</span></div><div class="line"><span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (started.get()) ScheduleMessageService.<span class="keyword">this</span>.persist();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            log.error(<span class="string">"scheduleAtFixedRate flush exception"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">10000</span>, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</div></pre></td></tr></table></figure>
<p><strong><u>调度机制</u></strong></p>
<p>ScheduleMessageService的start方法启动后，会为每一个延迟级别创建一个调度任务，每一个延迟级别对应SCHEDULE_TOPIC_XXXX主题下的一个消息消费队列。定时调度任务的实现类为DeliverDelayedMessageTimerTask，核心实现方法为executeOnTimeup</p>
<p><strong><em>代码：ScheduleMessageService$DeliverDelayedMessageTimerTask#executeOnTimeup</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//根据队列ID与延迟主题查找消息消费队列</span></div><div class="line">ConsumeQueue cq =</div><div class="line">    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,</div><div class="line">        delayLevel2QueueId(delayLevel));</div><div class="line">...</div><div class="line"><span class="comment">//根据偏移量从消息消费队列中获取当前队列中所有有效的消息</span></div><div class="line">SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</div><div class="line"></div><div class="line">...</div><div class="line"><span class="comment">//遍历ConsumeQueue,解析消息队列中消息</span></div><div class="line"><span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</div><div class="line">    <span class="keyword">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</div><div class="line">    <span class="keyword">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</div><div class="line">    <span class="keyword">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cq.isExtAddr(tagsCode)) &#123;</div><div class="line">        <span class="keyword">if</span> (cq.getExt(tagsCode, cqExtUnit)) &#123;</div><div class="line">            tagsCode = cqExtUnit.getTagsCode();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//can't find ext content.So re compute tags code.</span></div><div class="line">            log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;"</span>,</div><div class="line">                tagsCode, offsetPy, sizePy);</div><div class="line">            <span class="keyword">long</span> msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);</div><div class="line">            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">    <span class="keyword">long</span> deliverTimestamp = <span class="keyword">this</span>.correctDeliverTimestamp(now, tagsCode);</div><div class="line">    </div><div class="line">    ...</div><div class="line">    <span class="comment">//根据消息偏移量与消息大小,从CommitLog中查找消息.</span></div><div class="line">  	MessageExt msgExt =</div><div class="line">   ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(</div><div class="line">       offsetPy, sizePy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-5-8-顺序消息"><a href="#2-5-8-顺序消息" class="headerlink" title="2.5.8 顺序消息"></a>2.5.8 顺序消息</h3><p>顺序消息实现类是org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService</p>
<p><strong><em>代码：ConsumeMessageOrderlyService#start</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//如果消息模式为集群模式，启动定时任务，默认每隔20s执行一次锁定分配给自己的消息消费队列</span></div><div class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</div><div class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                ConsumeMessageOrderlyService.<span class="keyword">this</span>.lockMQPeriodically();</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="number">1000</span> * <span class="number">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：ConsumeMessageOrderlyService#submitConsumeRequest</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//构建消息任务,并提交消费线程池中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ProcessQueue processQueue,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue messageQueue,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> dispathToConsume)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</div><div class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(processQueue, messageQueue);</div><div class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>代码：ConsumeMessageOrderlyService$ConsumeRequest#run</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//如果消息队列为丢弃,则停止本次消费任务</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</div><div class="line">    log.warn(<span class="string">"run, the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//从消息队列中获取一个对象。然后消费消息时先申请独占objLock锁。顺序消息一个消息消费队列同一时刻只会被一个消费线程池处理</span></div><div class="line"><span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</div><div class="line"><span class="keyword">synchronized</span> (objLock) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-5-9-小结"><a href="#2-5-9-小结" class="headerlink" title="2.5.9 小结"></a>2.5.9 小结</h3><p>RocketMQ消息消费方式分别为集群模式、广播模式。</p>
<p>消息队列负载由RebalanceService线程默认每隔20s进行一次消息队列负载，根据当前消费者组内消费者个数与主题队列数量按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一个时间只会分配给一个消费者。</p>
<p>消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取，默认每次拉取32条消息，提交给消费者消费线程后继续下一次消息拉取。如果消息消费过慢产生消息堆积会触发消息消费拉取流控。 </p>
<p>并发消息消费指消费线程池中的线程可以并发对同一个消息队列的消息进行消费，消费成功后，取出消息队列中最小的消息偏移量作为消息消费进度偏移量存储在于消息消费进度存储文件中，集群模式消息消费进度存储在Broker（消息服务器），广播模式消息消费进度存储在消费者端。</p>
<p>RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别，例如1s、2s、5s等，可通过在broker配置文件中设置messageDelayLevel。</p>
<p>顺序消息一般使用集群模式，是指对消息消费者内的线程池中的线程对消息消费队列只能串行消费。并并发消息消费最本质的区别是消息消费时必须成功锁定消息消费队列，在Broker端会存储消息消费队列的锁占用情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-高级功能&quot;&gt;&lt;a href=&quot;#1-高级功能&quot; class=&quot;headerlink&quot; title=&quot;1. 高级功能&quot;&gt;&lt;/a&gt;1. 高级功能&lt;/h1&gt;&lt;h2 id=&quot;1-1-消息存储&quot;&gt;&lt;a href=&quot;#1-1-消息存储&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="RocketMQ" scheme="http://kingge.top/categories/RocketMQ/"/>
    
    
      <category term="rmq" scheme="http://kingge.top/tags/rmq/"/>
    
      <category term="RocketMQ源码分析" scheme="http://kingge.top/tags/RocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ基础知识</title>
    <link href="http://kingge.top/2019/11/13/RocketMQ%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://kingge.top/2019/11/13/RocketMQ基础知识/</id>
    <published>2019-11-13T02:21:59.000Z</published>
    <updated>2020-05-09T09:07:54.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MQ介绍"><a href="#1-MQ介绍" class="headerlink" title="1. MQ介绍"></a>1. MQ介绍</h1><p>##1.1 为什么要用MQ</p>
<p>消息队列是一种“先进先出”的数据结构</p>
<p><img src="/2019/11/13/RocketMQ基础知识/queue1.png" alt=""></p>
<p>其应用场景主要包含以下3个方面</p>
<ul>
<li>应用解耦</li>
</ul>
<p>系统的耦合性越高，容错性就越低。以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单操作异常，影响用户使用体验。</p>
<p><img src="/2019/11/13/RocketMQ基础知识/解耦1.png" alt=""></p>
<p>使用消息队列解耦合，系统的耦合性就会提高了。比如物流系统发生故障，需要几分钟才能来修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统回复后，补充处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障。</p>
<p><img src="/2019/11/13/RocketMQ基础知识/解耦2.png" alt=""></p>
<ul>
<li>流量削峰</li>
</ul>
<p><img src="/2019/11/13/RocketMQ基础知识/mq-5.png" alt=""></p>
<p>应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。</p>
<p><img src="/2019/11/13/RocketMQ基础知识/mq-6.png" alt=""></p>
<p>一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完毕，这样总不能下单体验要好。</p>
<p><u>处于经济考量目的：</u></p>
<p>业务系统正常时段的QPS如果是1000，流量最高峰是10000，为了应对流量高峰配置高性能的服务器显然不划算，这时可以使用消息队列对峰值流量削峰</p>
<ul>
<li>数据分发</li>
</ul>
<p><img src="/2019/11/13/RocketMQ基础知识/mq-1.png" alt=""></p>
<p>通过消息队列可以让数据在多个系统更加之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可</p>
<p><img src="/2019/11/13/RocketMQ基础知识/mq-2.png" alt=""></p>
<h2 id="1-2-MQ的优点和缺点"><a href="#1-2-MQ的优点和缺点" class="headerlink" title="1.2 MQ的优点和缺点"></a>1.2 MQ的优点和缺点</h2><p>优点：解耦、削峰、数据分发</p>
<p>缺点包含以下几点：</p>
<ul>
<li><p>系统可用性降低</p>
<p>系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。</p>
<p>如何保证MQ的高可用？</p>
</li>
<li><p>系统复杂度提高</p>
<p>MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。</p>
<p>如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p>
</li>
<li><p>一致性问题</p>
<p>A系统处理完业务，通过MQ给B、C、D三个系统发消息数据，如果B系统、C系统处理成功，D系统处理失败。</p>
<p>如何保证消息数据处理的一致性？</p>
</li>
</ul>
<h2 id="1-3-各种MQ产品的比较"><a href="#1-3-各种MQ产品的比较" class="headerlink" title="1.3 各种MQ产品的比较"></a>1.3 各种MQ产品的比较</h2><p>常见的MQ产品包括Kafka、ActiveMQ、RabbitMQ、RocketMQ。 </p>
<p><img src="/2019/11/13/RocketMQ基础知识/MQ比较.png" alt=""></p>
<h1 id="2-RocketMQ快速入门"><a href="#2-RocketMQ快速入门" class="headerlink" title="2. RocketMQ快速入门"></a>2. RocketMQ快速入门</h1><p>RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，在阿里内部，RocketMQ承接了例如“双11”等高并发场景的消息流转，能够处理万亿级别的消息。</p>
<h2 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h2><h3 id="2-1-1-下载RocketMQ"><a href="#2-1-1-下载RocketMQ" class="headerlink" title="2.1.1 下载RocketMQ"></a>2.1.1 下载RocketMQ</h3><p>RocketMQ最新版本：4.5.1</p>
<p><a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.5.1/rocketmq-all-4.5.1-bin-release.zip" target="_blank" rel="external">下载地址</a></p>
<h3 id="2-2-2-环境要求"><a href="#2-2-2-环境要求" class="headerlink" title="2.2.2 环境要求"></a>2.2.2 环境要求</h3><ul>
<li><p>Linux64位系统</p>
</li>
<li><p>JDK1.8(64位)</p>
</li>
<li><p>源码安装需要安装Maven 3.2.x</p>
</li>
</ul>
<h2 id="2-2-安装RocketMQ"><a href="#2-2-安装RocketMQ" class="headerlink" title="2.2 安装RocketMQ"></a>2.2 安装RocketMQ</h2><h3 id="2-2-1-安装步骤"><a href="#2-2-1-安装步骤" class="headerlink" title="2.2.1 安装步骤"></a>2.2.1 安装步骤</h3><p>本次以二进制包方式安装</p>
<ol>
<li><p>解压安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">unzip rocketmq-all-4.4.0-bin-release.zip</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>进入安装目录</li>
</ol>
<h3 id="2-2-2-目录介绍"><a href="#2-2-2-目录介绍" class="headerlink" title="2.2.2 目录介绍"></a>2.2.2 目录介绍</h3><ul>
<li>bin：启动脚本，包括shell脚本和CMD脚本</li>
<li>conf：实例配置文件 ，包括broker配置文件、logback配置文件等</li>
<li>lib：依赖jar包，包括Netty、commons-lang、FastJSON等</li>
</ul>
<h2 id="2-3-启动RocketMQ"><a href="#2-3-启动RocketMQ" class="headerlink" title="2.3 启动RocketMQ"></a>2.3 启动RocketMQ</h2><p><strong>进入bin目录启动。</strong></p>
<ol>
<li>启动NameServer</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span> 1.启动NameServer - 后台的方式启动</div><div class="line">nohup sh bin/mqnamesrv &amp;</div><div class="line"><span class="meta">#</span> 2.查看启动日志</div><div class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</div></pre></td></tr></table></figure>
<ol>
<li>启动Broker</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span> 1.启动Broker</div><div class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</div><div class="line"><span class="meta">#</span> 2.查看启动日志</div><div class="line">tail -f ~/logs/rocketmqlogs/broker.log</div></pre></td></tr></table></figure>
<ul>
<li><p>问题描述：</p>
<p>RocketMQ默认的虚拟机内存较大，启动Broker如果因为内存不足失败，需要编辑如下两个配置文件，修改JVM内存大小</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span> 编辑runbroker.sh和runserver.sh修改默认JVM大小</div><div class="line">vi runbroker.sh</div><div class="line">vi runserver.sh</div></pre></td></tr></table></figure>
<ul>
<li>参考设置：</li>
</ul>
<p>vi runbroker.sh文件修改为：</p>
<figure class="highlight plain"><figcaption><span>-server -Xms256m -Xmx256m -Xmn128m"```</span></figcaption><table><tr><td class="code"><pre><div class="line"></div><div class="line">vi runserver.sh文件修改为：</div><div class="line"></div><div class="line">```JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m  -XX:MaxMetaspaceSize=320m&quot;</div></pre></td></tr></table></figure>
<p>修改完成后，如果之前已经启动了nameserver，那么需要关闭重启，然后再启动broker。</p>
<h2 id="2-4-测试RocketMQ"><a href="#2-4-测试RocketMQ" class="headerlink" title="2.4 测试RocketMQ"></a>2.4 测试RocketMQ</h2><h3 id="2-4-1-发送消息"><a href="#2-4-1-发送消息" class="headerlink" title="2.4.1 发送消息"></a>2.4.1 发送消息</h3><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 1.设置环境变量</span></div><div class="line"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</div><div class="line"><span class="comment"># 2.使用安装包的Demo发送消息</span></div><div class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</div></pre></td></tr></table></figure>
<h3 id="2-4-2-接收消息"><a href="#2-4-2-接收消息" class="headerlink" title="2.4.2 接收消息"></a>2.4.2 接收消息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 1.设置环境变量</span></div><div class="line">export NAMESRV_ADDR=localhost:9876</div><div class="line"><span class="meta">#</span><span class="bash"> 2.接收消息</span></div><div class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</div></pre></td></tr></table></figure>
<h2 id="2-5-关闭RocketMQ"><a href="#2-5-关闭RocketMQ" class="headerlink" title="2.5 关闭RocketMQ"></a>2.5 关闭RocketMQ</h2><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 1.关闭NameServer</span></div><div class="line">sh bin/mqshutdown namesrv</div><div class="line"><span class="meta">#</span><span class="bash"> 2.关闭Broker</span></div><div class="line">sh bin/mqshutdown broker</div></pre></td></tr></table></figure>
<h1 id="3-RocketMQ集群搭建"><a href="#3-RocketMQ集群搭建" class="headerlink" title="3. RocketMQ集群搭建"></a>3. RocketMQ集群搭建</h1><h2 id="3-1-各角色介绍"><a href="#3-1-各角色介绍" class="headerlink" title="3.1 各角色介绍"></a>3.1 各角色介绍</h2><ul>
<li>Producer：消息的发送者，发送前需要询问nameser到底要发到哪个broker，broker地址在哪里</li>
<li>Consumer：消息接收者，订阅消息时，也要询问namesesr需要订阅的消息在那个borker</li>
<li>Broker：暂存和传输消息，启动后也需要向nameser汇报自己的状况信息。</li>
<li>NameServer：管理Broker。接受生产者和消费者的请求</li>
<li>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息</li>
<li>Message Queue：相当于是Topic的分区；用于并行发送和接收消息</li>
</ul>
<p><img src="/2019/11/13/RocketMQ基础知识/RocketMQ角色.jpg" alt=""></p>
<h2 id="3-2-集群搭建方式"><a href="#3-2-集群搭建方式" class="headerlink" title="3.2 集群搭建方式"></a>3.2 集群搭建方式</h2><h3 id="3-2-1-集群特点"><a href="#3-2-1-集群特点" class="headerlink" title="3.2.1 集群特点"></a>3.2.1 集群特点</h3><ul>
<li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。<ul>
<li>每一个nameser节点的数据都是一样的，但是他们之间是没有进行相互数据同步的，那么只能说明，broker启动后需要都给所有的nameser通信，汇报自己的情况。</li>
</ul>
</li>
<li>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。<ul>
<li>master和slave的出现目的是为了，进行读写分离。主节点是负责写。从节点负责读，他们之间进行数据同步（类似zk的集群架构）。</li>
</ul>
</li>
<li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li>
<li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。 </li>
</ul>
<h3 id="3-2-3-集群模式"><a href="#3-2-3-集群模式" class="headerlink" title="3.2.3 集群模式"></a>3.2.3 集群模式</h3><h4 id="1）单Master模式"><a href="#1）单Master模式" class="headerlink" title="1）单Master模式"></a>1）单Master模式</h4><p>这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。</p>
<h4 id="2）多Master模式"><a href="#2）多Master模式" class="headerlink" title="2）多Master模式"></a>2）多Master模式</h4><p>一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：</p>
<ul>
<li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>
<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li>
</ul>
<h4 id="3）多Master多Slave模式（消息异步更新）"><a href="#3）多Master多Slave模式（消息异步更新）" class="headerlink" title="3）多Master多Slave模式（消息异步更新）"></a>3）多Master多Slave模式（消息异步更新）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式（master和broker之间数据同步采用异步方式），主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>
<ul>
<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li>
<li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li>
</ul>
<h4 id="4）多Master多Slave模式（消息同步更新）"><a href="#4）多Master多Slave模式（消息同步更新）" class="headerlink" title="4）多Master多Slave模式（消息同步更新）"></a>4）多Master多Slave模式（消息同步更新）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p>
<ul>
<li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li>
<li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li>
</ul>
<h2 id="3-3-双主双从集群搭建"><a href="#3-3-双主双从集群搭建" class="headerlink" title="3.3 双主双从集群搭建"></a>3.3 双主双从集群搭建</h2><h3 id="3-3-1-总体架构"><a href="#3-3-1-总体架构" class="headerlink" title="3.3.1 总体架构"></a>3.3.1 总体架构</h3><p><strong>消息高可用采用2m-2s（同步双写）</strong>方式</p>
<p><img src="/2019/11/13/RocketMQ基础知识/RocketMQ集群.png" alt=""></p>
<h3 id="3-3-2-集群工作流程"><a href="#3-3-2-集群工作流程" class="headerlink" title="3.3.2 集群工作流程"></a>3.3.2 集群工作流程</h3><ol>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ol>
<h3 id="3-3-3-服务器环境"><a href="#3-3-3-服务器环境" class="headerlink" title="3.3.3 服务器环境"></a>3.3.3 服务器环境</h3><table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>IP</strong></th>
<th><strong>角色</strong></th>
<th><strong>架构模式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>192.168.25.135</td>
<td>nameserver、brokerserver</td>
<td>Master1、Slave2</td>
</tr>
<tr>
<td>2</td>
<td>192.168.25.138</td>
<td>nameserver、brokerserver</td>
<td>Master2、Slave1</td>
</tr>
</tbody>
</table>
<h3 id="3-3-4-Host添加信息"><a href="#3-3-4-Host添加信息" class="headerlink" title="3.3.4 Host添加信息"></a>3.3.4 Host添加信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">vim /etc/hosts</div></pre></td></tr></table></figure>
<p>配置如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># nameserver</span></div><div class="line">192.168.25.135 rocketmq-nameserver1</div><div class="line">192.168.25.138 rocketmq-nameserver2</div><div class="line"><span class="comment"># broker</span></div><div class="line">192.168.25.135 rocketmq-master1</div><div class="line">192.168.25.135 rocketmq-slave2</div><div class="line">192.168.25.138 rocketmq-master2</div><div class="line">192.168.25.138 rocketmq-slave1</div></pre></td></tr></table></figure>
<p>配置完成后, 重启网卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">systemctl restart network</div></pre></td></tr></table></figure>
<h3 id="3-3-5-防火墙配置"><a href="#3-3-5-防火墙配置" class="headerlink" title="3.3.5 防火墙配置"></a>3.3.5 防火墙配置</h3><p>宿主机需要远程访问虚拟机的rocketmq服务和web服务，需要开放相关的端口号，简单粗暴的方式是直接关闭防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 关闭防火墙</span></div><div class="line">systemctl stop firewalld.service </div><div class="line"><span class="comment"># 查看防火墙的状态</span></div><div class="line">firewall-cmd --state </div><div class="line"><span class="comment"># 禁止firewall开机启动</span></div><div class="line">systemctl <span class="built_in">disable</span> firewalld.service</div></pre></td></tr></table></figure>
<p>或者为了安全，只开放特定的端口号，RocketMQ默认使用3个端口：9876 、10911 、11011 。如果防火墙没有关闭的话，那么防火墙就必须开放这些端口：</p>
<ul>
<li><code>nameserver</code> 默认使用 9876 端口</li>
<li><code>master</code> 默认使用 10911 端口</li>
<li><code>slave</code> 默认使用11011 端口</li>
</ul>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 开放name server默认端口</span></div><div class="line">firewall-cmd --remove-port=9876/tcp --permanent</div><div class="line"><span class="comment"># 开放master默认端口</span></div><div class="line">firewall-cmd --remove-port=10911/tcp --permanent</div><div class="line"><span class="comment"># 开放slave默认端口 (当前集群模式可不开启)</span></div><div class="line">firewall-cmd --remove-port=11011/tcp --permanent </div><div class="line"><span class="comment"># 重启防火墙</span></div><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure>
<h3 id="3-3-6-环境变量配置"><a href="#3-3-6-环境变量配置" class="headerlink" title="3.3.6 环境变量配置"></a>3.3.6 环境变量配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure>
<p>在profile文件的末尾加入如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">#set rocketmq</span></div><div class="line">ROCKETMQ_HOME=/usr/<span class="built_in">local</span>/rocketmq/rocketmq-all-4.4.0-bin-release</div><div class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ROCKETMQ_HOME</span>/bin</div><div class="line"><span class="built_in">export</span> ROCKETMQ_HOME PATH</div></pre></td></tr></table></figure>
<p>输入:wq! 保存并退出， 并使得配置立刻生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">source</span> /etc/profile</div></pre></td></tr></table></figure>
<h3 id="3-3-7-创建消息存储路径"><a href="#3-3-7-创建消息存储路径" class="headerlink" title="3.3.7 创建消息存储路径"></a>3.3.7 创建消息存储路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq</div><div class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store</div><div class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store/commitlog</div><div class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</div><div class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store/index</div></pre></td></tr></table></figure>
<h3 id="3-3-8-broker配置文件"><a href="#3-3-8-broker配置文件" class="headerlink" title="3.3.8 broker配置文件"></a>3.3.8 broker配置文件</h3><p>我们可以打开rmq的conf配置目录：</p>
<p><img src="/2019/11/13/RocketMQ基础知识/image-20200417164915858.png" alt="image-20200417164915858"></p>
<p><strong>可以看到他本身就提供了三种样例的配置目录，从上往下分别是：双master和双slave的消息异步同步，双master和双slave的消息同步同步，双master。分别对应了我们上面所讲的三种集群模式。</strong></p>
<p><strong>因为本次搭建的是双m双s的消息同步的方式，所以只需要修改2m-2s-sync目录下的配置文件即可。</strong></p>
<h4 id="1）master1"><a href="#1）master1" class="headerlink" title="1）master1"></a>1）master1</h4><p>服务器：192.168.25.135</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-a.properties</div></pre></td></tr></table></figure>
<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">#所属集群名字</span></div><div class="line">brokerClusterName=rocketmq-cluster</div><div class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></div><div class="line">brokerName=broker<span class="_">-a</span></div><div class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></div><div class="line">brokerId=0</div><div class="line"><span class="comment">#显式声明当前master所在的ip地址</span></div><div class="line">brokerIP1=192.168.25.135</div><div class="line"><span class="comment">#nameServer地址，分号分割</span></div><div class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</div><div class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></div><div class="line">defaultTopicQueueNums=4</div><div class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></div><div class="line">autoCreateTopicEnable=<span class="literal">true</span></div><div class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></div><div class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></div><div class="line"><span class="comment">#Broker 对外服务的监听端口</span></div><div class="line">listenPort=10911</div><div class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></div><div class="line">deleteWhen=04</div><div class="line"><span class="comment">#文件保留时间，默认 48 小时</span></div><div class="line">fileReservedTime=120</div><div class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></div><div class="line">mapedFileSizeCommitLog=1073741824</div><div class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></div><div class="line">mapedFileSizeConsumeQueue=300000</div><div class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></div><div class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></div><div class="line"><span class="comment">#检测物理文件磁盘空间</span></div><div class="line">diskMaxUsedSpaceRatio=88</div><div class="line"><span class="comment">#存储路径</span></div><div class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</div><div class="line"><span class="comment">#commitLog 存储路径</span></div><div class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</div><div class="line"><span class="comment">#消费队列存储路径存储路径</span></div><div class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</div><div class="line"><span class="comment">#消息索引存储路径</span></div><div class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</div><div class="line"><span class="comment">#checkpoint 文件存储路径</span></div><div class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</div><div class="line"><span class="comment">#abort 文件存储路径</span></div><div class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</div><div class="line"><span class="comment">#限制的消息大小</span></div><div class="line">maxMessageSize=65536</div><div class="line"><span class="comment">#flushCommitLogLeastPages=4</span></div><div class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></div><div class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></div><div class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></div><div class="line"><span class="comment">#Broker 的角色</span></div><div class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></div><div class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></div><div class="line"><span class="comment">#- SLAVE</span></div><div class="line">brokerRole=SYNC_MASTER</div><div class="line"><span class="comment">#刷盘方式</span></div><div class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></div><div class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></div><div class="line">flushDiskType=SYNC_FLUSH</div><div class="line"><span class="comment">#checkTransactionMessageEnable=false</span></div><div class="line"><span class="comment">#发消息线程池数量</span></div><div class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></div><div class="line"><span class="comment">#拉消息线程池数量</span></div><div class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></div></pre></td></tr></table></figure>
<h4 id="2）slave2"><a href="#2）slave2" class="headerlink" title="2）slave2"></a>2）slave2</h4><p>服务器：192.168.25.135</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b-s.properties</div></pre></td></tr></table></figure>
<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">#所属集群名字</span></div><div class="line">brokerClusterName=rocketmq-cluster</div><div class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></div><div class="line">brokerName=broker-b</div><div class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></div><div class="line">brokerId=1</div><div class="line"><span class="comment">#显式声明当前slave所在的ip地址</span></div><div class="line">brokerIP1=192.168.25.135</div><div class="line"><span class="comment">#nameServer地址，分号分割</span></div><div class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</div><div class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></div><div class="line">defaultTopicQueueNums=4</div><div class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></div><div class="line">autoCreateTopicEnable=<span class="literal">true</span></div><div class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></div><div class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></div><div class="line"><span class="comment">#Broker 对外服务的监听端口</span></div><div class="line">listenPort=11011</div><div class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></div><div class="line">deleteWhen=04</div><div class="line"><span class="comment">#文件保留时间，默认 48 小时</span></div><div class="line">fileReservedTime=120</div><div class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></div><div class="line">mapedFileSizeCommitLog=1073741824</div><div class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></div><div class="line">mapedFileSizeConsumeQueue=300000</div><div class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></div><div class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></div><div class="line"><span class="comment">#检测物理文件磁盘空间</span></div><div class="line">diskMaxUsedSpaceRatio=88</div><div class="line"><span class="comment">#存储路径</span></div><div class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</div><div class="line"><span class="comment">#commitLog 存储路径</span></div><div class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</div><div class="line"><span class="comment">#消费队列存储路径存储路径</span></div><div class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</div><div class="line"><span class="comment">#消息索引存储路径</span></div><div class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</div><div class="line"><span class="comment">#checkpoint 文件存储路径</span></div><div class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</div><div class="line"><span class="comment">#abort 文件存储路径</span></div><div class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</div><div class="line"><span class="comment">#限制的消息大小</span></div><div class="line">maxMessageSize=65536</div><div class="line"><span class="comment">#flushCommitLogLeastPages=4</span></div><div class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></div><div class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></div><div class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></div><div class="line"><span class="comment">#Broker 的角色</span></div><div class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></div><div class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></div><div class="line"><span class="comment">#- SLAVE</span></div><div class="line">brokerRole=SLAVE</div><div class="line"><span class="comment">#刷盘方式</span></div><div class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></div><div class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></div><div class="line">flushDiskType=ASYNC_FLUSH</div><div class="line"><span class="comment">#checkTransactionMessageEnable=false</span></div><div class="line"><span class="comment">#发消息线程池数量</span></div><div class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></div><div class="line"><span class="comment">#拉消息线程池数量</span></div><div class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></div></pre></td></tr></table></figure>
<h4 id="3）master2"><a href="#3）master2" class="headerlink" title="3）master2"></a>3）master2</h4><p>服务器：192.168.25.138</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b.properties</div></pre></td></tr></table></figure>
<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">#所属集群名字</span></div><div class="line">brokerClusterName=rocketmq-cluster</div><div class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></div><div class="line">brokerName=broker-b</div><div class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></div><div class="line">brokerId=0</div><div class="line"><span class="comment">#显式声明当前master所在的ip地址</span></div><div class="line">brokerIP1=192.168.25.138</div><div class="line"><span class="comment">#nameServer地址，分号分割</span></div><div class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</div><div class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></div><div class="line">defaultTopicQueueNums=4</div><div class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></div><div class="line">autoCreateTopicEnable=<span class="literal">true</span></div><div class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></div><div class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></div><div class="line"><span class="comment">#Broker 对外服务的监听端口</span></div><div class="line">listenPort=10911</div><div class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></div><div class="line">deleteWhen=04</div><div class="line"><span class="comment">#文件保留时间，默认 48 小时</span></div><div class="line">fileReservedTime=120</div><div class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></div><div class="line">mapedFileSizeCommitLog=1073741824</div><div class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></div><div class="line">mapedFileSizeConsumeQueue=300000</div><div class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></div><div class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></div><div class="line"><span class="comment">#检测物理文件磁盘空间</span></div><div class="line">diskMaxUsedSpaceRatio=88</div><div class="line"><span class="comment">#存储路径</span></div><div class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</div><div class="line"><span class="comment">#commitLog 存储路径</span></div><div class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</div><div class="line"><span class="comment">#消费队列存储路径存储路径</span></div><div class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</div><div class="line"><span class="comment">#消息索引存储路径</span></div><div class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</div><div class="line"><span class="comment">#checkpoint 文件存储路径</span></div><div class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</div><div class="line"><span class="comment">#abort 文件存储路径</span></div><div class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</div><div class="line"><span class="comment">#限制的消息大小</span></div><div class="line">maxMessageSize=65536</div><div class="line"><span class="comment">#flushCommitLogLeastPages=4</span></div><div class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></div><div class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></div><div class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></div><div class="line"><span class="comment">#Broker 的角色</span></div><div class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></div><div class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></div><div class="line"><span class="comment">#- SLAVE</span></div><div class="line">brokerRole=SYNC_MASTER</div><div class="line"><span class="comment">#刷盘方式</span></div><div class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></div><div class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></div><div class="line">flushDiskType=SYNC_FLUSH</div><div class="line"><span class="comment">#checkTransactionMessageEnable=false</span></div><div class="line"><span class="comment">#发消息线程池数量</span></div><div class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></div><div class="line"><span class="comment">#拉消息线程池数量</span></div><div class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></div></pre></td></tr></table></figure>
<h4 id="4）slave1"><a href="#4）slave1" class="headerlink" title="4）slave1"></a>4）slave1</h4><p>服务器：192.168.25.138</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker<span class="_">-a</span>-s.properties</div></pre></td></tr></table></figure>
<p>修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">#所属集群名字</span></div><div class="line">brokerClusterName=rocketmq-cluster</div><div class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></div><div class="line">brokerName=broker<span class="_">-a</span></div><div class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></div><div class="line">brokerId=1</div><div class="line"><span class="comment">#显式声明当前slave所在的ip地址</span></div><div class="line">brokerIP1=192.168.25.138</div><div class="line"><span class="comment">#nameServer地址，分号分割</span></div><div class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</div><div class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></div><div class="line">defaultTopicQueueNums=4</div><div class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></div><div class="line">autoCreateTopicEnable=<span class="literal">true</span></div><div class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></div><div class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></div><div class="line"><span class="comment">#Broker 对外服务的监听端口</span></div><div class="line">listenPort=11011</div><div class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></div><div class="line">deleteWhen=04</div><div class="line"><span class="comment">#文件保留时间，默认 48 小时</span></div><div class="line">fileReservedTime=120</div><div class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></div><div class="line">mapedFileSizeCommitLog=1073741824</div><div class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></div><div class="line">mapedFileSizeConsumeQueue=300000</div><div class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></div><div class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></div><div class="line"><span class="comment">#检测物理文件磁盘空间</span></div><div class="line">diskMaxUsedSpaceRatio=88</div><div class="line"><span class="comment">#存储路径</span></div><div class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</div><div class="line"><span class="comment">#commitLog 存储路径</span></div><div class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</div><div class="line"><span class="comment">#消费队列存储路径存储路径</span></div><div class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</div><div class="line"><span class="comment">#消息索引存储路径</span></div><div class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</div><div class="line"><span class="comment">#checkpoint 文件存储路径</span></div><div class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</div><div class="line"><span class="comment">#abort 文件存储路径</span></div><div class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</div><div class="line"><span class="comment">#限制的消息大小</span></div><div class="line">maxMessageSize=65536</div><div class="line"><span class="comment">#flushCommitLogLeastPages=4</span></div><div class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></div><div class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></div><div class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></div><div class="line"><span class="comment">#Broker 的角色</span></div><div class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></div><div class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></div><div class="line"><span class="comment">#- SLAVE</span></div><div class="line">brokerRole=SLAVE</div><div class="line"><span class="comment">#刷盘方式</span></div><div class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></div><div class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></div><div class="line">flushDiskType=ASYNC_FLUSH</div><div class="line"><span class="comment">#checkTransactionMessageEnable=false</span></div><div class="line"><span class="comment">#发消息线程池数量</span></div><div class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></div><div class="line"><span class="comment">#拉消息线程池数量</span></div><div class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></div></pre></td></tr></table></figure>
<h3 id="3-3-81"><a href="#3-3-81" class="headerlink" title="3.3.81"></a>3.3.81</h3><p>同理把其余两个服务器还没有配置的配置文件，根据上面的broker配置，在配置即可</p>
<h3 id="3-3-9-修改启动脚本文件"><a href="#3-3-9-修改启动脚本文件" class="headerlink" title="3.3.9 修改启动脚本文件"></a>3.3.9 修改启动脚本文件</h3><h4 id="1）runbroker-sh"><a href="#1）runbroker-sh" class="headerlink" title="1）runbroker.sh"></a>1）runbroker.sh</h4><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">vi /usr/<span class="built_in">local</span>/rocketmq/bin/runbroker.sh</div></pre></td></tr></table></figure>
<p>需要根据内存大小进行适当的对JVM参数进行调整：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment">#===================================================</span></div><div class="line"><span class="comment"># 开发环境配置 JVM Configuration</span></div><div class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m"</span></div></pre></td></tr></table></figure>
<p>####2）runserver.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">vim /usr/<span class="built_in">local</span>/rocketmq/bin/runserver.sh</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></div></pre></td></tr></table></figure>
<h3 id="3-3-10-服务启动"><a href="#3-3-10-服务启动" class="headerlink" title="3.3.10 服务启动"></a>3.3.10 服务启动</h3><h4 id="1）启动NameServe集群"><a href="#1）启动NameServe集群" class="headerlink" title="1）启动NameServe集群"></a>1）启动NameServe集群</h4><p>分别在192.168.25.135和192.168.25.138启动NameServer</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</div><div class="line">nohup sh mqnamesrv &amp;</div></pre></td></tr></table></figure>
<h4 id="2）启动Broker集群"><a href="#2）启动Broker集群" class="headerlink" title="2）启动Broker集群"></a>2）启动Broker集群</h4><ul>
<li>在192.168.25.135上启动master1和slave2</li>
</ul>
<p>master1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</div><div class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker-a.properties &amp;</div></pre></td></tr></table></figure>
<p>slave2：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</div><div class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker-b-s.properties &amp;</div></pre></td></tr></table></figure>
<ul>
<li>在192.168.25.138上启动master2和slave2</li>
</ul>
<p>master2</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</div><div class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker-b.properties &amp;</div></pre></td></tr></table></figure>
<p>slave1</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</div><div class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker<span class="_">-a</span>-s.properties &amp;</div></pre></td></tr></table></figure>
<h3 id="3-3-11-查看进程状态"><a href="#3-3-11-查看进程状态" class="headerlink" title="3.3.11 查看进程状态"></a>3.3.11 查看进程状态</h3><p>启动后通过JPS查看启动进程</p>
<p><img src="/2019/11/13/RocketMQ基础知识/jps1.png" alt=""></p>
<h3 id="3-3-12-查看日志"><a href="#3-3-12-查看日志" class="headerlink" title="3.3.12 查看日志"></a>3.3.12 查看日志</h3><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 查看nameServer日志</span></div><div class="line">tail -500f ~/logs/rocketmqlogs/namesrv.log</div><div class="line"><span class="comment"># 查看broker日志</span></div><div class="line">tail -500f ~/logs/rocketmqlogs/broker.log</div></pre></td></tr></table></figure>
<h3 id="3-6-重要提示！！！！！"><a href="#3-6-重要提示！！！！！" class="headerlink" title="3.6 重要提示！！！！！"></a>3.6 重要提示！！！！！</h3><p>如果在云服务器上部署，配置跟以上是一样的，但是需要注意的是，为了避免启动的master或者slave使用内网ip进行通信，所以我们在配置《3.3.8broker配置文件中》</p>
<p>在每个properties配置文件中，需要显式声明master或者salve所属的ip地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">brokerIP1=106.13.13.172</div></pre></td></tr></table></figure>
<h2 id="3-4-mqadmin管理工具"><a href="#3-4-mqadmin管理工具" class="headerlink" title="3.4 mqadmin管理工具"></a>3.4 mqadmin管理工具</h2><h3 id="3-4-1-使用方式"><a href="#3-4-1-使用方式" class="headerlink" title="3.4.1 使用方式"></a>3.4.1 使用方式</h3><p>进入RocketMQ安装位置，在bin目录下执行<figure class="highlight plain"><figcaption><span>&#123;command&#125; &#123;args&#125;``` </span></figcaption><table><tr><td class="code"><pre><div class="line"></div><div class="line">###3.4.2 命令介绍</div><div class="line"></div><div class="line">####1）Topic相关</div><div class="line"></div><div class="line">&lt;table border=0 cellpadding=0 cellspacing=0 width=714&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=175&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=185&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl63 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;名称&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=175 style=&apos;width:131pt&apos;&gt;含义&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=177 style=&apos;width:133pt&apos;&gt;命令选项&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=185 style=&apos;width:139pt&apos;&gt;说明&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=132 style=&apos;height:99.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=8 height=593 class=xl68 width=163 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:444.0pt;border-top:none;width:122pt&apos;&gt;updateTopic&lt;/td&gt;</div><div class="line">  &lt;td rowspan=8 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;创建更新Topic配置&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;Broker 地址，表示 topic 所在</div><div class="line">  Broker，只支持单台Broker，地址为ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=132 style=&apos;height:99.0pt&apos;&gt;</div><div class="line">  &lt;td height=132 class=xl65 width=149 style=&apos;height:99.0pt;width:112pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;cluster 名称，表示 topic 所在集群（集群可通过</div><div class="line">  clusterList 查询）&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=149 style=&apos;height:17.0pt;width:112pt&apos;&gt;-h-&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=76 style=&apos;height:57.0pt&apos;&gt;</div><div class="line">  &lt;td height=76 class=xl65 width=149 style=&apos;height:57.0pt;width:112pt&apos;&gt;-p&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;指定新topic的读写权限( W=2|R=4|WR=6 )&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl65 width=149 style=&apos;height:29.0pt;width:112pt&apos;&gt;-r&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;可读队列数（默认为 8）&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl65 width=149 style=&apos;height:29.0pt;width:112pt&apos;&gt;-w&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;可写队列数（默认为 8）&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=95 style=&apos;height:71.0pt&apos;&gt;</div><div class="line">  &lt;td height=95 class=xl65 width=149 style=&apos;height:71.0pt;width:112pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;topic 名称（名称只能使用字符</div><div class="line">  ^[a-zA-Z0-9_-]+$ ）&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=132 style=&apos;height:99.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=307 class=xl68 width=163 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:230.0pt;border-top:none;width:122pt&apos;&gt;deleteTopic&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;删除Topic&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;cluster 名称，表示删除某集群下的某个 topic （集群</div><div class="line">  可通过 clusterList 查询）&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=149 style=&apos;height:17.0pt;width:112pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=95 style=&apos;height:71.0pt&apos;&gt;</div><div class="line">  &lt;td height=95 class=xl65 width=149 style=&apos;height:71.0pt;width:112pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;topic 名称（名称只能使用字符</div><div class="line">  ^[a-zA-Z0-9_-]+$ ）&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=3 height=287 class=xl68 width=163 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:215.0pt;border-top:none;width:122pt&apos;&gt;topicList&lt;/td&gt;</div><div class="line">  &lt;td rowspan=3 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;查看 Topic 列表信息&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=207 style=&apos;height:155.0pt&apos;&gt;</div><div class="line">  &lt;td height=207 class=xl65 width=149 style=&apos;height:155.0pt;width:112pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;不配置-c只返回topic列表，增加-c返回clusterName,</div><div class="line">  topic, consumerGroup信息，即topic的所属集群和订阅关系，没有参数&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=3 height=103 class=xl68 width=163 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:77.0pt;border-top:none;width:122pt&apos;&gt;topicRoute&lt;/td&gt;</div><div class="line">  &lt;td rowspan=3 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;查看 Topic 路由信息&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;topic 名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=149 style=&apos;height:17.0pt;width:112pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=3 height=103 class=xl68 width=163 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:77.0pt;border-top:none;width:122pt&apos;&gt;topicStatus&lt;/td&gt;</div><div class="line">  &lt;td rowspan=3 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;查看 Topic 消息队列offset&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;topic 名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=149 style=&apos;height:17.0pt;width:112pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=3 height=103 class=xl68 width=163 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:77.0pt;border-top:none;width:122pt&apos;&gt;topicClusterList&lt;/td&gt;</div><div class="line">  &lt;td rowspan=3 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;查看 Topic 所在集群列表&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;topic 名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=149 style=&apos;height:17.0pt;width:112pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=6 height=518 class=xl68 width=163 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:380pt;border-top:none;width:122pt&apos;&gt;updateTopicPerm&lt;/td&gt;</div><div class="line">  &lt;td rowspan=6 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;更新 Topic 读写权限&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;topic 名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=149 style=&apos;height:17.0pt;width:112pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=132 style=&apos;height:99.0pt&apos;&gt;</div><div class="line">  &lt;td height=132 class=xl65 width=149 style=&apos;height:99.0pt;width:112pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;Broker 地址，表示 topic 所在</div><div class="line">  Broker，只支持单台Broker，地址为ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=76 style=&apos;height:57.0pt&apos;&gt;</div><div class="line">  &lt;td height=76 class=xl65 width=149 style=&apos;height:57.0pt;width:112pt&apos;&gt;-p&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;指定新 topic 的读写权限( W=2|R=4|WR=6 )&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=207 style=&apos;height:155.0pt&apos;&gt;</div><div class="line">  &lt;td height=207 class=xl65 width=149 style=&apos;height:155.0pt;width:112pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;cluster 名称，表示 topic 所在集群（集群可通过</div><div class="line">  clusterList 查询），-b优先，如果没有-b，则对集群中所有Broker执行命令&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=5 height=199 class=xl68 width=163 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:149.0pt;border-top:none;width:122pt&apos;&gt;updateOrderConf&lt;/td&gt;</div><div class="line">  &lt;td rowspan=5 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;从NameServer上创建、删除、获取特定命名空间的kv配置，目前还未启用&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=149 style=&apos;height:17.0pt;width:112pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;topic，键&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl65 width=149 style=&apos;height:29.0pt;width:112pt&apos;&gt;-v&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;orderConf，值&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-m&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;method，可选get、put、delete&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=198 class=xl68 width=163 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:140pt;border-top:none;width:122pt&apos;&gt;allocateMQ&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;以平均负载算法计算消费者列表负载消息队列的负载结果&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;topic 名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=149 style=&apos;height:17.0pt;width:112pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=95 style=&apos;height:71.0pt&apos;&gt;</div><div class="line">  &lt;td height=95 class=xl65 width=149 style=&apos;height:71.0pt;width:112pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;ipList，用逗号分隔，计算这些ip去负载Topic的消息队列&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=142 class=xl68 width=163 style=&apos;border-bottom:1.0pt solid black;</div><div class="line">  height:106.0pt;border-top:1.0pt;width:122pt&apos;&gt;statsAll&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl70 width=135 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:101pt&apos;&gt;打印Topic订阅关系、TPS、积累量、24h读写总量等信息&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=149 style=&apos;width:112pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=149 style=&apos;height:43.0pt;width:112pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl65 width=149 style=&apos;height:29.0pt;width:112pt&apos;&gt;-a&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;是否只打印活跃topic&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=149 style=&apos;height:17.0pt;width:112pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=159 style=&apos;width:119pt&apos;&gt;指定topic&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">####2）集群相关</div><div class="line"></div><div class="line">&lt;table border=0 cellpadding=0 cellspacing=0 width=714&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=175&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=185&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl63 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;名称&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=175 style=&apos;width:131pt&apos;&gt;含义&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=177 style=&apos;width:133pt&apos;&gt;命令选项&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=185 style=&apos;width:139pt&apos;&gt;说明&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=207 style=&apos;height:155.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=326 class=xl67 width=177 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:244.0pt;border-top:none;width:133pt&apos;&gt;&lt;span</div><div class="line">  style=&apos;mso-spacerun:yes&apos;&gt; &lt;/span&gt;clusterList&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl70 width=175 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:131pt&apos;&gt;查看集群信息，集群、BrokerName、BrokerId、TPS等信息&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=177 style=&apos;width:133pt&apos;&gt;-m&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;打印更多信息 (增加打印出如下信息 #InTotalYest,</div><div class="line">  #OutTotalYest, #InTotalToday ,#OutTotalToday)&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=177 style=&apos;height:43.0pt;width:133pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl65 width=177 style=&apos;height:29.0pt;width:133pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;打印间隔，单位秒&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=95 style=&apos;height:71.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=8 height=391 class=xl67 width=177 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:292.0pt;border-top:none;width:133pt&apos;&gt;clusterRT&lt;/td&gt;</div><div class="line">  &lt;td rowspan=8 class=xl70 width=175 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:131pt&apos;&gt;发送消息检测集群各Broker RT。消息发往$&#123;BrokerName&#125; Topic。&lt;/td&gt;</div><div class="line">  &lt;td class=xl65 width=177 style=&apos;width:133pt&apos;&gt;-a&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;amount，每次探测的总数，RT = 总时间 /</div><div class="line">  amount&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl65 width=177 style=&apos;height:29.0pt;width:133pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;消息大小，单位B&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;探测哪个集群&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=76 style=&apos;height:57.0pt&apos;&gt;</div><div class="line">  &lt;td height=76 class=xl65 width=177 style=&apos;height:57.0pt;width:133pt&apos;&gt;-p&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;是否打印格式化日志，以|分割，默认不打印&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl65 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl65 width=177 style=&apos;height:29.0pt;width:133pt&apos;&gt;-m&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;所属机房，打印使用&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl65 width=177 style=&apos;height:29.0pt;width:133pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;发送间隔，单位秒&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl65 width=177 style=&apos;height:43.0pt;width:133pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl66 width=185 style=&apos;width:139pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">####3）Broker相关</div><div class="line"></div><div class="line">&lt;table border=0 cellpadding=0 cellspacing=0 width=714&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=175&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=185&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl63 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;名称&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=175 style=&apos;width:131pt&apos;&gt;含义&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=177 style=&apos;width:133pt&apos;&gt;命令选项&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=185 style=&apos;width:139pt&apos;&gt;说明&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=6 height=206 class=xl69 width=191 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:154.0pt;border-top:none;width:143pt&apos;&gt;updateBrokerConfig&lt;/td&gt;</div><div class="line">  &lt;td rowspan=6 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;更新 Broker 配置文件，会修改Broker.conf&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker 地址，格式为ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;cluster 名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-k&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;key 值&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-v&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;value 值&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=3 height=137 class=xl69 width=191 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:103.0pt;border-top:none;width:143pt&apos;&gt;brokerStatus&lt;/td&gt;</div><div class="line">  &lt;td rowspan=3 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;查看 Broker 统计信息、运行状态（你想要的信息几乎都在里面）&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker 地址，地址为ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=6 height=256 class=xl69 width=191 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:192.0pt;border-top:none;width:143pt&apos;&gt;brokerConsumeStats&lt;/td&gt;</div><div class="line">  &lt;td rowspan=6 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;Broker中各个消费者的消费情况，按Message Queue维度返回Consume</div><div class="line">  Offset，Broker Offset，Diff，TImestamp等信息&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker 地址，地址为ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;请求超时时间&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-l&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;diff阈值，超过阈值才打印&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-o&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否为顺序topic，一般为false&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=2 height=114 class=xl69 width=191 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:86.0pt;border-top:none;width:143pt&apos;&gt;getBrokerConfig&lt;/td&gt;</div><div class="line">  &lt;td rowspan=2 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;获取Broker配置&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker 地址，地址为ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=3 height=137 class=xl69 width=191 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:103.0pt;border-top:none;width:143pt&apos;&gt;wipeWritePerm&lt;/td&gt;</div><div class="line">  &lt;td rowspan=3 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;从NameServer上清除 Broker写权限&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker 地址，地址为ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=160 class=xl69 width=191 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:120.0pt;border-top:none;width:143pt&apos;&gt;cleanExpiredCQ&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;清理Broker上过期的Consume Queue，如果手动减少对列数可能产生过期队列&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker 地址，地址为ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;集群名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=88 style=&apos;mso-height-source:userset;height:66.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=191 class=xl69 width=191 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:143.0pt;border-top:none;width:143pt&apos;&gt;cleanUnusedTopic&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;清理Broker上不使用的Topic，从内存中释放Topic的Consume</div><div class="line">  Queue，如果手动删除Topic会产生不使用的Topic&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker 地址，地址为ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;集群名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=5 height=199 class=xl69 width=191 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:149.0pt;border-top:none;width:143pt&apos;&gt;sendMsgStatus&lt;/td&gt;</div><div class="line">  &lt;td rowspan=5 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;向Broker发消息，返回发送状态和RT&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;BrokerName，注意不同于Broker地址&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消息大小，单位B&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;发送次数&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">####4）消息相关</div><div class="line"></div><div class="line">&lt;table border=0 cellpadding=0 cellspacing=0 width=714&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=175&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=185&gt;</div><div class="line">&lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl63 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;名称&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=175 style=&apos;width:131pt&apos;&gt;含义&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=177 style=&apos;width:133pt&apos;&gt;命令选项&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=185 style=&apos;width:139pt&apos;&gt;说明&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=128 style=&apos;height:96.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=3 height=208 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:156.0pt;border-top:none;width:65pt&apos;&gt;queryMsgById&lt;/td&gt;</div><div class="line">  &lt;td rowspan=3 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;根据offsetMsgId查询msg，如果使用开源控制台，应使用offsetMsgId，此命令还有其他参数，具体作用请阅读QueryMsgByIdSubCommand。&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;msgId&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=126 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:94.0pt;border-top:none;width:65pt&apos;&gt;queryMsgByKey&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;根据消息 Key 查询消息&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-k&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;msgKey&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Topic 名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=225 style=&apos;height:169.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=6 height=390 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:292.0pt;border-top:none;width:65pt&apos;&gt;queryMsgByOffset&lt;/td&gt;</div><div class="line">  &lt;td rowspan=6 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;根据 Offset 查询消息&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker 名称，（这里需要注意</div><div class="line">  填写的是 Broker 的名称，不是 Broker 的地址，Broker 名称可以在 clusterList 查到）&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;query 队列 id&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-o&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;offset 值&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;topic 名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=47&gt;</div><div class="line">  &lt;td rowspan=6 height=209 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:156.0pt;border-top:none;width:65pt&apos;&gt;queryMsgByUniqueKey&lt;/td&gt;</div><div class="line">  &lt;td rowspan=6 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;根据msgId查询，msgId不同于offsetMsgId，区别详见常见运维问题。-g，-d配合使用，查到消息后尝试让特定的消费者消费消息并返回消费结果&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;uniqe msg id&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=36 style=&apos;height:27.0pt&apos;&gt;</div><div class="line">  &lt;td height=36 class=xl67 width=87 style=&apos;height:27.0pt;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;consumerGroup&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-d&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;clientId&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;topic名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=5 height=149 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:111.0pt;border-top:none;width:65pt&apos;&gt;checkMsgSendRT&lt;/td&gt;</div><div class="line">  &lt;td rowspan=5 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;检测向topic发消息的RT，功能类似clusterRT&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;topic名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-a&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;探测次数&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消息大小&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=8 height=218 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:162.0pt;border-top:none;width:65pt&apos;&gt;sendMessage&lt;/td&gt;</div><div class="line">  &lt;td rowspan=8 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;发送一条消息，可以根据配置发往特定Message Queue，或普通发送。&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;topic名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-p&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;body，消息体&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-k&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;keys&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;tags&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;BrokerName&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;queueId&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=10 height=312 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:232.0pt;border-top:none;width:65pt&apos;&gt;consumeMessage&lt;/td&gt;</div><div class="line">  &lt;td rowspan=10 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;消费消息。可以根据offset、开始&amp;amp;结束时间戳、消息队列消费消息，配置不同执行不同消费逻辑，详见ConsumeMessageCommand。&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;topic名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;BrokerName&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-o&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;从offset开始消费&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;queueId&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消费者分组&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;开始时间戳，格式详见-h&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-d&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;结束时间戳&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消费多少条消息&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=8 height=282 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:210.0pt;border-top:none;width:65pt&apos;&gt;printMsg&lt;/td&gt;</div><div class="line">  &lt;td rowspan=8 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;从Broker消费消息并打印，可选时间段&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;topic名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;字符集，例如UTF-8&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;subExpress，过滤表达式&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;开始时间戳，格式参见-h&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-e&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;结束时间戳&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-d&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否打印消息体&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=12 height=390 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:290.0pt;border-top:none;width:65pt&apos;&gt;printMsgByQueue&lt;/td&gt;</div><div class="line">  &lt;td rowspan=12 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;类似printMsg，但指定Message Queue&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;topic名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;queueId&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-a&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;BrokerName&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;字符集，例如UTF-8&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;subExpress，过滤表达式&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;开始时间戳，格式参见-h&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-e&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;结束时间戳&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-p&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否打印消息&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-d&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否打印消息体&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-f&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否统计tag数量并打印&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=7 height=410 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:307.0pt;border-top:none;width:65pt&apos;&gt;resetOffsetByTime&lt;/td&gt;</div><div class="line">  &lt;td rowspan=7 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;按时间戳重置offset，Broker和consumer都会重置&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消费者分组&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;topic名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;重置为此时间戳对应的offset&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=188 style=&apos;height:141.0pt&apos;&gt;</div><div class="line">  &lt;td height=188 class=xl67 width=87 style=&apos;height:141.0pt;width:65pt&apos;&gt;-f&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否强制重置，如果false，只支持回溯offset，如果true，不管时间戳对应offset与consumeOffset关系&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否重置c++客户端offset&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">#### 5）消费者、消费组相关</div><div class="line"></div><div class="line">&lt;table border=0 cellpadding=0 cellspacing=0 width=714&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=175&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=185&gt;</div><div class="line">&lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl63 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;名称&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=175 style=&apos;width:131pt&apos;&gt;含义&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=177 style=&apos;width:133pt&apos;&gt;命令选项&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=185 style=&apos;width:139pt&apos;&gt;说明&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=158 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:110pt;border-top:none;width:65pt&apos;&gt;consumerProgress&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl72 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  border-top:none;width:65pt&apos;&gt;查看订阅组消费状态，可以查看具体的client IP的消息积累量&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消费者所属组名&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否打印client IP&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=105 style=&apos;mso-height-source:userset;height:79.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=5 height=260 class=xl69 width=87 style=&apos;border-bottom:1.0pt;</div><div class="line">  height:195.0pt;border-top:none;width:65pt&apos;&gt;consumerStatus&lt;/td&gt;</div><div class="line">  &lt;td rowspan=5 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;查看消费者状态，包括同一个分组中是否都是相同的订阅，分析Process</div><div class="line">  Queue是否堆积，返回消费者jstack结果，内容较多，使用者参见ConsumerStatusSubCommand&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=36 style=&apos;height:27.0pt&apos;&gt;</div><div class="line">  &lt;td height=36 class=xl67 width=87 style=&apos;height:27.0pt;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;consumer group&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;clientId&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否执行jstack&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=5 height=181 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:135.0pt;border-top:none;width:65pt&apos;&gt;getConsumerStatus&lt;/td&gt;</div><div class="line">  &lt;td rowspan=5 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;获取 Consumer 消费进度&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消费者所属组名&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;查询主题&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Consumer 客户端 ip&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=13 height=761 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:569.0pt;border-top:none;width:65pt&apos;&gt;updateSubGroup&lt;/td&gt;</div><div class="line">  &lt;td rowspan=13 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;更新或创建订阅关系&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker地址&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;集群名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消费者分组名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;分组是否允许消费&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-m&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否从最小offset开始消费&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-d&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;是否是广播模式&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-q&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;重试队列数量&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-r&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;最大重试次数&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=207 style=&apos;height:155.0pt&apos;&gt;</div><div class="line">  &lt;td height=207 class=xl67 width=87 style=&apos;height:155.0pt;width:65pt&apos;&gt;-i&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;当slaveReadEnable开启时有效，且还未达到从slave消费时建议从哪个BrokerId消费，可以配置备机id，主动从备机消费&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=132 style=&apos;height:99.0pt&apos;&gt;</div><div class="line">  &lt;td height=132 class=xl67 width=87 style=&apos;height:99.0pt;width:65pt&apos;&gt;-w&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;如果Broker建议从slave消费，配置决定从哪个slave消费，配置BrokerId，例如1&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=76 style=&apos;height:57.0pt&apos;&gt;</div><div class="line">  &lt;td height=76 class=xl67 width=87 style=&apos;height:57.0pt;width:65pt&apos;&gt;-a&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;当消费者数量变化时是否通知其他消费者负载均衡&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=5 height=165 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:123.0pt;border-top:none;width:65pt&apos;&gt;deleteSubGroup&lt;/td&gt;</div><div class="line">  &lt;td rowspan=5 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;从Broker删除订阅关系&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-b&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;Broker地址&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-c&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;集群名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td height=39 class=xl67 width=87 style=&apos;height:29.0pt;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消费者分组名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=6 height=172 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:120pt;border-top:none;width:65pt&apos;&gt;cloneGroupOffset&lt;/td&gt;</div><div class="line">  &lt;td rowspan=6 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;在目标群组中使用源群组的offset&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;源消费者组&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-d&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;目标消费者组&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;topic名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-o&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;暂未使用&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">#### 6）连接相关</div><div class="line"></div><div class="line">&lt;table border=0 cellpadding=0 cellspacing=0 width=714&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=175&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=185&gt;</div><div class="line">&lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl63 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;名称&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=175 style=&apos;width:131pt&apos;&gt;含义&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=177 style=&apos;width:133pt&apos;&gt;命令选项&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=185 style=&apos;width:139pt&apos;&gt;说明&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=3 height=119 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:89.0pt;border-top:none;width:65pt&apos;&gt;consumerConnec tion&lt;/td&gt;</div><div class="line">  &lt;td rowspan=3 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;查询 Consumer 的网络连接&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;消费者所属组名&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=39 style=&apos;height:29.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=142 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:106.0pt;border-top:none;width:65pt&apos;&gt;producerConnec tion&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;查询 Producer 的网络连接&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-g&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;生产者所属组名&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-t&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;主题名称&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">#### 7）NameServer相关</div><div class="line"></div><div class="line">&lt;table border=0 cellpadding=0 cellspacing=0 width=714&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=175&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=185&gt;</div><div class="line">&lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl63 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;名称&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=175 style=&apos;width:131pt&apos;&gt;含义&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=177 style=&apos;width:133pt&apos;&gt;命令选项&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=185 style=&apos;width:139pt&apos;&gt;说明&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=21 style=&apos;height:16.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=5 height=143 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:100pt;border-top:none;width:65pt&apos;&gt;updateKvConfig&lt;/td&gt;</div><div class="line">  &lt;td rowspan=5 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;更新NameServer的kv配置，目前还未使用&lt;/td&gt;</div><div class="line">  &lt;td class=xl75 width=87 style=&apos;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl76 width=87 style=&apos;width:65pt&apos;&gt;命名空间&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=21 style=&apos;height:16.0pt&apos;&gt;</div><div class="line">  &lt;td height=21 class=xl75 width=87 style=&apos;height:16.0pt;width:65pt&apos;&gt;-k&lt;/td&gt;</div><div class="line">  &lt;td class=xl75 width=87 style=&apos;width:65pt&apos;&gt;key&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=21 style=&apos;height:16.0pt&apos;&gt;</div><div class="line">  &lt;td height=21 class=xl75 width=87 style=&apos;height:16.0pt;width:65pt&apos;&gt;-v&lt;/td&gt;</div><div class="line">  &lt;td class=xl75 width=87 style=&apos;width:65pt&apos;&gt;value&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=126 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:94.0pt;border-top:none;width:65pt&apos;&gt;deleteKvConfig&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;删除NameServer的kv配置&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-s&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;命名空间&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-k&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;key&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td height=57 class=xl67 width=87 style=&apos;height:43.0pt;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=2 height=80 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:60.0pt;border-top:none;width:65pt&apos;&gt;getNamesrvConfig&lt;/td&gt;</div><div class="line">  &lt;td rowspan=2 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;获取NameServer配置&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=4 height=126 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:94.0pt;border-top:none;width:65pt&apos;&gt;updateNamesrvConfig&lt;/td&gt;</div><div class="line">  &lt;td rowspan=4 class=xl72 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;修改NameServer配置&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-k&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;key&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-v&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;value&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">#### 8）其他</div><div class="line"></div><div class="line">&lt;table border=0 cellpadding=0 cellspacing=0 width=714&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=175&gt;</div><div class="line"> &lt;col width=177&gt;</div><div class="line"> &lt;col width=185&gt;</div><div class="line">&lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl63 width=177 style=&apos;height:17.0pt;width:133pt&apos;&gt;名称&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=175 style=&apos;width:131pt&apos;&gt;含义&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=177 style=&apos;width:133pt&apos;&gt;命令选项&lt;/td&gt;</div><div class="line">  &lt;td class=xl64 width=185 style=&apos;width:139pt&apos;&gt;说明&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=57 style=&apos;height:43.0pt&apos;&gt;</div><div class="line">  &lt;td rowspan=2 height=80 class=xl69 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  height:60.0pt;border-top:none;width:65pt&apos;&gt;startMonitoring&lt;/td&gt;</div><div class="line">  &lt;td rowspan=2 class=xl71 width=87 style=&apos;border-bottom:1.0pt</div><div class="line">  border-top:none;width:65pt&apos;&gt;开启监控进程，监控消息误删、重试队列消息数等&lt;/td&gt;</div><div class="line">  &lt;td class=xl67 width=87 style=&apos;width:65pt&apos;&gt;-n&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;NameServer 服务地址，格式 ip:port&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line"> &lt;tr height=23 style=&apos;height:17.0pt&apos;&gt;</div><div class="line">  &lt;td height=23 class=xl67 width=87 style=&apos;height:17.0pt;width:65pt&apos;&gt;-h&lt;/td&gt;</div><div class="line">  &lt;td class=xl68 width=87 style=&apos;width:65pt&apos;&gt;打印帮助&lt;/td&gt;</div><div class="line"> &lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div><div class="line"></div><div class="line">### 3.4.3 注意事项</div><div class="line"></div><div class="line">* 几乎所有命令都需要配置-n表示NameServer地址，格式为ip:port</div><div class="line">* 几乎所有命令都可以通过-h获取帮助</div><div class="line">* 如果既有Broker地址（-b）配置项又有clusterName（-c）配置项，则优先以Broker地址执行命令；如果不配置Broker地址，则对集群中所有主机执行命令</div><div class="line"></div><div class="line">## 3.5 集群监控平台搭建</div><div class="line"></div><div class="line">### 3.5.1 概述</div><div class="line"></div><div class="line">`RocketMQ`有一个对其扩展的开源项目[incubator-rocketmq-externals](https://github.com/apache/rocketmq-externals)，这个项目中有一个子模块叫`rocketmq-console`，这个便是管理控制台项目了，先将[incubator-rocketmq-externals](https://github.com/apache/rocketmq-externals)拉到本地，因为我们需要自己对`rocketmq-console`进行编译打包运行。</div><div class="line"></div><div class="line">![](rocketmq总结/rocketmq-console.png)</div><div class="line"></div><div class="line">### 3.5.2 下载并编译打包</div><div class="line"></div><div class="line">```sh</div><div class="line">git clone https://github.com/apache/rocketmq-externals</div><div class="line">cd rocketmq-console</div><div class="line">mvn clean package -Dmaven.test.skip=true</div></pre></td></tr></table></figure></p>
<p>注意：打包前在<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">```sh</div><div class="line">rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876</div></pre></td></tr></table></figure></p>
<p>启动rocketmq-console：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">java -jar rocketmq-console-ng-1.0.0.jar</div></pre></td></tr></table></figure>
<p>启动成功后，我们就可以通过浏览器访问<code>http://localhost:8080</code>进入控制台界面了，如下图：</p>
<p><img src="/2019/11/13/RocketMQ基础知识/rocketmq-console2.png" alt=""></p>
<p>集群状态：</p>
<p><img src="/2019/11/13/RocketMQ基础知识/rocketmq-console3.png" alt=""></p>
<h1 id="4-消息发送样例"><a href="#4-消息发送样例" class="headerlink" title="4. 消息发送样例"></a>4. 消息发送样例</h1><ul>
<li>导入MQ客户端依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>消息发送者步骤分析</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><div class="line">1.创建消息生产者producer，并制定生产者组名</div><div class="line">2.指定Nameserver地址</div><div class="line">3.启动producer</div><div class="line">4.创建消息对象，指定主题Topic、Tag和消息体</div><div class="line">5.发送消息</div><div class="line">6.关闭生产者producer</div></pre></td></tr></table></figure>
<ul>
<li>消息消费者步骤分析</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><div class="line">1.创建消费者Consumer，制定消费者组名</div><div class="line">2.指定Nameserver地址</div><div class="line">3.订阅主题Topic和Tag</div><div class="line">4.设置回调函数，处理消息</div><div class="line">5.启动消费者consumer</div></pre></td></tr></table></figure>
<h2 id="4-1-基本样例"><a href="#4-1-基本样例" class="headerlink" title="4.1 基本样例"></a>4.1 基本样例</h2><h3 id="4-1-1-消息发送"><a href="#4-1-1-消息发送" class="headerlink" title="4.1.1 消息发送"></a>4.1.1 消息发送</h3><h4 id="1）发送同步消息"><a href="#1）发送同步消息" class="headerlink" title="1）发送同步消息"></a>1）发送同步消息</h4><p><strong>意思就是：生产者发送消息后，阻塞等待rmq的ack通知。</strong></p>
<p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    	<span class="comment">// 实例化消息生产者Producer</span></div><div class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</div><div class="line">    	<span class="comment">// 设置NameServer的地址</span></div><div class="line">    	producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</div><div class="line">    	<span class="comment">// 启动Producer实例</span></div><div class="line">        producer.start();</div><div class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">    	    <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></div><div class="line">    	    Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</div><div class="line">        	<span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</div><div class="line">        	(<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></div><div class="line">        	);</div><div class="line">        	<span class="comment">// 发送消息到一个Broker</span></div><div class="line">            SendResult sendResult = producer.send(msg);<span class="comment">//阻塞等待rmq的ack</span></div><div class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></div><div class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</div><div class="line">    	&#125;</div><div class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></div><div class="line">    	producer.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2）发送异步消息"><a href="#2）发送异步消息" class="headerlink" title="2）发送异步消息"></a>2）发送异步消息</h4><p>​    异步消息通常用在对<strong>响应时间敏感（不用阻塞等待rmq响应）</strong>的业务场景，即发送端不能容忍长时间地等待Broker的响应。</p>
<p>​    提供了通过回调函数的方式，触发broker响应的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    	<span class="comment">// 实例化消息生产者Producer</span></div><div class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</div><div class="line">    	<span class="comment">// 设置NameServer的地址</span></div><div class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</div><div class="line">    	<span class="comment">// 启动Producer实例</span></div><div class="line">        producer.start();</div><div class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</div><div class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">            	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></div><div class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</div><div class="line">                    <span class="string">"TagA"</span>,</div><div class="line">                    <span class="string">"OrderID188"</span>,</div><div class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</div><div class="line">                <span class="comment">// SendCallback接收异步返回结果的回调</span></div><div class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</div><div class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</div><div class="line">                            sendResult.getMsgId());</div><div class="line">                    &#125;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">      	              System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</div><div class="line">      	              e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">            	&#125;);</div><div class="line">    	&#125;</div><div class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></div><div class="line">    	producer.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3）单向发送消息"><a href="#3）单向发送消息" class="headerlink" title="3）单向发送消息"></a>3）单向发送消息</h4><p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    	<span class="comment">// 实例化消息生产者Producer</span></div><div class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</div><div class="line">    	<span class="comment">// 设置NameServer的地址</span></div><div class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</div><div class="line">    	<span class="comment">// 启动Producer实例</span></div><div class="line">        producer.start();</div><div class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">        	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></div><div class="line">        	Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</div><div class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</div><div class="line">                (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></div><div class="line">        	);</div><div class="line">        	<span class="comment">// 发送单向消息，没有任何返回结果</span></div><div class="line">        	producer.sendOneway(msg);</div><div class="line"></div><div class="line">    	&#125;</div><div class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></div><div class="line">    	producer.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-1-2-消费消息"><a href="#4-1-2-消费消息" class="headerlink" title="4.1.2 消费消息"></a>4.1.2 消费消息</h3><p>消息消费模式由消费者来决定，可以由消费者设置MessageModel来决定消息模式。</p>
<p><strong>消息模式默认为集群消费模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</div><div class="line">consumer.setMessageModel(MessageModel.CLUSTERING);</div></pre></td></tr></table></figure>
<h4 id="1）负载均衡-集群模式-默认模式"><a href="#1）负载均衡-集群模式-默认模式" class="headerlink" title="1）负载均衡/集群模式 - 默认模式"></a>1）负载均衡/集群模式 - 默认模式</h4><p>消费者采用负载均衡方式消费消息，<strong>多个消费者共同消费队列消息，每个消费者处理的消息不同</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></div><div class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</div><div class="line">    <span class="comment">// 指定Namesrv地址信息.</span></div><div class="line">    consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</div><div class="line">    <span class="comment">// 订阅Topic</span></div><div class="line">    consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</div><div class="line">    <span class="comment">//负载均衡模式消费</span></div><div class="line">    consumer.setMessageModel(MessageModel.CLUSTERING);</div><div class="line">    <span class="comment">// 注册回调函数，处理消息</span></div><div class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></div><div class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</div><div class="line">            System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, </div><div class="line">                              Thread.currentThread().getName(), msgs);</div><div class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<span class="comment">//消费完成后需要返回值，这里标识消费成功</span></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//启动消息者</span></div><div class="line">    consumer.start();</div><div class="line">    System.out.printf(<span class="string">"Consumer Started.%n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>架构图</p>
<p><img src="/2019/11/13/RocketMQ基础知识/160707_kSpS_1469576.png" alt="rocketmq总结"></p>
<p>集群消息是指<strong>集群化部署消费者</strong></p>
<p>当使用集群消费模式时，MQ 认为任意一条消息只需要被集群内的任意一个消费者处理即可。</p>
<p><strong>特点</strong></p>
<ul>
<li>每条消息只需要被处理一次，broker只会把消息发送给消费集群中的一个消费者</li>
<li>在消息重投时（为什么会重投，那是因为你没有返回ack给rmq，所以rmq认为你没收到会再重发），但是不能保证路由到同一台机器上</li>
<li>消费状态由broker维护</li>
</ul>
<h4 id="2）广播模式"><a href="#2）广播模式" class="headerlink" title="2）广播模式"></a>2）广播模式</h4><p>消费者采用广播的方式消费消息，<strong>每个消费者消费的消息都是相同的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></div><div class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</div><div class="line">    <span class="comment">// 指定Namesrv地址信息.</span></div><div class="line">    consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</div><div class="line">    <span class="comment">// 订阅Topic</span></div><div class="line">    consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</div><div class="line">    <span class="comment">//广播模式消费</span></div><div class="line">    consumer.setMessageModel(MessageModel.BROADCASTING);</div><div class="line">    <span class="comment">// 注册回调函数，处理消息</span></div><div class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;<span class="comment">//一个queue开启多个线程同时消费</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></div><div class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</div><div class="line">            System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, </div><div class="line">                              Thread.currentThread().getName(), msgs);</div><div class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//启动消息者</span></div><div class="line">    consumer.start();</div><div class="line">    System.out.printf(<span class="string">"Consumer Started.%n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2019/11/13/RocketMQ基础知识/160902_4AOI_1469576.png" alt="rocketmq总结"></p>
<p>​    当使用广播消费模式时，MQ 会将每条消息推送给集群内所有注册过的客户端，保证消息至少被每台机器消费一次。</p>
<p><strong>特点</strong></p>
<ul>
<li><p>消费进度由consumer维护</p>
</li>
<li><p>保证每个消费者消费一次消息</p>
</li>
<li><p><strong>消费失败的消息不会重投</strong></p>
</li>
</ul>
<h3 id="为什么要定义组名！！！！"><a href="#为什么要定义组名！！！！" class="headerlink" title="为什么要定义组名！！！！"></a>为什么要定义组名！！！！</h3><p>我们可以看到在创建生产者或者消费者的时候，构造函数都需要传递一个组名；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;please_rename_unique_group_name&quot;);</div><div class="line"></div><div class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;group1&quot;);</div></pre></td></tr></table></figure>
<p>我们可以回过头看一下rmq集群架构图：</p>
<p><img src="/2019/11/13/RocketMQ基础知识/RocketMQ集群.png" alt=""></p>
<p>可以看到生产者和消费者，都会构建一个集群。那么例如生产者构建集群的目的到底有设么用？生产者不就负责发送消息就可以了么？</p>
<p>​    答案是：<strong>事务消息的时候会使用。</strong>我们是否还记得，rmq会回查生产者的接口，确认本次半消息是否投递commit。</p>
<p>而消费者定义组名，那么就可以做负载均衡。相同组内的所有消费者在消费消息时可以做负载均衡。</p>
<h2 id="4-2-顺序消息"><a href="#4-2-顺序消息" class="headerlink" title="4.2 顺序消息"></a>4.2 顺序消息</h2><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，<strong>可以分为分区有序或者全局有序</strong>。</p>
<p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)（<strong>broker中 可能存在多个队列</strong>）；而消费消息的时候从多个queue上拉取消息（<strong>消费者多线程消费消息</strong>），这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次<strong>发送到同一个queue中</strong>，<strong>消费的时候只从这个queue上依次拉取</strong>，则就保证了顺序。当发送和消费参与的queue只有一个，则是<strong>全局有序</strong>；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p>
<p>​    下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。</p>
<h3 id="4-2-1-顺序消息生产"><a href="#4-2-1-顺序消息生产" class="headerlink" title="4.2.1 顺序消息生产"></a>4.2.1 顺序消息生产</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Producer，发送顺序消息</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</div><div class="line"></div><div class="line">       producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</div><div class="line"></div><div class="line">       producer.start();</div><div class="line"></div><div class="line">       String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>&#125;;</div><div class="line"></div><div class="line">       <span class="comment">// 订单列表</span></div><div class="line">       List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> Producer().buildOrders();</div><div class="line"></div><div class="line">       Date date = <span class="keyword">new</span> Date();</div><div class="line">       SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">       String dateStr = sdf.format(date);</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">           <span class="comment">// 加个时间前缀</span></div><div class="line">           String body = dateStr + <span class="string">" Hello RocketMQ "</span> + orderList.get(i);</div><div class="line">           Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i, body.getBytes());</div><div class="line"></div><div class="line">                       <span class="comment">/**</span></div><div class="line"><span class="comment">             * 参数一：消息对象</span></div><div class="line"><span class="comment">             * 参数二：消息队列的选择器</span></div><div class="line"><span class="comment">             * 参数三：选择队列的业务标识（订单ID）</span></div><div class="line"><span class="comment">             */</span></div><div class="line">           SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</div><div class="line">                               <span class="comment">/**</span></div><div class="line"><span class="comment">                 *</span></div><div class="line"><span class="comment">                 * <span class="doctag">@param</span> mqs：队列集合，TopicTest主题下的所有消息队列</span></div><div class="line"><span class="comment">                 * <span class="doctag">@param</span> msg：消息对象</span></div><div class="line"><span class="comment">                 * <span class="doctag">@param</span> arg：业务标识的参数，，也就是在执行send方法时的传递第三个参数，他会回传到select方法</span></div><div class="line"><span class="comment">                 * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">                 */</span></div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</div><div class="line">                   Long id = (Long) arg;  <span class="comment">//根据订单id选择发送queue</span></div><div class="line">                   <span class="keyword">long</span> index = id % mqs.size();</div><div class="line">                   <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</div><div class="line">               &#125;</div><div class="line">           &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></div><div class="line"></div><div class="line">           System.out.println(String.format(<span class="string">"SendResult status:%s, queueId:%d, body:%s"</span>,</div><div class="line">               sendResult.getSendStatus(),</div><div class="line">               sendResult.getMessageQueue().getQueueId(),</div><div class="line">               body));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       producer.shutdown();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 订单的步骤</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStep</span> </span>&#123;</div><div class="line">       <span class="keyword">private</span> <span class="keyword">long</span> orderId;</div><div class="line">       <span class="keyword">private</span> String desc;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> orderId;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">long</span> orderId)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.orderId = orderId;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> desc;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.desc = desc;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="string">"OrderStep&#123;"</span> +</div><div class="line">               <span class="string">"orderId="</span> + orderId +</div><div class="line">               <span class="string">", desc='"</span> + desc + <span class="string">'\''</span> +</div><div class="line">               <span class="string">'&#125;'</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 生成模拟订单数据</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">private</span> List&lt;OrderStep&gt; <span class="title">buildOrders</span><span class="params">()</span> </span>&#123;</div><div class="line">       List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> ArrayList&lt;OrderStep&gt;();</div><div class="line"></div><div class="line">       OrderStep orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"推送"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</div><div class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</div><div class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</div><div class="line">       orderList.add(orderDemo);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> orderList;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-2-2-顺序消费消息"><a href="#4-2-2-顺序消费消息" class="headerlink" title="4.2.2 顺序消费消息"></a>4.2.2 顺序消费消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerInOrder</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       DefaultMQPushConsumer consumer = <span class="keyword">new</span> </div><div class="line">           DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_3"</span>);</div><div class="line">       consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</div><div class="line">       <span class="comment">/**</span></div><div class="line"><span class="comment">        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></div><div class="line"><span class="comment">        * 如果非第一次启动，那么按照上次消费的位置继续消费</span></div><div class="line"><span class="comment">        */</span></div><div class="line">       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</div><div class="line"></div><div class="line">       consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</div><div class="line"></div><div class="line">       consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;<span class="comment">//注册顺序消费监听</span></div><div class="line"></div><div class="line">           Random random = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</div><div class="line">               context.setAutoCommit(<span class="keyword">true</span>);</div><div class="line">               <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</div><div class="line">                   <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></div><div class="line">                   System.out.println(<span class="string">"consumeThread="</span> + Thread.currentThread().getName() + <span class="string">"queueId="</span> + msg.getQueueId() + <span class="string">", content:"</span> + <span class="keyword">new</span> String(msg.getBody()));</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">//模拟业务逻辑处理中...</span></div><div class="line">                   TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</div><div class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       consumer.start();</div><div class="line"></div><div class="line">       System.out.println(<span class="string">"Consumer Started."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">消费者启动</div><div class="line">线程名称：【ConsumeMessageThread_1】:OrderStep&#123;orderId=1065, desc=&apos;创建&apos;&#125;</div><div class="line">线程名称：【ConsumeMessageThread_1】:OrderStep&#123;orderId=1065, desc=&apos;付款&apos;&#125;</div><div class="line">线程名称：【ConsumeMessageThread_1】:OrderStep&#123;orderId=1065, desc=&apos;完成&apos;&#125;</div><div class="line"></div><div class="line">线程名称：【ConsumeMessageThread_2】:OrderStep&#123;orderId=7235, desc=&apos;创建&apos;&#125;</div><div class="line">线程名称：【ConsumeMessageThread_2】:OrderStep&#123;orderId=7235, desc=&apos;付款&apos;&#125;</div><div class="line">线程名称：【ConsumeMessageThread_2】:OrderStep&#123;orderId=7235, desc=&apos;完成&apos;&#125;</div><div class="line"></div><div class="line">线程名称：【ConsumeMessageThread_3】:OrderStep&#123;orderId=1039, desc=&apos;创建&apos;&#125;</div><div class="line">线程名称：【ConsumeMessageThread_3】:OrderStep&#123;orderId=1039, desc=&apos;付款&apos;&#125;</div><div class="line">线程名称：【ConsumeMessageThread_3】:OrderStep&#123;orderId=1039, desc=&apos;推送&apos;&#125;</div><div class="line">线程名称：【ConsumeMessageThread_3】:OrderStep&#123;orderId=1039, desc=&apos;完成&apos;&#125;</div></pre></td></tr></table></figure>
<p>同一个队列，都是用相同的线程消费（<strong>一个queue开启一个线程消费</strong>）。</p>
<h2 id="4-3-延时消息"><a href="#4-3-延时消息" class="headerlink" title="4.3 延时消息"></a>4.3 延时消息</h2><p>比如电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p>
<h3 id="4-3-1-启动消息消费者"><a href="#4-3-1-启动消息消费者" class="headerlink" title="4.3.1 启动消息消费者"></a>4.3.1 启动消息消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageConsumer</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      <span class="comment">// 实例化消费者</span></div><div class="line">      DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"ExampleConsumer"</span>);</div><div class="line">      <span class="comment">// 订阅Topics</span></div><div class="line">      consumer.subscribe(<span class="string">"TestTopic"</span>, <span class="string">"*"</span>);</div><div class="line">      <span class="comment">// 注册消息监听者</span></div><div class="line">      consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> </span>&#123;</div><div class="line">              <span class="keyword">for</span> (MessageExt message : messages) &#123;</div><div class="line">                  <span class="comment">// Print approximate delay time period</span></div><div class="line">                  System.out.println(<span class="string">"Receive message[msgId="</span> + message.getMsgId() + <span class="string">"] "</span> + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="string">"ms later"</span>);<span class="comment">//当前时间减去，消息保存到队列时间，就可以验证生产者设置的延时是否生效</span></div><div class="line">              &#125;</div><div class="line">              <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">      <span class="comment">// 启动消费者</span></div><div class="line">      consumer.start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-3-2-发送延时消息"><a href="#4-3-2-发送延时消息" class="headerlink" title="4.3.2 发送延时消息"></a>4.3.2 发送延时消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageProducer</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      <span class="comment">// 实例化一个生产者来产生延时消息</span></div><div class="line">      DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</div><div class="line">      <span class="comment">// 启动生产者</span></div><div class="line">      producer.start();</div><div class="line">      <span class="keyword">int</span> totalMessagesToSend = <span class="number">100</span>;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</div><div class="line">          Message message = <span class="keyword">new</span> Message(<span class="string">"TestTopic"</span>, (<span class="string">"Hello scheduled message "</span> + i).getBytes());</div><div class="line">          <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></div><div class="line">          message.setDelayTimeLevel(<span class="number">3</span>);</div><div class="line">          <span class="comment">// 发送消息</span></div><div class="line">          producer.send(message);</div><div class="line">      &#125;</div><div class="line">       <span class="comment">// 关闭生产者</span></div><div class="line">      producer.shutdown();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###4.3.3 验证</p>
<p>您将会看到消息的消费比存储时间晚10秒</p>
<h3 id="4-3-4-使用限制"><a href="#4-3-4-使用限制" class="headerlink" title="4.3.4 使用限制"></a>4.3.4 使用限制</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></div><div class="line"><span class="keyword">private</span> String messageDelayLevel = <span class="string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span>;</div><div class="line"></div><div class="line">使用方式：message.setDelayTimeLevel(<span class="number">3</span>);表示延时<span class="number">10</span>s</div><div class="line">    同理：message.setDelayTimeLevel(<span class="number">0</span>)，表示延时<span class="number">1</span>s</div></pre></td></tr></table></figure>
<p>现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18</p>
<h2 id="4-4-批量消息"><a href="#4-4-批量消息" class="headerlink" title="4.4 批量消息"></a>4.4 批量消息</h2><p>批量发送消息能显著提高传递小消息的性能。<strong>限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB。</strong></p>
<h3 id="4-4-1-发送批量消息"><a href="#4-4-1-发送批量消息" class="headerlink" title="4.4.1 发送批量消息"></a>4.4.1 发送批量消息</h3><p>如果您每次只发送不超过4MB的消息，则很容易使用批处理，样例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String topic = <span class="string">"BatchTest"</span>;</div><div class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID001"</span>, <span class="string">"Hello world 0"</span>.getBytes()));</div><div class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID002"</span>, <span class="string">"Hello world 1"</span>.getBytes()));</div><div class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID003"</span>, <span class="string">"Hello world 2"</span>.getBytes()));</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   producer.send(messages);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">   e.printStackTrace();</div><div class="line">   <span class="comment">//处理error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果消息的总长度可能大于4MB时，这时候最好把消息进行分割</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSplitter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">List</span>&lt;<span class="title">Message</span>&gt;&gt; </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_LIMIT = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> currIndex;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.messages = messages;</div><div class="line">   &#125;</div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> currIndex &lt; messages.size();</div><div class="line">   &#125;</div><div class="line">   	<span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Message&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> nextIndex = currIndex;</div><div class="line">       <span class="keyword">int</span> totalSize = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</div><div class="line">           Message message = messages.get(nextIndex);</div><div class="line">           <span class="keyword">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</div><div class="line">           Map&lt;String, String&gt; properties = message.getProperties();</div><div class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</div><div class="line">               tmpSize += entry.getKey().length() + entry.getValue().length();</div><div class="line">           &#125;</div><div class="line">           tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">// 增加日志的开销20字节</span></div><div class="line">           <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</div><div class="line">               <span class="comment">//单个消息超过了最大的限制</span></div><div class="line">               <span class="comment">//忽略,否则会阻塞分裂的进程</span></div><div class="line">               <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">//假如下一个子列表没有元素,则添加这个子列表然后退出循环,否则只是退出循环</span></div><div class="line">                  nextIndex++;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               totalSize += tmpSize;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">       List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</div><div class="line">       currIndex = nextIndex;</div><div class="line">       <span class="keyword">return</span> subList;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//把大的消息分裂成若干个小的消息</span></div><div class="line">ListSplitter splitter = <span class="keyword">new</span> ListSplitter(messages);</div><div class="line"><span class="keyword">while</span> (splitter.hasNext()) &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      List&lt;Message&gt;  listItem = splitter.next();</div><div class="line">      producer.send(listItem);</div><div class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">      <span class="comment">//处理error</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-5-过滤消息"><a href="#4-5-过滤消息" class="headerlink" title="4.5 过滤消息"></a>4.5 过滤消息</h2><p>在大多数情况下，TAG是一个简单而有用的设计，其可以来选择您想要的消息。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"CID_EXAMPLE"</span>);</div><div class="line">consumer.subscribe(<span class="string">"TOPIC"</span>, <span class="string">"TAGA || TAGB || TAGC"</span>);</div></pre></td></tr></table></figure>
<p><strong>消费者将接收包含TAGA或TAGB或TAGC的消息</strong>。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。在这种情况下，可以使用SQL表达式筛选消息。SQL特性可以通过发送消息时的属性来进行计算。在RocketMQ定义的语法下，可以实现一些简单的逻辑。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">------------</div><div class="line">| message  |</div><div class="line">|----------|  a &gt; 5 AND b = &apos;abc&apos;</div><div class="line">| a = 10   |  --------------------&gt; Gotten</div><div class="line">| b = &apos;abc&apos;|</div><div class="line">| c = true |</div><div class="line">------------</div><div class="line">------------</div><div class="line">| message  |</div><div class="line">|----------|   a &gt; 5 AND b = &apos;abc&apos;</div><div class="line">| a = 1    |  --------------------&gt; Missed</div><div class="line">| b = &apos;abc&apos;|</div><div class="line">| c = true |</div><div class="line">------------</div></pre></td></tr></table></figure>
<h3 id="4-5-1-SQL基本语法"><a href="#4-5-1-SQL基本语法" class="headerlink" title="4.5.1 SQL基本语法"></a>4.5.1 SQL基本语法</h3><p>RocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p>
<ul>
<li>数值比较，比如：<strong>&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=；</strong></li>
<li>字符比较，比如：<strong>=，&lt;&gt;，IN；</strong></li>
<li><strong>IS NULL</strong> 或者 <strong>IS NOT NULL；</strong></li>
<li>逻辑符号 <strong>AND，OR，NOT；</strong></li>
</ul>
<p>常量支持类型为：</p>
<ul>
<li>数值，比如：<strong>123，3.1415；</strong></li>
<li>字符，比如：<strong>‘abc’，必须用单引号包裹起来；</strong></li>
<li><strong>NULL</strong>，特殊的常量</li>
<li>布尔值，<strong>TRUE</strong> 或 <strong>FALSE</strong></li>
</ul>
<p>只有使用push模式的消费者才能用使用SQL92标准的sql语句，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(finalString topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span></div></pre></td></tr></table></figure>
<h3 id="4-5-2-消息生产者"><a href="#4-5-2-消息生产者" class="headerlink" title="4.5.2 消息生产者"></a>4.5.2 消息生产者</h3><p>发送消息时，你能通过<code>putUserProperty</code>来设置消息的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</div><div class="line">producer.start();</div><div class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</div><div class="line">   tag,</div><div class="line">   (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</div><div class="line">);</div><div class="line"><span class="comment">// 设置一些属性</span></div><div class="line">msg.putUserProperty(<span class="string">"a"</span>, String.valueOf(i));</div><div class="line">SendResult sendResult = producer.send(msg);</div><div class="line"></div><div class="line">producer.shutdown();</div></pre></td></tr></table></figure>
<h3 id="4-5-3-消息消费者"><a href="#4-5-3-消息消费者" class="headerlink" title="4.5.3 消息消费者"></a>4.5.3 消息消费者</h3><p>用MessageSelector.bySql来使用sql筛选消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</div><div class="line"><span class="comment">// 只有订阅的消息有这个属性a, a &gt;=0 and a &lt;= 3</span></div><div class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, MessageSelector.bySql(<span class="string">"a between 0 and 3"</span>);</div><div class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</div><div class="line">   &#125;</div><div class="line">&#125;);</div><div class="line">consumer.start();</div></pre></td></tr></table></figure>
<h2 id="4-6-事务消息"><a href="#4-6-事务消息" class="headerlink" title="4.6 事务消息"></a>4.6 事务消息</h2><p>###4.6.1 流程分析</p>
<p><img src="/2019/11/13/RocketMQ基础知识/事务消息.png" alt=""></p>
<p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<p><strong>分布式系统中的事务可以使用TCC（Try、Confirm、Cancel）、2pc来解决分布式系统中的消息原子性</strong></p>
<p><strong>rmq的事务消息默认使用，2PC。</strong></p>
<p>####1）事务消息发送及提交</p>
<p>(1) 发送消息（half消息）（预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<h4 id="2）事务补偿"><a href="#2）事务补偿" class="headerlink" title="2）事务补偿"></a>2）事务补偿</h4><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="3）事务消息状态"><a href="#3）事务消息状态" class="headerlink" title="3）事务消息状态"></a>3）事务消息状态</h4><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。broker端会删除半消息</li>
<li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li>
</ul>
<h4 id="RocketMQ实现方式"><a href="#RocketMQ实现方式" class="headerlink" title="RocketMQ实现方式"></a>RocketMQ实现方式</h4><p><strong>Half Message：</strong>预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中</p>
<p><strong>检查事务状态：</strong>Broker会开启一个定时任务，消费RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，等待下一次回调。</p>
<p><strong>超时：</strong>如果超过回查次数，默认回滚消息</p>
<h4 id="TransactionListener的两个方法"><a href="#TransactionListener的两个方法" class="headerlink" title="TransactionListener的两个方法"></a>TransactionListener的两个方法</h4><p>executeLocalTransaction</p>
<p>半消息发送成功触发此方法来执行本地事务</p>
<p>checkLocalTransaction</p>
<p>broker将发送检查消息来检查事务状态，并将调用此方法来获取本地事务状态</p>
<p>###4.6.1 发送事务消息</p>
<h4 id="1-创建事务性生产者"><a href="#1-创建事务性生产者" class="headerlink" title="1) 创建事务性生产者"></a>1) 创建事务性生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。回传的事务状态在请参考前一节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</div><div class="line">        <span class="comment">//创建事务监听器</span></div><div class="line">        TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</div><div class="line">        <span class="comment">//创建消息生产者</span></div><div class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"group6"</span>);</div><div class="line">        producer.setNamesrvAddr(<span class="string">"192.168.25.135:9876;192.168.25.138:9876"</span>);</div><div class="line">        <span class="comment">//生产者设置监听器</span></div><div class="line">        producer.setTransactionListener(transactionListener);</div><div class="line">        <span class="comment">//启动消息生产者</span></div><div class="line">        producer.start();</div><div class="line">        String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>&#125;;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TransactionTopic"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i,</div><div class="line">                        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</div><div class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</div><div class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//producer.shutdown();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2）实现事务的监听接口"><a href="#2）实现事务的监听接口" class="headerlink" title="2）实现事务的监听接口"></a>2）实现事务的监听接口</h4><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTranscation</code> 方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"执行本地事务"</span>);</div><div class="line">        <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagA"</span>, msg.getTags())) &#123;</div><div class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagB"</span>, msg.getTags())) &#123;</div><div class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">      <span class="comment">//提供给mq回查本次本地事务执行的状态，然后返回响应的消息的事务状态</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"MQ检查消息Tag【"</span>+msg.getTags()+<span class="string">"】的本地事务执行结果"</span>);</div><div class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-6-2-使用限制"><a href="#4-6-2-使用限制" class="headerlink" title="4.6.2 使用限制"></a>4.6.2 使用限制</h3><ol>
<li>事务消息不支持延时消息和批量消息。</li>
<li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</li>
<li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</li>
<li>事务性消息可能不止一次被检查或消费。</li>
<li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li>
<li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li>
</ol>
<h1 id="kafka和rmq"><a href="#kafka和rmq" class="headerlink" title="kafka和rmq"></a>kafka和rmq</h1><p>kafka的定位是：日志处理，那么他对消息的丢失是可以容忍的。</p>
<p>rmq的定位是：消息中间件，对于消息的丢失和处理要求更高。rmq他是借鉴与kafka产生的。</p>
<p>​    rmq中，broker的master之间是没有进行数据同步的，生产者发送的消息会路由到其中某一个master。也就是说，2m-2s架构中两个master的作用就相当于负载均衡的效果，就是为了承担生产者的写请求压力。两个slave就是承担消费者的读压力。</p>
<p>​    也就是说，整个rmq的集群你会发现，nameserver之间也是不进行通信的，broker之间也是不进行通信的。仅仅只有master和slave才会存在通信（需要做数据同步）</p>
<p>​    <strong>rmq做到了读写分离，master负责写，slave负责读。而且假设master挂掉了，slave也不会重新选举master，挂了就挂了。但是此时与挂掉的master相关联的slave还是可以接受读请求的</strong>。</p>
<h1 id="错误详解"><a href="#错误详解" class="headerlink" title="错误详解"></a>错误详解</h1><h2 id="RocketMQ-同步复制-SLAVE-NOT-AVAILABLE-异常源码分析"><a href="#RocketMQ-同步复制-SLAVE-NOT-AVAILABLE-异常源码分析" class="headerlink" title="RocketMQ 同步复制 SLAVE_NOT_AVAILABLE 异常源码分析"></a>RocketMQ 同步复制 SLAVE_NOT_AVAILABLE 异常源码分析</h2><p>解决方案：<a href="https://blog.csdn.net/zchdjb/article/details/102889760" target="_blank" rel="external">https://blog.csdn.net/zchdjb/article/details/102889760</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-MQ介绍&quot;&gt;&lt;a href=&quot;#1-MQ介绍&quot; class=&quot;headerlink&quot; title=&quot;1. MQ介绍&quot;&gt;&lt;/a&gt;1. MQ介绍&lt;/h1&gt;&lt;p&gt;##1.1 为什么要用MQ&lt;/p&gt;
&lt;p&gt;消息队列是一种“先进先出”的数据结构&lt;/p&gt;
&lt;p&gt;&lt;img 
    
    </summary>
    
      <category term="RocketMQ" scheme="http://kingge.top/categories/RocketMQ/"/>
    
    
      <category term="rmq" scheme="http://kingge.top/tags/rmq/"/>
    
      <category term="RocketMQ基础知识" scheme="http://kingge.top/tags/RocketMQ%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>king-spring</title>
    <link href="http://kingge.top/2019/06/12/kingspring%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"/>
    <id>http://kingge.top/2019/06/12/kingspring总结文档/</id>
    <published>2019-06-12T02:21:59.000Z</published>
    <updated>2020-05-04T01:32:48.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编写king-spring的目的"><a href="#编写king-spring的目的" class="headerlink" title="编写king-spring的目的"></a>编写king-spring的目的</h1><p>旨在能够了解spring整个架构核心的脉络，从而更好的理解spring的架构精神和底层原理</p>
<p><strong>A tiny IoC container refer to Spring</strong></p>
<h1 id="king-spring的结构逻辑"><a href="#king-spring的结构逻辑" class="headerlink" title="king-spring的结构逻辑"></a>king-spring的结构逻辑</h1><p><img src="/2019/06/12/kingspring总结文档/image-20200503162236006.png" alt="image-20200503162330790"></p>
<p>可以看到整个spring的简化版逻辑就是这样子的，核心就是<strong>IOC/DI，MVC。</strong></p>
<p>那么我们接下来就模拟spring实现我们的king-spring</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="配置阶段-做准备工作"><a href="#配置阶段-做准备工作" class="headerlink" title="配置阶段-做准备工作"></a>配置阶段-做准备工作</h2><h3 id="配置web-xml和配置控制类-KDispatcherServlet"><a href="#配置web-xml和配置控制类-KDispatcherServlet" class="headerlink" title="配置web.xml和配置控制类 - KDispatcherServlet"></a>配置web.xml和配置控制类 - KDispatcherServlet</h3><blockquote>
<p><strong>创建web请求控制类 - KDispatcherServlet</strong></p>
</blockquote>
<p><img src="/2019/06/12/kingspring总结文档/image-20200503165359658.png" alt="image-20200503165359658"></p>
<blockquote>
<p><strong>配置到web.xml中</strong></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC</span></div><div class="line"><span class="meta"> "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></div><div class="line"><span class="meta"> "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>king-srping project<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>kc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kingge.spring.web.servlet.KDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>kc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="配置application-properties"><a href="#配置application-properties" class="headerlink" title="配置application.properties"></a>配置application.properties</h3><p>这里采用的是properties的方式进行spring项目的配置（后期可以能会扩展成xml方式）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">scanPackage=com.kingge.spring</div></pre></td></tr></table></figure>
<p>目前就配置一项，项目扫描根目录</p>
<h3 id="实现扫描注解"><a href="#实现扫描注解" class="headerlink" title="实现扫描注解"></a>实现扫描注解</h3><p>​    我们应该知道，spring是通过校验某个bean是否加了特定的注解，从而决定是否加入到IOC容器中，也即是：<strong>bean的生命周期管理是否托管给spring。</strong></p>
<p>​    常用的注解有这几个：@Component、@Service、@Controller、@Repository，后三个实际上都是基于Component的实现，所以他们的效果等同@Component，但是后三个出现的目的是<strong>为了标识业务层次</strong>，所以在使用过程中，我们最好是按照不同的业务层次使用不同的注解，<strong>而且在spring官网上提到，后面这三个注解在以后可能还会赋予其他的含义。</strong></p>
<p>逐层分为两个层次(包)：</p>
<p> <img src="/2019/06/12/kingspring总结文档/image-20200503164323048.png" alt="image-20200503164323048"></p>
<p><strong>业务层和web控制层</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    做完这一步，我们基本把king-spring的整体架构搭建出来了，而且某些注解类和控制类也已经建立，但是某些细节实现还是没有完成，例如KDispatcherServlet内部还没有实现。</p>
<p>​    <strong>接下来就实现，具体的解析配置信息（application.properties）</strong></p>
<h2 id="初始化IOC容器-解析配置类"><a href="#初始化IOC容器-解析配置类" class="headerlink" title="初始化IOC容器-解析配置类"></a>初始化IOC容器-解析配置类</h2><p><strong>首先我们把这段代码逻辑是声明在了KDispatcherServlet的init方法中，也即是项目启动过程中就会去执行</strong></p>
<p><strong>这个过程分为四步</strong></p>
<h3 id="根据web-xml配置的contextConfigLocation解析配置类"><a href="#根据web-xml配置的contextConfigLocation解析配置类" class="headerlink" title="根据web.xml配置的contextConfigLocation解析配置类"></a>根据web.xml配置的contextConfigLocation解析配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//1.加载配置文件</span></div><div class="line">    loadConfig(config.getInitParameter(CONFIG_PROPERTIES_LOCATION));<span class="comment">//CONFIG_PROPERTIES_LOCATION的值等于"contextConfigLocation"</span></div><div class="line"></div><div class="line"><span class="comment">//2. 将配置类映射到Properties中</span></div><div class="line"><span class="comment">//保存解析application.properties 的配置文件信息</span></div><div class="line">    <span class="keyword">private</span> Properties contextConfig = <span class="keyword">new</span> Properties();</div></pre></td></tr></table></figure>
<h3 id="根据配置类获取扫描包的路径"><a href="#根据配置类获取扫描包的路径" class="headerlink" title="根据配置类获取扫描包的路径"></a>根据配置类获取扫描包的路径</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//2.根据配置文件配置的扫描路径，扫描类</span></div><div class="line">    scanPackage(contextConfig.getProperty(<span class="string">"scanPackages"</span>));</div><div class="line"><span class="comment">//经过这个方法会把递归把包路径下的所有类都放到下面的list中</span></div><div class="line"></div><div class="line">    <span class="comment">//3.保存扫描到的所有bean的全类名（还未过滤，可能包含不需要注入到ioc容器的bean）</span></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div></pre></td></tr></table></figure>
<p>需要注意的是，扫描到的类，可能存在某些类需要过滤掉，并不是都需要加到IOC容器中，判断是否加入IOC容器中的依据是：<strong>是否被我们上面定义的注解所修饰</strong></p>
<h3 id="解析需要注入到ioc容器中的bean"><a href="#解析需要注入到ioc容器中的bean" class="headerlink" title="解析需要注入到ioc容器中的bean"></a>解析需要注入到ioc容器中的bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//3.筛选上面扫描的所有类，将标有注入注解的类，放到IOC容器中</span></div><div class="line">        <span class="comment">//类似于解析xml的bean标签</span></div><div class="line">            initContext();</div><div class="line"></div><div class="line"><span class="comment">//最终根据注解筛选出需要放到IOC容器中的bean。classNames经过了过滤后得到的bean放入下面的map中</span></div><div class="line"><span class="keyword">private</span> Map&lt;String,Object&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String,Object&gt;(<span class="number">256</span>);</div></pre></td></tr></table></figure>
<h3 id="解决IOC容器中bean-的依赖问题"><a href="#解决IOC容器中bean-的依赖问题" class="headerlink" title="解决IOC容器中bean 的依赖问题"></a>解决IOC容器中bean 的依赖问题</h3><p><strong>也就是DI依赖注入阶段</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//4.解析IOC容器中的bean，并设置依赖 - DI阶段</span></div><div class="line">    diBean();</div></pre></td></tr></table></figure>
<h3 id="控制层的url绑定处理方法"><a href="#控制层的url绑定处理方法" class="headerlink" title="控制层的url绑定处理方法"></a>控制层的url绑定处理方法</h3><p>​    <strong>实际上就是处理IOC容器中被@KController注解修饰的类，然后再根据@KRequestMapping获取映射的url，然后再绑定url对应的处理方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//5.初始化handlerMapping，解析所有控制类的url地址和相关联的处理method</span></div><div class="line">    initHandlerMapping();<span class="comment">//解析出来的映射关系，保存到下面的handlerMapping中</span></div><div class="line"></div><div class="line">    <span class="comment">//保存控制层，url跟处理方法的映射关系</span></div><div class="line">    <span class="keyword">private</span> Map&lt;String,Method&gt; handlerMapping = <span class="keyword">new</span> ConcurrentHashMap&lt;String,Method&gt;();</div></pre></td></tr></table></figure>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p><strong>实际上就是根据请求的url，然后从上面的handlerMapping中，获取url对应的处理方法，然后执行，返回结果。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//客户端处理请求</span></div><div class="line">doDispatcher(req, resp);</div></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>​    <strong>IOC容器</strong>在上面我们是使用<code>private Map&lt;String,Object&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String,Object&gt;(256);</code>  <strong>key是beanName（默认是类名首字母小写），value是bean的实例</strong></p>
<p>​    </p>
<p>​    url映射关系我们使用的是<strong>handlerMapping</strong>，他的类型是：<code>private Map&lt;String,Method&gt; handlerMapping = new ConcurrentHashMap&lt;String,Method&gt;();</code>     <strong>key就是请求url，value就是url映射的method</strong></p>
<blockquote>
<p><strong>自我实现的king-spring 使用了那些设计模式</strong></p>
</blockquote>
<p>模板模式：init方法，把初始化分为了多个步骤，每个步骤自己实现自己的逻辑</p>
<p>策略模式：根据注解类型选择不同的操作方式。</p>
<p>委托模式：doGet()、doPost().</p>
<p>单例模式：Constants类</p>
<blockquote>
<p><strong>项目地址</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">https://github.com/JeremyKinge/king-spring.git //项目地址</div></pre></td></tr></table></figure>
<h1 id="回过头来查看spring源码"><a href="#回过头来查看spring源码" class="headerlink" title="回过头来查看spring源码"></a>回过头来查看spring源码</h1><h2 id="spring的ioc容器怎么实现的呢？跟我们自己的实现有何不同"><a href="#spring的ioc容器怎么实现的呢？跟我们自己的实现有何不同" class="headerlink" title="spring的ioc容器怎么实现的呢？跟我们自己的实现有何不同"></a>spring的ioc容器怎么实现的呢？跟我们自己的实现有何不同</h2><p>通过查看我们发现，spring在启动时，假设是注解版本那么，使用的context是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AnnotationConfigApplicationContext context</div><div class="line">      = <span class="keyword">new</span> AnnotationConfigApplicationContext();</div><div class="line">那么也就意味着，最终扫描包下的类，然后放到IOC容器中的逻辑肯定在其中</div></pre></td></tr></table></figure>
<p>最后跟踪到，DefaultListableBeanFactory的registerBeanDefinition()方法，最后调用了<code>this.beanDefinitionMap.put(beanName, beanDefinition);</code></p>
<p>也就是说BeanDefinitionMap就是我们需要查找的IOC容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/** Map of bean definition objects, keyed by bean name */</div><div class="line">private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</div></pre></td></tr></table></figure>
<p>可以看到，他的key跟我们的定义的一样，也是通过beanName方式，<strong>但是value跟我们却不同</strong>。</p>
<blockquote>
<p><strong>BeanDefinition</strong></p>
</blockquote>
<p>​    他实际上就是spring对于注解的描述类。我们还记不记得，在使用@Service这样的注解时，我们是可以配置作用域，生命周期，是否懒加载等等信息。那么这些信息就是保存在BeanDefinition中。</p>
<p>​    换句话说，spring的BeanDefinition实现，更加全面，而且更加面对对对象。 <strong>我们上面的做法是直接把实例化的bean当做value，那么这样势必会造成内存的浪费。</strong></p>
<h2 id="spring的handlermapping是怎么实现的呢？"><a href="#spring的handlermapping是怎么实现的呢？" class="headerlink" title="spring的handlermapping是怎么实现的呢？"></a>spring的handlermapping是怎么实现的呢？</h2><p>那么这个属性的定义肯定是在DispatcherServlet中的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** List of HandlerMappings used by this servlet */</span></div><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</div></pre></td></tr></table></figure>
<p>可以看到spring他的实现，是一个list，值得类型是HandlerMapping，在handlerMapping维护URl跟method 的映射关系。</p>
<p><strong>我们的实现是map数据结构，key是url，value是url映射的method</strong></p>
<p>那为什么不用我们的map结构呢？map架构取数据不是更加清晰么？</p>
<p>我觉得spring应该是考虑到冗余原则，因为如果用map方式，那么key的值就只能是url。为了保证能够获取更多的信息，那么就封装成对象，然后使用list保存 - <strong>满足单一原则</strong>，就是我所有信息都可以用一个对象保存，干嘛还要分开成key-value的形式呢？。<strong>其实我觉得map也很不错，选择不同而已</strong></p>
<p>那为什么不用map<string,handlermapping>呢？其实也可以。</string,handlermapping></p>
<h1 id="目前存在的缺点"><a href="#目前存在的缺点" class="headerlink" title="目前存在的缺点"></a>目前存在的缺点</h1><p><strong>1.在doDispatcher方法中，调用处理方法时，请求参数的拼接是静态写死的，后期需要修改成动态拼接</strong></p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="spring中的bean是线程安全的么？"><a href="#spring中的bean是线程安全的么？" class="headerlink" title="spring中的bean是线程安全的么？"></a>spring中的bean是线程安全的么？</h2><p>​    首先，我们要知道，spring的bean是在spring启动时，通过反射实例化出来，然后放到IOC容器中的，也就是说spring中的bean只是帮你管理而已，并没有做什么增强或者修改工作。</p>
<p>​    也就是说，bean的是不是线程安全的，那么取决于你对于bean的实现，跟spring没有任何关系。</p>
<p> 所以这个思考题的答案是：spring中的bean是否线程安全，是这个bean的问题，如果你在bean中有操作共享资源的操作，那么就有线程安全的问题，如果没有那么就是跟线程安全的。所以bean是否是线程安全的取决于bean自身的实现，而不是spring的问题。</p>
<p>​    <strong>虽然IOC容器是基于chm实现的。</strong> 应该说，spring存取bean的操作是线程安全的。这样的因为会比较好点。</p>
<h2 id="spring中的bean什么时候被回收"><a href="#spring中的bean什么时候被回收" class="headerlink" title="spring中的bean什么时候被回收"></a>spring中的bean什么时候被回收</h2><p>这个跟bean的生命周期 有关系，spring的bean生命周期有：singleton、prototype、request、session。</p>
<p>所以什么时候被回收，取决于，你设定的生命周期类型</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;编写king-spring的目的&quot;&gt;&lt;a href=&quot;#编写king-spring的目的&quot; class=&quot;headerlink&quot; title=&quot;编写king-spring的目的&quot;&gt;&lt;/a&gt;编写king-spring的目的&lt;/h1&gt;&lt;p&gt;旨在能够了解spring整个
    
    </summary>
    
      <category term="king-spring" scheme="http://kingge.top/categories/king-spring/"/>
    
    
      <category term="spring" scheme="http://kingge.top/tags/spring/"/>
    
      <category term="spring源码" scheme="http://kingge.top/tags/spring%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>项目全局异常处理</title>
    <link href="http://kingge.top/2019/05/11/%E9%A1%B9%E7%9B%AE%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://kingge.top/2019/05/11/项目全局异常处理/</id>
    <published>2019-05-11T02:21:59.000Z</published>
    <updated>2019-09-03T13:24:12.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p><img src="/2019/05/11/项目全局异常处理/1567479454980.png" alt="1567479454980"></p>
<p>这是service层的一个业务方法，业务功能是：查询某些二维码数据。可以看到我们在这个方法里面除了<code>主要的业务逻辑</code>，还有数据非空判断，以及异常处理等等。</p>
<p>如果我们不仅仅是在service层添加try catch异常处理，在controller层调用service方法的地方也添加了try catch这样的异常处理代码，<strong>那么代码冗余严重且不易维护</strong></p>
<blockquote>
<p>总结-上诉代码存在两个问题</p>
</blockquote>
<p>1、上边的代码只要操作不成功仅向用户返回“错误代码：-1，失败信息：操作失败”，无法区别具体的错误信<br>息。–参见第三处代码<br>2、service方法在执行过程出现异常在哪捕获？在service中需要都加try/catch，如果在controller也需要添加<br>try/catch，代码冗余严重且不易维护。</p>
<blockquote>
<p><strong>以下项目是 springboot2.0.1 下开发</strong></p>
</blockquote>
<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>1、在Service方法中的编码顺序是先校验判断，有问题则抛出具体的异常信息，最后执行具体的业务操作，返回成<br>功信息。</p>
<p>2、在统一异常处理类中去捕获异常，无需controller捕获异常，向用户返回统一规范的响应信息。</p>
<h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><blockquote>
<p>系统对异常的处理使用统一的异常处理流程：</p>
</blockquote>
<p>1、自定义异常类型。</p>
<p>2、自定义错误代码及错误信息。</p>
<p>3、对于可预知的异常由程序员在代码中主动抛出，由SpringMVC统一捕获。可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。</p>
<p>4、对于不可预知的异常（运行时异常）由SpringMVC统一捕获Exception类型的异常。不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为<br>RuntimeException类型（运行时异常）。</p>
<p>5、可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随请求响应给客户端。</p>
<p><img src="/2019/05/11/项目全局异常处理/1567479831709.png" alt="1567479831709"></p>
<p>1、在controller、service、dao中程序员抛出自定义异常；springMVC框架抛出框架异常类型<br>2、统一由异常捕获类捕获异常，并进行处理<br>3、捕获到自定义异常则直接取出错误代码及错误信息，响应给用户。</p>
<p>4、捕获到非自定义异常类型首先从Map中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误<br>信息并响应给用户，如果从Map中找不到异常类型所对应的错误代码则统一为99999错误代码并响应给用户。</p>
<p>5、将错误代码及错误信息以Json格式响应给用户。</p>
<blockquote>
<p>特别解释</p>
</blockquote>
<p>不可知异常我们在上图中有两个分支，左边的分支表示的是有些不可知异常我们是知道的（这个可能比较拗口），例如SQLException，HttpMessageNotReadableException（消息转化异常），这些异常我们是可以特别处理的，可以给其标注响应的错误信息，而不用走右边的99999默认消息异常处理分支。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="定义常用错误代码接口-错误信息格式"><a href="#定义常用错误代码接口-错误信息格式" class="headerlink" title="定义常用错误代码接口-错误信息格式"></a>定义常用错误代码接口-错误信息格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface ResultCode &#123;</div><div class="line">    //操作是否成功,true为成功，false操作失败</div><div class="line">    boolean success();</div><div class="line">    //操作代码</div><div class="line">    int code();</div><div class="line">    //提示信息</div><div class="line">    String message();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据这个信息格式我们可以自定义我们的错误实现。例如通用的消息模块CommonCode里面包含了常用的错误消息例子、文件上传消息模块FileSystemCode、认证消息模块AuthCode等等。满足我们自己业务的相关提示和异常提示。</p>
<h3 id="定义通用的消息模块CommonCode"><a href="#定义通用的消息模块CommonCode" class="headerlink" title="定义通用的消息模块CommonCode"></a>定义通用的消息模块CommonCode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public enum CommonCode implements ResultCode&#123;</div><div class="line">    INVALID_PARAM(false,10003,&quot;非法参数！&quot;),</div><div class="line">    SUCCESS(true,10000,&quot;操作成功！&quot;),</div><div class="line">    FAIL(false,11111,&quot;操作失败！&quot;),</div><div class="line">    UNAUTHENTICATED(false,10001,&quot;此操作需要登陆系统！&quot;),</div><div class="line">    UNAUTHORISE(false,10002,&quot;权限不足，无权操作！&quot;),</div><div class="line">    SERVER_ERROR(false,99999,&quot;抱歉，系统繁忙，请稍后重试！&quot;);</div><div class="line">    //操作是否成功</div><div class="line">    boolean success;</div><div class="line">    //操作代码</div><div class="line">    int code;</div><div class="line">    //提示信息</div><div class="line">    String message;</div><div class="line">    private CommonCode(boolean success,int code, String message)&#123;</div><div class="line">        this.success = success;</div><div class="line">        this.code = code;</div><div class="line">        this.message = message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean success() &#123;</div><div class="line">        return success;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int code() &#123;</div><div class="line">        return code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String message() &#123;</div><div class="line">        return message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="文件上传消息模块FileSystemCode-可选"><a href="#文件上传消息模块FileSystemCode-可选" class="headerlink" title="文件上传消息模块FileSystemCode-可选"></a>文件上传消息模块FileSystemCode-可选</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public enum FileSystemCode implements ResultCode &#123;</div><div class="line">    FS_UPLOADFILE_FILEISNULL(false,25001,&quot;上传文件为空！&quot;),</div><div class="line">    FS_UPLOADFILE_BUSINESSISNULL(false,25002,&quot;业务Id为空！&quot;),</div><div class="line">    FS_UPLOADFILE_SERVERFAIL(false,25003,&quot;上传文件服务器失败！&quot;),</div><div class="line">    FS_DELETEFILE_NOTEXISTS(false,25004,&quot;删除的文件不存在！&quot;),</div><div class="line">    FS_DELETEFILE_DBFAIL(false,25005,&quot;删除文件信息失败！&quot;),</div><div class="line">    FS_DELETEFILE_SERVERFAIL(false,25006,&quot;删除文件失败！&quot;),</div><div class="line">    FS_UPLOADFILE_METAERROR(false,25007,&quot;上传文件的元信息请使用json格式！&quot;),</div><div class="line">    FS_UPLOADFILE_USERISNULL(false,25008,&quot;上传文件用户为空！&quot;);</div><div class="line"></div><div class="line">    //操作代码</div><div class="line">    boolean success;</div><div class="line"></div><div class="line">    //操作代码</div><div class="line">    int code;</div><div class="line">    //提示信息</div><div class="line">    String message;</div><div class="line">    private FileSystemCode(boolean success, int code, String message)&#123;</div><div class="line">        this.success = success;</div><div class="line">        this.code = code;</div><div class="line">        this.message = message;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    @Override</div><div class="line">    public boolean success() &#123;</div><div class="line">        return success;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int code() &#123;</div><div class="line">        return code;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String message() &#123;</div><div class="line">        return message;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基础的消息格式我们已经做完了，那么接下来就是定义我们的异常</p>
<h3 id="可预知异常和不可预知异常处理"><a href="#可预知异常和不可预知异常处理" class="headerlink" title="可预知异常和不可预知异常处理"></a><strong>可预知异常和不可预知异常处理</strong></h3><p>（1）<strong>自定义异常类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 自定义异常类型</div><div class="line"> **/</div><div class="line">public class CustomException extends RuntimeException &#123;</div><div class="line"></div><div class="line">    //错误代码</div><div class="line">    ResultCode resultCode;</div><div class="line"></div><div class="line">    public CustomException(ResultCode resultCode)&#123;</div><div class="line">        this.resultCode = resultCode;</div><div class="line">    &#125;</div><div class="line">    public ResultCode getResultCode()&#123;</div><div class="line">        return resultCode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（2）<strong>异常抛出类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 异常抛出类，业务端代码直接调用即可</div><div class="line"> * 避免在service或者controller端书写throw new CustomException(resultCode);这样的重复性代码</div><div class="line"> *可以直接使用ExceptionCast.cast（）的方式直接抛出异常</div><div class="line"> **/</div><div class="line">public class ExceptionCast &#123;</div><div class="line"></div><div class="line">    public static void cast(ResultCode resultCode)&#123;</div><div class="line">        throw new CustomException(resultCode);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（3）<strong>异常捕获类</strong></p>
<p>使用 @ControllerAdvice和@ExceptionHandler注解来捕获指定类型的异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 统一异常捕获类</div><div class="line"> **/</div><div class="line">@ControllerAdvice//控制器增强</div><div class="line">public class ExceptionCatch &#123;</div><div class="line"></div><div class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch.class);</div><div class="line"></div><div class="line">    //定义map，配置异常类型所对应的错误代码 - 这个就是存储我们在不可预知异常的左边分支的异常</div><div class="line">    private static ImmutableMap&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; EXCEPTIONS;</div><div class="line">    //定义map的builder对象，去构建ImmutableMap</div><div class="line">    protected static ImmutableMap.Builder&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; builder = ImmutableMap.builder();</div><div class="line"></div><div class="line">    //捕获CustomException此类异常 -处理可预知异常关键方法（1）</div><div class="line">    @ExceptionHandler(CustomException.class)</div><div class="line">    @ResponseBody//返回给controller的json串格式的异常消息格式</div><div class="line">    public ResponseResult customException(CustomException customException)&#123;</div><div class="line">        customException.printStackTrace();</div><div class="line">        //记录日志</div><div class="line">        LOGGER.error(&quot;catch exception:&#123;&#125;&quot;,customException.getMessage());</div><div class="line">        ResultCode resultCode = customException.getResultCode();</div><div class="line">        return new ResponseResult(resultCode);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //捕获Exception此类异常 - 处理不可预知异常关键方法（2）</div><div class="line">    //里面包含我们在异常处理流程中&lt;处理不可预知异常&gt;的左右两个分支</div><div class="line">    //根据异常的全类名在我们自定义的异常map中查找是否存在已经自定义的不可预知异常，存在直接返回，不存在则当做99999全局异常处理</div><div class="line">    @ExceptionHandler(Exception.class)</div><div class="line">    @ResponseBody</div><div class="line">    public ResponseResult exception(Exception exception)&#123;</div><div class="line">        exception.printStackTrace();</div><div class="line">        //记录日志</div><div class="line">        LOGGER.error(&quot;catch exception:&#123;&#125;&quot;,exception.getMessage());</div><div class="line">        if(EXCEPTIONS == null)&#123;</div><div class="line">            EXCEPTIONS = builder.build();//EXCEPTIONS构建成功</div><div class="line">        &#125;</div><div class="line">        //从EXCEPTIONS中找异常类型所对应的错误代码，如果找到了将错误代码响应给用户，如果找不到给用户响应99999异常</div><div class="line">        ResultCode resultCode = EXCEPTIONS.get(exception.getClass());</div><div class="line">        if(resultCode !=null)&#123;</div><div class="line">            return new ResponseResult(resultCode);</div><div class="line">        &#125;else&#123;</div><div class="line">            //返回99999异常</div><div class="line">            return new ResponseResult(CommonCode.SERVER_ERROR);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        //定义异常类型所对应的错误代码</div><div class="line">        builder.put(HttpMessageNotReadableException.class,CommonCode.INVALID_PARAM);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h3><p>改造上诉代码，try catch语句可以去掉，而且可以返回我们精准自定义的错误信息</p>
<p><img src="/2019/05/11/项目全局异常处理/1567481359314.png" alt="1567481359314"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实现的关键点在于，<code>使用 @ControllerAdvice和@ExceptionHandler注解来捕获指定类型的异常</code></p>
<blockquote>
<p><strong>@ExceptionHandler</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//该注解作用对象为方法</div><div class="line">@Target(&#123;ElementType.METHOD&#125;)</div><div class="line">//在运行时有效</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface ExceptionHandler &#123;</div><div class="line">	//value()可以指定异常类</div><div class="line">    Class&lt;? extends Throwable&gt;[] value() default &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>@ControllerAdvice</strong> 增强版控制器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Target(&#123;ElementType.TYPE&#125;)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">@Component</div><div class="line">public @interface ControllerAdvice &#123;</div><div class="line">    @AliasFor(&quot;basePackages&quot;)</div><div class="line">    String[] value() default &#123;&#125;;</div><div class="line"></div><div class="line">    @AliasFor(&quot;value&quot;)</div><div class="line">    String[] basePackages() default &#123;&#125;;</div><div class="line"></div><div class="line">    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;</div><div class="line"></div><div class="line">    Class&lt;?&gt;[] assignableTypes() default &#123;&#125;;</div><div class="line"></div><div class="line">    Class&lt;? extends Annotation&gt;[] annotations() default &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/05/11/项目全局异常处理/1567479454980.png&quot; alt=&quot;1567479454980&quot;&gt;
    
    </summary>
    
      <category term="springboot项目常用技术实现" scheme="http://kingge.top/categories/springboot%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="异常处理" scheme="http://kingge.top/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
      <category term="ControllerAdvice注解" scheme="http://kingge.top/tags/ControllerAdvice%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="ExceptionHandler注解" scheme="http://kingge.top/tags/ExceptionHandler%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud个人总结</title>
    <link href="http://kingge.top/2019/05/01/SpringCloud%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://kingge.top/2019/05/01/SpringCloud个人总结/</id>
    <published>2019-05-01T02:21:59.000Z</published>
    <updated>2019-09-03T13:09:54.499Z</updated>
    
    <content type="html"><![CDATA[<p>一下内容就是个人学习sc微服务架构中的学习总结，整个架构的东西很多，大家可以在需要某个组件时再去学习。</p>
<p>一、为什么需要微服务</p>
<p>我么那首先思考下面这些问题，为什么需要微服务，微服务能够解决什么痛点，它有什么优缺点？微服务和微服务架构是什么关系？什么是分布式？什么是集群？为了解决这些问题我们得从实现一个系统的架构的到底发生了那些演变说起。</p>
<h2 id="1-1分布式的演化"><a href="#1-1分布式的演化" class="headerlink" title="1.1分布式的演化"></a>1.1分布式的演化</h2><p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-16_15-07-20.png" alt=""></p>
<h3 id="1-1-1单一应用架构"><a href="#1-1-1单一应用架构" class="headerlink" title="1.1.1单一应用架构"></a>1.1.1单一应用架构</h3><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-16_15-10-27.png" alt=""></p>
<p>优点：</p>
<blockquote>
<p>适用于小型网站，小型管理系统，将所有功能都部署到一个工程里，简单易用，易于开发</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>  1、性能扩展比较难 </p>
<p>  2、协同开发问题</p>
<p>  3、不利于升级维护</p>
<p>  4、  只能采用同一种技术，很难用不同的语言或者语言不同版本开发不同模块；</p>
<p>  5、系统耦合性强，一旦其中一个模块有问题，整个系统就瘫痪了；一旦升级其中一个模块，整个系统就停机了；</p>
<p>  6、  <strong>集群只能是复制整个系统，即使只是其中一个模块压力大</strong>。（可能整个订单处理，仅仅是支付模块压力过大，按道理只需要升级支付模块，但是在单一场景里面是不能的）</p>
</blockquote>
<p>那么这个时候我么那肯定产生了想法，就是把所有功能模块切开，分而治之，那么就演变成了下面的架构。</p>
<h3 id="1-1-2-垂直应用架构"><a href="#1-1-2-垂直应用架构" class="headerlink" title="1.1.2 垂直应用架构"></a>1.1.2 垂直应用架构</h3><pre><code>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用**拆成互不相干**的几个应用，以提升效率，**这样就可以单独修改某个模块而不用重启或者影响其他模块，同时也可以给某个访问量剧增的模块，单独添加服务器部署集群**。此时，用于加速前端页面开发的Web框架(MVC)是关键。
</code></pre><p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-16_15-15-13.png" alt=""></p>
<pre><code>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。
</code></pre><p>缺点： </p>
<blockquote>
<p>公用模块无法重复利用，开发性的浪费（存在重复开发的问题）</p>
<p>面对突变的应用场景，可能某个模块对于web界面会频繁修改，但是模块业务功能没有变化，这样会造成单个应用频繁修改。所以需要<strong>界面+业务逻辑的实现分离。</strong></p>
<p>没有处理好应用之间的交互问题，系统之间相互独立，例如订单模块可能会需要查询商品模块的信息。</p>
</blockquote>
<p>这个时候，虽然切分了各个模块，但是没有很好地考虑到服务之间的引用等等问题。</p>
<h3 id="1-1-3-分布式服务架构"><a href="#1-1-3-分布式服务架构" class="headerlink" title="1.1.3 分布式服务架构"></a>1.1.3 分布式服务架构</h3><p>当垂直应用越来越多，<strong>应用之间交互不可避免</strong>，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架(RPC)是关键。</strong></p>
<p>例如我们常见的springcloud和dubbo就是属于分布式服务架构，但是严格上来讲dubbo并不是属于分布式架构，因为他并不具备分布式架构的某些特性，例如服务的分布式配置，服务网关，数据流，批量任务等等。一般认为Dubbo只是相当于SpringCloud中的Eureka模块（服务注册中心）</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-16_15-28-15.png" alt=""></p>
<p><a href=""><strong>分布式服务框架很好的解决了垂直应用架构的缺点，实现界面和服务的分离，实现界面和服务，以及服务与服务之间的调度。</strong></a></p>
<pre><code>但是存在问题，那就是没有一个**统一管理服务的机制和基于访问压力的调度中心(服务注册中心，负载均衡)**，容易造成资源浪费，什么意思呢？假设用户服务部署了200台服务器，但是在某个时间段，他的访问压力很小，订单服务的访问压力剧增，服务器不够用。那么就会造成资源浪费和倾斜，存在服务器闲置或者请求量少的情况。
</code></pre><h3 id="1-1-4-流动计算架构"><a href="#1-1-4-流动计算架构" class="headerlink" title="1.1.4 流动计算架构"></a>1.1.4 流动计算架构</h3><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个<strong>调度中心</strong>基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>(SOA)<a href="">Service Oriented Architecture]</a><strong>是关键</strong>。</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-16_15-32-41.png" alt=""></p>
<p><img src="/2019/05/01/SpringCloud个人总结/1525530804753.png" alt="1525530804753"></p>
<p>以前出现了什么问题？</p>
<ul>
<li>服务越来越多，需要管理每个服务的地址</li>
<li>调用关系错综复杂，难以理清依赖关系</li>
<li>服务过多，服务状态难以管理，无法根据服务情况动态管理</li>
</ul>
<p>服务治理要做什么？</p>
<ul>
<li>服务注册中心，实现服务自动注册和发现，无需人为记录服务地址</li>
<li>服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系</li>
<li>动态监控服务状态监控报告，人为控制服务状态</li>
</ul>
<p>缺点：</p>
<ul>
<li>服务间会有依赖关系，一旦某个环节出错会影响较大</li>
<li>服务关系复杂，运维、测试部署困难，不符合DevOps思想</li>
</ul>
<p></p>
<h3 id="1-1-5-微服务架构"><a href="#1-1-5-微服务架构" class="headerlink" title="1.1.5 微服务架构"></a>1.1.5 微服务架构</h3><p>前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实却有一些差别：</p>
<p>微服务的特点：</p>
<ul>
<li>单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li>
<li>面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。</li>
<li>自治：自治是说服务间互相独立，互不干扰<ul>
<li>团队独立：每个服务都是一个独立的开发团队，人数不能过多。</li>
<li>技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉</li>
<li>前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口</li>
<li>数据库分离：每个服务都使用自己的数据源</li>
<li>部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护</li>
</ul>
</li>
</ul>
<p>微服务结构图：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1526860071166.png" alt="1526860071166"></p>
<h2 id="1-2-基本概念梳理"><a href="#1-2-基本概念梳理" class="headerlink" title="1.2 基本概念梳理"></a>1.2 基本概念梳理</h2><blockquote>
<p>分布式：一个业务分拆多个子业务，部署在不同的服务器上</p>
<p>集群：  同一个业务，部署在多个服务器上</p>
<p>微服务： 微服务化的核心就是<strong>将传统的一站式应用,根据业务拆分成一个一个的服务</strong>,彻底地去耦合,每一个微服务提供<strong>单个业务功能的服务</strong>,一个服务做一件事,从技术角度看就是一种小而独立的处理过程,类似进程概念,能够自行单独启动或销毁，可以拥有自己独立的数据库。（我们之前使用springboot开发的项目就是属于一个微服务，他是单一进程，处理单一服务。-<strong>他关注的是单一业务的实现细节</strong>）    </p>
<p>微服务架构：微服务架构是一种架构模式,它提倡将单一应用程序划分成一组小的服务,服务之间互相协调、互相配合,为用户提供最终价值.每个服务运行在其独立的进程中,服务与服务间采用轻量级的通信机制互相协作(通常是基于HTTP协议的RESTful API).每个服务都围绕着具体业务进行构建,并且能够被独立的部署到生产环境、类生产环境等.另外,应当尽量避免统一的、集中式的服务管理机制,对具体的一个服务而言,应根据业务上下文,选择合适的语言、工具对其进行构建.（springcloud就是一个微服务架构，通过一系列措施，管理微服务，实现系统整体的功能-<strong>他关注的是整体项目的实现和架构</strong>）</p>
</blockquote>
<p>微服务提出者：马丁.福勒(Martin Fowler) </p>
<p>论文网址:<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="external">https://martinfowler.com/articles/microservices.html</a></p>
<p>​    </p>
<p><img src="/2019/05/01/SpringCloud个人总结/Topic17NotesImage48.jpg" alt=""></p>
<h2 id="1-3-微服务优缺点"><a href="#1-3-微服务优缺点" class="headerlink" title="1.3 微服务优缺点"></a>1.3 微服务优缺点</h2><p>优点：</p>
<blockquote>
<p>每个服务足够内聚,足够小,代码容易理解这样能聚焦一个指定的业务功能或业务需求</p>
<p>开发简单、开发效率提高,一个服务可能就是专一的只干一件事.</p>
<p>微服务能够被小团队单独开服,这个小团队是2到5人的开发人员组成</p>
<p>微服务是松耦合的,是有功能意义的服务,无论是在开发阶段或部署阶段都是独立的.</p>
<p>微服务能试用不同的语言开发</p>
<p>易于和第三方集成,微服务允许容易且灵活的方式集成自动部署,通过持续集成工具,如Jenkins,Hudson,bamboo.</p>
<p>微服务易于被一个开发人员理解,修改和维护,这样小团队能够更关注自己的工作成果.无需通过合作才能体现价值</p>
<p>微服务允许你利用融合最新技术.</p>
<p>微服务只是业务逻辑的代码,不会和HTML,CSS或其他界面组件混合.</p>
<p>每个微服务都有自己的存储能力,可以有自己的数据库.也可以有统一的数据库</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>开发人员要处理分布式系统的复杂性</p>
<p>多服务运维难度,随着服务的增加,运维的压力也在增大</p>
<p>系统部署依赖</p>
<p>服务间通信成本</p>
<p>数据一致性</p>
<p>系统集成测试</p>
<p>性能监控</p>
</blockquote>
<h2 id="1-4-常见微服务架构"><a href="#1-4-常见微服务架构" class="headerlink" title="1.4 常见微服务架构"></a>1.4 常见微服务架构</h2><table>
<thead>
<tr>
<th style="text-align:center">微服务条目</th>
<th style="text-align:center">落地技术</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">服务开发</td>
<td style="text-align:center">SpringBoot,Spring,SpringMVC</td>
</tr>
<tr>
<td style="text-align:center">服务配置与管理</td>
<td style="text-align:center">Netflix公司的Archaius、阿里的Diamond等</td>
</tr>
<tr>
<td style="text-align:center">服务注册与发现</td>
<td style="text-align:center">Eureka、Consul、Zookeeper等</td>
</tr>
<tr>
<td style="text-align:center">服务调用</td>
<td style="text-align:center">Rest、RPC、gRPC</td>
</tr>
<tr>
<td style="text-align:center">服务熔断器</td>
<td style="text-align:center">Hystrix、Envoy等</td>
</tr>
<tr>
<td style="text-align:center">负载均衡</td>
<td style="text-align:center">Ribbon、Nginx等</td>
</tr>
<tr>
<td style="text-align:center">服务接口调用（客户端调用服务的简化工具）</td>
<td style="text-align:center">Feign等</td>
</tr>
<tr>
<td style="text-align:center">消息队列</td>
<td style="text-align:center">Kafka、RabbitMQ、ActiveMQ等</td>
</tr>
<tr>
<td style="text-align:center">服务配置中心管理</td>
<td style="text-align:center">SpringCloudConfig、Chef等</td>
</tr>
<tr>
<td style="text-align:center">服务路由（API网关）</td>
<td style="text-align:center">Zuul等</td>
</tr>
<tr>
<td style="text-align:center">服务监控</td>
<td style="text-align:center">Zabbix、Nagios、Metrics、Specatator等</td>
</tr>
<tr>
<td style="text-align:center">全链路追踪</td>
<td style="text-align:center">Zipkin、Brave、Dapper等</td>
</tr>
<tr>
<td style="text-align:center">服务部署</td>
<td style="text-align:center">Docker、OpenStack、Kubernetes等</td>
</tr>
<tr>
<td style="text-align:center">数据流操作开发包</td>
<td style="text-align:center">SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息)</td>
</tr>
<tr>
<td style="text-align:center">事件消息总线</td>
<td style="text-align:center">SpringCloud Bus</td>
</tr>
</tbody>
</table>
<h1 id="二-springcloud和dubbo"><a href="#二-springcloud和dubbo" class="headerlink" title="二.springcloud和dubbo"></a>二.springcloud和dubbo</h1><p>为什么现在流行的微服务架构是springcloud而不是dubbo，最主要的是dubbo在这之前停止更新过几年的时间，这个时候springcloud异军突起，很好地抢占了先机，整体解决方案和框架成熟度，社区热度，可维护性，学习曲线也是它更加火爆的原因：</p>
<p>最主要的是，Dubbo 的定位始终是一款 RPC 框架，目的是提<a href=""><strong>供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案</strong></a></p>
<p>然而：Spring Cloud 的目标是微服务架构下的一站式解决方案，换句话说，dubbo更像是springcloud的Eureka模块。</p>
<p>接下来我么你看一段关于Dubbo目前负责人刘军的一段采访</p>
<p><a href="https://www.oschina.net/question/2896879_2272652?sort=time" target="_blank" rel="external">https://www.oschina.net/question/2896879_2272652?sort=time</a></p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-16_16-01-12.png" alt=""></p>
<p>当前各大IT公司用的微服务架构有哪些</p>
<blockquote>
<p>阿里Dubbo/HSF<br>京东JSF<br>新浪微博Motan<br>当当网DubboX</p>
</blockquote>
<h2 id="1-各微服务的框架对比"><a href="#1-各微服务的框架对比" class="headerlink" title="1.各微服务的框架对比"></a>1.各微服务的框架对比</h2><table>
<thead>
<tr>
<th style="text-align:center">功能点/服务框架</th>
<th style="text-align:center">Netflix/SpringCloud</th>
<th style="text-align:center">Motan</th>
<th style="text-align:center">gRPC</th>
<th style="text-align:center">Thrift</th>
<th style="text-align:center">Dubbo/DubboX</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">功能定位</td>
<td style="text-align:center">完整的微服务架构</td>
<td style="text-align:center">RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册/发现</td>
<td style="text-align:center">RPC框架</td>
<td style="text-align:center">RPC框架</td>
<td style="text-align:center">服务框架</td>
</tr>
<tr>
<td style="text-align:center">支持Rest</td>
<td style="text-align:center">是，Ribbon支持多种可插拔的序列化选择</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">支持RPC</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">支持多语言</td>
<td style="text-align:center">是（Rest形式）</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">服务注册/发现</td>
<td style="text-align:center">是（Eureka） Eureka服务注册表，Karyon服务端框架支持服务自注册和健康检查</td>
<td style="text-align:center">是（zookeeper/consul）</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">负载均衡</td>
<td style="text-align:center">是（服务端zuul+客户端Ribbon） zuul-服务，动态路由 云端负载均衡  Eureka（针对中间层服务器）</td>
<td style="text-align:center">是（客户端）</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是（客户端）</td>
</tr>
<tr>
<td style="text-align:center">配置服务</td>
<td style="text-align:center">Netflix Archaius SpringCloud Config Server集中配置</td>
<td style="text-align:center">是（zookeeper提供）</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">服务调用链监控</td>
<td style="text-align:center">是（zuul） Zuul提供边缘服务，API网关</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">高可用/容错</td>
<td style="text-align:center">是（服务端Hystrix+客户端Ribbon）</td>
<td style="text-align:center">是（客户端）</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是（客户端）</td>
</tr>
<tr>
<td style="text-align:center">典型应用案例</td>
<td style="text-align:center">Netflix</td>
<td style="text-align:center">Sina</td>
<td style="text-align:center">Google</td>
<td style="text-align:center">Facebook</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">社区活跃度</td>
<td style="text-align:center">高</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">高</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">2017年7月才重启</td>
</tr>
<tr>
<td style="text-align:center">学习难度</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">高</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center">文档丰富度</td>
<td style="text-align:center">高</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center">其他</td>
<td style="text-align:center">Spring Cloud Bus为我们应用程序带来了更多管理端点</td>
<td style="text-align:center">支持降级</td>
<td style="text-align:center">Netflix内部在开发集成gRPC</td>
<td style="text-align:center">IDL定义</td>
<td style="text-align:center">实践公司比较多</td>
</tr>
</tbody>
</table>
<h2 id="2-springcloud-VS-Dubbo"><a href="#2-springcloud-VS-Dubbo" class="headerlink" title="2. springcloud VS Dubbo"></a>2. springcloud VS Dubbo</h2><p>社区活跃度</p>
<p><a href="https://github.com/dubbo" target="_blank" rel="external">https://github.com/dubbo</a><br><a href="https://github.com/springcloud" target="_blank" rel="external">https://github.com/springcloud</a></p>
<p>功能对比</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">Dubbo</th>
<th style="text-align:center">Spring</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务注册中心</td>
<td style="text-align:center">Zookeeper</td>
<td style="text-align:center">Spring Cloud Netfilx Eureka</td>
</tr>
<tr>
<td>服务调用方式</td>
<td style="text-align:center">RPC</td>
<td style="text-align:center">REST API</td>
</tr>
<tr>
<td>服务监控</td>
<td style="text-align:center">Dubbo-monitor</td>
<td style="text-align:center">Spring Boot Admin</td>
</tr>
<tr>
<td>断路器</td>
<td style="text-align:center">不完善</td>
<td style="text-align:center">Spring Cloud Netflix Hystrix</td>
</tr>
<tr>
<td>服务网关</td>
<td style="text-align:center">无</td>
<td style="text-align:center">Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td>分布式配置</td>
<td style="text-align:center">无</td>
<td style="text-align:center">Spring Cloud Config</td>
</tr>
<tr>
<td>服务跟踪</td>
<td style="text-align:center">无</td>
<td style="text-align:center">Spring Cloud Sleuth</td>
</tr>
<tr>
<td>消息总线</td>
<td style="text-align:center">无</td>
<td style="text-align:center">Spring Cloud Bus</td>
</tr>
<tr>
<td>数据流</td>
<td style="text-align:center">无</td>
<td style="text-align:center">Spring Cloud Stream</td>
</tr>
<tr>
<td>批量任务</td>
<td style="text-align:center">无</td>
<td style="text-align:center">Spring Cloud Task</td>
</tr>
</tbody>
</table>
<p><strong>最大区别：</strong></p>
<ul>
<li>Spring Cloud抛弃了RPC通讯，采用基于HTTP的REST方式。Spring Cloud牺牲了服务调用的性能，但是同时也避免了原生RPC带来的问题。REST比RPC更为灵活，不存在代码级别的强依赖，在强调快速演化的微服务环境下，显然更合适。</li>
<li>==一句话：Dubbo像组装机，Spring Cloud像一体机==</li>
<li>社区的支持与力度：Dubbo曾经停运了5年，虽然重启了，但是对于技术发展的新需求，还是需要开发者自行去拓展，对于中小型公司，显然显得比较费时费力，也不一定有强大的实力去修改源码</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>解决的问题域不一样：Dubbo的定位是一款RPC框架，Spring Cloud的目标是微服务架构下的一站式解决方案</li>
</ol>
<h1 id="三-服务调用方式"><a href="#三-服务调用方式" class="headerlink" title="三.服务调用方式"></a>三.服务调用方式</h1><h2 id="1-RPC和HTTP"><a href="#1-RPC和HTTP" class="headerlink" title="1.RPC和HTTP"></a>1.RPC和HTTP</h2><p>无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？</p>
<p>常见的远程调用方式有以下2种：</p>
<ul>
<li><p>RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表</p>
</li>
<li><p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。</p>
<p>现在热门的Rest风格，就可以通过http协议来实现。</p>
</li>
</ul>
<p>如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。</p>
<p>相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么SpringCloud搭建微服务是不二之选。在我们的项目中，我们会选择SpringCloud套件，因此我们会使用Http方式来实现服务间调用。</p>
<h2 id="2-Http客户端工具"><a href="#2-Http客户端工具" class="headerlink" title="2.Http客户端工具"></a>2.Http客户端工具</h2><p>既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：</p>
<ul>
<li>HttpClient</li>
<li>OKHttp</li>
<li>URLConnection</li>
</ul>
<p>接下来，不过这些不同的客户端，API各不相同</p>
<h2 id="3-Spring的RestTemplate"><a href="#3-Spring的RestTemplate" class="headerlink" title="3.Spring的RestTemplate"></a>3.Spring的RestTemplate</h2><p>Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：</p>
<ul>
<li>HttpClient</li>
<li>OkHttp</li>
<li>JDK原生的URLConnection（默认的）</li>
</ul>
<p>RestTemplate简单使用</p>
<p>首先在项目中注册一个<code>RestTemplate</code>对象，可以在启动类位置注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDemoApplication</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		SpringApplication.run(HttpDemoApplication.class, args);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Bean</span></div><div class="line">	<span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</div><div class="line">   </div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在测试类中直接<code>@Autowired</code>注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span>(classes = HttpDemoApplication.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDemoApplicationTests</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line"></div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">httpGet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 调用springboot案例中的rest接口</span></div><div class="line">		User user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://localhost/user/1"</span>, User.class);</div><div class="line">		System.out.println(user);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。</li>
</ul>
<p><img src="/2019/05/01/SpringCloud个人总结/1525573702492.png" alt="1525573702492"></p>
<p>学习完了Http客户端工具，接下来就可以正式学习微服务了。</p>
<h1 id="四-初识SpringCloud"><a href="#四-初识SpringCloud" class="headerlink" title="四.初识SpringCloud"></a>四.初识SpringCloud</h1><p>微服务是一种架构方式，最终肯定需要技术架构去实施。</p>
<p>微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？</p>
<ul>
<li>后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。</li>
<li>技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了</li>
<li>群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。</li>
<li>使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建</li>
</ul>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>SpringCloud是Spring旗下的项目之一，<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="external">官网地址：http://projects.spring.io/spring-cloud/</a></p>
<p>官网介绍:<a href="https://spring.io/" target="_blank" rel="external">https://spring.io/</a></p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-16_16-08-43.png" alt=""></p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-16_16-09-14.png" alt=""></p>
<p>SpringCloud,基于springboot提供了一套为服务解决方案.</p>
<p>Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。</p>
<p>SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：</p>
<ul>
<li>Eureka：服务治理组件，包含服务注册中心，服务注册与发现机制的实现。（服务治理，服务注册/发现） </li>
<li>Zuul：网关组件，提供智能路由，访问过滤功能 </li>
<li>Ribbon：客户端负载均衡的服务调用组件（客户端负载） </li>
<li>Feign：服务调用，给予Ribbon和Hystrix的声明式服务调用组件 （声明式服务调用） </li>
<li>Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。(熔断、断路器，容错) </li>
</ul>
<p>架构图：</p>
<p> <img src="/SpringCloud个人总结/1525575656796.png" alt="1525575656796"></p>
<p>以上只是其中一部分。</p>
<blockquote>
<p>SpringCloud,基于springboot提供了一套为服务解决方案,包括服务注册与发现,配置中心,全链路监控,服务网关,负载均衡,熔断器等组件,除了基于NetFlix的开源组件做高度抽象封装之外,还有一些选型中立的开源组件.</p>
<p>SpringCloud利用springboot的开发便利性巧妙地简化了分布式系统基础设施的开发,SpringCloud为开发人员提供了快速构建分布式系统的一些工具,包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等,它们都可以利用Springboot的开发风格做到一键启动和部署.</p>
<p>SpringBoot并没有重复制造轮子,它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来,通过Springboot风格进行再封装屏蔽掉了复杂的配置和实现原理,最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包.</p>
</blockquote>
<h2 id="2-SpringCloud和springboot是什么关系"><a href="#2-SpringCloud和springboot是什么关系" class="headerlink" title="2.SpringCloud和springboot是什么关系"></a>2.SpringCloud和springboot是什么关系</h2><p><strong>Springboot专注于快速方便的开发单个个体微服务.</strong></p>
<p>SpringCloud是<strong>关注全局的微服务协调整理治理框架</strong>,它将Springboot开发的一个个单体微服务整合并管理起来,为各个微服务质检提供,配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</p>
<p><strong>Springboot可以离开SpringCloud独立使用开发项目,但是SpringCloud离不开Springboot,属于依赖的关系.</strong><br><strong>Springboot专注于快速、方便的开发单个微服务个体,SpringCloud关注全局的服务治理框架.</strong></p>
<h2 id="3-springcloud的版本"><a href="#3-springcloud的版本" class="headerlink" title="3.springcloud的版本"></a>3.springcloud的版本</h2><p>因为Spring Cloud不同其他独立项目，它拥有很多子项目的大项目。所以它的版本是版本名+版本号 （如Angel.SR6）。  </p>
<p>版本名：是伦敦的地铁名  </p>
<p>版本号：SR（Service Releases）是固定的 ,大概意思是稳定版本。后面会有一个递增的数字。 </p>
<p>所以 Edgware.SR3就是Edgware的第3个Release版本。  </p>
<p> <img src="/2019/05/01/SpringCloud个人总结/1528263985902.png" alt="1528263985902"></p>
<p>我们在项目中，会是以Finchley的版本。</p>
<p>其中包含的组件，也都有各自的版本，如下表：</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Edgware.SR3</th>
<th>Finchley.RC1</th>
<th>Finchley.BUILD-SNAPSHOT</th>
</tr>
</thead>
<tbody>
<tr>
<td>spring-cloud-aws</td>
<td>1.2.2.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-bus</td>
<td>1.3.2.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-cli</td>
<td>1.4.1.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-commons</td>
<td>1.3.3.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-contract</td>
<td>1.2.4.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-config</td>
<td>1.4.3.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-netflix</td>
<td>1.4.4.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-security</td>
<td>1.2.2.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-cloudfoundry</td>
<td>1.1.1.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-consul</td>
<td>1.3.3.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-sleuth</td>
<td>1.3.3.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-stream</td>
<td>Ditmars.SR3</td>
<td>Elmhurst.RELEASE</td>
<td>Elmhurst.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-zookeeper</td>
<td>1.2.1.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-boot</td>
<td>1.5.10.RELEASE</td>
<td>2.0.1.RELEASE</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-task</td>
<td>1.2.2.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.RELEASE</td>
</tr>
<tr>
<td>spring-cloud-vault</td>
<td>1.1.0.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-gateway</td>
<td>1.0.1.RELEASE</td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
<tr>
<td>spring-cloud-openfeign</td>
<td></td>
<td>2.0.0.RC1</td>
<td>2.0.0.BUILD-SNAPSHOT</td>
</tr>
</tbody>
</table>
<p><img src="/2019/05/01/SpringCloud个人总结/1528263942152.png" alt="1528263942152"></p>
<h2 id="4-SpringCloud的参考资料"><a href="#4-SpringCloud的参考资料" class="headerlink" title="4.SpringCloud的参考资料"></a>4.SpringCloud的参考资料</h2><h1 id="五-springcloud的实现准备"><a href="#五-springcloud的实现准备" class="headerlink" title="五.springcloud的实现准备"></a>五.springcloud的实现准备</h1><p>为了下面使用springcloud微服务架构各个优秀的组件，我们先搭建一个基本的分布式项目工程。</p>
<p>案例使用的springcloud和springboot版本分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;Dalston.SR1&lt;/version&gt;</div><div class="line">    &lt;type&gt;pom&lt;/type&gt;</div><div class="line">    &lt;scope&gt;import&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">    &lt;type&gt;pom&lt;/type&gt;</div><div class="line">    &lt;scope&gt;import&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h2 id="1-新建父工程-microservicecloud"><a href="#1-新建父工程-microservicecloud" class="headerlink" title="1 新建父工程-microservicecloud"></a>1 新建父工程-microservicecloud</h2><p>microservicecloud</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-16_16-24-07.png" alt=""></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image003.jpg" alt="img"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image005.jpg" alt="img"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image007.jpg" alt="img"></p>
<p><strong>打包方式设置为pom</strong></p>
<p> 设置pom.xml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</div><div class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">    &lt;groupId&gt;com.kingge.springcloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</div><div class="line">    &lt;properties&gt;</div><div class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</div><div class="line">        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</div><div class="line">        &lt;junit.version&gt;4.12&lt;/junit.version&gt;</div><div class="line">        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;</div><div class="line">        &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;</div><div class="line">    &lt;/properties&gt;</div><div class="line"></div><div class="line">    &lt;dependencyManagement&gt;</div><div class="line">        &lt;dependencies&gt;</div><div class="line">            &lt;dependency&gt;</div><div class="line">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;Dalston.SR1&lt;/version&gt;</div><div class="line">                &lt;type&gt;pom&lt;/type&gt;</div><div class="line">                &lt;scope&gt;import&lt;/scope&gt;</div><div class="line">            &lt;/dependency&gt;</div><div class="line">            &lt;dependency&gt;</div><div class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">                &lt;type&gt;pom&lt;/type&gt;</div><div class="line">                &lt;scope&gt;import&lt;/scope&gt;</div><div class="line">            &lt;/dependency&gt;</div><div class="line">            &lt;dependency&gt;</div><div class="line">                &lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;5.0.4&lt;/version&gt;</div><div class="line">            &lt;/dependency&gt;</div><div class="line">            &lt;dependency&gt;</div><div class="line">                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;druid&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;1.0.31&lt;/version&gt;</div><div class="line">            &lt;/dependency&gt;</div><div class="line">            &lt;dependency&gt;</div><div class="line">                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;1.3.0&lt;/version&gt;</div><div class="line">            &lt;/dependency&gt;</div><div class="line">            &lt;dependency&gt;</div><div class="line">                &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;1.2.3&lt;/version&gt;</div><div class="line">            &lt;/dependency&gt;</div><div class="line">            &lt;dependency&gt;</div><div class="line">                &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</div><div class="line">                &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">            &lt;/dependency&gt;</div><div class="line">            &lt;dependency&gt;</div><div class="line">                &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class="line">                &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;</div><div class="line">            &lt;/dependency&gt;</div><div class="line">        &lt;/dependencies&gt;</div><div class="line">    &lt;/dependencyManagement&gt;</div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>查看项目</p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image008.png" alt="img"></p>
<p>新建父工程目的：定义pom文件，统一各个子模块的jar依赖版本，方面管理，避免每个子模块使用相同组件不同版本，造成项目测试运行出现问题。</p>
<h2 id="2-根据父工程，新建api公共模块-microservicecloud-api"><a href="#2-根据父工程，新建api公共模块-microservicecloud-api" class="headerlink" title="2 根据父工程，新建api公共模块-microservicecloud-api"></a>2 根据父工程，新建api公共模块-microservicecloud-api</h2><p>目的：抽取出所有子项目公共的bean或者方法。例如在下面的创建的服务提供者和服务消费者都是用到了Person这个javabean，那么我们就需要把这个bean放在这里。然后服务提供者和消费者就可以依赖这个api公共模块，从而实用Person实体类。</p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image010.jpg" alt="img"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image012.jpg" alt="img"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image014.jpg" alt="img"></p>
<p>创建完毕</p>
<h3 id="2-1-查看父工程pom"><a href="#2-1-查看父工程pom" class="headerlink" title="2.1 查看父工程pom"></a>2.1 查看父工程pom</h3><p><img src="/2019/05/01/SpringCloud个人总结/clip_image015.png" alt="img"></p>
<p>发现多了这一行，因为我们是在父工程microserviceproject下新建的，表示microservicecloud-api工程为父工程子模块。</p>
<h3 id="2-2-修改microservicecloud-api的pom文件"><a href="#2-2-修改microservicecloud-api的pom文件" class="headerlink" title="2.2 修改microservicecloud-api的pom文件"></a>2.2 修改microservicecloud-api的pom文件</h3><p>修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</div><div class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">    &lt;parent&gt;</div><div class="line">        &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt;</div><div class="line">        &lt;groupId&gt;com.kingge.springcloud&lt;/groupId&gt;</div><div class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">    &lt;/parent&gt;</div><div class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">    &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt;</div><div class="line">    &lt;dependencies&gt;&lt;!-- 当前Module需要用到的jar包，按自己需求添加，如果父类已经包含了，可以不用写版本号 --&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;  </div><div class="line">        &lt;/dependency&gt;//这个组件可用可不用</div><div class="line">    &lt;/dependencies&gt;</div><div class="line"></div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>Lombok组件在真实项目中不建议使用，虽然他简化了javabean的开发，但是代码的可读性也产生了严重的影响。</p>
<h3 id="2-3-新建公共bean-Person"><a href="#2-3-新建公共bean-Person" class="headerlink" title="2.3 新建公共bean-Person"></a>2.3 新建公共bean-Person</h3><p><img src="/2019/05/01/SpringCloud个人总结/clip_image017.jpg" alt="img"></p>
<p>生成get/set方法</p>
<h3 id="2-4-项目结构"><a href="#2-4-项目结构" class="headerlink" title="2.4 项目结构"></a>2.4 项目结构</h3><p><img src="/2019/05/01/SpringCloud个人总结/clip_image018.png" alt="img"></p>
<h2 id="3-根据父工程，新建微服务提供者-provider"><a href="#3-根据父工程，新建微服务提供者-provider" class="headerlink" title="3 根据父工程，新建微服务提供者-provider"></a>3 根据父工程，新建微服务提供者-provider</h2><p>microservicecloud-provider-person-8001 –&gt; 8001表示服务暴露的端口号</p>
<p>新建方法同新建-microservicecloud-api 模块</p>
<h3 id="3-1-修改pom文件"><a href="#3-1-修改pom文件" class="headerlink" title="3.1 修改pom文件"></a>3.1 修改pom文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</div><div class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">    &lt;parent&gt;</div><div class="line">        &lt;artifactId&gt;microservicecloud&lt;/artifactId&gt;</div><div class="line">        &lt;groupId&gt;com.kingge.springcloud&lt;/groupId&gt;</div><div class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">    &lt;/parent&gt;</div><div class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">    &lt;artifactId&gt;microservicecloud-provider-person-8001&lt;/artifactId&gt;</div><div class="line"></div><div class="line">    &lt;dependencies&gt;</div><div class="line">        &lt;!-- 引入自己定义的api通用包，可以使用Person用户Entity --&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;com.kingge.springcloud&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">       </div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;!-- 修改后立即生效，热部署 --&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;springloaded&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">    &lt;/dependencies&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<h3 id="3-2-新建application-yml文件"><a href="#3-2-新建application-yml文件" class="headerlink" title="3.2 新建application.yml文件"></a>3.2 新建application.yml文件</h3><p><img src="/2019/05/01/SpringCloud个人总结/clip_image019.png" alt="img"></p>
<p>内容是：详细的参见代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 8001</div><div class="line"></div><div class="line">mybatis:</div><div class="line">  config-location: classpath:mybatis/mybatis.cfg.xml        # mybatis配置文件所在路径</div><div class="line">  type-aliases-package: com.kingge.entity    # 所有Entity别名类所在包</div><div class="line">  mapper-locations:</div><div class="line">  - classpath:mybatis/mapper/**/*.xml                       # mapper映射文件</div><div class="line"></div><div class="line"></div><div class="line">spring:</div><div class="line">   application:</div><div class="line">    name: microservicecloud-person                          #很重要，对外暴露的微服务的名称</div><div class="line">   datasource:</div><div class="line">    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</div><div class="line">    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包</div><div class="line">    url: jdbc:mysql://127.0.0.1:3306/test              # 数据库名称</div><div class="line">    username: root</div><div class="line">    password: 123</div><div class="line">    dbcp2:</div><div class="line">      min-idle: 5                                           # 数据库连接池的最小维持连接数</div><div class="line">      initial-size: 5                                       # 初始化连接数</div><div class="line">      max-total: 5                                          # 最大连接数</div><div class="line">      max-wait-millis: 200</div></pre></td></tr></table></figure>
<p><strong>注意每个属性后面必须是有空格-yml文件的格式</strong></p>
<h3 id="3-3-新建person数据表"><a href="#3-3-新建person数据表" class="headerlink" title="3.3 新建person数据表"></a>3.3 新建person数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DROP TABLE IF EXISTS `person`;</div><div class="line">CREATE TABLE `person` (</div><div class="line">  `deptno` int(255) NOT NULL AUTO_INCREMENT,</div><div class="line">  `dname` varchar(255) DEFAULT NULL,</div><div class="line">  `db_source` varchar(255) DEFAULT NULL, //这和字段标识当前数据来源于那个数据库，后面讲解Eureka集群时会使用到</div><div class="line">  PRIMARY KEY (`deptno`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;</div><div class="line"></div><div class="line">-- ----------------------------</div><div class="line">-- Records of person</div><div class="line">-- ----------------------------</div><div class="line">INSERT INTO `person` VALUES (&apos;1&apos;, &apos;开发部&apos;, &apos;test&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;2&apos;, &apos;人事部&apos;, &apos;test&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;3&apos;, &apos;集成部&apos;, &apos;test&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;4&apos;, &apos;市场部&apos;, &apos;test&apos;);</div></pre></td></tr></table></figure>
<h3 id="3-4-新建dao和mapper"><a href="#3-4-新建dao和mapper" class="headerlink" title="3.4 新建dao和mapper"></a>3.4 新建dao和mapper</h3><p><img src="/2019/05/01/SpringCloud个人总结/clip_image020.png" alt="img"></p>
<p>内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.kingge.entity.Person;</div><div class="line">import org.apache.ibatis.annotations.Mapper;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">@Mapper</div><div class="line">public interface PersonDao &#123;</div><div class="line">    public boolean addDept(Person dept);</div><div class="line"></div><div class="line">    public Person findById(Long id);</div><div class="line"></div><div class="line">    public List&lt;Person&gt; findAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-1-新建mybatis-cfg-xml"><a href="#3-4-1-新建mybatis-cfg-xml" class="headerlink" title="3.4.1 新建mybatis.cfg.xml"></a>3.4.1 新建mybatis.cfg.xml</h3><p>实际上我们不需要这个xml文件，因为我们的配置一般都是已经放置在了application.yml文件中，但是为了整体架构的扩展性，这里也新建了改文件</p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image021.png" alt="img"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image023.jpg" alt="img"></p>
<h3 id="3-5-新建PersonMapper-xml"><a href="#3-5-新建PersonMapper-xml" class="headerlink" title="3.5 新建PersonMapper.xml"></a>3.5 新建PersonMapper.xml</h3><p><img src="/2019/05/01/SpringCloud个人总结/clip_image024.png" alt="img"></p>
<p>存放mapper.xml文件的位置我们在上面application.yml中已经声明</p>
<p>内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</div><div class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</div><div class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</div><div class="line"></div><div class="line">&lt;mapper namespace=&quot;com.kingge.dao.PersonDao&quot;&gt;</div><div class="line"></div><div class="line">	&lt;select id=&quot;findById&quot; resultType=&quot;Person&quot; parameterType=&quot;Long&quot;&gt;</div><div class="line">		select deptno,dname,db_source from person where deptno=#&#123;deptno&#125;;</div><div class="line">	&lt;/select&gt;</div><div class="line">	&lt;select id=&quot;findAll&quot; resultType=&quot;Person &quot;&gt;</div><div class="line">		select deptno,dname,db_source from person;</div><div class="line">	&lt;/select&gt;</div><div class="line">	&lt;insert id=&quot;addDept&quot; parameterType=&quot;Person &quot;&gt;</div><div class="line">		INSERT INTO person(dname,db_source) VALUES(#&#123;dname&#125;,DATABASE());</div><div class="line">	&lt;/insert&gt;</div><div class="line"></div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure>
<h3 id="3-6-新建PersonService接口和接口实现类impl"><a href="#3-6-新建PersonService接口和接口实现类impl" class="headerlink" title="3.6 新建PersonService接口和接口实现类impl"></a>3.6 新建PersonService接口和接口实现类impl</h3><p><img src="/2019/05/01/SpringCloud个人总结/clip_image025.png" alt="img"></p>
<p>PersonService 接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface PersonService&#123;</div><div class="line">       publicboolean add(Person dept);</div><div class="line">       public Personget(Long id);</div><div class="line">       publicList&lt;Person&gt; list();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PersonServiceImpl 实现类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Service</div><div class="line">public class PersonServiceImpl implements PersonService&#123;</div><div class="line">	@Autowired</div><div class="line">	private PersonDao dao;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public boolean add(Person person)&#123;</div><div class="line">		return dao.addDept(person);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Person get(Long id)&#123;</div><div class="line">		return dao.findById(id);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public List&lt;Person&gt; list()&#123;</div><div class="line">		return dao.findAll();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-7-controller控制层-PersonController"><a href="#3-7-controller控制层-PersonController" class="headerlink" title="3.7 controller控制层-PersonController"></a>3.7 controller控制层-PersonController</h3><p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">@RestController</div><div class="line">public class PersonController</div><div class="line">&#123;</div><div class="line">	@Autowired</div><div class="line">	private PersonService service;</div><div class="line">//全部使用restful风格，返回json字符串</div><div class="line">	@RequestMapping(value = &quot;/person/add&quot;, method = RequestMethod.POST)</div><div class="line">	public boolean add(@RequestBody Person person)</div><div class="line">	&#123;</div><div class="line">		return service.add(person);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@RequestMapping(value = &quot;/person/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</div><div class="line">	public Person get(@PathVariable(&quot;id&quot;) Long id)</div><div class="line">	&#123;</div><div class="line">		return service.get(id);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@RequestMapping(value = &quot;/person/list&quot;, method = RequestMethod.GET)</div><div class="line">	public List&lt;Person&gt; list()</div><div class="line">	&#123;</div><div class="line">		return service.list();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-8-springboot启动类"><a href="#3-8-springboot启动类" class="headerlink" title="3.8 springboot启动类"></a>3.8 springboot启动类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">public class ApplicationBootStart &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        SpringApplication.run(ApplicationBootStart.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>启动服务并测试访问。</p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image027.jpg" alt="img"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image029.jpg" alt="img"></p>
<h3 id="3-9-项目整体结构"><a href="#3-9-项目整体结构" class="headerlink" title="3.9 项目整体结构"></a>3.9 项目整体结构</h3><p><img src="/2019/05/01/SpringCloud个人总结/clip_image030.png" alt="img"></p>
<h2 id="4-根据父工程，新建微服务消费者-consumer"><a href="#4-根据父工程，新建微服务消费者-consumer" class="headerlink" title="4 根据父工程，新建微服务消费者-consumer"></a>4 根据父工程，新建微服务消费者-consumer</h2><p>microservicecloud-consumer-person-80 方法同上</p>
<h3 id="4-1-修改pom文件"><a href="#4-1-修改pom文件" class="headerlink" title="4.1 修改pom文件"></a>4.1 修改pom文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">	&lt;dependency&gt;&lt;!-- 自己定义的api --&gt;</div><div class="line">		&lt;groupId&gt;com.kingge.springcloud&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	        &lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">       &lt;/dependency&gt;</div><div class="line"></div><div class="line">       &lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">           &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;</div><div class="line">           &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">       &lt;/dependency&gt;</div><div class="line">	&lt;!-- 修改后立即生效，热部署 --&gt;</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;springloaded&lt;/artifactId&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<h3 id="4-2-添加application-yml文件"><a href="#4-2-添加application-yml文件" class="headerlink" title="4.2 添加application.yml文件"></a>4.2 添加application.yml文件</h3><p>添加端口配置</p>
<p>server:</p>
<p>  port: 80</p>
<h3 id="4-3-新建-Configuration注解的配置类"><a href="#4-3-新建-Configuration注解的配置类" class="headerlink" title="4.3 新建@Configuration注解的配置类"></a>4.3 新建@Configuration注解的配置类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class ConfigBean</div><div class="line">&#123; </div><div class="line">	@Bean</div><div class="line">	public RestTemplate getRestTemplate()</div><div class="line">	&#123;</div><div class="line">		return new RestTemplate();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的作用就是我们整合SSM的时候，对应的applicationContext.xml</p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image032.jpg" alt="img"></p>
<h3 id="4-4-新建消费者控制器，访问服务提供者获取数据"><a href="#4-4-新建消费者控制器，访问服务提供者获取数据" class="headerlink" title="4.4 新建消费者控制器，访问服务提供者获取数据"></a>4.4 新建消费者控制器，访问服务提供者获取数据</h3><p>通过RestTemplate获取消息提供者暴露的服务信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@RestController</div><div class="line">public class ConsumerController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private RestTemplate restTemplate;</div><div class="line"></div><div class="line">    private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;//这里通过书写固定的服务提供者的地址，后面我们学习到了Eureka服务注册中心，那么注重修改这里</div><div class="line"></div><div class="line">    @RequestMapping(value = &quot;/consumer/person/add&quot;)</div><div class="line">    public boolean add(Person person)</div><div class="line">    &#123;</div><div class="line">        return restTemplate.postForObject(REST_URL_PREFIX + &quot;/person/add&quot;, person, Boolean.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @RequestMapping(value = &quot;/consumer/person/get/&#123;id&#125;&quot;)</div><div class="line">    public Person get(@PathVariable(&quot;id&quot;) Long id)</div><div class="line">    &#123;</div><div class="line">        return restTemplate.getForObject(REST_URL_PREFIX + &quot;/person/get/&quot; + id, Person.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    @RequestMapping(value = &quot;/consumer/person/list&quot;)</div><div class="line">    public List&lt;Person&gt; list()</div><div class="line">    &#123;</div><div class="line">        return restTemplate.getForObject(REST_URL_PREFIX + &quot;/person/list&quot;, List.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-5-新建启动类"><a href="#4-5-新建启动类" class="headerlink" title="4.5 新建启动类"></a>4.5 新建启动类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">public class ApplicationBootStart &#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        SpringApplication.run(ApplicationBootStart.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-6-完整项目结构"><a href="#4-6-完整项目结构" class="headerlink" title="4.6 完整项目结构"></a>4.6 完整项目结构</h3><p><img src="/2019/05/01/SpringCloud个人总结/C1565962178357.png" alt="1565962178357"></p>
<h2 id="5-同时启动服务提供者和服务消费者"><a href="#5-同时启动服务提供者和服务消费者" class="headerlink" title="5 同时启动服务提供者和服务消费者"></a>5 同时启动服务提供者和服务消费者</h2><p>也就是运行ApplicationBootStart8001和ApplicationBootStart80启动类即可</p>
<p>测试服务是否可以消费，访问消费者</p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image034.jpg" alt="img"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image036.jpg" alt="img"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image038.jpg" alt="img"></p>
<p>测试成功,以上就是成功的搭建了一个简单的微服务架构，下面我们会逐步的加入springcloud的其他组件，完善这个架构</p>
<h2 id="5-上面的项目存在什么问题"><a href="#5-上面的项目存在什么问题" class="headerlink" title="5.上面的项目存在什么问题"></a>5.上面的项目存在什么问题</h2><p>存在什么问题？</p>
<ul>
<li>在consumer中，我们把url地址硬编码到了代码中，不方便后期维护</li>
<li>consumer需要记忆provider的地址，如果出现变更，可能得不到通知，地址将失效</li>
<li>consumer不清楚provider的状态，服务宕机也不知道</li>
<li>provider只有1台服务，不具备高可用性</li>
<li>即便provider形成集群，consumer还需自己实现负载均衡</li>
</ul>
<p>其实上面说的问题，概括一下就是分布式服务必然要面临的问题：</p>
<ul>
<li>服务管理<ul>
<li>如何自动注册和发现</li>
<li>如何实现状态监管</li>
<li>如何实现动态路由</li>
</ul>
</li>
<li>服务如何实现负载均衡</li>
<li>服务如何解决容灾问题</li>
<li>服务如何实现统一配置</li>
</ul>
<p>以上的问题，我们都将在SpringCloud中得到答案。</p>
<h1 id="六-Eureka注册中心"><a href="#六-Eureka注册中心" class="headerlink" title="六.Eureka注册中心"></a>六.Eureka注册中心</h1><pre><code>**首先我们来解决第一问题，服务的管理 - 利用Eureka解决服务治理问题**
</code></pre><h2 id="1-Eureka概念"><a href="#1-Eureka概念" class="headerlink" title="1.Eureka概念"></a>1.Eureka概念</h2><p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-17_11-15-12.png" alt=""></p>
<pre><code>Eureka是Netflix的一个子模块，也是核心模块之一。Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。**服务注册与发现对于微服务架构来说是非常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务(解决上诉案例在consumer中，我们把服务提供者的url地址硬编码到了代码中)**，而不需要修改服务调用的配置文件了。功能类似于dubbo的注册中心，比如Zookeeper。



Netflix在设计Eureka时遵守的就是CAP规则中的AP原则。
</code></pre><blockquote>
<p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得</p>
</blockquote>
<p>特别提示：同样作为dubbo服务注册中心的zookeeper遵守的是CP原则。</p>
<h2 id="2-Eureka架构和原理"><a href="#2-Eureka架构和原理" class="headerlink" title="2.Eureka架构和原理"></a>2.Eureka架构和原理</h2><p>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现(请对比Zookeeper)。</p>
<p><strong>Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心</strong>。</p>
<p>而系统中的其他微服务，使用 <strong>Eureka 的客户端（上诉案例中的，服务提供者和服务消费者相对于EurekaServer都是属于客户端，前者是向EurekaServer注册服务，后者是向EurekaServer获取服务）</strong>连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。SpringCloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。</p>
<blockquote>
<p>基本架构：</p>
</blockquote>
<p><img src="/SpringCloud个人总结/1525597885059.png" alt="1525597885059"></p>
<p>Eureka包含两个组件：Eureka Server和Eureka Client</p>
<blockquote>
<p>Eureka Server提供服务注册服务<br>各个节点启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到</p>
<p>EurekaClient是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）         </p>
</blockquote>
<ul>
<li>Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址</li>
<li>提供者：启动后向Eureka注册自己信息（地址，提供什么服务）</li>
<li>消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li>
<li>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</li>
</ul>
<h2 id="3-实现EurekaServer"><a href="#3-实现EurekaServer" class="headerlink" title="3. 实现EurekaServer"></a>3. 实现EurekaServer</h2><p>接下来我们通过加入springcloud的Eureka服务治理组件，改造之前的例子，解决动态路由（上个例子中我们是把服务提供者的url硬编码到消费者中）、注册发现，动态监管的问题</p>
<h3 id="3-1-根据父工程实现单节点Eureka服务注册中心"><a href="#3-1-根据父工程实现单节点Eureka服务注册中心" class="headerlink" title="3.1 根据父工程实现单节点Eureka服务注册中心"></a>3.1 根据父工程实现单节点Eureka服务注册中心</h3><p>根据父工程microservicecloud  创建 microservicecloud-eureka-7001模块</p>
<h4 id="3-1-1-修改pom文件导入EurekaServer依赖"><a href="#3-1-1-修改pom文件导入EurekaServer依赖" class="headerlink" title="3.1.1 修改pom文件导入EurekaServer依赖"></a>3.1.1 修改pom文件导入EurekaServer依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">       &lt;!--eureka-server服务端 --&gt;</div><div class="line">       &lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</div><div class="line">       &lt;/dependency&gt;</div><div class="line">       &lt;!-- 修改后立即生效，热部署 --&gt;</div><div class="line">       &lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;springloaded&lt;/artifactId&gt;</div><div class="line">       &lt;/dependency&gt;</div><div class="line">       &lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</div><div class="line">       &lt;/dependency&gt;</div><div class="line">   &lt;/dependencies</div></pre></td></tr></table></figure>
<h4 id="3-1-2-修改application-yml配置文件"><a href="#3-1-2-修改application-yml配置文件" class="headerlink" title="3.1.2 修改application.yml配置文件"></a>3.1.2 修改application.yml配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 7001</div><div class="line"></div><div class="line">eureka:</div><div class="line">  instance:</div><div class="line">    hostname: localhost #eureka服务端的实例名称</div><div class="line">  client:</div><div class="line">    register-with-eureka: false     #false表示不向注册中心注册自己。</div><div class="line">    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</div><div class="line">    service-url:</div><div class="line">       defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</div><div class="line">       # #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。</div><div class="line">       #等同于 http://localhost:7001/eureka/</div></pre></td></tr></table></figure>
<h4 id="3-1-3-创建启动类并添加-EnableEurekaServer注解"><a href="#3-1-3-创建启动类并添加-EnableEurekaServer注解" class="headerlink" title="3.1.3 创建启动类并添加@EnableEurekaServer注解"></a>3.1.3 创建启动类并添加@EnableEurekaServer注解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.entity;</div><div class="line"></div><div class="line">import org.springframework.boot.SpringApplication;</div><div class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</div><div class="line"></div><div class="line"></div><div class="line">@SpringBootApplication</div><div class="line">@EnableEurekaServer ////EurekaServer服务器端启动类,接受其它微服务注册进来</div><div class="line">public class ApplicationBootStart7001 &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart7001.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-1-4-完整项目结构"><a href="#3-1-4-完整项目结构" class="headerlink" title="3.1.4 完整项目结构"></a>3.1.4 完整项目结构</h4><p><img src="/2019/05/01/SpringCloud个人总结/5C1565961802586.png" alt="1565961802586"></p>
<h4 id="3-1-5-运行启动类，启动EurekaServer"><a href="#3-1-5-运行启动类，启动EurekaServer" class="headerlink" title="3.1.5 运行启动类，启动EurekaServer"></a>3.1.5 运行启动类，启动EurekaServer</h4><p>访问网址：<strong><a href="http://localhost:7001/" target="_blank" rel="external">http://localhost:7001/</a></strong></p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-17_11-16-35.png" alt=""></p>
<p><strong>No application available 没有服务被发现 —- 因为没有注册服务进来当然不可能有服务被发现</strong></p>
<p>接下来我门把8001模块服务注册进来</p>
<h3 id="3-2-修改-服务提供者"><a href="#3-2-修改-服务提供者" class="headerlink" title="3.2 修改 服务提供者"></a>3.2 修改 服务提供者</h3><p>也就是修改上面我们实现的：microservicecloud-provider-person-8001 模块，将人员服务注册进EurekaServer中</p>
<h4 id="3-2-1-修改pom文件"><a href="#3-2-1-修改pom文件" class="headerlink" title="3.2.1 修改pom文件"></a>3.2.1 修改pom文件</h4><p>修改内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- 将微服务provider端注册进eureka --&gt;</div><div class="line">       &lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">       &lt;/dependency&gt;</div><div class="line">       &lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line">       &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h4 id="3-2-2-修改application-yml配置文件"><a href="#3-2-2-修改application-yml配置文件" class="headerlink" title="3.2.2 修改application.yml配置文件"></a>3.2.2 修改application.yml配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">eureka:</div><div class="line">  client: #客户端注册进eureka服务列表内</div><div class="line">    service-url: </div><div class="line">      defaultZone: http://localhost:7001/eureka #这个地址就是我们在3.1.2定义的EurekaServer对外暴露的连接地址。</div></pre></td></tr></table></figure>
<h4 id="3-2-3-修改启动类添加-EnableEurekaClient注解"><a href="#3-2-3-修改启动类添加-EnableEurekaClient注解" class="headerlink" title="3.2.3 修改启动类添加@EnableEurekaClient注解"></a>3.2.3 修改启动类添加@EnableEurekaClient注解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableEurekaClient////本服务启动后会自动注册进 eureka服务中</div><div class="line">public class ApplicationBootStart8001 &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart8001.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-修改服务消费者"><a href="#3-3-修改服务消费者" class="headerlink" title="3.3 修改服务消费者"></a>3.3 修改服务消费者</h3><p><strong>通过访问服务名称的方式消费服务，解决硬编码服务提供者url的问题</strong></p>
<p>也就是修改上面我们实现的：microservicecloud-consumer-person-80 模块</p>
<h4 id="3-3-1-修改pom文件"><a href="#3-3-1-修改pom文件" class="headerlink" title="3.3.1 修改pom文件"></a>3.3.1 修改pom文件</h4><p>修改内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- 将微服务provider端注册进eureka --&gt;</div><div class="line">       &lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">       &lt;/dependency&gt;</div><div class="line">       &lt;dependency&gt;</div><div class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line">       &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h4 id="3-3-2-修改application-yml配置文件"><a href="#3-3-2-修改application-yml配置文件" class="headerlink" title="3.3.2 修改application.yml配置文件"></a>3.3.2 修改application.yml配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">eureka:</div><div class="line">  client:</div><div class="line">    register-with-eureka: false</div><div class="line">    service-url:</div><div class="line">      defaultZone: http://localhost:7001/eureka/</div></pre></td></tr></table></figure>
<h4 id="3-3-3-修改启动类添加-EnableEurekaClient注解"><a href="#3-3-3-修改启动类添加-EnableEurekaClient注解" class="headerlink" title="3.3.3 修改启动类添加@EnableEurekaClient注解"></a>3.3.3 修改启动类添加@EnableEurekaClient注解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableEurekaClient//</div><div class="line">public class ApplicationBootStart80 &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart80.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-4修改ConsumerController代码"><a href="#3-3-4修改ConsumerController代码" class="headerlink" title="3.3.4修改ConsumerController代码"></a>3.3.4修改ConsumerController代码</h4><p>修改内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//    private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;</div><div class="line">    private static final String REST_URL_PREFIX = &quot;http://MICROSERVICECLOUD-PERSON&quot;;</div></pre></td></tr></table></figure>
<p>把url更改为服务名称。</p>
<h3 id="3-4-启动EurekaServer和服务提供者，以及服务消费者"><a href="#3-4-启动EurekaServer和服务提供者，以及服务消费者" class="headerlink" title="3.4 启动EurekaServer和服务提供者，以及服务消费者"></a>3.4 启动EurekaServer和服务提供者，以及服务消费者</h3><p>运行ApplicationBootStart7001和ApplicationBootStart8001、ApplicationBootStart80</p>
<p>查看地址：<strong><a href="http://localhost:7001/" target="_blank" rel="external">http://localhost:7001/</a></strong></p>
<p><img src="/2019/05/01/SpringCloud个人总结/65963220408.png" alt="1565963220408"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/966479080.png" alt="1565966479080"></p>
<p>注册成功！！！</p>
<p>服务名称就是我们在服务提供者的application.yml配置文件中配置的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring:</div><div class="line">   application:</div><div class="line">    name: microservicecloud-person                          #很重要，对外暴露的微服务的名称</div></pre></td></tr></table></figure>
<p>我们发现生成的实例名称是没有任何意义的，而且实例的介绍地址不是ip的形式</p>
<p><img src="/2019/05/01/SpringCloud个人总结/963618268.png" alt="1565963618268"></p>
<p>下面就讲解修改这些小细节</p>
<h2 id="4-actuator与注册微服务信息完善"><a href="#4-actuator与注册微服务信息完善" class="headerlink" title="4.actuator与注册微服务信息完善"></a>4.<strong>actuator与注册微服务信息完善</strong></h2><h3 id="4-1-修改服务实例名和实例名访问路径显示ip"><a href="#4-1-修改服务实例名和实例名访问路径显示ip" class="headerlink" title="4.1 修改服务实例名和实例名访问路径显示ip"></a>4.1 修改服务实例名和实例名访问路径显示ip</h3><p>修改microservicecloud-provider-person-8001 模块的配置文件，添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">instance:</div><div class="line">  instance-id: microservicecloud-person8001</div><div class="line">  prefer-ip-address: true     #访问路径可以显示IP地址</div></pre></td></tr></table></figure>
<p>注意instance属性是eureka的子属性</p>
<p><img src="/2019/05/01/SpringCloud个人总结/565964019636.png" alt="1565964019636"></p>
<p>重启服务提供者ApplicationBootStart8001</p>
<p>查看EurekaServer</p>
<p><img src="/2019/05/01/SpringCloud个人总结/565964513626.png" alt="1565964513626"></p>
<p>这里涉及到了Eureka 的自我保护机制，下一章节我们会讲到。</p>
<h3 id="4-2-修改服务实例的详情页info"><a href="#4-2-修改服务实例的详情页info" class="headerlink" title="4.2 修改服务实例的详情页info"></a>4.2 修改服务实例的详情页info</h3><p>默认我么你点击服务实例名，跳转到的界面是：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/64617801.png" alt="1565964617801"></p>
<p>接下来我们要定制一下这界面，显示一下当前服务实例的一些说明信息。</p>
<p>（1）修改microservicecloud-provider-person-8001 模块的pom文件，添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- actuator监控信息完善 --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>（2）修改microservicecloud-provider-person-8001 模块的配置文件，添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">info:</div><div class="line">  app.name: $&#123;spring.application.name&#125;</div><div class="line">  company.name: kingge.top</div><div class="line">  build.artifactId: $&#123;project.artifactId&#125;</div><div class="line">  build.version: $&#123;project.version&#125;</div><div class="line">  app.desc: 这是一个提供查询部门人员信息的服务</div></pre></td></tr></table></figure>
<p>（3）修改父工程的pom文件，添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;build&gt;</div><div class="line">        &lt;finalName&gt;microservicecloud&lt;/finalName&gt;</div><div class="line">        &lt;resources&gt;</div><div class="line">            &lt;resource&gt;</div><div class="line">                &lt;directory&gt;src/main/resources&lt;/directory&gt;</div><div class="line">                &lt;filtering&gt;true&lt;/filtering&gt;</div><div class="line">            &lt;/resource&gt;</div><div class="line">        &lt;/resources&gt;</div><div class="line">        &lt;plugins&gt;</div><div class="line">            &lt;plugin&gt;</div><div class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</div><div class="line">                &lt;configuration&gt;</div><div class="line">                    &lt;delimiters&gt;</div><div class="line">                        &lt;delimit&gt;$&lt;/delimit&gt;</div><div class="line">                    &lt;/delimiters&gt;</div><div class="line">                &lt;/configuration&gt;</div><div class="line">            &lt;/plugin&gt;</div><div class="line">        &lt;/plugins&gt;</div><div class="line">    &lt;/build&gt;</div></pre></td></tr></table></figure>
<p>如果不添加那么就无法解析像这样的动态赋值${spring.application.name}</p>
<p>重启EurekaServer和服务提供者</p>
<p>再次查看服务实例名的info界面</p>
<p><img src="/2019/05/01/SpringCloud个人总结/C1565965118437.png" alt="1565965118437"></p>
<h2 id="5-Eureka详解"><a href="#5-Eureka详解" class="headerlink" title="5.Eureka详解"></a>5.Eureka详解</h2><h3 id="5-1-基础架构"><a href="#5-1-基础架构" class="headerlink" title="5.1.基础架构"></a>5.1.基础架构</h3><p>Eureka架构中的三个核心角色：</p>
<ul>
<li><p>服务注册中心</p>
<p>Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的7001模块。</p>
</li>
<li><p>服务提供者</p>
<p>提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的8001模块。</p>
</li>
<li><p>服务消费者</p>
<p>消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的80模块。</p>
</li>
</ul>
<p><strong>服务提供和服务消费者相对于服务注册中心，他们都是客户端。所以他们访问EurekaServer导入的依赖是相同的都是spring-cloud-starter-netflix-eureka-client</strong></p>
<h3 id="5-2-服务提供者"><a href="#5-2-服务提供者" class="headerlink" title="5.2.服务提供者"></a>5.2.服务提供者</h3><p>服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。</p>
<blockquote>
<p>服务注册</p>
</blockquote>
<p>服务提供者在启动时，会检测配置属性中的：<code>eureka.client.register-with-eureka=true</code>参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。</p>
<ul>
<li>第一层Map的Key就是服务id，一般是配置中的<code>spring.application.name</code>属性</li>
<li>第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：<code>locahost:service-provider:8081</code></li>
<li>值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。</li>
</ul>
<blockquote>
<p>服务续约</p>
</blockquote>
<p>在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；</p>
<p>有两个重要参数可以修改服务续约的行为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    lease-expiration-duration-in-seconds:</span> <span class="number">90</span></div><div class="line"><span class="attr">    lease-renewal-interval-in-seconds:</span> <span class="number">30</span></div></pre></td></tr></table></figure>
<ul>
<li>lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒</li>
<li>lease-expiration-duration-in-seconds：服务失效时间，默认值90秒</li>
</ul>
<p>也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。</p>
<p>但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    lease-expiration-duration-in-seconds:</span> <span class="number">10</span> <span class="comment"># 10秒即过期</span></div><div class="line"><span class="attr">    lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 5秒一次心跳</span></div></pre></td></tr></table></figure>
<h3 id="5-3-服务消费者"><a href="#5-3-服务消费者" class="headerlink" title="5.3.服务消费者"></a>5.3.服务消费者</h3><blockquote>
<p>获取服务列表</p>
</blockquote>
<p>当服务消费者启动时，会检测<code>eureka.client.fetch-registry=true</code>参数的值，如果为true，则会拉取Eureka Server服务的列表只读备份，然后缓存在本地。并且<code>每隔30秒</code>会重新获取并更新数据。我们可以通过下面的参数来修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    registry-fetch-interval-seconds:</span> <span class="number">5</span></div></pre></td></tr></table></figure>
<p>生产环境中，我们不需要修改这个值。</p>
<p>但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。</p>
<h3 id="5-4-失效剔除和自我保护"><a href="#5-4-失效剔除和自我保护" class="headerlink" title="5.4.失效剔除和自我保护"></a>5.4.失效剔除和自我保护</h3><blockquote>
<p>服务下线</p>
</blockquote>
<p>当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。</p>
<blockquote>
<p>失效剔除</p>
</blockquote>
<p>有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。</p>
<p>可以通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒，生产环境不要修改。</p>
<p>这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如：10秒</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1528696142799.png" alt="1528696142799"></p>
<blockquote>
<p>自我保护</p>
</blockquote>
<p>我们关停一个服务，就会在Eureka面板看到一条警告：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1525618396076.png" alt="1525618396076"></p>
<p>这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。</p>
<p><strong>也就是好死不如赖活着，这个就是用EurekaServer的AP原则，保证可用性</strong></p>
<p>但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：（itcast-eureka）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  server:</span></div><div class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护模式（缺省为打开）</span></div><div class="line"><span class="attr">    eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 扫描失效服务的间隔时间（缺省为60*1000ms）</span></div></pre></td></tr></table></figure>
<p><strong>综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留），也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。</strong></p>
<p><strong>一句话：某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存</strong></p>
<h2 id="6-消费者获取服务信息"><a href="#6-消费者获取服务信息" class="headerlink" title="6.消费者获取服务信息"></a>6.消费者获取服务信息</h2><p>如果我们想要在消费者端获取服务者提供的服务实例列表，那么应该怎么做？<strong>对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息</strong></p>
<p>既然是消费者端想查看服务端暴露的服务信息，那么就需要在服务提供者实现一个查询暴露服务实例的列表的接口</p>
<p>1.修改服务端PersonController</p>
<p>添加如下代码，查询服务名称为MICROSERVICECLOUD-PERSON的服务实例列表信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Autowired</div><div class="line">private DiscoveryClient client;</div><div class="line">@RequestMapping(value = &quot;/person/discovery&quot;, method = RequestMethod.GET)</div><div class="line">public Object discovery()</div><div class="line">&#123;</div><div class="line">	List&lt;String&gt; list = client.getServices();</div><div class="line">	System.out.println(&quot;**********&quot; + list);</div><div class="line"></div><div class="line">	List&lt;ServiceInstance&gt; srvList = client.getInstances(&quot;MICROSERVICECLOUD-PERSON&quot;);</div><div class="line">	for (ServiceInstance element : srvList) &#123;</div><div class="line">		System.out.println(element.getServiceId() + &quot;\t&quot; + element.getHost() + &quot;\t&quot; + element.getPort() + &quot;\t&quot;</div><div class="line">				+ element.getUri());</div><div class="line">	&#125;</div><div class="line">	return this.client;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.服务提供者启动类添加注解@EnableDiscoveryClient （后来测试发现其实这一步是多余的）</p>
<p><img src="/2019/05/01/SpringCloud个人总结/5C1565967990809.png" alt="1565967990809"></p>
<p>因为@EnableEurekaClient注解已经包含了@EnableDiscoveryClient 注解</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1565968096288.png" alt="1565968096288"></p>
<p><strong>也就是说当服务注册中心是Eureka的时候那么官方已经为了包装了一个注解替代了@EnableDiscoveryClient，但是如果注册中心不是Eureka的话，那么建议使用@EnableDiscoveryClient注解实现服务发现，因为这里注册中心是Eureka那么就是用官方推荐的@EnableEurekaClient</strong></p>
<p>3.修改ConsumerController代码，访问服务提供者提供的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="comment">// 测试@EnableDiscoveryClient,消费端可以调用服务发现</span></div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/consumer/person/discovery"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">discovery</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="string">"/person/discovery"</span>, Object.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.启动服务提供者和服务消费者</p>
<p>消费者访问接口</p>
<p><img src="/2019/05/01/SpringCloud个人总结/C1565968242592.png" alt="1565968242592"></p>
<h2 id="7-EurekaServer集群"><a href="#7-EurekaServer集群" class="headerlink" title="7.EurekaServer集群"></a>7.EurekaServer集群</h2><p>单个的EurekaServer很明显是不符合HA，高可用原则，所以下面再加两台EurekaServer-8002和8003构成EurekaServer集群</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1565970421791.png" alt="1565970421791"></p>
<p>基本原理</p>
<blockquote>
<p> 上图是来自eureka的官方架构图，这是基于集群配置的eureka； </p>
<p> - 处于不同节点的eureka通过Replicate进行数据同步 </p>
<p> - Application Service为服务提供者 </p>
<p> - Application Client为服务消费者 </p>
<p> - Make Remote Call完成一次服务调用</p>
<p> 服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。</p>
<p> 当服务注册中心Eureka Server检测到服务提供者因为宕机、网络原因不可用时，则在服务注册中心将服务置为DOWN状态，并把当前服务提供者状态向订阅者发布，订阅过的服务消费者更新本地缓存。</p>
<p> 服务提供者在启动后，周期性（默认30秒）向Eureka Server发送心跳，以证明当前服务是可用状态。Eureka Server在一定的时间（默认90秒）未收到客户端的心跳，则认为服务宕机，注销该实例。</p>
</blockquote>
<h3 id="7-1-根据microservicecloud-eureka-7001创建两个相同的工程"><a href="#7-1-根据microservicecloud-eureka-7001创建两个相同的工程" class="headerlink" title="7.1 根据microservicecloud-eureka-7001创建两个相同的工程"></a>7.1 根据microservicecloud-eureka-7001创建两个相同的工程</h3><p>分别是microservicecloud-eureka-7002和microservicecloud-eureka-7003</p>
<p>按照7001为模板粘贴POM</p>
<p>修改7002和7003的主启动类</p>
<p>完整工程如下</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1565970941327.png" alt="1565970941327"></p>
<h3 id="7-2-修改映射配置-实现唯一的eureka服务端的实例名称"><a href="#7-2-修改映射配置-实现唯一的eureka服务端的实例名称" class="headerlink" title="7.2 修改映射配置-实现唯一的eureka服务端的实例名称"></a>7.2 修改映射配置-实现唯一的eureka服务端的实例名称</h3><p>为了模拟EurekaServer集群，不同的EurekaServer在不同的机器，而且拥有不同的实例名称</p>
<p><strong>找到C:\Windows\System32\drivers\etc路径下的hosts文件</strong></p>
<table>
<thead>
<tr>
<th><strong>修改映射配置添加进hosts文件</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>127.0.0.1  peer1</strong></td>
<td></td>
</tr>
<tr>
<td><strong>127.0.0.1  peer2</strong></td>
<td></td>
</tr>
<tr>
<td><strong>127.0.0.1  peer3</strong></td>
</tr>
</tbody>
</table>
<h3 id="7-3-修改7001-7003三台EurekaServer的配置文件"><a href="#7-3-修改7001-7003三台EurekaServer的配置文件" class="headerlink" title="7.3 修改7001-7003三台EurekaServer的配置文件"></a>7.3 修改7001-7003三台EurekaServer的配置文件</h3><p>7001 修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 7001</div><div class="line"></div><div class="line">eureka:</div><div class="line">  instance:</div><div class="line">    hostname: peer1 #peer1 #eureka服务端的实例名称</div><div class="line">  client:</div><div class="line">    register-with-eureka: false     #false表示不向注册中心注册自己。</div><div class="line">    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</div><div class="line">    service-url:</div><div class="line">       defaultZone: http://peer2:7002/eureka/,http://peer3:7003/eureka/ #注册7002和7003 自己不用声明</div></pre></td></tr></table></figure>
<p>7002 修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 7002</div><div class="line"></div><div class="line">eureka:</div><div class="line">  instance:</div><div class="line">    hostname: peer2 #eureka服务端的实例名称</div><div class="line">  client:</div><div class="line">    register-with-eureka: false     #false表示不向注册中心注册自己。</div><div class="line">    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</div><div class="line">    service-url:</div><div class="line">       defaultZone: http://peer1:7001/eureka/,http://peer3:7003/eureka/ #注册7001和7003 自己不用声明</div><div class="line">       #等同于http://localhost:7001/eureka/</div></pre></td></tr></table></figure>
<p>7003修改内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 7003</div><div class="line"></div><div class="line">eureka:</div><div class="line">  instance:</div><div class="line">    hostname: peer3 #eureka服务端的实例名称</div><div class="line">  client:</div><div class="line">    register-with-eureka: false     #false表示不向注册中心注册自己。</div><div class="line">    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</div><div class="line">    service-url:</div><div class="line">       defaultZone: http://peer1:7001/eureka/,http://peer2:7002/eureka/ #注册7001和7002 自己不用声明</div><div class="line">       #等同于http://localhost:7001/eureka/</div></pre></td></tr></table></figure>
<p>需要注意的是service-url:defaultZone的值，都是包含其他EurekaServer的值，不用书写自己的。</p>
<h3 id="7-4-修改服务提供者的配置文件"><a href="#7-4-修改服务提供者的配置文件" class="headerlink" title="7.4 修改服务提供者的配置文件"></a>7.4 修改服务提供者的配置文件</h3><p>也就是修改microservicecloud-provider-person-8001模块修改内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 8001</div><div class="line"></div><div class="line">mybatis:</div><div class="line">  config-location: classpath:mybatis/mybatis.cfg.xml        # mybatis配置文件所在路径</div><div class="line">  type-aliases-package: com.kingge.entity    # 所有Entity别名类所在包</div><div class="line">  mapper-locations:</div><div class="line">  - classpath:mybatis/mapper/**/*.xml                       # mapper映射文件</div><div class="line"></div><div class="line">spring:</div><div class="line">   application:</div><div class="line">    name: microservicecloud-person                          #很重要，对外暴露的微服务的名称</div><div class="line">   datasource:</div><div class="line">    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</div><div class="line">    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包</div><div class="line">    url: jdbc:mysql://127.0.0.1:3306/test              # 数据库名称</div><div class="line">    username: root</div><div class="line">    password: 123</div><div class="line">    dbcp2:</div><div class="line">      min-idle: 5                                           # 数据库连接池的最小维持连接数</div><div class="line">      initial-size: 5                                       # 初始化连接数</div><div class="line">      max-total: 5                                          # 最大连接数</div><div class="line">      max-wait-millis: 200                                  # 等待连接获取的最大超时时间</div><div class="line">#</div><div class="line">eureka:</div><div class="line">  client: #客户端注册进eureka服务列表内</div><div class="line">    service-url:</div><div class="line">      defaultZone: http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/</div><div class="line">#      http://localhost:7001/eureka #单机版本使用</div><div class="line">#      defaultZone: http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/</div><div class="line">  instance:</div><div class="line">    instance-id: microservicecloud-person8001 #自定义服务实例名</div><div class="line">    prefer-ip-address: true     #访问路径可以显示IP地址</div><div class="line">#</div><div class="line">info:</div><div class="line">  app.name: $&#123;spring.application.name&#125;</div><div class="line">  company.name: kingge.top</div><div class="line">  build.artifactId: $&#123;project.artifactId&#125;</div><div class="line">  build.version: $&#123;project.version&#125;</div><div class="line">  app.desc: 这是一个提供查询部门人员信息的服务</div></pre></td></tr></table></figure>
<p>实际上就是修改了service-url:defaultZone的值，修改为了EurekaServer集群的地址，其他配置没有改变</p>
<h3 id="7-5重启7001-7003服务器"><a href="#7-5重启7001-7003服务器" class="headerlink" title="7.5重启7001-7003服务器"></a>7.5重启7001-7003服务器</h3><p>也就是分别运行ApplicationBootStart7001、ApplicationBootStart7002、ApplicationBootStart7003</p>
<p>访问查看</p>
<p><img src="/2019/05/01/SpringCloud个人总结/565971841015.png" alt="1565971841015"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/1565972117167.png" alt="1565972117167"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/963618212368.png" alt="1565972150084"></p>
<p>部署成功！！！！！！！</p>
<h2 id="8-Eureka和Zookeeper-服务注册中心比较"><a href="#8-Eureka和Zookeeper-服务注册中心比较" class="headerlink" title="8.Eureka和Zookeeper-服务注册中心比较"></a>8.<strong>Eureka和Zookeeper-服务注册中心比较</strong></h2><p>著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性P在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。</p>
<p>那么分布式系统，必然要求分区容错性，也就是P原则，那么Zookeeper选择了C，Eureka选择了A</p>
<p> 因此Zookeeper保证的是CP,Eureka则是AP。</p>
<h3 id="8-1-Zookeeper保证CP"><a href="#8-1-Zookeeper保证CP" class="headerlink" title="8.1 Zookeeper保证CP"></a>8.1 Zookeeper保证CP</h3><pre><code>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。
</code></pre><h3 id="8-2-Eureka保证AP"><a href="#8-2-Eureka保证AP" class="headerlink" title="8.2 Eureka保证AP"></a>8.2 Eureka保证AP</h3><pre><code>Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的 ，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： 
</code></pre><blockquote>
<pre><code>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 

Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)

当网络稳定时，当前实例新的注册信息会被同步到其它节点中
</code></pre><p>因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p>
</blockquote>
<p> 那么既然保证了保证了可用性，那么数据的一致性肯定是不能够保证了，所以这个就是自我保护的机制。所以到底是AP还是CP，又或者是AC（数据库），要看业务场景来定。</p>
<h1 id="七-Ribbon负载均衡"><a href="#七-Ribbon负载均衡" class="headerlink" title="七.Ribbon负载均衡"></a>七.<strong>Ribbon负载均衡</strong></h1><p><strong>接下来解决第二个问题，那就是假设在多个服务提供者提供服务的情况下，怎么做到负载均衡，解决需要把服务提供者url硬编码到消费者端的问题。</strong></p>
<h2 id="7-1-Ribbon概念"><a href="#7-1-Ribbon概念" class="headerlink" title="7.1 Ribbon概念"></a>7.1 Ribbon概念</h2><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端 负载均衡的工具</strong> 。</p>
<pre><code>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供**客户端**的**软件负载**均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon**实现自定义的负载均衡算法**。
</code></pre><h2 id="7-2-什么叫LB（负载均衡）"><a href="#7-2-什么叫LB（负载均衡）" class="headerlink" title="7.2 什么叫LB（负载均衡）"></a>7.2 什么叫<strong>LB（负载均衡）</strong></h2><p> LB，即负载均衡(Load Balance)，在微服务或分布式集群中经常用的一种应用。</p>
<p>负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA。</p>
<p>常见的负载均衡有软件Nginx，LVS，硬件 F5等。</p>
<p>相应的在中间件，例如：dubbo和SpringCloud中均给我们提供了负载均衡，SpringCloud的负载均衡算法可以自定义。 </p>
<p> 两种负载均衡：</p>
<ol>
<li>集中式LB：偏硬件，服务的消费方和提供方之间使用独立的LB设施，由该设施负责把访问请求以某种策略转发至服务的提供方。</li>
<li><p>进程内LB：偏软件， 将LB逻辑集成到消费方，消费方从服务注册中心指导哪些地址可用，再自己选择一个合适的服务器。</p>
<p><strong>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</strong></p>
</li>
</ol>
<h2 id="7-3-Ribbon负载均衡实现"><a href="#7-3-Ribbon负载均衡实现" class="headerlink" title="7.3 Ribbon负载均衡实现"></a>7.3 Ribbon负载均衡实现</h2><p>因为在上面的例子中只存在一个8001模块在提供服务，那么为了能够演示负载均衡的例子，这里需要再增加两个服务提供者8002和8003</p>
<h3 id="7-3-1-根据8001模块复制新建两份分别命名为8002和8003"><a href="#7-3-1-根据8001模块复制新建两份分别命名为8002和8003" class="headerlink" title="7.3.1 根据8001模块复制新建两份分别命名为8002和8003"></a>7.3.1 根据8001模块复制新建两份分别命名为8002和8003</h3><p>请看完整项目结构图</p>
<p>8002模块</p>
<p><img src="/2019/05/01/SpringCloud个人总结/C1566008410173.png" alt="1566008410173"></p>
<p>8003模块</p>
<p><img src="/2019/05/01/SpringCloud个人总结/566008463016.png" alt="1566008463016"></p>
<h3 id="7-3-2-新建数据库test2、test3，让各自微服务分别连各自的数据库"><a href="#7-3-2-新建数据库test2、test3，让各自微服务分别连各自的数据库" class="headerlink" title="7.3.2 新建数据库test2、test3，让各自微服务分别连各自的数据库"></a>7.3.2 新建数据库test2、test3，<strong>让各自微服务分别连各自的数据库</strong></h3><p>我们知道一个微服务可能是一套完整的系统，那么也就意味着他可能拥有自己的数据库。而且为了方便测试负载均衡，我们让8001-8003这三个服务提供者各自连接自己的数据库，也方便验证负载均衡是否实现。</p>
<p>给test2数据库导入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DROP TABLE IF EXISTS `person`;</div><div class="line">CREATE TABLE `person` (</div><div class="line">  `deptno` int(255) NOT NULL AUTO_INCREMENT,</div><div class="line">  `db_source` varchar(255) DEFAULT NULL,</div><div class="line">  `dname` varchar(255) DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`deptno`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;</div><div class="line"></div><div class="line">-- ----------------------------</div><div class="line">-- Records of person</div><div class="line">-- ----------------------------</div><div class="line">INSERT INTO `person` VALUES (&apos;5&apos;, &apos;test2&apos;, &apos;开发部&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;6&apos;, &apos;test2&apos;, &apos;人事部&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;7&apos;, &apos;test2&apos;, &apos;集成部&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;8&apos;, &apos;test2&apos;, &apos;市场部&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;9&apos;, &apos;test2&apos;, &apos;hr&apos;);</div></pre></td></tr></table></figure>
<p>db_source字段标识，数据来源那个数据库</p>
<p>给test3数据库导入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DROP TABLE IF EXISTS `person`;</div><div class="line">CREATE TABLE `person` (</div><div class="line">  `deptno` int(255) NOT NULL AUTO_INCREMENT,</div><div class="line">  `db_source` varchar(255) DEFAULT NULL,</div><div class="line">  `dname` varchar(255) DEFAULT NULL,</div><div class="line">  PRIMARY KEY (`deptno`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;</div><div class="line"></div><div class="line">-- ----------------------------</div><div class="line">-- Records of person</div><div class="line">-- ----------------------------</div><div class="line">INSERT INTO `person` VALUES (&apos;5&apos;, &apos;test3&apos;, &apos;开发部&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;6&apos;, &apos;test3&apos;, &apos;人事部&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;7&apos;, &apos;test3&apos;, &apos;集成部&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;8&apos;, &apos;test3&apos;, &apos;市场部&apos;);</div><div class="line">INSERT INTO `person` VALUES (&apos;9&apos;, &apos;test3&apos;, &apos;hr&apos;);</div></pre></td></tr></table></figure>
<p><img src="/2019/05/01/SpringCloud个人总结/6009325282.png" alt="1566009325282"></p>
<h3 id="7-3-3-修改8002-8003各自application-yml配置文件"><a href="#7-3-3-修改8002-8003各自application-yml配置文件" class="headerlink" title="7.3.3 修改8002/8003各自application.yml配置文件"></a>7.3.3 <strong>修改8002/8003各自application.yml配置文件</strong></h3><p>实际上只需要修改三个地方：服务暴露的端口号，服务连接的数据库，服务的实例名</p>
<p><strong>注意：服务名称不能够修改</strong></p>
<p><img src="/2019/05/01/SpringCloud个人总结/566008980542.png" alt="1566008980542"></p>
<p><strong><em>因为这三个服务都是提供同样的业务，那么就不会归属到一个服务组下，也就是说我们想要的是：microservicecloud-person 这个服务名称（服务组）下面有三个服务实例（8001-8003）提供服务，这样负载均衡才能够演示</em></strong></p>
<blockquote>
<p>8002模块修改如下</p>
</blockquote>
<p><img src="/2019/05/01/SpringCloud个人总结/66009196970.png" alt="1566009196970"></p>
<blockquote>
<p>8003模块修改如下</p>
</blockquote>
<p><img src="/2019/05/01/SpringCloud个人总结/1566009240467.png" alt="1566009240467"></p>
<h3 id="7-3-4-启动EurekaServer集群和8001-8003服务模块"><a href="#7-3-4-启动EurekaServer集群和8001-8003服务模块" class="headerlink" title="7.3.4 启动EurekaServer集群和8001-8003服务模块"></a>7.3.4 启动EurekaServer集群和8001-8003服务模块</h3><p><img src="/2019/05/01/SpringCloud个人总结/6009501569.png" alt="1566009501569"></p>
<p>查看EurekaServer</p>
<p><a href="http://peer1:7001/" target="_blank" rel="external">http://peer1:7001/</a></p>
<p><img src="/2019/05/01/SpringCloud个人总结/6009599956.png" alt="1566009599956"></p>
<p><a href="http://peer2:7002/" target="_blank" rel="external">http://peer2:7002/</a></p>
<p><img src="/2019/05/01/SpringCloud个人总结/566009617535.png" alt="1566009617535"></p>
<p><a href="http://peer3:7003/" target="_blank" rel="external">http://peer3:7003/</a></p>
<p><img src="/2019/05/01/SpringCloud个人总结/C1566009632534.png" alt="1566009632534"></p>
<p>服务提供者集群创建成功</p>
<h3 id="7-3-5-自测启动的服务是否可用"><a href="#7-3-5-自测启动的服务是否可用" class="headerlink" title="7.3.5 自测启动的服务是否可用"></a>7.3.5 自测启动的服务是否可用</h3><p><img src="/2019/05/01/SpringCloud个人总结/1566009826135.png" alt="1566009826135"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/566009838479.png" alt="1566009838479"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566009865015.png" alt="1566009865015"></p>
<h3 id="7-3-6-修改服务消费者-采取负载均衡方式访问服务"><a href="#7-3-6-修改服务消费者-采取负载均衡方式访问服务" class="headerlink" title="7.3.6 修改服务消费者-采取负载均衡方式访问服务"></a>7.3.6 修改服务消费者-采取负载均衡方式访问服务</h3><p>也就是修改microservicecloud-consumer-person-80模块</p>
<p><strong>（1）修改pom文件添加Robbin依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- Ribbon相关 --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p><strong>（2）修改application.yml文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 80</div><div class="line">  </div><div class="line">#</div><div class="line">eureka:</div><div class="line">  client:</div><div class="line">    register-with-eureka: false</div><div class="line">    service-url:</div><div class="line">      defaultZone: http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/</div></pre></td></tr></table></figure>
<p>也就是修改服务注册中心地址为集群地址</p>
<p><strong>（3）修改ConfigBean配置类添加@LoadBalanced注解，获取rest服务的时候添加ribbon</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class ConfigBean</div><div class="line">&#123; </div><div class="line">	@Bean</div><div class="line">	@LoadBalanced</div><div class="line">	public RestTemplate getRestTemplate()</div><div class="line">	&#123;</div><div class="line">		return new RestTemplate();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>（4）主启动类ApplicationBootStart80添加@EnableEurekaClient</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableEurekaClient//这里建议使用@EnableDiscoveryClient 替换@EnableEurekaClient</div><div class="line">public class ApplicationBootStart80 &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart80.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-3-7-修改服务消费者"><a href="#7-3-7-修改服务消费者" class="headerlink" title="7.3.7 修改服务消费者"></a>7.3.7 修改服务消费者</h3><p>修改ConsumerController代码</p>
<p>修改内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//    private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;</div><div class="line">    private static final String REST_URL_PREFIX = &quot;http://MICROSERVICECLOUD-PERSON&quot;;</div></pre></td></tr></table></figure>
<p>把url更改为服务名称</p>
<p><strong>Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号</strong></p>
<h3 id="7-3-8-启动7001-7003-8001-8003，80"><a href="#7-3-8-启动7001-7003-8001-8003，80" class="headerlink" title="7.3.8 启动7001-7003,8001-8003，80"></a>7.3.8 启动7001-7003,8001-8003，80</h3><p><img src="/2019/05/01/SpringCloud个人总结/566010881201.png" alt="1566010881201"></p>
<p>启动完成后测试：</p>
<p>第一次访问</p>
<p><img src="/2019/05/01/SpringCloud个人总结/566011120741.png" alt="1566011120741"></p>
<p>第二次访问：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566011157293.png" alt="1566011157293"></p>
<p>第三次访问：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/6011173416.png" alt="1566011173416"></p>
<p>第四次访问：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/66011196418.png" alt="1566011196418"></p>
<p>我们注意db_source的值是变换的，说明负载均衡成功。但是当我们访问一轮后，发现他又从头开始：</p>
<p>test2-&gt;test3-&gt;test-&gt;test2-&gt;test3-&gt;test  说明Ribbon默认采用的是轮询的负载均衡策略</p>
<h3 id="7-3-9-总结"><a href="#7-3-9-总结" class="headerlink" title="7.3.9 总结"></a>7.3.9 总结</h3><p><img src="/2019/05/01/SpringCloud个人总结/1566011028903.png" alt="1566011028903"></p>
<p>Ribbon在工作时分成两步</p>
<blockquote>
<p>第一步先选择 EurekaServer ,它优先选择在同一个区域内负载较少的server. </p>
<p>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。</p>
</blockquote>
<p>其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。</p>
<p><strong>Ribbon其实就是一个软负载均衡的客户端组件， 他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</strong></p>
<h2 id="7-4-Ribbon负载均衡实现核心接口IRule"><a href="#7-4-Ribbon负载均衡实现核心接口IRule" class="headerlink" title="7.4 Ribbon负载均衡实现核心接口IRule"></a>7.4 Ribbon负载均衡实现核心接口IRule</h2><h3 id="7-4-1-源码跟踪"><a href="#7-4-1-源码跟踪" class="headerlink" title="7.4.1.源码跟踪"></a>7.4.1.源码跟踪</h3><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p>
<p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code></p>
<p>在consumer的ConsumerController如下代码打断点：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/566012847807.png" alt="1566012847807"></p>
<p>一路源码跟踪：RestTemplate.getForObject –&gt; RestTemplate.execute –&gt; RestTemplate.doExecute：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566013203247.png" alt="1566013203247"></p>
<p>点击进入AbstractClientHttpRequest.execute –&gt; AbstractBufferingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.execute:</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1528776489965.png" alt="1528776489965"></p>
<p>继续跟入：LoadBalancerInterceptor.intercept方法</p>
<p><img src="/2019/05/01/SpringCloud个人总结/66013476262.png" alt="1566013476262"></p>
<p>获取请求的服务名称，我们发现执行this.loadBalancer.execute()方法的loadBalancer是一个接口LoadBalancerClient，那么很明显执行execute（）方法的只能是LoadBalancerClient的实现类。</p>
<p>继续跟入execute方法发现执行该方法的类是：RibbonLoadBalancerClient负载均衡客户端类：</p>
<p>发现获取了8003端口的服务</p>
<p><img src="/2019/05/01/SpringCloud个人总结/566013958604.png" alt="1566013958604"></p>
<p>我们查看一下获取的负载均衡器的信息：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566014122746.png" alt="1566014122746"></p>
<h3 id="7-4-2-负载均衡策略"><a href="#7-4-2-负载均衡策略" class="headerlink" title="7.4.2.负载均衡策略"></a>7.4.2.负载均衡策略</h3><p>Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下：</p>
<p>编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，找到choose方法的接口方法，是这样介绍的：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/1525622320277.png" alt="1525622320277"></p>
<p>现在这个就是负载均衡获取实例的方法。</p>
<p>我们注入这个类的对象，然后对其测试：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/C1566014544201.png" alt="1566014544201"></p>
<p>测试内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span>(classes = ApplicationBootStart80.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalanceTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RibbonLoadBalancerClient client;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadBalance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            ServiceInstance instance = <span class="keyword">this</span>.client.choose(<span class="string">"MICROSERVICECLOUD-PERSON"</span>);</div><div class="line">            System.out.println(instance.getHost() + <span class="string">":"</span> +instance.getPort());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/C1566015460435.png" alt="1566015460435"></p>
<p>符合了我们的预期推测，确实是轮询方式。</p>
<p>我们是否可以修改负载均衡的策略呢？</p>
<p>继续跟踪源码，发现这么一段代码：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/1525622652849.png" alt="1525622652849"></p>
<p>我们看看这个rule是谁：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/1525622699666.png" alt="1525622699666"></p>
<p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/1525622754316.png" alt="1525622754316"></p>
<p>这不就是轮询的意思嘛。</p>
<p>我们注意到，这个类其实是实现了接口IRule的，查看一下：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/1525622817451.png" alt="1525622817451"></p>
<p>定义负载均衡的规则接口。</p>
<p>它有以下实现：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/1528782624098.png" alt="1528782624098"></p>
<h4 id="七大方法"><a href="#七大方法" class="headerlink" title="七大方法"></a>七大方法</h4><p>IRule是一个接口，七大方法是其实现类</p>
<ul>
<li>RoundRobinRule：轮询（默认方法）</li>
<li>RandomRule：随机</li>
<li>AvailabilityFilteringRule：先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务进行轮询</li>
<li>WeightedResponseTimeRule：根据平均响应时间计算服务的权重。统计信息不足时会按照轮询，统计信息足够会按照响应的时间选择服务</li>
<li>RetryRule：正常时按照轮询选择服务，若过程中有服务出现故障，在轮询一定次数后依然故障，则会跳过故障的服务继续轮询。</li>
<li>BestAvailableRule：先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li>
<li>ZoneAvoidanceRule：默认规则，符合判断server所在的区域的性能和server的可用性选择服务</li>
</ul>
<p><img src="/2019/05/01/SpringCloud个人总结/5C1566022083352.png" alt="1566022083352"></p>
<h3 id="7-4-3-负载均衡自定义"><a href="#7-4-3-负载均衡自定义" class="headerlink" title="7.4.3 负载均衡自定义"></a>7.4.3 负载均衡自定义</h3><h4 id="1-修改某个服务的负载均衡策略"><a href="#1-修改某个服务的负载均衡策略" class="headerlink" title="1.修改某个服务的负载均衡策略"></a>1.修改某个服务的负载均衡策略</h4><p>例如我们只想修改 MICROSERVICECLOUD-PERSON服务的负载均衡策略</p>
<p><strong>这里一共有两种方法实现一种是使用yml配置的方式声明-一种是使用注解的方式声明</strong></p>
<h5 id="第一种使用配置方式（建议使用）"><a href="#第一种使用配置方式（建议使用）" class="headerlink" title="第一种使用配置方式（建议使用）"></a>第一种使用配置方式（建议使用）</h5><p>（1）修改消费者端（microservicecloud-consumer-person-80）的application.yml配置文件</p>
<p>修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MICROSERVICECLOUD-PERSON: </div><div class="line">  ribbon:</div><div class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</div></pre></td></tr></table></figure>
<p>格式是：<code>{服务名称}.ribbon.NFLoadBalancerRuleClassName</code>，值就是IRule的实现类。</p>
<p>（2）运行上面的LoadBalanceTest</p>
<p><img src="/2019/05/01/SpringCloud个人总结/19186732.png" alt="1566019186732"></p>
<h5 id="第二种使用配置方式"><a href="#第二种使用配置方式" class="headerlink" title="第二种使用配置方式"></a>第二种使用配置方式</h5><p><strong>前提：注释掉第一种方式实现的 配置信息（不注释掉也可以，因为第一种方式跟第二种方式同时存在时，以第二种方式为主）</strong></p>
<p>（1）修改消费者端启动类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">#@EnableEurekaClient</div><div class="line">@EnableDiscoveryClient //服务发现</div><div class="line">@RibbonClient(name = &quot;MICROSERVICECLOUD-PERSON&quot;,configuration = OwnRule.class)</div><div class="line">public class ApplicationBootStart80 &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart80.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加一下注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@RibbonClient(name = &quot;MICROSERVICECLOUD-PERSON&quot;,configuration = OwnRule.class)</div></pre></td></tr></table></figure>
<p>（2）新建OwnRule自定义侧略类</p>
<p>首先新建包com.myrule</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class OwnRule &#123;</div><div class="line">    @Bean</div><div class="line">    public IRule getIuIRule()&#123;</div><div class="line">        System.out.println(&quot;进入了自定义负载均衡策略&quot;);</div><div class="line">        return new RandomRule();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2019/05/01/SpringCloud个人总结/5C1566019594262.png" alt="1566019594262"></p>
<p><strong>注意：</strong></p>
<blockquote>
<p>官方文档明确给出了警告：</p>
<p>这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，</p>
<p>否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说</p>
<p>我们达不到特殊化定制的目的了。</p>
<p>所以上面的OwnRule类是不在启动类同级包或者子包下的。</p>
</blockquote>
<p><img src="/2019/05/01/SpringCloud个人总结/5C1566019672480.png" alt="1566019672480"></p>
<p>所以我们也可以利用这个特性，修改全局的所有服务的获取策略为某个策略</p>
<p>（3）运行上面的LoadBalanceTest</p>
<p><img src="/2019/05/01/SpringCloud个人总结/19186732.png" alt="1566019186732"></p>
<h4 id="2-修改全局的服务访问策略（替换默认的轮询策略）"><a href="#2-修改全局的服务访问策略（替换默认的轮询策略）" class="headerlink" title="2. 修改全局的服务访问策略（替换默认的轮询策略）"></a>2. 修改全局的服务访问策略（替换默认的轮询策略）</h4><p>很简单，直接在IOC容器注入想要替换成的负载均衡策略即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class ConfigBean</div><div class="line">applicationContext.xml</div><div class="line">&#123; </div><div class="line">	@Bean</div><div class="line">	@LoadBalanced</div><div class="line">	public RestTemplate getRestTemplate()</div><div class="line">	&#123;</div><div class="line">		return new RestTemplate();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Bean</div><div class="line">	public IRule getIuIRule()&#123;</div><div class="line">		return new RandomRule();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-自定义负载均衡策略"><a href="#3-自定义负载均衡策略" class="headerlink" title="3.自定义负载均衡策略"></a>3.自定义负载均衡策略</h4><p>上上面的两个章节实际上使用的都是Ribbon提供的负载均衡策略，所以接下来我们要实现一个负载均衡策略</p>
<blockquote>
<p>提出需求：</p>
</blockquote>
<p><strong>问题：修改MICROSERVICECLOUD-PERSON服务的负载均衡策略：依旧使用轮询策略，但是加上新需求，每个服务器（现在有三台8001-8003）要求被调用5次。也即 以前是每台机器一次，现在是每台机器5次</strong></p>
<p>在实现之前拜读一下官方的RandomRule 源代码，然后再修改出符合我们需求的策略类</p>
<p><a href="https://github.com/Netflix/ribbon/blob/master/ribbon-loadbalancer/src/main/java/com/netflix/loadbalancer/RandomRule.java" target="_blank" rel="external">https://github.com/Netflix/ribbon/blob/master/ribbon-loadbalancer/src/main/java/com/netflix/loadbalancer/RandomRule.java</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class RandomRule extends AbstractLoadBalancerRule &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line"></div><div class="line">     * Randomly choose from all living servers</div><div class="line"></div><div class="line">     */</div><div class="line"></div><div class="line">    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE&quot;)</div><div class="line"></div><div class="line">    public Server choose(ILoadBalancer lb, Object key) &#123;</div><div class="line">        if (lb == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Server server = null;//需要返回的服务</div><div class="line"></div><div class="line">        while (server == null) &#123;//使用while循环知道获取服务</div><div class="line"></div><div class="line">            if (Thread.interrupted()) &#123;//如果当前线程已经中断，那么直接返回null</div><div class="line"></div><div class="line">                return null;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            List&lt;Server&gt; upList = lb.getReachableServers();//获取所有可达的服务列表</div><div class="line">            List&lt;Server&gt; allList = lb.getAllServers();//获取所有服务列表</div><div class="line"></div><div class="line">            int serverCount = allList.size();//得到服务列表里服务实例的数量</div><div class="line"></div><div class="line">            if (serverCount == 0) &#123;</div><div class="line"></div><div class="line">                /*</div><div class="line"></div><div class="line">                 * No servers. End regardless of pass, because subsequent passes</div><div class="line"></div><div class="line">                 * only get more restrictive.</div><div class="line"></div><div class="line">                 */</div><div class="line"></div><div class="line">                return null;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            int index = chooseRandomInt(serverCount);//根据服务数量所及获取服务下标</div><div class="line">           等同于Random.rand.nextInt(serverCount);</div><div class="line"></div><div class="line">            server = upList.get(index);//根据随机获取到的下标，从可用服务列表实例中获取服务</div><div class="line">            if (server == null) &#123;//获取不到时，暂停当前正在执行的线程对象(及放弃当前拥有的cup资源),并执行其他线程</div><div class="line">            //然后继续while循环获取</div><div class="line"></div><div class="line">                /*</div><div class="line"></div><div class="line">                 * The only time this should happen is if the server list were</div><div class="line"></div><div class="line">                 * somehow trimmed. This is a transient condition. Retry after</div><div class="line"></div><div class="line">                 * yielding.</div><div class="line"></div><div class="line">                 */</div><div class="line"></div><div class="line">                Thread.yield();</div><div class="line"></div><div class="line">                continue;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (server.isAlive()) &#123;</div><div class="line"></div><div class="line">                return (server);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Shouldn&apos;t actually happen.. but must be transient or a bug.</div><div class="line"></div><div class="line">            server = null;</div><div class="line">            Thread.yield();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return server;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    protected int chooseRandomInt(int serverCount) &#123;</div><div class="line"></div><div class="line">        return ThreadLocalRandom.current().nextInt(serverCount);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line"></div><div class="line">	public Server choose(Object key) &#123;</div><div class="line"></div><div class="line">		return choose(getLoadBalancer(), key);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码其实很简单</p>
<h5 id="（1）新建RandomRuleModify类"><a href="#（1）新建RandomRuleModify类" class="headerlink" title="（1）新建RandomRuleModify类"></a>（1）新建RandomRuleModify类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.myrule;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">        import com.netflix.client.config.IClientConfig;</div><div class="line">        import com.netflix.loadbalancer.AbstractLoadBalancerRule;</div><div class="line">        import com.netflix.loadbalancer.ILoadBalancer;</div><div class="line">        import com.netflix.loadbalancer.Server;</div><div class="line"></div><div class="line">public class RandomRuleModify extends AbstractLoadBalancerRule</div><div class="line">&#123;</div><div class="line"></div><div class="line">    // total = 0 // 当total==5以后，我们指针才能往下走，</div><div class="line">    // index = 0 // 当前对外提供服务的服务器地址，</div><div class="line">    // total需要重新置为零，但是已经达到过一个5次，我们的index = 1</div><div class="line">    // 分析：我们5次，但是微服务只有8001 8002 8003 三台，OK？</div><div class="line">    //</div><div class="line"></div><div class="line"></div><div class="line">    private int total = 0; 			// 总共被调用的次数，目前要求每台被调用5次</div><div class="line">    private int currentIndex = 0;	// 当前提供服务的机器号</div><div class="line"></div><div class="line">    public Server choose(ILoadBalancer lb, Object key)</div><div class="line">    &#123;</div><div class="line">        if (lb == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Server server = null;</div><div class="line"></div><div class="line">        while (server == null) &#123;</div><div class="line">            if (Thread.interrupted()) &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            List&lt;Server&gt; upList = lb.getReachableServers();</div><div class="line">            List&lt;Server&gt; allList = lb.getAllServers();</div><div class="line"></div><div class="line">            int serverCount = allList.size();</div><div class="line">            if (serverCount == 0) &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if(total &lt; 5)</div><div class="line">            &#123;</div><div class="line">                server = upList.get(currentIndex);</div><div class="line">                total++;</div><div class="line">            &#125;else &#123;</div><div class="line">                total = 0;</div><div class="line">                currentIndex++;</div><div class="line">                if(currentIndex &gt;= upList.size())</div><div class="line">                &#123;</div><div class="line">                    currentIndex = 0;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (server == null) &#123;</div><div class="line">                Thread.yield();</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (server.isAlive()) &#123;</div><div class="line">                return (server);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Shouldn&apos;t actually happen.. but must be transient or a bug.</div><div class="line">            server = null;</div><div class="line">            Thread.yield();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return server;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Server choose(Object key)</div><div class="line">    &#123;</div><div class="line">        return choose(getLoadBalancer(), key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void initWithNiwsConfig(IClientConfig clientConfig)</div><div class="line">    &#123;</div><div class="line">        // TODO Auto-generated method stub</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这个类不能够放在启动类的同级或者子包下，否则将被设置为全局的负载均衡策略，起不到为MICROSERVICECLOUD-PERSON服务定制策略的作用</strong></p>
<p><img src="/2019/05/01/SpringCloud个人总结/5C1566021323120.png" alt="1566021323120"></p>
<h5 id="（2）OwnRule返回我们实现的RandomRuleModify"><a href="#（2）OwnRule返回我们实现的RandomRuleModify" class="headerlink" title="（2）OwnRule返回我们实现的RandomRuleModify"></a>（2）OwnRule返回我们实现的RandomRuleModify</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class OwnRule &#123;</div><div class="line">    @Bean</div><div class="line">    public IRule getIuIRule()&#123;</div><div class="line">        System.out.println(&quot;进入了自定义负载均衡策略&quot;);</div><div class="line">        return new RandomRuleModify();//RandomRule();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="（3）修改启动类"><a href="#（3）修改启动类" class="headerlink" title="（3）修改启动类"></a>（3）修改启动类</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">//@EnableEurekaClient</div><div class="line">@EnableDiscoveryClient //服务发现</div><div class="line">@RibbonClient(name = &quot;MICROSERVICECLOUD-PERSON&quot;,configuration = OwnRule.class)</div><div class="line">public class ApplicationBootStart80 &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart80.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="（4）运行测试类LoadBalanceTest"><a href="#（4）运行测试类LoadBalanceTest" class="headerlink" title="（4）运行测试类LoadBalanceTest"></a>（4）运行测试类LoadBalanceTest</h5><p><img src="/2019/05/01/SpringCloud个人总结/5C1566021621272.png" alt="1566021621272"></p>
<p>轮询的同时每个服务器调用五次！！！</p>
<h5 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h5><p>我们也可以使用配置类的方式为某个服务配置特定的负载均衡策略实现类（参考7.4.3.1 章节的第一种配置方式），这样就可以省略上面的第二和第三步骤</p>
<p>通过配置的方式更加，灵活</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566021993675.png" alt="1566021993675"></p>
<p>然后运行测试类LoadBalanceTest，结果一模一样。</p>
<h1 id="八-Feign负载均衡"><a href="#八-Feign负载均衡" class="headerlink" title="八. Feign负载均衡"></a>八. <strong>Feign负载均衡</strong></h1><h2 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1.简介"></a>8.1.简介</h2><p>Feign出现的原因是什么，既然他也是提供负载均衡的功能，那么他跟Ribbon有什么区别？</p>
<blockquote>
<p>项目主页：</p>
</blockquote>
<p><a href="https://github.com/OpenFeign/feign" target="_blank" rel="external">https://github.com/OpenFeign/feign</a></p>
<blockquote>
<p>官网解释：</p>
</blockquote>
<p><a href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign" target="_blank" rel="external">http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign</a></p>
<blockquote>
<p> Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单, <strong>它的使用方法是定义一个接口，然后在上面添加注解</strong>，同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign<strong>可以与Eureka和Ribbon组合使用以支持负载均衡</strong>。</p>
</blockquote>
<p> <img src="/2019/05/01/SpringCloud个人总结/566106445678.png" alt="1566106445678"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/5C1566106480369.png" alt="1566106480369"></p>
<p>Feign的出现的目的是：为了迎合我们平时面向接口编程和调用的习惯。例如我们在Controller通过注入Service层的接口调用相关的业务。但是在上面的Ribbon例子中我们是通过RestTemplate和URL的方式调用某个服务：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/566106719992.png" alt="1566106719992"></p>
<p>Feign的实现其实也很简单：<strong>只需要创建一个接口，然后在上面添加注解即可。</strong></p>
<p>有道词典的英文解释：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image0ee02.png" alt="img"></p>
<p>为什么叫伪装？</p>
<p><strong>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。</strong></p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image0ee04.png" alt="img"></p>
<p><strong>总的来说：Feign通过封装Ribbon实现了我们常用的面向接口编程</strong></p>
<h2 id="8-2-实现Feign"><a href="#8-2-实现Feign" class="headerlink" title="8.2 实现Feign"></a>8.2 实现Feign</h2><p>其实就是复制microservicecloud-consumer-person-80工程代码，在做一些修改。</p>
<h3 id="（1）根据父工程新建microservicecloud-consumer-person-80-feign模块"><a href="#（1）根据父工程新建microservicecloud-consumer-person-80-feign模块" class="headerlink" title="（1）根据父工程新建microservicecloud-consumer-person-80-feign模块"></a>（1）根据父工程新建microservicecloud-consumer-person-80-feign模块</h3><h3 id="（2）复制80模块代码到80-feign模块"><a href="#（2）复制80模块代码到80-feign模块" class="headerlink" title="（2）复制80模块代码到80-feign模块"></a>（2）复制80模块代码到80-feign模块</h3><p><img src="/2019/05/01/SpringCloud个人总结/C1566107268418.png" alt="1566107268418"></p>
<p>修改启动类的名字。</p>
<h3 id="（3）修改80-feign模块的pom文件，添加Feign依赖"><a href="#（3）修改80-feign模块的pom文件，添加Feign依赖" class="headerlink" title="（3）修改80-feign模块的pom文件，添加Feign依赖"></a>（3）修改80-feign模块的pom文件，添加Feign依赖</h3><p>添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">       &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">       &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</div><div class="line">   &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="（4）修改api公共模块"><a href="#（4）修改api公共模块" class="headerlink" title="（4）修改api公共模块"></a>（4）修改api公共模块</h3><p><strong>也就是修改microservicecloud-api，因为我们知道我们抽象出来的服务，有可能其他模块也会调用，不仅仅是80-feign模块。所以公共的东西我们都放在api模块</strong></p>
<p><strong>1.修改pom文件，添加feign依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">     &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>2.<strong>新建PersonClientService接口并新增注解@FeignClient</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@FeignClient(value = &quot;MICROSERVICECLOUD-PERSON&quot;)</div><div class="line">public interface PersonClientService</div><div class="line">&#123;</div><div class="line">   @RequestMapping(value = &quot;/person/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</div><div class="line">   public Person get(@PathVariable(&quot;id&quot;) long id);</div><div class="line"></div><div class="line">   @RequestMapping(value = &quot;/person/list&quot;, method = RequestMethod.GET)</div><div class="line">   public List&lt;Person&gt; list();</div><div class="line"></div><div class="line">   @RequestMapping(value = &quot;/person/add&quot;, method = RequestMethod.POST)</div><div class="line">   public boolean add(Person person);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>•               首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像</strong></p>
<p><strong>•               @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称</strong></p>
<p><strong>•               接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果</strong></p>
</blockquote>
<h3 id="（5）feign工程修改Controller，添加上一步新建的PersonClientService接口"><a href="#（5）feign工程修改Controller，添加上一步新建的PersonClientService接口" class="headerlink" title="（5）feign工程修改Controller，添加上一步新建的PersonClientService接口"></a>（5）<strong>feign工程修改Controller，添加上一步新建的PersonClientService接口</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@RestController</div><div class="line">public class ConsumerController &#123;</div><div class="line"></div><div class="line">//    @Autowired</div><div class="line">//    private RestTemplate restTemplate;</div><div class="line"></div><div class="line">//    private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;</div><div class="line">//    private static final String REST_URL_PREFIX = &quot;http://MICROSERVICECLOUD-PERSON&quot;;</div><div class="line">@Autowired</div><div class="line">private PersonClientService personClientService;</div><div class="line">    @RequestMapping(value = &quot;/consumer/person/add&quot;)</div><div class="line">    public boolean add(Person person)</div><div class="line">    &#123;</div><div class="line">//        return restTemplate.postForObject(REST_URL_PREFIX + &quot;/person/add&quot;, person, Boolean.class);</div><div class="line">        return personClientService.add(person);</div><div class="line">    &#125;</div><div class="line">    @RequestMapping(value = &quot;/consumer/person/list&quot;)</div><div class="line">    public List&lt;Person&gt; list()</div><div class="line">    &#123;</div><div class="line">//        return restTemplate.getForObject(REST_URL_PREFIX + &quot;/person/list&quot;, List.class);</div><div class="line">        return personClientService.list();</div><div class="line">    &#125;</div><div class="line">        @RequestMapping(value = &quot;/consumer/person/get/&#123;id&#125;&quot;)</div><div class="line">    public Person get(@PathVariable(&quot;id&quot;) Long id)</div><div class="line">    &#123;</div><div class="line">        return this.personClientService.get(id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到我们注释掉了以往的RestTemplate+URL请求服务的方式，通过注入接口调用的方式，实现了面向借口编程。</p>
<h3 id="（6）feign工程修改主启动类"><a href="#（6）feign工程修改主启动类" class="headerlink" title="（6）feign工程修改主启动类"></a>（6）<strong>feign工程修改主启动类</strong></h3><p>添加@EnableFeignClients // 开启feign客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableDiscoveryClient //服务发现</div><div class="line">@EnableFeignClients // 开启feign客户端</div><div class="line">public class ApplicationBootStart80feign &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart80feign.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="（7）启动EurekaServer7001-7003和服务提供集群8001-8003，启动feign工程进行测试"><a href="#（7）启动EurekaServer7001-7003和服务提供集群8001-8003，启动feign工程进行测试" class="headerlink" title="（7）启动EurekaServer7001-7003和服务提供集群8001-8003，启动feign工程进行测试"></a><strong>（7）启动EurekaServer7001-7003和服务提供集群8001-8003，启动feign工程进行测试</strong></h3><p><img src="/2019/05/01/SpringCloud个人总结/566108827974.png" alt="1566108827974"></p>
<p>请求</p>
<p><img src="/2019/05/01/SpringCloud个人总结/C1566108849361.png" alt="1566108849361"></p>
<p><strong>默认使用轮询的负载均衡方式</strong></p>
<h2 id="8-3-总结"><a href="#8-3-总结" class="headerlink" title="8.3 总结"></a>8.3 总结</h2><p> Feign通过接口的方法调用Rest服务（之前是Ribbon+RestTemplate） ，</p>
<p>该请求发送给Eureka服务器（<a href="http://MICROSERVICECLOUD-PERSON/person/list）" target="_blank" rel="external">http://MICROSERVICECLOUD-PERSON/person/list）</a>,</p>
<p>通过Feign直接找到服务接口，由于在进行服务调用的时候融合了Ribbon技术，所以也支持负载均衡作用。</p>
<p>也就是说Feign只是封装了Ribbon，改造成了我们习惯的面向接口编程的方式。</p>
<p><strong>自定义负载均衡的方式跟之前使用Ribbon 的一样，也就是支持注解和配置两种方式实现某个服务或者全局服务的负载均衡策略自定义</strong></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableDiscoveryClient //服务发现</div><div class="line">@EnableFeignClients // 开启feign客户端</div><div class="line">@RibbonClient(name = &quot;MICROSERVICECLOUD-PERSON&quot;,configuration = OwnRule.class)</div><div class="line">public class ApplicationBootStart80feign &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart80feign.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="8-4-请求压缩-了解"><a href="#8-4-请求压缩-了解" class="headerlink" title="8.4.请求压缩(了解)"></a>8.4.请求压缩(了解)</h2><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：</p>
<p>feign:<br>   compression:<br>     request:<br>       enabled: true # 开启请求压缩<br>     response:<br>       enabled: true # 开启响应压缩</p>
<p>同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p>
<p>feign:<br>   compression:<br>     request:<br>       enabled: true # 开启请求压缩<br>       mime-types: text/html,application/xml,application/json # 设置压缩的数据类型<br>       min-request-size: 2048 # 设置触发压缩的大小下限</p>
<p>注：上面的数据类型、压缩大小下限均为默认值。</p>
<h2 id="8-5-日志级别-了解"><a href="#8-5-日志级别-了解" class="headerlink" title="8.5.日志级别(了解)"></a>8.5.日志级别(了解)</h2><p>前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p>
<p>1）设置com.kingge包下的日志级别都为debug</p>
<p>logging:<br>   level:<br>     com.kingge: debug</p>
<p>2）新建FeignLogConfiguration配置类，定义日志级别</p>
<p>内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class FeignLogConfiguration &#123;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    Logger.Level feignLoggerLevel()&#123;</div><div class="line">        return Logger.Level.FULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里指定的Level级别是FULL，Feign支持4种级别：</p>
<p>•               NONE：不记录任何日志信息，这是默认值。</p>
<p>•               BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</p>
<p>•               HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</p>
<p>•               FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</p>
<p>3）在FeignClient中指定配置类：</p>
<p>@FeignClient(value = “MICROSERVICECLOUD-PERSON” configuration = FeignLogConfiguration.class)<br> public interface UserFeignClient {<br>     @GetMapping(“/user/{id}”)<br>     User queryUserById(@PathVariable(“id”) Long id);<br> }</p>
<p>4）重启项目，即可看到每次访问的日志：</p>
<h2 id="8-6-Hystrix支持"><a href="#8-6-Hystrix支持" class="headerlink" title="8.6.Hystrix支持"></a>8.6.Hystrix支持</h2><p>参加下面服务降级的案例</p>
<h1 id="九-Hystrix断路器"><a href="#九-Hystrix断路器" class="headerlink" title="九.Hystrix断路器"></a>九.Hystrix断路器</h1><pre><code>**首先我们来解决第三问题，服务的容灾处理**
</code></pre><p><strong>跟Ribbon和Feign是客户端技术不同的是Hystrix是服务端的技术，也就是他是作用在服务提供端</strong></p>
<h2 id="1-分布式系统面临的问题"><a href="#1-分布式系统面临的问题" class="headerlink" title="1.分布式系统面临的问题"></a>1.<strong>分布式系统面临的问题</strong></h2><p><strong>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败</strong></p>
<p><strong>1.雪崩问题</strong></p>
<p>微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/646178ttttt01.png" alt="标题: fig:"></p>
<p>如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务（这个就是所谓的<strong>扇出</strong>）。</p>
<p>如果此时，某个服务出现异常：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/64rrrttt01.png" alt="标题: fig:"></p>
<p>例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/565964513rrr626.png" alt="标题: fig:"></p>
<p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成<strong>雪崩效应</strong>，<strong>所以我们需要阻断故障的传播，这个就是断路器</strong>。</p>
<p>这就好比，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。 此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。 </p>
<p>备注：一般情况对于服务依赖的保护主要有3中解决方案：</p>
<blockquote>
<p><strong>（1）熔断模式：这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</strong></p>
<p><strong>（2）（降级）隔离模式：这种模式就像对系统请求按类型划分成一个个小岛的一样，当某个小岛被火少光了，不会影响到其他的小岛。例如可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。这种模式使用场景非常多，例如将一个服务拆开，对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。</strong></p>
<p><strong>（3）限流模式：上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。</strong></p>
</blockquote>
<p> springcloud的Hystrix就是提供了前两种解决方式：</p>
<p><strong>Hystix解决雪崩问题的手段有两个：</strong></p>
<p><strong>•               线程隔离（降级）</strong></p>
<p><strong>•               服务熔断</strong></p>
<h2 id="2-Hystrix简介"><a href="#2-Hystrix简介" class="headerlink" title="2.Hystrix简介"></a>2.Hystrix简介</h2><pre><code>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。

 Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。

“断路器”本身是一种开关装置，当某个服务单元发生故障之后，**通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack）（解决思路）** ，**而不是长时间的等待或者抛出调用方无法处理的异常** ，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。
</code></pre><blockquote>
<p> 官网资料 </p>
</blockquote>
<p><a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use" target="_blank" rel="external">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></p>
<h2 id="3-服务端的服务熔断"><a href="#3-服务端的服务熔断" class="headerlink" title="3.服务端的服务熔断"></a>3.服务端的服务熔断</h2><p><strong>熔断机制是应对雪崩效应的一种微服务链路保护机制。他是在服务端实现。</strong></p>
<pre><code>**当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回&quot;错误&quot;的响应信息**。 当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。**熔断机制的注解是@HystrixCommand。**
</code></pre><h3 id="3-1-熔断原理"><a href="#3-1-熔断原理" class="headerlink" title="3.1 熔断原理"></a>3.1 熔断原理</h3><p>熔断器，也叫断路器，其英文单词为：Circuit Breaker </p>
<p><img src="/2019/05/01/SpringCloud个人总结/6009599rrr956.png" alt="img"></p>
<p>熔断状态机3个状态：</p>
<p>•               Closed：关闭状态，所有请求都正常访问。</p>
<p>•               Open：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。</p>
<p>•               Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时</p>
<pre><code>当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回&quot;错误&quot;的响应信息。 当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是@HystrixCommand。
</code></pre><h3 id="3-2-案例演示"><a href="#3-2-案例演示" class="headerlink" title="3.2 案例演示"></a>3.2 案例演示</h3><h4 id="3-2-1-参考microservicecloud-provider-person-8001-新建microservicecloud-provider-person-hystrix-8001"><a href="#3-2-1-参考microservicecloud-provider-person-8001-新建microservicecloud-provider-person-hystrix-8001" class="headerlink" title="3.2.1 参考microservicecloud-provider-person-8001 新建microservicecloud-provider-person-hystrix-8001"></a>3.2.1 参考microservicecloud-provider-person-8001 新建microservicecloud-provider-person-hystrix-8001</h4><p>赋值pom文件和代码已经application.yml文件</p>
<h4 id="3-2-2-修改新建hystrix-8001模块的pom文件和启动类"><a href="#3-2-2-修改新建hystrix-8001模块的pom文件和启动类" class="headerlink" title="3.2.2 修改新建hystrix-8001模块的pom文件和启动类"></a>3.2.2 修改新建hystrix-8001模块的pom文件和启动类</h4><p>（1）pom文件添加hystrix依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!--  hystrix --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>（2）修改启动类名称并添加<strong>@EnableCircuitBreaker注解</strong>//对hystrixR熔断机制的支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">//@EnableEurekaClient</div><div class="line">@EnableDiscoveryClient //服务发现</div><div class="line">@EnableCircuitBreaker//对hystrixR熔断机制的支持</div><div class="line">public class ApplicationBootStart8001hystrix &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart8001hystrix.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-2-3-修改配置文件"><a href="#3-2-3-修改配置文件" class="headerlink" title="3.2.3 修改配置文件"></a>3.2.3 修改配置文件</h4><p>其实就是修改服务实例名字，避免跟8001模块冲突</p>
<p><img src="/2019/05/01/SpringCloud个人总结/5C1566145616539.png" alt="1566145616539"></p>
<h4 id="3-2-4-修改PersonController，添加熔断处理"><a href="#3-2-4-修改PersonController，添加熔断处理" class="headerlink" title="3.2.4 修改PersonController，添加熔断处理"></a>3.2.4 修改PersonController，添加熔断处理</h4><p>在某个方法使用<strong>@HystrixCommand</strong>注解，模拟报异常后如何处理</p>
<p><strong>一旦调用服务方法失败并抛出了错误信息/请求超时后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法</strong> </p>
<p>下面以get方法为例，代码内容（下面模拟的是出现异常）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@RestController</div><div class="line">public class PersonController</div><div class="line">&#123;</div><div class="line">   @Autowired</div><div class="line">   private PersonService service;</div><div class="line"></div><div class="line">//全部使用restful风格，返回json字符串</div><div class="line">   @RequestMapping(value = &quot;/person/add&quot;, method = RequestMethod.POST)</div><div class="line">   public boolean add(@RequestBody Person person)</div><div class="line">   &#123;</div><div class="line">      return service.add(person);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @RequestMapping(value = &quot;/person/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</div><div class="line">   @HystrixCommand(fallbackMethod = &quot;processHystrix_Get&quot;) //关键代码</div><div class="line">   public Person get(@PathVariable(&quot;id&quot;) Long id)</div><div class="line">   &#123;</div><div class="line">      Person person = service.get(id);</div><div class="line">      if(null == person)</div><div class="line">      &#123;</div><div class="line">         throw new RuntimeException(&quot;该ID：&quot;+id+&quot;没有没有对应的信息&quot;);</div><div class="line">      &#125;</div><div class="line">      return person;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   public Person processHystrix_Get(@PathVariable(&quot;id&quot;) Long id)//关键代码</div><div class="line">   &#123;</div><div class="line">      Person person =    new Person();</div><div class="line">      person.setDeptno(id);person.setDname(&quot;该ID：&quot;+id+&quot;没有没有对应的信息,null--@HystrixCommand&quot;);</div><div class="line">      person.setDb_source(&quot;no this database in MySQL&quot;);</div><div class="line">      return person;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @RequestMapping(value = &quot;/person/list&quot;, method = RequestMethod.GET)</div><div class="line">   public List&lt;Person&gt; list()</div><div class="line">   &#123;</div><div class="line">      return service.list();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，配置的fallbackMethod方法必须与被@HystrixCommand注解的方法有相同的入参和返回值</p>
<h4 id="3-2-5-启动EurekaServer集群和8001-hystrix模块、80模块"><a href="#3-2-5-启动EurekaServer集群和8001-hystrix模块、80模块" class="headerlink" title="3.2.5 启动EurekaServer集群和8001-hystrix模块、80模块"></a>3.2.5 启动EurekaServer集群和8001-hystrix模块、80模块</h4><p><img src="/2019/05/01/SpringCloud个人总结/5C1566146282120.png" alt="1566146282120"></p>
<p>消费者访问</p>
<p><a href="http://localhost/consumer/person/get/5" target="_blank" rel="external">http://localhost/consumer/person/get/5</a></p>
<p>输出：{“deptno”:5,”dname”:”开发部”,”db_source”:”test”}</p>
<p>我们假设获取某个不存在的用户</p>
<p><a href="http://localhost/consumer/person/get/55" target="_blank" rel="external">http://localhost/consumer/person/get/55</a></p>
<p>输出：{“deptno”:55,”dname”:”该ID：55没有没有对应的信息,null–@HystrixCommand”,”db_source”:”no this database in MySQL”}</p>
<h2 id="4-客户端的服务降级"><a href="#4-客户端的服务降级" class="headerlink" title="4.客户端的服务降级"></a>4.客户端的服务降级</h2><pre><code>既然有了服务熔断，为什么还需要服务降级？
</code></pre><p>   <strong>服务降级处理是在客户端实现完成的,与服务端没有关系，客户端自带一个异常处理机制。上面的服务熔断是在服务端实现</strong></p>
<p>  <strong>客户端的服务降级，能够快速的响应用户的请求，当服务不可达，那么立即返回定制的错误信息。</strong> </p>
<p> 整体资源快不够了,忍痛将某些服务先关掉,待渡过难关,再开启回来</p>
<p>优先保证核心服务，而非核心服务不可用或弱可用。</p>
<p>用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息 。</p>
<p><strong>服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。</strong></p>
<p><strong>而且上面的服务端熔断案例存在一些缺点：控制层每实现一个方法，就要实现对应的fallBack方法处理相关的异常逻辑，那么代码量会越来越大，而且跟业务逻辑偶合在一起。所以我们需要解耦，我们把熔断的的fallback方法都放在一个类中，去除控制层的@HystrixCommand，这样能够保证业务的纯粹。</strong></p>
<h3 id="4-1-案例演示"><a href="#4-1-案例演示" class="headerlink" title="4.1 案例演示"></a>4.1 案例演示</h3><h4 id="4-1-1-修改microservicecloud-api的工程-根据已有的PersonClientService接口新建一个实现类-FallbackFactory接口的类PersonClientServiceFallbackFactory"><a href="#4-1-1-修改microservicecloud-api的工程-根据已有的PersonClientService接口新建一个实现类-FallbackFactory接口的类PersonClientServiceFallbackFactory" class="headerlink" title="4.1.1 修改microservicecloud-api的工程, 根据已有的PersonClientService接口新建一个实现类 FallbackFactory接口的类PersonClientServiceFallbackFactory"></a>4.1.1 修改microservicecloud-api的工程, 根据已有的PersonClientService接口新建一个实现类 FallbackFactory接口的类PersonClientServiceFallbackFactory</h4><p>​    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Component//不要忘记添加</div><div class="line">public class PersonClientServiceFallbackFactory implements FallbackFactory&lt;PersonClientService&gt; &#123;</div><div class="line">    @Override</div><div class="line">    public PersonClientService create(Throwable throwable) &#123;</div><div class="line">        return new PersonClientService() &#123;</div><div class="line">            @Override</div><div class="line">            public Person get(long id) &#123;</div><div class="line">                Person person = 	new Person();</div><div class="line">                person.setDeptno(id);person.setDname(&quot;该ID&quot;+id+&quot;没有对应的信息,Consumer客户端提供的降级信息,此服务Provider已经关闭&quot;);</div><div class="line">                person.setDb_source(&quot;no this database in MySQL&quot;);</div><div class="line">                return person;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public List&lt;Person&gt; list() &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public boolean add(Person person) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    </p>
<h4 id="4-1-2-修改microservicecloud-api工程-PersonClientService接口在注解-FeignCLient中添加fallbackFactory属性值"><a href="#4-1-2-修改microservicecloud-api工程-PersonClientService接口在注解-FeignCLient中添加fallbackFactory属性值" class="headerlink" title="4.1.2  修改microservicecloud-api工程,PersonClientService接口在注解@FeignCLient中添加fallbackFactory属性值"></a>4.1.2  修改microservicecloud-api工程,PersonClientService接口在注解@FeignCLient中添加fallbackFactory属性值</h4><p>​    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@FeignClient(value = &quot;MICROSERVICECLOUD-PERSON&quot;,fallbackFactory = PersonClientServiceFallbackFactory.class)</div><div class="line">public interface PersonClientService</div><div class="line">&#123;</div><div class="line">	@RequestMapping(value = &quot;/person/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</div><div class="line">	public Person get(@PathVariable(&quot;id&quot;) long id);</div><div class="line"></div><div class="line">	@RequestMapping(value = &quot;/person/list&quot;, method = RequestMethod.GET)</div><div class="line">	public List&lt;Person&gt; list();</div><div class="line"></div><div class="line">	@RequestMapping(value = &quot;/person/add&quot;, method = RequestMethod.POST)</div><div class="line">	public boolean add(Person person);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    </p>
<h4 id="4-1-3-修改80-feign消费者端配置文件，开启服务熔断"><a href="#4-1-3-修改80-feign消费者端配置文件，开启服务熔断" class="headerlink" title="4.1.3 修改80-feign消费者端配置文件，开启服务熔断"></a>4.1.3 修改80-feign消费者端配置文件，开启服务熔断</h4><pre><code>microservicecloud-consumer-person-80-feign工程修改YML 
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">feign:</div><div class="line">  hystrix:</div><div class="line">    enabled: true</div></pre></td></tr></table></figure>
<h4 id="4-1-4-测试"><a href="#4-1-4-测试" class="headerlink" title="4.1.4 测试"></a>4.1.4 测试</h4><pre><code>启动3个eureka先启动和微服务microservicecloud-provider-person-8001启动                                    microservicecloud-consumer-person-80-feign启动      
</code></pre><p> 正常访问测试      <a href="http://localhost/consumer/dept/get/5" target="_blank" rel="external">http://localhost/consumer/dept/get/5</a>        </p>
<p>  输出：{“deptno”:5,”dname”:”hr”,”db_source”:”test”}</p>
<p>​                  </p>
<p> 故意关闭微服务microservicecloud-provider-person-8001                                   </p>
<p> 访问测试     <a href="http://localhost/consumer/dept/get/5" target="_blank" rel="external">http://localhost/consumer/dept/get/5</a></p>
<p>输出：”deptno”:5,”dname”:”该ID5没有对应的信息,Consumer客户端提供的降级信息,此服务Provider已经关闭”,”db_source”:”no this database in MySQL”}</p>
<p>成功！！！</p>
<pre><code>**此时服务端provider已经down了,但是我们做了服务降级处理,让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器**
</code></pre><p><strong>也就是说，如果服务端能够正常调用那么就返回值，如果不能够调用那么就返回由fallbackFactory定义的值</strong></p>
<h2 id="5-服务监控HystrixDashboard"><a href="#5-服务监控HystrixDashboard" class="headerlink" title="5. 服务监控HystrixDashboard"></a>5. 服务监控HystrixDashboard</h2><blockquote>
<pre><code>除了隔离依赖服务的调用以外,Hystrix还提供了准实时的调用监控(Hystrix      Dashboard),Hystrix      会持续地**记录所有通过Hystrix发起的请求的执行信息**,并以统计报表和图形的形式展示给用户,包括每秒执行多少请求多少成功,多少失败等.Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控.Spring Cloud也提供了Hystrix Dashboard的整合.对监控内容转化成可视化界面.     
</code></pre></blockquote>
<p><strong>也就是说，服务端必须是集成了Hystrix组件，才能够被监控，也即是：启动类添加@EnableCircuitBreaker//对hystrixR熔断机制的支持。例如我们的服务8002和8003是监控不到的</strong></p>
<pre><code>记下来看案例实现
</code></pre><h3 id="5-1-案例实现"><a href="#5-1-案例实现" class="headerlink" title="5.1   案例实现"></a>5.1   案例实现</h3><h4 id="5-1-1-新建-microservicecloud-consumer-hystrix-dashboard-9001-模块"><a href="#5-1-1-新建-microservicecloud-consumer-hystrix-dashboard-9001-模块" class="headerlink" title="5.1.1 新建    microservicecloud-consumer-hystrix-dashboard-9001    模块"></a>5.1.1 新建    microservicecloud-consumer-hystrix-dashboard-9001    模块</h4><p>根据父工程 microservicecloud新建服务监控模块（ 参考microservicecloud-consumer-person-80-feign ）          </p>
<pre><code>（1）复制80-feign模块pom文件并添加dashboard依赖
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- hystrix和 hystrix-dashboard相关--&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<pre><code>（2）修改application.yml配置文件          
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 9001</div></pre></td></tr></table></figure>
<pre><code>（3）启动类ApplicationBootStart9001dashboard添加@EnableHystrixDashboard         
</code></pre><p>​    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableHystrixDashboard</div><div class="line">public class ApplicationBootStart9001dashboard &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart9001dashboard.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    </p>
<p>  （4）所有Provider微服务提供类(8001/8002/8003)都需要监控依赖配置       </p>
<p>​         </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- actuator监控信息完善 --&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>​    </p>
<p>   （5）完整工程                        </p>
<pre><code>![](SpringCloud个人总结/Snipaste_2019-08-19_16-34-32.png)
</code></pre><p>​                            </p>
<h4 id="5-1-2-启动dashboard-9001模块"><a href="#5-1-2-启动dashboard-9001模块" class="headerlink" title="5.1.2 启动dashboard-9001模块"></a>5.1.2 启动dashboard-9001模块</h4><pre><code>http://localhost:9001/hystrix 
</code></pre><p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-19_16-36-15.png" alt=""></p>
<p>部署成功</p>
<h4 id="5-1-3-启动3个eureka集群"><a href="#5-1-3-启动3个eureka集群" class="headerlink" title="5.1.3 启动3个eureka集群"></a>5.1.3 启动3个eureka集群</h4><h4 id="5-1-4启动microservicecloud-provider-person-hystrix-8001和microservicecloud-consumer-person-80-feign-服务端和消费者"><a href="#5-1-4启动microservicecloud-provider-person-hystrix-8001和microservicecloud-consumer-person-80-feign-服务端和消费者" class="headerlink" title="5.1.4启动microservicecloud-provider-person-hystrix-8001和microservicecloud-consumer-person-80-feign 服务端和消费者"></a>5.1.4启动microservicecloud-provider-person-hystrix-8001和microservicecloud-consumer-person-80-feign 服务端和消费者</h4><h4 id="5-1-4dashboard填写需要监控的服务地址"><a href="#5-1-4dashboard填写需要监控的服务地址" class="headerlink" title="5.1.4dashboard填写需要监控的服务地址"></a>5.1.4dashboard填写需要监控的服务地址</h4><p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-19_16-46-55.png" alt=""></p>
<p>1：Delay：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，可以通过配置该属性来降低客户端的网络和CPU消耗。</p>
<p>2：Title：该参数对应了头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，可以通过配置该信息来展示更合适的标题。 </p>
<p>点击Monitor Stream  开始监控</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-19_16-49-56.png" alt=""></p>
<p><strong>怎么查看这张图：关键的部位我已经用红色方框，框住。核心就是：7色（服务的状态），1圈，1线。</strong>                           </p>
<pre><code>   1圈                   

      实心圆:共有两种含义.它通过颜色的变化代表了 实例健康程度,它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减.该实心圆除了颜色的变化之外,它的大小也会根据实例的请求流量发生变化,流量越大该实心圆就越大.所以通过该实心圆的展示,就可以在大量的实例中快速的发现故障实例和高压力实例.              

1线                   

     曲线:用来记录2分钟内流量的相对变化,可以通过它来观察到流量的上升和下降趋势.
</code></pre><p><img src="/2019/05/01/SpringCloud个人总结/dashbnoars.png" alt=""></p>
<h4 id="5-1-5-多次刷新http-localhost-consumer-person-get-1"><a href="#5-1-5-多次刷新http-localhost-consumer-person-get-1" class="headerlink" title="5.1.5 多次刷新http://localhost/consumer/person/get/1"></a>5.1.5 多次刷新<a href="http://localhost/consumer/person/get/1" target="_blank" rel="external">http://localhost/consumer/person/get/1</a></h4><p>也即是多次请求8001服务，然后查看监控的状态</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-19_16-53-58.png" alt=""></p>
<p>显示请求的get方法的情况。圆圈变大，曲线上升。（<strong>如果请求多个方法会增加图形说明</strong>）</p>
<h1 id="十-zuul路由网关"><a href="#十-zuul路由网关" class="headerlink" title="十. zuul路由网关"></a>十. zuul路由网关</h1><pre><code>通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：
</code></pre><p><img src="/2019/05/01/SpringCloud个人总结/C1566221714611.png" alt="1566221714611"></p>
<p><strong>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</strong></p>
<p> 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？</p>
<p>先来说说这样架构需要做的一些事儿以及存在的不足：</p>
<p>•               破坏了服务无状态特点。</p>
<pre><code>为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。

  从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。
</code></pre><p>•               无法直接复用既有接口。</p>
<pre><code>当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。
</code></pre><p>面对类似上面的问题，我们要如何解决呢？答案是：服务网关！</p>
<p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。</p>
<p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p>
<p>Zuul包含了对请求的路由和过滤两个最主要的功能：</p>
<p><strong>其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础.Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。</strong></p>
<pre><code>**注意：Zuul服务最终还是会注册进Eureka**

提供=代理+路由+过滤三大功能
</code></pre><h2 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h2><p>官网：<a href="https://github.com/Netflix/zuul" target="_blank" rel="external">https://github.com/Netflix/zuul</a></p>
<p> <img src="/2019/05/01/SpringCloud个人总结/njl002.png" alt="标题: fig:"></p>
<p>Zuul：维基百科</p>
<p>电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。</p>
<p>事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！</p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image0yy04.png" alt="img"></p>
<h2 id="2-Zuul加入后的架构"><a href="#2-Zuul加入后的架构" class="headerlink" title="2.Zuul加入后的架构"></a>2.Zuul加入后的架构</h2><p> <img src="file:///C:/Users/JEREMY~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" alt="标题: fig:"></p>
<p>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</p>
<p>​        </p>
<h2 id="3-路由基本配置（例子）"><a href="#3-路由基本配置（例子）" class="headerlink" title="3.路由基本配置（例子）"></a>3.路由基本配置（例子）</h2><h3 id="3-1新建Module模块microservicecloud-zuul-gateway-9999"><a href="#3-1新建Module模块microservicecloud-zuul-gateway-9999" class="headerlink" title="3.1新建Module模块microservicecloud-zuul-gateway-9999"></a>3.1<strong>新建Module模块microservicecloud-zuul-gateway-9999</strong></h3><h3 id="3-2-修改pom文件"><a href="#3-2-修改pom文件" class="headerlink" title="3.2 修改pom文件"></a>3.2 修改pom文件</h3><p>主要添加：</p>
<pre><code>&lt;!-- zuul路由网关 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>完整内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;!-- zuul路由网关 --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;!-- actuator监控 --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;!--  hystrix容错--&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;!-- 日常标配 --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.kingge.springcloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;!-- 热部署插件 --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;springloaded&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<h3 id="3-3-修改application-yml"><a href="#3-3-修改application-yml" class="headerlink" title="3.3 修改application.yml"></a>3.3 修改application.yml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 9999</div><div class="line"></div><div class="line">spring:</div><div class="line">  application:</div><div class="line">    name: microservicecloud-zuul-gateway</div><div class="line"></div><div class="line">eureka:</div><div class="line">  client:</div><div class="line">    service-url:</div><div class="line">      defaultZone: http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/</div><div class="line">  instance:</div><div class="line">    instance-id: microservicecloud-zuul-gateway9999</div><div class="line">    prefer-ip-address: true</div><div class="line"></div><div class="line"></div><div class="line">info:</div><div class="line">  app.name: $&#123;spring.application.name&#125;</div><div class="line">  company.name: kingge.top</div><div class="line">  build.artifactId: $&#123;project.artifactId&#125;</div><div class="line">  build.version: $&#123;project.version&#125;</div><div class="line">  app.desc: 这是一个zuul</div></pre></td></tr></table></figure>
<h3 id="3-4-修改主启动类ApplicationBootStart9999zuul"><a href="#3-4-修改主启动类ApplicationBootStart9999zuul" class="headerlink" title="3.4 修改主启动类ApplicationBootStart9999zuul"></a>3.4 修改主启动类ApplicationBootStart9999zuul</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableZuulProxy</div><div class="line">public class ApplicationBootStart9999zuul &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart9999zuul.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-1完整工程展示"><a href="#3-4-1完整工程展示" class="headerlink" title="3.4.1完整工程展示"></a>3.4.1完整工程展示</h3><p><img src="/2019/05/01/SpringCloud个人总结/C1566226205578.png" alt="1566226205578"></p>
<h3 id="3-5启动三个eureka集群-、一个服务提供类microservicecloud-provider-person-8001-、9999模块路由"><a href="#3-5启动三个eureka集群-、一个服务提供类microservicecloud-provider-person-8001-、9999模块路由" class="headerlink" title="3.5启动三个eureka集群 、一个服务提供类microservicecloud-provider-person-8001 、9999模块路由"></a>3.5启动三个eureka集群 、一个服务提供类microservicecloud-provider-person-8001 、9999模块路由</h3><p><img src="/2019/05/01/SpringCloud个人总结/566222721701.png" alt="1566222721701"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/C1566222752232.png" alt="1566222752232"></p>
<h3 id="3-6-测试"><a href="#3-6-测试" class="headerlink" title="3.6 测试"></a>3.6 测试</h3><p>不用路由访问：<a href="http://localhost:8001/person/get/2" target="_blank" rel="external">http://localhost:8001/person/get/2</a><br>启用路由访问 <a href="http://localhost:9999/microservicecloud-person/person/get/2" target="_blank" rel="external">http://localhost:9999/microservicecloud-person/person/get/2</a></p>
<p>输出都是：{“deptno”:5,”dname”:”开发部”,”db_source”:”test”}</p>
<h2 id="4-路由访问映射规则"><a href="#4-路由访问映射规则" class="headerlink" title="4.路由访问映射规则"></a>4.<strong>路由访问映射规则</strong></h2><p>上面的案例存在一个问题，那就是使用路由访问服务的时候</p>
<p><a href="http://localhost:9999/microservicecloud-person/person/get/2" target="_blank" rel="external">http://localhost:9999/microservicecloud-person/person/get/2</a></p>
<p>我们暴露了 服务名称：microservicecloud-person ，所以我们想隐藏他。</p>
<h3 id="4-1-修改9999模块配置文件"><a href="#4-1-修改9999模块配置文件" class="headerlink" title="4.1 修改9999模块配置文件"></a>4.1 修改9999模块配置文件</h3><p>添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">zuul: </div><div class="line">  routes: </div><div class="line">    myperson.serviceId: microservicecloud-person</div><div class="line">    myperson.path: /myperson/**</div></pre></td></tr></table></figure>
<p><strong><em>重要</em></strong></p>
<p><strong>规则说明</strong>：</p>
<p>•   zuul.routes.<route>.path=/xxx/**： 来指定映射路径。<route>是自定义的路由名（在上面是myperson）</route></route></p>
<p>•   zuul.routes.<route>.serviceId=service-provider：来指定服务名。</route></p>
<p><strong>而大多数情况下，我们的<route>路由名称往往和服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：zuul.routes.<serviceid>=<path></path></serviceid></route></strong></p>
<p><strong>比方说上面我们关于microservicecloud-person的配置可以简化为一条：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">zuul:</div><div class="line">  routes:</div><div class="line">    microservicecloud-person: /myperson/** # 这里是映射路径</div><div class="line">#    myperson.serviceId: microservicecloud-person</div><div class="line">#    myperson.path: /myperson/**</div></pre></td></tr></table></figure>
<p>省去了对服务名称的配置。</p>
<h3 id="4-2-重启9999模块"><a href="#4-2-重启9999模块" class="headerlink" title="4.2 重启9999模块"></a>4.2 重启9999模块</h3><p>访问如下两个网址</p>
<p>（1）服务名称映射后路由访问OK<br><a href="http://localhost:9999/myperson/person/get/5" target="_blank" rel="external">http://localhost:9999/myperson/person/get/5</a></p>
<p>（2）未映射服务名称原路径访问OK  - <strong>默认的路由规则</strong><br><a href="http://localhost:9999/microservicecloud-person/person/get/5" target="_blank" rel="external">http://localhost:9999/microservicecloud-person/person/get/5</a></p>
<p><strong>如果在保留第一种方式的情况下，禁止第二种方式的访问。</strong></p>
<h3 id="4-3-原真实服务名忽略-关闭默认的路由规则"><a href="#4-3-原真实服务名忽略-关闭默认的路由规则" class="headerlink" title="4.3 原真实服务名忽略-关闭默认的路由规则"></a>4.3 <strong>原真实服务名忽略-关闭默认的路由规则</strong></h3><p>增你家该属性即可：ignored-services:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">zuul:</div><div class="line">  ignored-services: microservicecloud-person #单个具体，多个可以用&quot;*&quot; ignored-services: *</div><div class="line">  routes:</div><div class="line">    myperson.serviceId: microservicecloud-person</div><div class="line">    myperson.path: /myperson/**</div></pre></td></tr></table></figure>
<p>重启9999zuul模块：</p>
<p>访问：<a href="http://localhost:9999/microservicecloud-person/person/get/5" target="_blank" rel="external">http://localhost:9999/microservicecloud-person/person/get/5</a> </p>
<p>访问失败</p>
<p><img src="/2019/05/01/SpringCloud个人总结/C1566223608884.png" alt="1566223608884"></p>
<h3 id="4-4-设置统一公共前缀"><a href="#4-4-设置统一公共前缀" class="headerlink" title="4.4 设置统一公共前缀"></a>4.4 <strong>设置统一公共前缀</strong></h3><p>增加prefix属性即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">zuul:</div><div class="line">  ignored-services: microservicecloud-person #单个具体，多个可以用&quot;*&quot; ignored-services: *</div><div class="line">  routes:</div><div class="line">    myperson.serviceId: microservicecloud-person</div><div class="line">    myperson.path: /myperson/**</div><div class="line">  prefix: /sb  #必须有反斜杠</div></pre></td></tr></table></figure>
<p><a href="http://localhost:9999/sb/myperson/person/get/5" target="_blank" rel="external">http://localhost:9999/sb/myperson/person/get/5</a> //访问成功</p>
<p><a href="http://localhost:9999/myperson/person/get/5" target="_blank" rel="external">http://localhost:9999/myperson/person/get/5</a> //不加前缀访问失败</p>
<h2 id="5-默认的路由规则"><a href="#5-默认的路由规则" class="headerlink" title="5 .默认的路由规则"></a>5 .默认的路由规则</h2><p>在使用Zuul的过程中，上面讲述的规则（<strong>也就是上面4.1小节的规则</strong>）已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：</p>
<p>•               默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：service-provider，则默认的映射路径就 是：/service-provider/**</p>
<p>也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。</p>
<p>终极简化版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">zuul:</div><div class="line">#  routes:</div><div class="line">#    microservicecloud-person: /myperson/** # 这里是映射路径</div><div class="line">#    myperson.serviceId: microservicecloud-person</div><div class="line">#    myperson.path: /myperson/**</div></pre></td></tr></table></figure>
<p>那么默认microservicecloud-person服务的映射路径是：/microservicecloud-person/**</p>
<p>为了不暴露服务名称，那么我么你需要关闭默认的路由规则：见4.3小节</p>
<h2 id="6-过滤器"><a href="#6-过滤器" class="headerlink" title="6.过滤器"></a>6.过滤器</h2><p>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。</p>
<h3 id="6-1-ZuulFilter"><a href="#6-1-ZuulFilter" class="headerlink" title="6.1.ZuulFilter"></a>6.1.ZuulFilter</h3><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public abstract ZuulFilter implements IZuulFilter&#123;</div><div class="line"> </div><div class="line">     abstract public String filterType();</div><div class="line"> </div><div class="line">     abstract public int filterOrder();</div><div class="line">     </div><div class="line">     boolean shouldFilter();// 来自IZuulFilter</div><div class="line"> </div><div class="line">     Object run() throws ZuulException;// IZuulFilter</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>•               shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</p>
<p>•               run：过滤器的具体业务逻辑。</p>
<p>•               filterType：返回字符串，代表过滤器的类型。包含以下4种：</p>
<p>–               pre：请求在被路由之前执行</p>
<p>–               route：在路由请求时调用</p>
<p>–               post：在route和errror过滤器之后调用</p>
<p>–               error：处理请求时发生错误调用</p>
<p>•               filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</p>
<h3 id="6-2-过滤器执行生命周期"><a href="#6-2-过滤器执行生命周期" class="headerlink" title="6.2.过滤器执行生命周期"></a>6.2.过滤器执行生命周期</h3><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。</p>
<p><img src="/2019/05/01/SpringCloud个人总结/clip_image002yyyy.png" alt="img"></p>
<p>正常流程：</p>
<p>•               请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</p>
<p>异常流程：</p>
<p>•               整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</p>
<p>•               如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。</p>
<p>•               如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和route不同的是，请求不会再到达POST过滤器了。</p>
<p>所有内置过滤器列表：</p>
<p> <img src="/2019/05/01/SpringCloud个人总结/clip_imaggggge004.png" alt="标题: fig:"></p>
<h3 id="6-3-使用场景"><a href="#6-3-使用场景" class="headerlink" title="6.3.使用场景"></a>6.3.使用场景</h3><p>场景非常多：</p>
<p>•               请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了</p>
<p>•               异常处理：一般会在error类型和post类型过滤器中结合来处理。</p>
<p>•               服务调用时长统计：pre和post结合使用。</p>
<h2 id="7-自定义过滤器"><a href="#7-自定义过滤器" class="headerlink" title="7.自定义过滤器"></a>7.自定义过滤器</h2><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p>
<h3 id="7-1-定义过滤器类"><a href="#7-1-定义过滤器类" class="headerlink" title="7.1.定义过滤器类"></a>7.1.定义过滤器类</h3><p><img src="/2019/05/01/SpringCloud个人总结/5C1566226606544.png" alt="1566226606544"></p>
<p>内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.filter;</div><div class="line"></div><div class="line">import com.netflix.zuul.ZuulFilter;</div><div class="line">import com.netflix.zuul.context.RequestContext;</div><div class="line">import com.netflix.zuul.exception.ZuulException;</div><div class="line">import org.apache.commons.lang.StringUtils;</div><div class="line">import org.springframework.http.HttpStatus;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line"></div><div class="line">@Component</div><div class="line">public class LoginFilter extends ZuulFilter &#123;</div><div class="line">    /**</div><div class="line">     * 过滤器类型，前置过滤器</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public String filterType() &#123;</div><div class="line">        return &quot;pre&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 过滤器的执行顺序</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int filterOrder() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 该过滤器是否生效</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean shouldFilter() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 登陆校验逻辑</div><div class="line">     * @return</div><div class="line">     * @throws ZuulException</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public Object run() &#123;</div><div class="line">        // 获取zuul提供的上下文对象</div><div class="line">        RequestContext context = RequestContext.getCurrentContext();</div><div class="line">        // 从上下文对象中获取请求对象</div><div class="line">        HttpServletRequest request = context.getRequest();</div><div class="line">        // 获取token信息</div><div class="line">        String token = request.getParameter(&quot;access-token&quot;);</div><div class="line">        // 判断</div><div class="line">        if (StringUtils.isBlank(token)) &#123;</div><div class="line">            // 过滤该请求，不对其进行路由</div><div class="line">            context.setSendZuulResponse(false);</div><div class="line">            // 设置响应状态码，401</div><div class="line">            context.setResponseStatusCode(401);</div><div class="line">            // 设置响应信息</div><div class="line">            context.setResponseBody(&quot;&#123;\&quot;status\&quot;:\&quot;401\&quot;, \&quot;text\&quot;:\&quot;request error!\&quot;&#125;&quot;);</div><div class="line">        &#125;</div><div class="line">        // 校验通过，把登陆信息放入上下文信息，继续向后执行</div><div class="line">        context.set(&quot;token&quot;, token);</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-2-测试"><a href="#7-2-测试" class="headerlink" title="7.2.测试"></a>7.2.测试</h3><p>没有token参数时，访问失败：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/5C1566226821375.png" alt="1566226821375"></p>
<p>添加token参数后：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566226885002.png" alt="1566226885002"></p>
<h2 id="8-负载均衡和熔断"><a href="#8-负载均衡和熔断" class="headerlink" title="8.负载均衡和熔断"></a>8.负载均衡和熔断</h2><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p>
<p>hystrix:<br>   command:<br>     default:<br>       execution:<br>         isolation:<br>           thread:<br>             timeoutInMilliseconds: 2000 # 设置hystrix的超时时间为6000ms</p>
<h1 id="十一-SpringCloud-Config-分布式配置中心"><a href="#十一-SpringCloud-Config-分布式配置中心" class="headerlink" title="十一.SpringCloud Config 分布式配置中心"></a>十一.<strong>SpringCloud Config 分布式配置中心</strong></h1><pre><code>**解决第四个问题，统一配置的问题**
</code></pre><h2 id="1-为什么需要配置中心"><a href="#1-为什么需要配置中心" class="headerlink" title="1.为什么需要配置中心"></a>1.为什么需要配置中心</h2><p>   举个简单的例子，我们想要修改8001模块的服务名称的值（spring.application.name），那么我们首先得找到8001模块，然后找到配置文件，然后再进去修改。如果修改修改8003模块的配置信息，重复之前的步骤。</p>
<p> 所以我们需要一个集中管理所有微服务配置信息的地方。</p>
<pre><code>微服务意味着要将单体应用中的业务拆分成一个个子服务,每个服务的粒度相对较小,因此系统中会出现大量的服务.由于每个服务都需要必要的配置信息才能运行（application.yml）,所以一套集中式的、动态的配置管理设施是必不可少的.SpringCloud提供了ConfigServer来解决这个问题(我们每一个微服务自己带着一个application.yml,上百个配置文件的管理的问题)
</code></pre><p>​         </p>
<pre><code>**总而言之：是为了更加方便的帮助我们集中式的管理微服务架构里面微服务的配置信息。**
</code></pre><h2 id="2-config配置中心"><a href="#2-config配置中心" class="headerlink" title="2. config配置中心"></a>2. config配置中心</h2><p><strong>SpringCloud Config 为微服务架构中的微服务提供集中化的外部配置支持,配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置，方便我们集中式的修改微服务的配置</strong></p>
<p><strong>SpringCloud Config分为服务端和客户端两部分.</strong></p>
<p><strong>服务端也称为分布式配置中心,它是一个独立的微服务应用,用来连接配置服务器并为客户端提供获取配置信息,加密/解密信息等访问接口</strong></p>
<p><strong>客户端则是通过制定的配置中心来管理应用资源,以及业务相关的配置内容,并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息,这样就有助于对环境配置进行版本管理,并且可以通过git客户端工具来方便的管理和访问配置内容.（客户端可以是我们的8001,8003模块，也即是需要获取配置信息的微服务都是客户端）</strong></p>
<blockquote>
<p>功能：</p>
</blockquote>
<ul>
<li>1.集中管理配置文件</li>
<li>2.不同环境不同配置,动态化的配置更新,分环境部署比如dev/test/prod/beta/release</li>
<li>3.运行期间动态调整配置,不再需要在每个服务部署的机器上编写配置文件,服务会向配置中心统一拉取配置自己的信息</li>
<li>4.当配置发生变动时,服务不需要重启即可感知到配置的变化并应用新的配置</li>
<li>5.将配置信息以REST接口的形式暴露</li>
</ul>
<blockquote>
<p>配置中心配置文件放置的位置：与GitHub整合配置</p>
</blockquote>
<p>由于SpringCloudConfig默认使用Git来存储配置文件(也有其他方式,比如支持SVN和本地文件),<br>但最推荐的还是使用Git,而且使用的是http/https访问形式</p>
<h2 id="3-SpringCloud-Config服务端配置"><a href="#3-SpringCloud-Config服务端配置" class="headerlink" title="3.SpringCloud Config服务端配置"></a>3.SpringCloud Config服务端配置</h2><h3 id="3-1-在GitHub上新建一个名为springcloud-config-server的新Repository"><a href="#3-1-在GitHub上新建一个名为springcloud-config-server的新Repository" class="headerlink" title="3.1 在GitHub上新建一个名为springcloud-config-server的新Repository"></a>3.1 在GitHub上新建一个名为springcloud-config-server的新Repository</h3><p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_09-42-33.png" alt=""></p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_09-59-45.png" alt=""></p>
<p>git@github.com:JeremyKinge/springcloud-config-server.git</p>
<h3 id="3-2-本地磁盘获取上述创建的仓库"><a href="#3-2-本地磁盘获取上述创建的仓库" class="headerlink" title="3.2 本地磁盘获取上述创建的仓库"></a>3.2 本地磁盘获取上述创建的仓库</h3><p>git命令:<br>git clone git@github.com:JeremyKinge/springcloud-config-server.git</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_10-01-44.png" alt=""></p>
<h3 id="3-3-在上述磁盘新建配置文件并上传到git仓库"><a href="#3-3-在上述磁盘新建配置文件并上传到git仓库" class="headerlink" title="3.3 在上述磁盘新建配置文件并上传到git仓库"></a>3.3 在上述磁盘新建配置文件并上传到git仓库</h3><p>（1）添加配置文件application.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring:</div><div class="line">  profiles:</div><div class="line">    active:</div><div class="line">    - dev</div><div class="line">---</div><div class="line">spring:</div><div class="line">  profiles: dev</div><div class="line">  application:    #开发环境</div><div class="line">    name: microservicecloud-config-kingge-dev</div><div class="line">---</div><div class="line">spring:</div><div class="line">  profiles: test   #测试环境</div><div class="line">  application:</div><div class="line">    name: microservicecloud-config-kingge-test</div><div class="line">#请保存为UTF-8格式</div></pre></td></tr></table></figure>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_10-06-13.png" alt=""></p>
<p>（2）git bash执行上传命令：</p>
<p>git add .<br>git commit -m “新建配置文件”<br>git push origin master</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_10-08-51.png" alt=""></p>
<p>（3）查看github</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_10-09-16.png" alt=""></p>
<h3 id="3-4-新建Module模块microservicecloud-config-10000它即为Cloud的配置中心模块"><a href="#3-4-新建Module模块microservicecloud-config-10000它即为Cloud的配置中心模块" class="headerlink" title="3.4 新建Module模块microservicecloud-config-10000它即为Cloud的配置中心模块"></a>3.4 新建Module模块microservicecloud-config-10000它即为Cloud的配置中心模块</h3><h3 id="3-5-修改10000模块pom文件和yml配置文件、启动类"><a href="#3-5-修改10000模块pom文件和yml配置文件、启动类" class="headerlink" title="3.5 修改10000模块pom文件和yml配置文件、启动类"></a>3.5 修改10000模块pom文件和yml配置文件、启动类</h3><p>（1）修改pom文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">&lt;dependencies&gt;</div><div class="line"> &lt;!-- springCloud Config 关键代码--&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;!-- 避免Config的Git插件报错：org/eclipse/jgit/api/TransportConfigCallback  --&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">     &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;</div><div class="line">     &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;</div><div class="line">     &lt;version&gt;4.10.0.201712302008-r&lt;/version&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;!-- 图形化监控 --&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;!-- 熔断 --&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;!-- 热部署插件 --&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;springloaded&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line"> &lt;dependency&gt;</div><div class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">   &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</div><div class="line"> &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<p>关键代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- springCloud Config 关键代码--&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>（2）修改yml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server: </div><div class="line">  port: 10000 </div><div class="line">  </div><div class="line">spring:</div><div class="line">  application:</div><div class="line">    name:  microservicecloud-config</div><div class="line">  cloud:</div><div class="line">    config:</div><div class="line">      server:</div><div class="line">        git:</div><div class="line">          uri: git@github.com:JeremyKinge/springcloud-config-server.git #GitHub上面的git仓库名字</div><div class="line">          #username: xxxxxx  #如果访问github需要密码那么填写下面三项</div><div class="line">          #password: xxxxxxx</div><div class="line">          #force-pull: true</div></pre></td></tr></table></figure>
<p>（3）启动类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableConfigServer</div><div class="line">public class ApplicationBootStart10000config &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        SpringApplication.run(ApplicationBootStart10000config.class,args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-6-完整项目结构"><a href="#3-6-完整项目结构" class="headerlink" title="3.6 完整项目结构"></a>3.6 完整项目结构</h3><p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_10-18-53.png" alt=""></p>
<h3 id="3-7-测试通过Config微服务是否可以从GitHub上获取配置内容"><a href="#3-7-测试通过Config微服务是否可以从GitHub上获取配置内容" class="headerlink" title="3.7 测试通过Config微服务是否可以从GitHub上获取配置内容"></a>3.7 测试通过Config微服务是否可以从GitHub上获取配置内容</h3><p>启动微服务10000<br><a href="http://localhost:10000/application-dev.yml" target="_blank" rel="external">http://localhost:10000/application-dev.yml</a></p>
<p>输出：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_10-23-00.png" alt=""></p>
<p><a href="http://localhost:10000/application-test.yml" target="_blank" rel="external">http://localhost:10000/application-test.yml</a></p>
<p>输出：</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_10-23-19.png" alt=""></p>
<p><a href="http://localhost:10000/application-xxx.yml(不存在的配置" target="_blank" rel="external">http://localhost:10000/application-xxx.yml(不存在的配置</a>)</p>
<p><strong>成功实现了用SpringCloud Config通过GitHub获取配置信息</strong></p>
<h3 id="3-8-配置文件读取规则"><a href="#3-8-配置文件读取规则" class="headerlink" title="3.8 配置文件读取规则"></a>3.8 配置文件读取规则</h3><p><img src="/2019/05/01/SpringCloud个人总结/Topic578NotesImage5.jpg" alt=""></p>
<p>上面3.8测试中，我们采用的是第二种方式，通过10000配置中心去github获取配置文件</p>
<p>请求例子：</p>
<p>/{application}-{profile}.yml<br>  <a href="http://localhost:10000/application-dev.yml" target="_blank" rel="external">http://localhost:10000/application-dev.yml</a><br>  <a href="http://localhost:10000/application-test.yml" target="_blank" rel="external">http://localhost:10000/application-test.yml</a><br>  <a href="http://localhost:10000/application-xxx.yml(不存在的配置" target="_blank" rel="external">http://localhost:10000/application-xxx.yml(不存在的配置</a>)<br>/{application}/{profile}[/{label}]<br>  <a href="http://localhost:10000/application/dev/master" target="_blank" rel="external">http://localhost:10000/application/dev/master</a><br>  <a href="http://localhost:10000/application/test/master" target="_blank" rel="external">http://localhost:10000/application/test/master</a><br>  <a href="http://localhost:10000/application/xxx/master" target="_blank" rel="external">http://localhost:10000/application/xxx/master</a><br>/{label}/{application}-{profile}.yml<br>  <a href="http://localhost:10000/master/application-dev.yml" target="_blank" rel="external">http://localhost:10000/master/application-dev.yml</a><br>  <a href="http://localhost:10000/master/application-test.yml" target="_blank" rel="external">http://localhost:10000/master/application-test.yml</a></p>
<h2 id="4-SpringCloud-Config客户端配置与测试"><a href="#4-SpringCloud-Config客户端配置与测试" class="headerlink" title="4.SpringCloud Config客户端配置与测试"></a>4.SpringCloud Config客户端配置与测试</h2><p>在上面中我们已经搭建好了，配置中心的服务端。那么接下来演示一下客户端怎么取获取服务端的配置信息。</p>
<p><strong>新建8004服务提供者，他的配置信息我们取自配置中心（而不是在application.yml中配置，动态获取）</strong></p>
<h3 id="4-1-新建8004-配置文件并上传到github"><a href="#4-1-新建8004-配置文件并上传到github" class="headerlink" title="4.1 新建8004 配置文件并上传到github"></a>4.1 新建8004 配置文件并上传到github</h3><p>新建microservicecloud-provider-person-config-client-8004.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring: </div><div class="line">  profiles:</div><div class="line">    active:</div><div class="line">    - dev</div><div class="line">--- </div><div class="line">server:</div><div class="line">  port: 8004</div><div class="line"></div><div class="line">mybatis:</div><div class="line">  config-location: classpath:mybatis/mybatis.cfg.xml        # mybatis配置文件所在路径</div><div class="line">  type-aliases-package: com.kingge.entity    # 所有Entity别名类所在包</div><div class="line">  mapper-locations:</div><div class="line">  - classpath:mybatis/mapper/**/*.xml                       # mapper映射文件</div><div class="line"></div><div class="line">spring:</div><div class="line">   profiles: dev</div><div class="line">   application:</div><div class="line">    name: microservicecloud-person                          #很重要，对外暴露的微服务的名称</div><div class="line">   datasource:</div><div class="line">    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</div><div class="line">    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包</div><div class="line">    url: jdbc:mysql://127.0.0.1:3306/test              # 数据库名称</div><div class="line">    username: root</div><div class="line">    password: 123</div><div class="line">    dbcp2:</div><div class="line">      min-idle: 5                                           # 数据库连接池的最小维持连接数</div><div class="line">      initial-size: 5                                       # 初始化连接数</div><div class="line">      max-total: 5                                          # 最大连接数</div><div class="line">      max-wait-millis: 200                                  # 等待连接获取的最大超时时间</div><div class="line">#</div><div class="line">eureka:</div><div class="line">  client: #客户端注册进eureka服务列表内</div><div class="line">    service-url:</div><div class="line">      defaultZone: http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/</div><div class="line">#      http://localhost:7001/eureka #单机版本使用</div><div class="line">#      defaultZone: http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/</div><div class="line">  instance:</div><div class="line">    instance-id: microservicecloud-person8001 #自定义服务实例名</div><div class="line">    prefer-ip-address: true     #访问路径可以显示IP地址</div><div class="line">    lease-expiration-duration-in-seconds: 10 # 10秒即过期</div><div class="line">    lease-renewal-interval-in-seconds: 5 # 5秒一次心跳</div><div class="line">#</div><div class="line">info:</div><div class="line">  app.name: $&#123;spring.application.name&#125;</div><div class="line">  company.name: kingge.top</div><div class="line">  build.artifactId: $&#123;project.artifactId&#125;</div><div class="line">  build.version: $&#123;project.version&#125;</div><div class="line">  app.desc: 这是一个提供查询部门人员信息的服务</div><div class="line">---</div><div class="line">server:</div><div class="line">  port: 8005</div><div class="line"></div><div class="line">mybatis:</div><div class="line">  config-location: classpath:mybatis/mybatis.cfg.xml        # mybatis配置文件所在路径</div><div class="line">  type-aliases-package: com.kingge.entity    # 所有Entity别名类所在包</div><div class="line">  mapper-locations:</div><div class="line">  - classpath:mybatis/mapper/**/*.xml                       # mapper映射文件</div><div class="line"></div><div class="line">spring:</div><div class="line">   profiles: test</div><div class="line">   application:</div><div class="line">    name: microservicecloud-person                          #很重要，对外暴露的微服务的名称</div><div class="line">   datasource:</div><div class="line">    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型</div><div class="line">    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包</div><div class="line">    url: jdbc:mysql://127.0.0.1:3306/test2              # 数据库名称</div><div class="line">    username: root</div><div class="line">    password: 123</div><div class="line">    dbcp2:</div><div class="line">      min-idle: 5                                           # 数据库连接池的最小维持连接数</div><div class="line">      initial-size: 5                                       # 初始化连接数</div><div class="line">      max-total: 5                                          # 最大连接数</div><div class="line">      max-wait-millis: 200                                  # 等待连接获取的最大超时时间</div><div class="line">#</div><div class="line">eureka:</div><div class="line">  client: #客户端注册进eureka服务列表内</div><div class="line">    service-url:</div><div class="line">      defaultZone: http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/</div><div class="line">#      http://localhost:7001/eureka #单机版本使用</div><div class="line">#      defaultZone: http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/</div><div class="line">  instance:</div><div class="line">    instance-id: microservicecloud-person8001 #自定义服务实例名</div><div class="line">    prefer-ip-address: true     #访问路径可以显示IP地址</div><div class="line">    lease-expiration-duration-in-seconds: 10 # 10秒即过期</div><div class="line">    lease-renewal-interval-in-seconds: 5 # 5秒一次心跳</div><div class="line">#</div><div class="line">info:</div><div class="line">  app.name: $&#123;spring.application.name&#125;</div><div class="line">  company.name: kingge.top</div><div class="line">  build.artifactId: $&#123;project.artifactId&#125;</div><div class="line">  build.version: $&#123;project.version&#125;</div><div class="line">  app.desc: 这是一个提供查询部门人员信息的服务</div></pre></td></tr></table></figure>
<p><strong>dev和test环境的不同在于，他们的服务端口不同和访问的数据库不同</strong></p>
<h3 id="4-2-microservicecloud-provider-person-config-client-8004模块"><a href="#4-2-microservicecloud-provider-person-config-client-8004模块" class="headerlink" title="4.2 microservicecloud-provider-person-config-client-8004模块"></a>4.2 microservicecloud-provider-person-config-client-8004模块</h3><p>（1）修改pom文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;!-- 引入自己定义的api通用包，可以使用Person用户Entity --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.kingge.springcloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;microservicecloud-api&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;!-- SpringCloud Config客户端 --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;!-- actuator监控信息完善 --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;!-- 将微服务provider端注册进eureka --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;!-- 修改后立即生效，热部署 --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;springloaded&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<p>关键依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- SpringCloud Config客户端 --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="4-3-新建bootstrap-yml-系统级别配置文件"><a href="#4-3-新建bootstrap-yml-系统级别配置文件" class="headerlink" title="4.3 新建bootstrap.yml 系统级别配置文件"></a>4.3 新建bootstrap.yml 系统级别配置文件</h3><p>applicaiton.yml是用户级的资源配置项<br>bootstrap.yml是系统级的，优先级更加高</p>
<p>Spring Cloud会创建一个<code>Bootstrap Context</code>，作为Spring应用的<code>Application Context</code>的父上下文。初始化的时候，<code>Bootstrap Context</code>负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。<code>Bootstrap</code>属性有高优先级，默认情况下，它们不会被本地配置覆盖。 <code>Bootstrap context</code>和<code>Application Context</code>有着不同的约定，<br>所以新增了一个<code>bootstrap.yml</code>文件，保证<code>Bootstrap Context</code>和<code>Application Context</code>配置的分离。</p>
<p><strong>换句话说，如果将下面内容放到application.yml中，那么项目启动会报错，因为是找不到控制层ConfigClientRest导入的属性</strong></p>
<p><strong>@Value(“${spring.application.name}”)</strong></p>
<p>（1）增加内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    config:</div><div class="line">      name: microservicecloud-provider-person-config-client-8004 #需要从github上读取的资源名称，注意没有yml后缀名</div><div class="line">      profile: dev   #本次访问的配置项-profile值是什么，决定从github上读取什么</div><div class="line">      label: master</div><div class="line">      uri: http://localhost:10000  #本微服务启动后先去找config配置中心地址，通过SpringCloudConfig获取GitHub的服务地址</div></pre></td></tr></table></figure>
<p>（2）为了配置文件的完整性我们新建一个空的application.yml</p>
<h3 id="4-4-新建一个控制层，获取配置文件的某些属性（测试）"><a href="#4-4-新建一个控制层，获取配置文件的某些属性（测试）" class="headerlink" title="4.4 新建一个控制层，获取配置文件的某些属性（测试）"></a>4.4 新建一个控制层，获取配置文件的某些属性（测试）</h3><p>实际上如果8004服务端能够正常启动和访问，也能够说明客户端获取config配置中心配置文件成功。不过为了证实一下，所以这里通过控制层输出某些属性</p>
<p>（1）新建ConfigClientRest </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@RestController</div><div class="line">public class ConfigClientRest &#123;</div><div class="line"></div><div class="line">    @Value(&quot;$&#123;spring.application.name&#125;&quot;)</div><div class="line">    private String applicationName;</div><div class="line"></div><div class="line">    @Value(&quot;$&#123;eureka.client.service-url.defaultZone&#125;&quot;)</div><div class="line">    private String eurekaServers;</div><div class="line"></div><div class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</div><div class="line">    private String port;</div><div class="line"></div><div class="line">    @Value(&quot;$&#123;spring.datasource.url&#125;&quot;)</div><div class="line">    private String datasourceurl;</div><div class="line"></div><div class="line">    @RequestMapping(&quot;/config&quot;)</div><div class="line">    public String getConfig()</div><div class="line">    &#123;</div><div class="line">        String str = &quot;applicationName: &quot;+applicationName+&quot;\t eurekaServers:&quot;+eurekaServers+&quot;\t port: &quot;+port;</div><div class="line">        System.out.println(&quot;******str: &quot;+ str);</div><div class="line">        return &quot;applicationName: &quot;+applicationName+&quot;\t eurekaServers:&quot;+eurekaServers+&quot;\t port: &quot;+port + &quot;\t datasourceurl：&quot;+datasourceurl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后面可以通过更改 bootstrap.yml的profile属性的值，访问/config,查看服务端口号和数据库url是否改变。</p>
<h3 id="4-5-新建启动类-1"><a href="#4-5-新建启动类-1" class="headerlink" title="4.5 新建启动类"></a>4.5 新建启动类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">public class ApplicationBootStart8004client &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        SpringApplication.run(ApplicationBootStart8004client.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-5-1-完整目录机构"><a href="#4-5-1-完整目录机构" class="headerlink" title="4.5.1 完整目录机构"></a>4.5.1 完整目录机构</h3><p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_11-07-11.png" alt=""></p>
<h3 id="4-6-启动10000配置中心和8004服务"><a href="#4-6-启动10000配置中心和8004服务" class="headerlink" title="4.6 启动10000配置中心和8004服务"></a>4.6 启动10000配置中心和8004服务</h3><p> （1） 启动Config配置中心10000微服务并自测</p>
<p><img src="/2019/05/01/SpringCloud个人总结/Snipaste_2019-08-20_11-05-27.png" alt=""></p>
<p>（2）启动8004作为Client准备访问</p>
<pre><code>  bootstrap.yml里面的profile值是什么，决定从github上读取什么

2.1 启动成功，说明配置文件获取成功



   2.2 额外验证
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">假如目前是 profile: dev</div><div class="line">  dev默认在github上对应的端口就是8004</div><div class="line">  http://localhost:8004/config</div><div class="line">  输出：applicationName: microservicecloud-person	eurekaServers:http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/	port: 8004	datasourceurl：jdbc:mysql://127.0.0.1:3306/test</div></pre></td></tr></table></figure>
<p>​<br>​    假如目前是 profile: test<br>​      test默认在github上对应的端口就是8005<br>​      <a href="http://localhost:8005/config" target="_blank" rel="external">http://localhost:8005/config</a><br>​      输出：applicationName: microservicecloud-person    eurekaServers:<a href="http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/" target="_blank" rel="external">http://peer1:7001/eureka/,http://peer2:7002/eureka/,http://peer3:7003/eureka/</a>    port: 8005    datasourceurl：jdbc:mysql://127.0.0.1:3306/test2</p>
<h2 id="5-手动刷新配置"><a href="#5-手动刷新配置" class="headerlink" title="5.手动刷新配置"></a>5.手动刷新配置</h2><pre><code>上面的案例，有个缺点，那就是我们修改了github上面的配置文件（例如修改了连接数据库的地址），对应的8004模块没有刷新，也就是，他获取的连接数据库的地址还是未修改前的。

在真实的案例中，我们不可能手动关闭服务器，然后重启。所以就需要8004它能够自动刷新
</code></pre><p><img src="/2019/05/01/SpringCloud个人总结/1566377247710.png" alt="1566377247710"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566377271635.png" alt="1566377271635"></p>
<p> 需要依赖actuator组件和通过psot方式访问请求配置变动的服务器（也即是@RefreshScope注解所在的bean）</p>
<p>（1）8004模块引入actuator依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>（2）8004启动类添加@EnableDiscoveryClient服务发现注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableDiscoveryClient</div><div class="line">public class ApplicationBootStart8004client &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SpringApplication.run(ApplicationBootStart8004client.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（3）8004模块修改application.yml文件，暴露所有端点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">management:</div><div class="line">  security:</div><div class="line">    enabled: false</div></pre></td></tr></table></figure>
<p>（4）8004添加controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@RestController</div><div class="line">@RefreshScope</div><div class="line">public class ConfigClientRest &#123;</div><div class="line"></div><div class="line">    @Value(&quot;$&#123;spring.application.name&#125;&quot;)</div><div class="line">    private String applicationName;</div><div class="line"></div><div class="line">    @Value(&quot;$&#123;eureka.client.service-url.defaultZone&#125;&quot;)</div><div class="line">    private String eurekaServers;</div><div class="line"></div><div class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</div><div class="line">    private String port;</div><div class="line"></div><div class="line">    @Value(&quot;$&#123;spring.datasource.url&#125;&quot;)</div><div class="line">    private String datasourceurl;</div><div class="line"></div><div class="line">    @RequestMapping(&quot;/config&quot;)</div><div class="line">    public String getConfig()</div><div class="line">    &#123;</div><div class="line">        String str = &quot;applicationName: &quot;+applicationName+&quot;\t eurekaServers:&quot;+eurekaServers+&quot;\t port: &quot;+port;</div><div class="line">        System.out.println(&quot;******str: &quot;+ str);</div><div class="line">        return &quot;applicationName: &quot;+applicationName+&quot;\t eurekaServers:&quot;+eurekaServers+&quot;\t port: &quot;+port + &quot;\t datasourceurl：&quot;+datasourceurl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（5）启动configserver10000和8004模块</p>
<p> 打印通过configserver从github上面获取的配置信息</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566379397446.png" alt="1566379397446"></p>
<p>此时数据库的url是：jdbc:mysql://127.0.0.1:3306/test1</p>
<p>（5）这个时候我们修改8004模块在github中引入的配置文件-</p>
<p>也就是修改microservicecloud-provider-person-config-client-8004.yml 文件。</p>
<p>1.修改访问数据库的url为，原先是test1</p>
<blockquote>
<p>url: jdbc:mysql://127.0.0.1:3306/test2    </p>
</blockquote>
<p>2.修改8004的服务端口为8005，原先是8008 - <strong>这个修改我们预测不会成功，因为服务器没有重启</strong></p>
<p>server.port：8005</p>
<p>（6）请求：curl -X POST <a href="http://localhost:8008/refresh" target="_blank" rel="external">http://localhost:8008/refresh</a>  手动更新8004模块的配置</p>
<p>  我们只需要请求这个地址就可以实现配置文件的更新，而不用重启8004模块，他默认会帮我们刷新配置文件。</p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566379561052.png" alt="1566379561052"></p>
<p><img src="/2019/05/01/SpringCloud个人总结/1566379675277.png" alt="1566379675277"></p>
<p>我们发现数据库访问地址修改成功，但是服务端口号没有成功（很明显这种做法是错误的，因为服务端口号不会轻易的变动）</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果执行curl -X POST <a href="http://localhost:8008/refresh" target="_blank" rel="external">http://localhost:8008/refresh</a> 包如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;&quot;timestamp&quot;:1513070580796,&quot;status&quot;:401,&quot;error&quot;:&quot;Unauthorized&quot;,&quot;message&quot;:&quot;Full authentication is required to access this resource.&quot;,&quot;path&quot;:&quot;/refresh&quot;&#125;</div></pre></td></tr></table></figure>
<p>那就说明默认开启访问端口验证了。需要关闭</p>
<p>一、在Spring Boot1.5.x版本中通过management.security.enabled=false来暴露所有端点</p>
<p><img src="/2019/05/01/SpringCloud个人总结/asdfafd.png" alt="img"></p>
<p>二、切换SpringBoot版本为2.x 使用IDE的搜索功能，找到类ManagementServerProperties，发现Security内部类已经被删除，通过去官网查看2.0暴露端点的方式得知：</p>
<blockquote>
<p>方式1：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 启用端点 env</div><div class="line">management.endpoint.env.enabled=true</div><div class="line"> </div><div class="line"># 暴露端点 env 配置多个,隔开</div><div class="line">management.endpoints.web.exposure.include=env</div></pre></td></tr></table></figure>
<blockquote>
<p>方式2：</p>
</blockquote>
<p>方式1中的暴露方式需要一个一个去开启需要暴露的端点，方式2直接开启和暴露所有端点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">management.endpoints.web.exposure.include=*</div></pre></td></tr></table></figure>
<p>注意在使用Http访问端点时，需要加上默认/actuator 前缀</p>
<p>三、如果这三种还不行，可以尝试在8004添加security验证依赖，然后给8004模块设置访问账号和密码， 然后通过  curl -X POST <a href="http://账号:密码@localhost:8008/refresh" target="_blank" rel="external">http://账号:密码@localhost:8008/refresh</a>  这种方式访问</p>
<h2 id="6-自动刷新配置"><a href="#6-自动刷新配置" class="headerlink" title="6.自动刷新配置"></a>6.自动刷新配置</h2><p>上面是通过手动刷新方式，缺点就是，如果我们在github上面修改了20个服务器的配置，那么我们需要手动执行20次 curl -X POST  ——  ，那么我们想能够缩减执行命令的次数或者说自动刷新配置。</p>
<h1 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h1><h2 id="1-spring-cloud服务发现注解之-EnableDiscoveryClient与-EnableEurekaClient区别"><a href="#1-spring-cloud服务发现注解之-EnableDiscoveryClient与-EnableEurekaClient区别" class="headerlink" title="1.spring cloud服务发现注解之@EnableDiscoveryClient与@EnableEurekaClient区别"></a>1.spring cloud服务发现注解之@EnableDiscoveryClient与@EnableEurekaClient区别</h2><p>在使用服务发现的时候有两种注解，</p>
<p>一种为@EnableDiscoveryClient,</p>
<p>一种为@EnableEurekaClient,</p>
<p>用法上基本一致，下文是从stackoverflow上面找到的对这<a href="https://www.cnblogs.com/liaojie970/p/What%E2%80%99s%20the%20difference%20between%20EnableEurekaClient%20and%20EnableDiscoveryClient?" target="_blank" rel="external">两者的解释</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">There are multiple implementations of &quot;Discovery Service&quot; (eureka, consul, zookeeper). </div><div class="line">@EnableDiscoveryClient lives in spring-cloud-commons and picks the implementation on the classpath.  </div><div class="line">@EnableEurekaClient lives in spring-cloud-netflix and only works for eureka. If eureka is on your classpath, they are effectively the same.</div></pre></td></tr></table></figure>
<p>意思也就是spring cloud中discovery service有许多种实现（eureka、consul、zookeeper等等）</p>
<p>@EnableDiscoveryClient基于spring-cloud-commons；而 @EnableEurekaClient基于spring-cloud-netflix</p>
<p>对@EnableEurekaClient的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Convenience annotation for clients to enable Eureka discovery configuration</div><div class="line"> * (specifically). Use this (optionally) in case you want discovery and know for sure that</div><div class="line"> * it is Eureka you want. All it does is turn on discovery and let the autoconfiguration</div><div class="line"> * find the eureka classes if they are available (i.e. you need Eureka on the classpath as</div><div class="line"> * well).</div><div class="line"> *</div><div class="line"> * @author Dave Syer</div><div class="line"> * @author Spencer Gibb</div><div class="line"> */</div><div class="line">@Target(ElementType.TYPE)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">@Inherited</div><div class="line">@EnableDiscoveryClient</div><div class="line">public @interface EnableEurekaClient &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注解@EnableEurekaClient上有@EnableDiscoveryClient注解，可以说基本就是EnableEurekaClient有@EnableDiscoveryClient的功能，另外上面的注释中提到，其实@EnableEurekaClient注解就是一种方便使用eureka的注解而已，可以说使用其他的注册中心后，都可以使用@EnableDiscoveryClient注解，</p>
<p>但是使用@EnableEurekaClient的情景，就是在服务采用eureka作为注册中心的时候，使用场景较为单一。</p>
<p><strong>所以还是比较建议使用@EnableDiscoveryClient。</strong></p>
<p><strong>所以上面的还是建议使用@EnableDiscoveryClient替换@EnableEurekaClient</strong></p>
<h2 id="2-Ribbon和Feign"><a href="#2-Ribbon和Feign" class="headerlink" title="2.Ribbon和Feign"></a>2.Ribbon和Feign</h2><p>这两种都是SPringcloud提供的负载均衡技术，都是客户端的软负载均衡技术。feign优化的Ribbon的服务调用方式，实现了面向接口编程的封装。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一下内容就是个人学习sc微服务架构中的学习总结，整个架构的东西很多，大家可以在需要某个组件时再去学习。&lt;/p&gt;
&lt;p&gt;一、为什么需要微服务&lt;/p&gt;
&lt;p&gt;我么那首先思考下面这些问题，为什么需要微服务，微服务能够解决什么痛点，它有什么优缺点？微服务和微服务架构是什么关系？什么
    
    </summary>
    
      <category term="springcloud" scheme="http://kingge.top/categories/springcloud/"/>
    
    
      <category term="分布式" scheme="http://kingge.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="springcloud" scheme="http://kingge.top/tags/springcloud/"/>
    
      <category term="微服务架构" scheme="http://kingge.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈dubbo和springcloud</title>
    <link href="http://kingge.top/2019/04/27/%E6%B5%85%E8%B0%88dubbo%E5%92%8Cspringcloud/"/>
    <id>http://kingge.top/2019/04/27/浅谈dubbo和springcloud/</id>
    <published>2019-04-27T02:21:59.000Z</published>
    <updated>2019-08-25T02:08:25.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Dubbo负责人的采访"><a href="#一、Dubbo负责人的采访" class="headerlink" title="一、Dubbo负责人的采访"></a>一、Dubbo负责人的采访</h1><p>刘军，阿里巴巴中间件高级研发工程师，主导了 Dubbo 重启维护以后的几个发版计划，所以让我们来看一下他关于Dubbo和Springcloud是否二选一，他们之间的区别的阐述。</p>
<blockquote>
<p><strong>7、目前 Dubbo 被拿来比较最多的就是 Spring Cloud ，您怎么看待二者的关系，业务上是否有所冲突？</strong></p>
</blockquote>
<p>关于 Dubbo 和 Spring Cloud 间的关系，我们在<a href="https://www.oschina.net/2017-beijing-ceremony" target="_blank" rel="external">开源中国年终盛典</a>的 Dubbo 分享中也作了简单阐述，首先要明确的一点是 Dubbo 和 Spring Cloud 并不是完全的竞争关系，两者所解决的问题域并不一样：<strong>Dubbo 的定位始终是一款 RPC 框架</strong>，<strong>而 Spring Cloud 的目标是微服务架构下的一站式解决方案</strong>。如果非要比较的话，<strong>我觉得 Dubbo 可以类比到 Netflix OSS 技术栈，而 Spring Cloud 集成了 Netflix OSS 作为分布式服务治理解决方案，但除此之外 Spring Cloud 还提供了包括 config、stream、security、sleuth 等等分布式问题解决方案</strong>。</p>
<p>当前由于 RPC 协议、注册中心元数据不匹配等问题，在面临微服务基础框架选型时 Dubbo 与 Spring Cloud 是只能二选一，这也是为什么大家总是拿 Dubbo 和 Spring Cloud 做对比的原因之一。Dubbo 之后会积极寻求适配到 Spring Cloud 生态，比如作为 Spring Cloud 的二进制通信方案来发挥 Dubbo 的性能优势，或者 Dubbo 通过模块化以及对 http 的支持适配到 Spring Cloud 。</p>
<blockquote>
<p>Netflix OSS 技术栈</p>
</blockquote>
<p>1.Netflix Eureka 服务注册中心，提供服务的注册和发现</p>
<p>2.Netflix Ribbon 客户端负载均衡</p>
<p>3.Netflix Feign   客户端负载均衡，包装Ribbon，提供了接口式的服务调用</p>
<p>4.Netflix Hystrix 熔断器，负责服务的熔断和降级</p>
<p>5.NetFlix Hystrix dashboard 提供服务监控</p>
<p>6.Netflix zuul 路由网管 提供代理+路由+过滤三大功能</p>
<h1 id="二、Dubbo和Springcloud比较"><a href="#二、Dubbo和Springcloud比较" class="headerlink" title="二、Dubbo和Springcloud比较"></a>二、Dubbo和Springcloud比较</h1><blockquote>
<p>1.社区活跃度</p>
</blockquote>
<p><a href="https://github.com/dubbo" target="_blank" rel="external">https://github.com/dubbo</a> dubbo社区<br><a href="https://github.com/springcloud" target="_blank" rel="external">https://github.com/springcloud</a> springcloud社区</p>
<p>可以进去看一下他们对于技术的活跃程度曲线</p>
<blockquote>
<p>2.解决问题的方向</p>
</blockquote>
<p>dubbo：定位始终是一款 RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>springcloud：微服务架构，提供微服务架构的一站式服务。</p>
<blockquote>
<p>3.功能对比</p>
</blockquote>
<p>根据两者的解决问题的域，得到他们的功能</p>
<table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>Spring</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务注册中心</td>
<td>Zookeeper</td>
<td>Spring   Cloud Netfilx Eureka</td>
</tr>
<tr>
<td>服务调用方式</td>
<td>RPC</td>
<td>REST   API</td>
</tr>
<tr>
<td>服务监控</td>
<td>Dubbo-monitor</td>
<td>Spring   Boot Admin</td>
</tr>
<tr>
<td>断路器</td>
<td>不完善</td>
<td>Spring   Cloud Netflix Hystrix</td>
</tr>
<tr>
<td>服务网关</td>
<td>无</td>
<td>Spring   Cloud Netflix Zuul</td>
</tr>
<tr>
<td>分布式配置</td>
<td>无</td>
<td>Spring   Cloud Config</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>无</td>
<td>Spring   Cloud Sleuth</td>
</tr>
<tr>
<td>消息总线</td>
<td>无</td>
<td>Spring   Cloud Bus</td>
</tr>
<tr>
<td>数据流</td>
<td>无</td>
<td>Spring   Cloud Stream</td>
</tr>
<tr>
<td>批量任务</td>
<td>无</td>
<td>Spring   Cloud Task</td>
</tr>
</tbody>
</table>
<p>Dubbo的某些功能都是，通过整合其他组件实现，springcloud是通过实现Netflix oss的技术栈和原有的技术，实现的架构。</p>
<p>Dubbo提供了各种Filter，对于上述中“无”的要素，可以通过扩展Filter来完善。</p>
<blockquote>
<p>例如</p>
<p>1．分布式配置：可以使用淘宝的diamond、百度的disconf来实现分布式配置管理</p>
<p>2．服务跟踪：可以使用京东开源的Hydra，或者扩展Filter用Zippin来做服务跟踪</p>
<p>3．批量任务：可以使用当当开源的Elastic-Job、tbschedule</p>
</blockquote>
<p>总结：从核心要素来看，Spring Cloud 更胜一筹，在开发过程中只要整合Spring Cloud的子项目就可以顺利的完成各种组件的融合，而Dubbo缺需要通过实现各种Filter来做定制，开发成本以及技术难度略高。Dubbo更像是一个组装机，springcloud是一体机。</p>
<blockquote>
<p>4.服务调用方式</p>
</blockquote>
<p>Spring Cloud抛弃了RPC通讯，采用基于HTTP的REST方式。Spring Cloud牺牲了服务调用的性能，但是同时也避免了原生RPC带来的问题。REST比RPC更为灵活，不存在代码级别的强依赖，在强调快速演化的微服务环境下，显然更合适。</p>
<blockquote>
<p>5.服务获取方式</p>
</blockquote>
<p>dubbo通过长连接推送服务提供者地址列表给消费端，即是：Dubbo订阅Zookeeper下相应的节点，当节点的状态发生改变时，Zookeeper会立即反馈订阅的Client，实时性很高。</p>
<p>springcloud的eureka是 消费者端主动去eurekaServer注册中心获取数据，消费者可以配置去EurekaServer拉去服务列表的周期</p>
<p><strong>dubbo支持各种通信协议，而且消费方和服务方使用长链接方式交互，通信速度上略胜Spring Cloud，如果对于系统的响应时间有严格要求，长链接更合适。</strong></p>
<blockquote>
<p>6.服务注册中心满足的CAP原则</p>
</blockquote>
<p>著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于分区容错性P在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。</p>
<p>Dubbo推荐使用zookeeper作为服务注册中心，zookeeper满足CP原则，一致性和分区容错性。springcloud的服务注册中心是Eureka，他满足的是AP原则，可用性和分区容错性。</p>
<p>Zookeeper如何保证CP</p>
<p> 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p>
<p>Eureka如何保证AP</p>
<p> Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的 ，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： </p>
<p> Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 </p>
<p> Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</p>
<p> 当网络稳定时，当前实例新的注册信息会被同步到其它节点中</p>
<p>因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p>
<p>总结：那么既然保证了保证了可用性，那么数据的一致性肯定是不能够保证了，所以这个就是自我保护的机制。所以到底是AP还是CP，又或者是AC（数据库），要看业务场景来定。</p>
<p>而且Eureka部署集群时非常简单的，相比于dubbo部署zookeeper集群。</p>
<blockquote>
<p>7.节点性质</p>
</blockquote>
<p>Dubbo只有Consumer订阅Provider节点，也就是Consumer发现Provider节点信息</p>
<p>Eureka不区分Consumer或者Provider，两者都统称为Client，一个Client内可能同时含有Provider，Consumer，通过服务发现组件获取的是其他所有的Client节点信息，在调用时根据应用名称来筛选节点</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、Dubbo负责人的采访&quot;&gt;&lt;a href=&quot;#一、Dubbo负责人的采访&quot; class=&quot;headerlink&quot; title=&quot;一、Dubbo负责人的采访&quot;&gt;&lt;/a&gt;一、Dubbo负责人的采访&lt;/h1&gt;&lt;p&gt;刘军，阿里巴巴中间件高级研发工程师，主导了 Dubb
    
    </summary>
    
      <category term="dubbo" scheme="http://kingge.top/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://kingge.top/tags/dubbo/"/>
    
      <category term="分布式" scheme="http://kingge.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="rpc" scheme="http://kingge.top/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>spring注解-辅助学习springboot和springcloud</title>
    <link href="http://kingge.top/2019/03/14/spring%E6%B3%A8%E8%A7%A3-%E8%BE%85%E5%8A%A9%E5%AD%A6%E4%B9%A0springboot%E5%92%8Cspringcloud/"/>
    <id>http://kingge.top/2019/03/14/spring注解-辅助学习springboot和springcloud/</id>
    <published>2019-03-14T14:59:59.000Z</published>
    <updated>2019-09-03T12:48:30.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p> 因为后面要学习sb（springboot）和sc（springcloud），所以需要学习一些相关的注解和了解他们底层代码实现，例如@import注解，Aware接口，生命周期。</p>
<p>​    通过前面几个章节的学习，你会发现无论springboot还是springcloud的很多知识都是来源于spring相关的知识，章节还有一些内容没有补充完整，后续如果有时间会逐步更新完成！！！</p>
<h1 id="2-组件注册"><a href="#2-组件注册" class="headerlink" title="2.组件注册"></a>2.组件注册</h1><p>我们知道spring得IOC容器中存储了很多类的实例化对象，那么下面介绍几种往IOC容器中注册实体类的方式</p>
<h2 id="2-1-xml配置文件实例化实体类（方式一）"><a href="#2-1-xml配置文件实例化实体类（方式一）" class="headerlink" title="2.1 xml配置文件实例化实体类（方式一）"></a>2.1 xml配置文件实例化实体类（方式一）</h2><ol>
<li><p>首先新建spring.xml 文件，通过bean 标签实例化实体类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414688035.png" alt="1567414688035"></p>
</li>
</ol>
<p>2.通过ClassPathXmlApplicationContext获取实体类</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414725611.png" alt="1567414725611"></p>
<p>缺点：大型项目的实体类会非常多，那么配置文件会变得非常的臃肿，而且也不易于维护。</p>
<h2 id="2-2-使用-Configuration和-bean（方式二）"><a href="#2-2-使用-Configuration和-bean（方式二）" class="headerlink" title="2.2 使用@ Configuration和@bean（方式二）"></a>2.2 使用@ Configuration和@bean（方式二）</h2><p>Spring提供了配置实体类的第二种方式，就是不用通过书写xml文件，通过两个注解就可以达到2.1 的功能。</p>
<ol>
<li>编写配置类，配置bean</li>
</ol>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414770812.png" alt="1567414770812"></p>
<ol>
<li><p>通过AnnotationConfigApplicationContext获取实体类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414786811.png" alt="1567414786811"></p>
</li>
</ol>
<p>这里是new了一个AnnotationConfigApplicationContext对象，以前new的ClassPathXmlApplicationContext对象，的构造函数里面传的是配置文件的位置，而现在AnnotationConfigApplicationContext对象的构造函数里面传的是配置类的类型</p>
<h2 id="2-3-ComponentScan-自动扫描组件-amp-指定扫描规则（方式三）"><a href="#2-3-ComponentScan-自动扫描组件-amp-指定扫描规则（方式三）" class="headerlink" title="2.3 @ComponentScan-自动扫描组件&amp;指定扫描规则（方式三）"></a>2.3 @ComponentScan-自动扫描组件&amp;指定扫描规则（方式三）</h2><pre><code>**实际上这个注解跟前面两种方式是配合使用的，避免书写ClassPathXmlApplicationContext或者AnnotationConfigApplicationContext** **获取IOC容器。**
</code></pre><p>我们知道，在实际开发中我们是不会通过ClassPathXmlApplicationContext这样的代码方式获取对象，而是通过包扫描的方式进行实例化对象并注入IOC容器中</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414821714.png" alt="1567414821714"></p>
<p>他的扫描规则是：以下这几个注解都是继承自@Component</p>
<p>@controller(给web层的注解)</p>
<p>@service(给serivce层加的注解)</p>
<p>@repository(给dao层加的注解) </p>
<p>@component(给java类加注解,老版本spring只有这一个注解)</p>
<p>只要书写了上面四个注解的类，那么会自动装配到ioc容器中。<strong>Id默认是类名首字母小写</strong></p>
<h3 id="1-ComponentScan注解的结构"><a href="#1-ComponentScan注解的结构" class="headerlink" title="1. @ComponentScan注解的结构"></a>1. @ComponentScan注解的结构</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414886849.png" alt="1567414886849"></p>
<p>1.这个注解上，也是可以指定要排除哪些包或者是只包含哪些包来进行管理：里面传是一个Filter[]数组。</p>
<p>2.Value ：就相当于spring的xml配置文件-</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414894134.png" alt="1567414894134"></p>
<h3 id="2-用例"><a href="#2-用例" class="headerlink" title="2.用例"></a>2.用例</h3><p>–那么我们使用配置类的方式实现component-sacn同样的功能</p>
<p>1.首先在配置文件类，添加扫描的范围</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414906119.png" alt="1567414906119"></p>
<p>2.添加几个注解类-</p>
<p>@controller（UserController）</p>
<p>@service（UserService）</p>
<p>@repository （UserDao）</p>
<p>@component（ComponentTest）</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414919145.png" alt="1567414919145"></p>
<p>3.书写IOC</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414938745.png" alt="1567414938745"></p>
<p>输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414956045.png" alt="1567414956045"></p>
<p><strong>发现-扫描进入IOC容器的bean的id默认是：类名首字母小写</strong></p>
<p>4.使用Filter去除某些注解类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414983170.png" alt="1567414983170"></p>
<p>根据注解的方式排除，排除使用@Controller注解注解的类</p>
<p>–注意在使用includeFilters 扫描只包含那些组件的时候，要禁用spring默认全局扫描（跟配置文件一样，也是需要禁用的）</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567414996062.png" alt="1567414996062"></p>
<p>例子4</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415050284.png" alt="1567415050284"></p>
<h3 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3.    扩展"></a>3.    扩展</h3><p>我们打开Component注解的源码，发现他是：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415143194.png" alt="1567415143194"></p>
<p>多了Repeatable注解，也就是说明，这个Component注解是可以多次重复用的</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415194264.png" alt="1567415194264"></p>
<p>那么你可能会问，如果不是jdk1.8,那么怎么书写多个扫描策略呢？</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415212225.png" alt="1567415212225"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415217769.png" alt="1567415217769"></p>
<p>也就是说，我们可以在配置类，使用ComponentScans注解，配置多个扫描策略</p>
<p>例子：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415246906.png" alt="1567415246906"></p>
<p>跟 { 例子4 } 效果一样</p>
<h4 id="4-1-FilterType-过滤规则"><a href="#4-1-FilterType-过滤规则" class="headerlink" title="4.1 FilterType 过滤规则"></a>4.1 FilterType 过滤规则</h4><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415321043.png" alt="1567415321043"></p>
<p>下面我们注重讲解一下，CUSTOM 自定义实现类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415342468.png" alt="1567415342468"></p>
<p>需要先实现 TypeFilter</p>
<p>1.首先定义一个扫描规则类</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415368545.png" alt="1567415368545"></p>
<ol>
<li>配置类，实现自定义过滤规则</li>
</ol>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415379844.png" alt="1567415379844"></p>
<p> 表示 – 扫描的类中如果包含er那么就会被过滤掉（注意：他是会取扫描com.kingge下面的所有类-<strong>包括哪些没有被注解，注解的类也会被扫描</strong>）</p>
<h2 id="2-4-Import注解"><a href="#2-4-Import注解" class="headerlink" title="2.4      @Import注解"></a>2.4      @Import注解</h2><p><strong>有三种使用方式</strong></p>
<p><strong>第一种写法</strong>：直接在import注解中配置需要导入的类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415399146.png" alt="1567415399146"></p>
<p>他在IOC容器中的id是：（全类名）</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415407178.png" alt="1567415407178"></p>
<p>缺点：如果有多个类需要注入IOC，那么代码量就很长</p>
<p><strong>第二种实现方式</strong>：自定义导入逻辑，批量导入，只需要返回需要导入的全类名数组</p>
<p>  实现ImportSelector 类</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415418134.png" alt="1567415418134"></p>
<p>配置类上使用</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415430330.png" alt="1567415430330"></p>
<p>这样 pp就注入到了IOC 容器中</p>
<p><strong>第三种方式</strong>：ImportBeanDefinitionRegistrar 实现这个类。</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415449102.png" alt="1567415449102"></p>
<p>例子：</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415496868.png" alt="1567415496868"></p>
<p>配置类引用</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415510372.png" alt="1567415510372"></p>
<p>调用：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415521934.png" alt="1567415521934"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415535174.png" alt="1567415535174"></p>
<h3 id="2-4-1-总结"><a href="#2-4-1-总结" class="headerlink" title="2.4.1 总结"></a>2.4.1 总结</h3><p>@Import[快速的给容器中导入一个组件]</p>
<p>（1）、 @Import(要导入容器中的组件);容器中就会自动的注册这个组件，id默认是全类名</p>
<p>（2）、 ImportSelector ：返回需要的组件的全类名的数组；</p>
<p>（3）、 ImportBeanDefinitionRegistrar : 手动注册bean到容器中</p>
<p> <strong>前面学习的springboot中，用到了该注解的次数很多。</strong></p>
<h2 id="2-5-Factorybean-工厂bean"><a href="#2-5-Factorybean-工厂bean" class="headerlink" title="2.5 Factorybean 工厂bean"></a>2.5 Factorybean 工厂bean</h2><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415551953.png" alt="1567415551953"></p>
<p>例子：</p>
<p>1.实现这个工厂bean</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415565829.png" alt="1567415565829"></p>
<p>getObject 方法：当调用bean时候，调用这个方法获取bean实例。</p>
<p>getObjectType：返回对象类型</p>
<p>isSIngleton: 是否是单例。False-表示是多例。True-表示是单例。（如果配置类中配置<strong>@Scope注解，企图改变UserDao的单实例，无效，以isDingleto方法设置为准</strong>）</p>
<p>2.配置类配置</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415579392.png" alt="1567415579392"></p>
<p>输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415589497.png" alt="1567415589497"></p>
<blockquote>
<p>输出：</p>
<p>class com.kingge.dao.UserDao</p>
<p>false</p>
</blockquote>
<p>、</p>
<p>第二个输出肯定是false</p>
<p>不过为什么第一个输出的是 Userdao的全类名而不是UserDaoFactoryBean的全类名呢？因为在构造的时候spring默认返回的就是getObjectType的值。</p>
<p>那么怎么获取这个工厂bean呢？spring提供了一个方式：加上&amp;</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415621835.png" alt="1567415621835"></p>
<p>输出：class com.kingge.utils.UserDaoFactoryBean</p>
<h2 id="2-6-总结-组件注册"><a href="#2-6-总结-组件注册" class="headerlink" title="2.6 总结-组件注册"></a>2.6 总结-组件注册</h2><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415637061.png" alt="1567415637061"></p>
<pre><code>/**

 \* 给容器中注册组件：

 \* 1）、扫描+组件标注注解（@Controller/@Service/@Repository/@Component）

 \* 【局限于要求是自己写的类，如果导入的第三方没有添加这些注解，那么就注册不上了】

 *

 \* 2）、@Bean[导入的第三方包里面的组件]

 \* 3）、@Import[快速的给容器中导入一个组件]

 \*      （1）、 @Import(要导入容器中的组件);容器中就会自动的注册这个组件，id默认是全类名

 \*      （2）、 ImportSelector ：返回需要的组件的全类名的数组；

 \*      （3）、 ImportBeanDefinitionRegistrar : 手动注册bean到容器中

 *

 \* 4）、使用Spring提供的FactoryBean（工厂bean）

 \*      （1）、默认获取到的是工厂bean调用getObject创建的对象

 \*      （2）、要获取工厂bean本身，我们需要给id前面加上一个“&amp;”符号：&amp;userDaoFactoryBean
</code></pre><p>第一种方式：一般用于自己定义的类，但是如果我们是通过导入第三方jar的方式导入了很多组件（类），但是我想把这些类注册到IOC容器中怎么办呢？这个时候就需要使用bean注解的方式注册组件。</p>
<p>第二种方式：可以实现自定义类或者第三方类的注入到IOC容器。缺点，那就是每实例化一个bean就得写个方法。这样代码量太多。</p>
<p>第三种方式：import标签（作用在配置类）</p>
<h1 id="3-修饰Bean的相关注解"><a href="#3-修饰Bean的相关注解" class="headerlink" title="3.修饰Bean的相关注解"></a>3.修饰Bean的相关注解</h1><h2 id="3-1-Scope注解"><a href="#3-1-Scope注解" class="headerlink" title="3.1 @Scope注解"></a>3.1 @Scope注解</h2><p>他一般是<strong>和@Bean注解配套使用</strong>，标识实体类的作用范围。我们知道IOC容器中的实体类，默认是单实例的。</p>
<p>证明：</p>
<ol>
<li>自定义IOC容器-实现配置类</li>
</ol>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415657803.png" alt="1567415657803"></p>
<p>2.获取 Person实体类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415670181.png" alt="1567415670181"></p>
<p>我们不难发现-这里输出的是true，所以spring扫描bean策略默认是单实例。</p>
<p>那么怎么修改这种作用域呢？</p>
<p>查看Scope注解源码，发现可以指定这四种类型的作用范围</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415683803.png" alt="1567415683803"></p>
<p>第一个是多实例，第二个是：单实例（<strong>默认值</strong>）</p>
<p>第三个是：web环境下，用一个请求创建一次实例</p>
<p>第四个是：web环境下，同一个session创建一次实例</p>
<p>那么上诉代码只需要修改为</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415696308.png" alt="1567415696308"></p>
<p>这样就是多实例。</p>
<p><strong>总结：</strong></p>
<p>   单实例：在IOC容器启动的时候就已经实例化好Person（调用getPerson实例化），那么每次获取的时候直接从IOC容器中拿。</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415714441.png" alt="1567415714441"></p>
<p>这段代码运行时候会去调用getPerson方法完成实例</p>
<p>多实例：IOC容器启动时，不会去实例化Person，而是每次获取的时候才会去调用getPerson获取对象。</p>
<h2 id="3-2-Lazy注解"><a href="#3-2-Lazy注解" class="headerlink" title="3.2 @Lazy注解"></a>3.2 @Lazy注解</h2><p><strong>和@Bean注解配套使用，解决单实例bean在IOC容器启动就马上创建实例的问题。</strong></p>
<p><strong>懒加载bean，这个只对于单实例的情况下才有用</strong></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415726984.png" alt="1567415726984"></p>
<p>也就是IOC容器初始化的时候，不会去调用getPerson，实例化Person。<strong>第一次获取的时候才会去创建，以后再使用该实例化，会使用以前获取的</strong></p>
<h2 id="3-3-Conditional"><a href="#3-3-Conditional" class="headerlink" title="3.3 @Conditional"></a>3.3 @Conditional</h2><p>根据满足某个特定的条件创建一个特定的Bean。</p>
<p>因为我们可能存在一个需求那就是，根据不同的业务场景我们会有选择性的实例化某些bean，那么就可以使用这个注解。</p>
<h3 id="1-例子"><a href="#1-例子" class="headerlink" title="1.例子"></a>1.例子</h3><p> 需求：根据不同的系统实例化不同的bean。</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415756903.png" alt="1567415756903"></p>
<p>输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415769824.png" alt="1567415769824"></p>
<p>l  <strong>增加需求</strong> <strong>–</strong> <strong>当使用windows系统时，在IOC容器中创建windows实体类，反之创建linux</strong> <strong>实体类</strong></p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415788706.png" alt="1567415788706"></p>
<p>\1.      实现两个 条件类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415816993.png" alt="1567415816993"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415830634.png" alt="1567415830634"></p>
<p>2.配置类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415842983.png" alt="1567415842983"></p>
<p>\2.      实例化IOC 容器</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415854254.png" alt="1567415854254"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415865773.png" alt="1567415865773"></p>
<p>你会发现仅仅只是实例化了windows，linux实体类已经不见了，那么说明是条件生效了。</p>
<p>备注：</p>
<p>   @Conditional注解是可以作用在配置类上面的，那么他的作用就是全局的条件，只有满足了这个条件，配置类里面的bean才能够实例化。（局部方法配置Conditional注解会失效）</p>
<h1 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4.生命周期"></a>4.生命周期</h1><pre><code>我们知道，Bean的生命周期是由IOC容器来管理的，那么我们也是可以自定义初始化方法和销毁方法。
</code></pre><p>Bean生命周期：<strong>bean创建-初始化-销毁</strong>，那么下面我们将来介绍，能够控制Bean生命周期的几种方式。</p>
<h2 id="4-1-init-method、destory-method-管理bean生命周期"><a href="#4-1-init-method、destory-method-管理bean生命周期" class="headerlink" title="4.1. init-method、destory-method 管理bean生命周期"></a>4.1. init-method、destory-method 管理bean生命周期</h2><p>需要注意的是，单实例和多实例的情况下，bean生命周期是不一样的。<strong>单实例bean的生命周期全部托管给IOC容器，多实例部分托管</strong>。</p>
<h3 id="1-在配置文件XML中："><a href="#1-在配置文件XML中：" class="headerlink" title="1.在配置文件XML中："></a>1.在配置文件XML中：</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415958501.png" alt="1567415958501"></p>
<p>这两个方法是来控制初始化和销毁的</p>
<h3 id="2-代码控制初始化和销毁"><a href="#2-代码控制初始化和销毁" class="headerlink" title="2.代码控制初始化和销毁"></a>2.代码控制初始化和销毁</h3><h4 id="单实例情况下"><a href="#单实例情况下" class="headerlink" title="单实例情况下"></a>单实例情况下</h4><p>其实也就是在Bean注解，上填充init-method和destory-method方法</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415979268.png" alt="1567415979268"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415990937.png" alt="1567415990937"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567415998217.png" alt="1567415998217"></p>
<p>输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416012675.png" alt="1567416012675"></p>
<p><strong>因为是单实例的原因</strong>-所以容器启动的时候就开始调用了无参构造器创建对象，然后调用init初始化方法，容器关闭时，调用销毁方法.</p>
<h4 id="多实例情况下"><a href="#多实例情况下" class="headerlink" title="多实例情况下"></a>多实例情况下</h4><p>我们把配置类获取Car对象的方法改为多实例的形式，观察输出。</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416024604.png" alt="1567416024604"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416034091.png" alt="1567416034091"></p>
<p>输出</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416054016.png" alt="1567416054016"></p>
<p>我们发现我们在关闭容器的时候，<strong>他并没有调用destory销毁实例</strong>，因为多实例的bean他是不归于容器管辖，需要我们自己手动销毁</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>总的来说，bean在IOC容器的生命周期如下：</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416082833.png" alt="1567416082833"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* 我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法</div><div class="line">* </div><div class="line">* 构造（对象创建）</div><div class="line">* 		单实例：在容器启动的时候创建对象</div><div class="line">* 		多实例：在每次获取的时候创建对象</div><div class="line">* </div><div class="line">* BeanPostProcessor.postProcessBeforeInitialization</div><div class="line">* 初始化：</div><div class="line">* 		对象创建完成，并赋值好，调用初始化方法。。。</div><div class="line">* BeanPostProcessor.postProcessAfterInitialization</div><div class="line">* 销毁：</div><div class="line">* 		单实例：容器关闭的时候</div><div class="line">* 		多实例：容器不会管理这个bean；容器不会调用销毁方法；</div></pre></td></tr></table></figure>
<h2 id="4-2-InitializingBean和DisposableBean-控制bean生命周期"><a href="#4-2-InitializingBean和DisposableBean-控制bean生命周期" class="headerlink" title="4.2 InitializingBean和DisposableBean 控制bean生命周期"></a>4.2 InitializingBean和DisposableBean 控制bean生命周期</h2><h3 id="1单实例情况下"><a href="#1单实例情况下" class="headerlink" title="1单实例情况下"></a>1单实例情况下</h3><p>1.新建Food类实现这两个接口</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416100346.png" alt="1567416100346"></p>
<p>配置类扫描</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416118482.png" alt="1567416118482"></p>
<p>测试</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416129315.png" alt="1567416129315"></p>
<p>输出：</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416137640.png" alt="1567416137640"></p>
<p>很明显单实例情况下，bean的生命周期是全部托管到IOC容器中。</p>
<h3 id="2-多实例情况下"><a href="#2-多实例情况下" class="headerlink" title="2.多实例情况下"></a>2.多实例情况下</h3><p>如果Food注入IOC容器时，选择多实例的方式的话，那么上面的案例在启动IOC容器时，不会有任何输出，因为多实例的情况下只有获取对象才会去做相关的初始化工作。</p>
<p>验证1：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416163330.png" alt="1567416163330"></p>
<p>没有任何输出。</p>
<p>验证2：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416175448.png" alt="1567416175448"></p>
<p>输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416191108.png" alt="1567416191108"></p>
<h3 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3.总结"></a>3.总结</h3><blockquote>
<p><strong>很明显没有调用DisposableBean接口的destory方法和自定义的destory方法。</strong></p>
<p><strong>也就是说在多实例的情况下IOC容器只帮我们做创建和初始化bean的工作，但是销毁bean的工作他没有帮我们做，需要自己去实现。</strong></p>
</blockquote>
<h2 id="4-3-PostConstruct和-PreDestroy注解"><a href="#4-3-PostConstruct和-PreDestroy注解" class="headerlink" title="4.3 @PostConstruct和@PreDestroy注解"></a>4.3 @PostConstruct和@PreDestroy注解</h2><p>这两个注解是作用在方法上面的。</p>
<p>可以使用JSR250规范里面定义的两个注解：</p>
<p>@PostConstruct :在bean创建完成并且属性赋值完成，来执行初始化方法</p>
<p>@PreDestroy ：在容器销毁bean之前通知我们来进行清理工作</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416209944.png" alt="1567416209944"></p>
<p>初始化容器</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416222017.png" alt="1567416222017"></p>
<p>输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416237939.png" alt="1567416237939"></p>
<p>很明显-这两个注解的作用比4.2章节的两个接口的重载方法的调用更早，注意看官方的 注释说明</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416255764.png" alt="1567416255764"></p>
<p><strong>注意：这两个注解注解的方法，无返回值（void）</strong></p>
<h2 id="4-4-BeanPostProcessor-后置处理接口（重要）"><a href="#4-4-BeanPostProcessor-后置处理接口（重要）" class="headerlink" title="4.4 BeanPostProcessor 后置处理接口（重要）"></a>4.4 BeanPostProcessor 后置处理接口（重要）</h2><p>我们发现上面三种管理bean生命周期的方式，他们的方法是没有入参和出参的。，下面这种方式提供了</p>
<p>BeanPostProcessor接口：bean的后置处理器，在bean初始化前后做一些处理工作，这个接口有两个方法：</p>
<p>postProcessBeforeInitialization：在初始化之前工作</p>
<p>postProcessAfterInitialization：在初始化之后工作</p>
<p>（1）. 实现Food实体类</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416280606.png" alt="1567416280606"></p>
<p>（2）.配置类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416311128.png" alt="1567416311128"></p>
<p>（3）.  启动容器查看输出</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416341585.png" alt="1567416341585"></p>
<p>（4）输出</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416364626.png" alt="1567416364626"></p>
<p><strong>他没有销毁方法。</strong></p>
<h2 id="4-1-4-4总结"><a href="#4-1-4-4总结" class="headerlink" title="4.1-4.4总结"></a>4.1-4.4总结</h2><p>上面这四种方式调用顺序</p>
<p>对象构造器 –&gt;&gt; PostConstruct -&gt;&gt; afterPropertiesSet -&gt;&gt; init-method -&gt;&gt; <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416382230.png" alt="1567416382230"> -&gt;&gt;   <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416398530.png" alt="1567416398530">-&gt;&gt;PreDestroy注解 自定义实现的destory方法-&gt;&gt; DisposableBean的destroy方法 -&gt;&gt;Food 自定义实现的destoryMethod方法</p>
<p>销毁：</p>
<p>  @PreDestroy注解的 PreDestroy —》DisposableBean接口的destory —》 destroy-method</p>
<h2 id="4-5BeanPostProcessor-原理"><a href="#4-5BeanPostProcessor-原理" class="headerlink" title="4.5BeanPostProcessor 原理"></a>4.5BeanPostProcessor 原理</h2><h3 id="1-两个方法打上断点"><a href="#1-两个方法打上断点" class="headerlink" title="1.两个方法打上断点"></a>1.两个方法打上断点</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416431574.png" alt="1567416431574"></p>
<p>Dubug方式启动IOC容器</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416442452.png" alt="1567416442452"></p>
<p>2.查看方法栈调用</p>
<p>创建容器构造器</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416469689.png" alt="1567416469689"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416483129.png" alt="1567416483129"></p>
<pre><code>前置处理器调用的方法：调用getBeanPostProcessors()方法找到容器里面的所有的BeanPostProcessor，挨个遍历，调用BeanPostProcessor的postProcessBeforeInitialization方法，一旦调用postProcessBeforeInitialization方法的返回值为null的时候，就直接跳出遍历 ，后面的BeanPostProcessor 的postProcessBeforeInitialization也就不会执行了：
</code></pre><p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416501945.png" alt="1567416501945"></p>
<p>后置处理器调用的方法：调用getBeanPostProcessors()方法找到容器里面的所有的BeanPostProcessor，挨个遍历，调用BeanPostProcessor的postProcessAfterInitialization方法，一旦调用postProcessAfterInitialization方法的返回值为null的时候，就直接跳出遍历 ，后面的BeanPostProcessor 的postProcessAfterInitialization也就不会执行了：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416524867.png" alt="1567416524867"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416538029.png" alt="1567416538029"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416547870.png" alt="1567416547870"></p>
<h3 id="2-BeanPostProcessor在springboot中的使用"><a href="#2-BeanPostProcessor在springboot中的使用" class="headerlink" title="2.BeanPostProcessor在springboot中的使用"></a>2.BeanPostProcessor在springboot中的使用</h3><p>查看该接口的实现类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416562220.png" alt="1567416562220"></p>
<p>这个接口，其实在spring的IOC容器中使用的频率是很多的，而且spring提供了很多实现类，例如如果我们想在bean中使用IOC容器的话，那么就可以使用</p>
<h3 id="1-ApplicationContextAwareProcessor"><a href="#1-ApplicationContextAwareProcessor" class="headerlink" title="1.ApplicationContextAwareProcessor"></a>1.ApplicationContextAwareProcessor</h3><p>给实体类，注入IOC容器。</p>
<p>ApplicationContextAware 接口，注入IOC容器</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416620035.png" alt="1567416620035"></p>
<p>例如：Dog实体类需要使用到IOC容器，那么就可以实现这个接口</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416633367.png" alt="1567416633367"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416638886.png" alt="1567416638886"></p>
<p>然后 他实际上是去 调用这个ApplicationContextAwareProcessor，方法，在创建Dog 对象他会去调用 postProcessBeforeInitialization 方法，判断实例化</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416668422.png" alt="1567416668422"></p>
<p>然后判断当前Dog实体类是否实现了ApplicationContextAware，如果是，那么调用invokeAwareInterface注入，IOC容器。</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416682517.png" alt="1567416682517"></p>
<p>最终去调用 Dog的 setApplicationContext 方法，赋值。</p>
<h3 id="1-BeanValidationPostProcessor"><a href="#1-BeanValidationPostProcessor" class="headerlink" title="1.    BeanValidationPostProcessor"></a>1.    BeanValidationPostProcessor</h3><p>实体类校验，后置处理器</p>
<h3 id="2-InitDestroyAnnotationBeanPostProcessor"><a href="#2-InitDestroyAnnotationBeanPostProcessor" class="headerlink" title="2.InitDestroyAnnotationBeanPostProcessor"></a>2.InitDestroyAnnotationBeanPostProcessor</h3><p>这个处理类，就是处理，我们3.3章节的两个注解。</p>
<h3 id="3-AutowiredAnnotationBeanPostProcessor"><a href="#3-AutowiredAnnotationBeanPostProcessor" class="headerlink" title="3.AutowiredAnnotationBeanPostProcessor"></a>3.AutowiredAnnotationBeanPostProcessor</h3><p>这个类就是处理我们的Autoware注解的</p>
<h3 id="4-BeanFactoryPostProcessor"><a href="#4-BeanFactoryPostProcessor" class="headerlink" title="4. BeanFactoryPostProcessor"></a>4. BeanFactoryPostProcessor</h3><p>BeanFactory的后置处理器，在BeanFactory的标准初始化之后调用</p>
<p>所有bean的定义已经保存加载到BeanFactory，但是bean的实例还未创建</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416709158.png" alt="1567416709158"></p>
<p>运行IOC容器</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416721160.png" alt="1567416721160"></p>
<p>查看输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416731721.png" alt="1567416731721"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416742609.png" alt="1567416742609"></p>
<p><strong>很明显他是在bean实例创建之前执行的。</strong></p>
<p>  BeanFactoryPostProcessor原理:</p>
<p>  1)、ioc容器创建对象</p>
<p>  2)、invokeBeanFactoryPostProcessors(beanFactory);</p>
<pre><code>如何找到所有的BeanFactoryPostProcessor并执行他们的方法；

          1）、直接在BeanFactory中找到所有类型是BeanFactoryPostProcessor的组件，并执行他们的方法

          2）、在初始化创建其他组件前面执行
</code></pre><h3 id="5-BeanDefinitionRegistryPostProcessor"><a href="#5-BeanDefinitionRegistryPostProcessor" class="headerlink" title="5.BeanDefinitionRegistryPostProcessor"></a>5.BeanDefinitionRegistryPostProcessor</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416769528.png" alt="1567416769528"></p>
<p>启动ioc容器查看输出</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416783886.png" alt="1567416783886"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416793969.png" alt="1567416793969"></p>
<h3 id="6-ApplicationListener"><a href="#6-ApplicationListener" class="headerlink" title="6. ApplicationListener"></a>6. ApplicationListener</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416807398.png" alt="1567416807398"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416820306.png" alt="1567416820306"></p>
<h1 id="5-属性赋值"><a href="#5-属性赋值" class="headerlink" title="5.属性赋值"></a>5.属性赋值</h1><h2 id="5-1-Value注解"><a href="#5-1-Value注解" class="headerlink" title="5.1 @Value注解"></a>5.1 @Value注解</h2><p>这个注解一般是作用在类的属性上面，他的作用等同于</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417097750.png" alt="1567417097750"></p>
<p>那么他可以书写那些值呢？</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416934645.png" alt="1567416934645"></p>
<p>第三种是取配置文件的数据</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416950884.png" alt="1567416950884"></p>
<p>那么怎么使用 第三种方式赋值呢？下面讲解</p>
<h2 id="5-2-PropertySource-注解"><a href="#5-2-PropertySource-注解" class="headerlink" title="5.2 @ PropertySource 注解"></a>5.2 @ PropertySource 注解</h2><p>他的作用相当于XML的：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567416959675.png" alt="1567416959675"></p>
<p>1.配置类添加配置注解</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417123219.png" alt="1567417123219"></p>
<p>2.Person实体类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417130983.png" alt="1567417130983"></p>
<p>输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417138775.png" alt="1567417138775"></p>
<p>我们也可以通过IOC容器手动的去获取配置的信息</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417160484.png" alt="1567417160484"></p>
<h2 id="3-3-通过实现-EmbeddedValueResolverAware-获取属性值"><a href="#3-3-通过实现-EmbeddedValueResolverAware-获取属性值" class="headerlink" title="3.3   通过实现 EmbeddedValueResolverAware 获取属性值"></a>3.3   通过实现 EmbeddedValueResolverAware 获取属性值</h2><p>l  <strong>见6.5</strong> <strong>章节</strong></p>
<h1 id="6-自动装配"><a href="#6-自动装配" class="headerlink" title="6.自动装配"></a>6.自动装配</h1><h2 id="6-1-Autowire、-Qualifier、-Primary（spring规范的注解）"><a href="#6-1-Autowire、-Qualifier、-Primary（spring规范的注解）" class="headerlink" title="6.1 @Autowire、@Qualifier、@Primary（spring规范的注解）"></a>6.1 @Autowire、@Qualifier、@Primary（spring规范的注解）</h2><p>在spring的项目中我们是经常这个Autowire来进行实体类之间的依赖注入，他的注入规则是：</p>
<p>\1.      默认按照类型去IOC容器中查找需要的实体类（例如UserDao.class）</p>
<p>\2.      如果找到多个同类型的实体类，那么他会根据属性名作为组件ID去进一步匹配。</p>
<p>例如：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417175481.png" alt="1567417175481"></p>
<p>然后IOC容器中有两个UserDao实例，一个是ID为userDao，一个ID为userDao1.</p>
<p>那么上面service注入的是哪一个呢？</p>
<p>  答案：注入的是ID为userDao的实体类。如果想要注入userDao1，那么应该把属性名改为userDao1</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417185951.png" alt="1567417185951"></p>
<p>@Qualifier，指定需要装配的ID，取消默认根据属性名去匹配。</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417197152.png" alt="1567417197152"> 默认是必须找到需要的依赖实体类，然后注入Service，否则就会报错，我们可以使用required属性来控制</p>
<p>@Primary ： <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417205766.png" alt="1567417205766"></p>
<p>这个注解是作用在被依赖的实体类（UserDao）上面，明确指定，当某个类（UserService）依赖这个实体类的时候，假设IOC容器中存在多个相同类型的被依赖类（UserDao）那么首选呗Primary注解的被依赖类。（</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417215346.png" alt="1567417215346"></p>
<p>如果UserService同时使用了@Qualifier<strong>注解</strong> ，那么@Primary的效果将会失效，以Qualifier注解需要的ID为主</p>
<h3 id="Autowire注解扩展"><a href="#Autowire注解扩展" class="headerlink" title="@Autowire注解扩展"></a>@Autowire注解扩展</h3><p>他可以标在构造器上，方法上</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417225715.png" alt="1567417225715"></p>
<h2 id="6-2-Resource、-Inject（java规范的注解）"><a href="#6-2-Resource、-Inject（java规范的注解）" class="headerlink" title="6.2 @Resource、@Inject（java规范的注解）"></a>6.2 @Resource、@Inject（java规范的注解）</h2><pre><code>![1567417242591](spring注解-辅助学习springboot和springcloud\1567417242591.png)
</code></pre><p><strong>@Resource注解</strong></p>
<p>他的作用跟@Autowire注解的作用是一样的，默认根据属性名进行装配。Name属性可以更改装配的id</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417260280.png" alt="1567417260280"></p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417265681.png" alt="1567417265681"></p>
<p><strong>@Inject</strong> <strong>的使用，需要添加依赖</strong></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417277299.png" alt="1567417277299"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417283634.png" alt="1567417283634"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417290770.png" alt="1567417290770"></p>
<p>支持@Primary功能，但是他没有属性</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417301282.png" alt="1567417301282"></p>
<h2 id="6-3-Aware接口-（重要）"><a href="#6-3-Aware接口-（重要）" class="headerlink" title="6.3 Aware接口 （重要）"></a>6.3 Aware接口 （重要）</h2><p>自定义组件想要使用Spring容器底层的一些组件（ApplicationContext、BeanFactory…）</p>
<p>自定义组件实现xxxAware接口就可以实现，在创建对象的时候，会调用接口规定的方法注入相关的组件，把Spring底层的一些组件注入到自定义的bean中。 xxxAware等这些都是</p>
<p>利用<strong>后置处理器的机制</strong>，比如ApplicationContextAware 是通过ApplicationContextAwareProcessor来进行处理的。</p>
<p>如果我们想在自定义实体类中，使用IOC容器的context怎么办呢？</p>
<p>例子：我有在第四章节中 BeanPostProcessor中讲过。</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417315217.png" alt="1567417315217"></p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417323109.png" alt="1567417323109"></p>
<p>例子：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417358798.png" alt="1567417358798"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417366098.png" alt="1567417366098"></p>
<h3 id="1-下面我们就是用一个例子来详细讲解一下Aware接口的工作流程。"><a href="#1-下面我们就是用一个例子来详细讲解一下Aware接口的工作流程。" class="headerlink" title="1.下面我们就是用一个例子来详细讲解一下Aware接口的工作流程。"></a>1.下面我们就是用一个例子来详细讲解一下Aware接口的工作流程。</h3><p>（1）.实现一个entity，实现<strong>ApplicationContextAware</strong> 接口</p>
<p>实现该接口的setApplicationContext方法。</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417382674.png" alt="1567417382674"></p>
<p>（2）. 配置类，配置Blue实体类，实例化到IOC容器中</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417392347.png" alt="1567417392347"></p>
<p>（3）.获取IOC容器</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417433281.png" alt="1567417433281"></p>
<p>（4）输出</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417443301.png" alt="1567417443301"></p>
<h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h3><p>在setApplicationContext 打个断点。</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417460772.png" alt="1567417460772"></p>
<p>发现他是去调用 ApplicationContextAwareProcessor 实体类，这个实体类实现了BeanPostProcessor 后置处理器。</p>
<p>2.执行postProcessBeforeInitialization 前置方法，判断当前的实体类是否继承了某些接口。做一些权限判断</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417474653.png" alt="1567417474653"></p>
<p>3.然后调用 invokeAwareInterfaces ，紧接着调用实体类实现的 <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417484555.png" alt="1567417484555"> 方法，注入IOC容器</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417501646.png" alt="1567417501646"></p>
<h2 id="6-4-Profile注解"><a href="#6-4-Profile注解" class="headerlink" title="6.4 @Profile注解"></a>6.4 @Profile注解</h2><pre><code>和Springboot的profile是一致的。
</code></pre><p>@profile注解是spring提供的一个用来标明当前运行环境的注解。我们正常开发的过程中经常遇到的问题是，开发环境是一套环境，qa测试是一套环境，线上部署又是一套环境。这样从开发到测试再到部署，会对程序中的配置修改多次，尤其是从qa到上线这个环节，让qa的也不敢保证改了哪个配置之后能不能在线上运行。</p>
<p>为了解决上面的问题，我们一般会使用一种方法，就是配置文件，然后通过不同的环境读取不同的配置文件，从而在不同的场景中跑我们的程序。</p>
<p>那么，spring中的@profile注解的作用就体现在这里。在spring使用DI来依赖注入的时候，能够根据当前制定的运行环境来注入相应的bean。最常见的就是使用不同的DataSource了。</p>
<p><strong>下面-结合</strong> <strong>properties配置文件的三种注入方式来讲解一下@Profile注解的用法</strong></p>
<p>—-以作用在方法上，表示只要在当前设置的环境下才会往IOC容器中注册当前bean。</p>
<p>—-作用在类上面 </p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417520813.png" alt="1567417520813"></p>
<p>类里面的所有bean，能够被注册到IOC容器中的条件是：只要开发环境满足了当前配置类上面的Prifile注解标识的环境。 </p>
<p>例如：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417527878.png" alt="1567417527878"></p>
<p>主要开发环境是test 里面的bean才能够被注册。</p>
<p>-</p>
<h2 id="6-5-profile的使用"><a href="#6-5-profile的使用" class="headerlink" title="6.5 @profile的使用"></a>6.5 @profile的使用</h2><p>我们知道，如果在组件上标识了这个注解，那么如果没有激活，那么就不会被注册到IOC容器中。通过这个特性来过滤一些组件的注册。</p>
<p>@Profile(“default”) 是默认注册某个bean</p>
<p>1.配置类</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417566591.png" alt="1567417566591"></p>
<p>2.测试</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417580291.png" alt="1567417580291"></p>
<p>输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417588458.png" alt="1567417588458"></p>
<p>很明显，三个配置都没有被注册在IOC容器中，因为没有指定运行环境。</p>
<p>\3.      制定运行环境（第一种方式：虚拟机参数位置添加-Dspring.profiles.active=test）</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417616396.png" alt="1567417616396"></p>
<p>这样</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417625690.png" alt="1567417625690"> 就会输出了。</p>
<p>\4.      制定运行环境（第二种方式-代码方式）</p>
<p> <img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417638837.png" alt="1567417638837"></p>
<p>可以指定多个配置环境</p>
<p>输出：</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417653302.png" alt="1567417653302"></p>
<h1 id="7-AOP"><a href="#7-AOP" class="headerlink" title="7.AOP"></a>7.AOP</h1><blockquote>
<p> 什么叫AOP和他的作用</p>
</blockquote>
<p>在程序运行期间，动态的将某段代码切入到指定方法运行时的指定时机运行，其实就是动态代理。</p>
<blockquote>
<p>作用场景</p>
</blockquote>
<pre><code>可以在某个业务实现的过程前后，或者出现异常，进行一些额外业务的操作。例如当你调用add()方法进行加法运算的时候，我们可以在调用方法前，得到结果后，或者出现异常时，记录一些日志。以前我们传统的做法是，在方法里面打印日志（System.out.println）,但是这样会造成耦合，而且我们也想把打印日志抽离成一个统一的模块。
</code></pre><h2 id="1-例子-1"><a href="#1-例子-1" class="headerlink" title="1.  例子"></a>1.  例子</h2><p> Maven依赖：spring提供了对AOP的支持</p>
<h3 id="（1）导入aop依赖"><a href="#（1）导入aop依赖" class="headerlink" title="（1）导入aop依赖"></a>（1）导入aop依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.3.14.RELEASE&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="（2）MathCalculator-java"><a href="#（2）MathCalculator-java" class="headerlink" title="（2）MathCalculator.java"></a>（2）MathCalculator.java</h3><pre><code>业务逻辑类：要求在业务方法运行时打印日志
</code></pre><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417713757.png" alt="1567417713757"></p>
<h3 id="（3）：日志切面类：LogAspects-java"><a href="#（3）：日志切面类：LogAspects-java" class="headerlink" title="（3）：日志切面类：LogAspects.java"></a>（3）：日志切面类：LogAspects.java</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.aop;</div><div class="line"></div><div class="line">import java.util.Arrays;</div><div class="line"></div><div class="line">import org.aspectj.lang.JoinPoint;</div><div class="line">import org.aspectj.lang.annotation.After;</div><div class="line">import org.aspectj.lang.annotation.AfterReturning;</div><div class="line">import org.aspectj.lang.annotation.AfterThrowing;</div><div class="line">import org.aspectj.lang.annotation.Aspect;</div><div class="line">import org.aspectj.lang.annotation.Before;</div><div class="line">import org.aspectj.lang.annotation.Pointcut;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 切面类</div><div class="line"> * @Aspect： 告诉Spring当前类是一个切面类</div><div class="line"> *</div><div class="line"> */</div><div class="line">@Aspect</div><div class="line">public class LogAspects &#123;</div><div class="line"></div><div class="line">	//抽取公共的切入点表达式</div><div class="line">	//1、本类引用</div><div class="line">	//2、其他的切面引用</div><div class="line">	@Pointcut(&quot;execution(public int com.kingge.aop.MathCalculator.*(..))&quot;)</div><div class="line">	public void pointCut()&#123;&#125;;</div><div class="line"></div><div class="line">	//@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入）</div><div class="line">	@Before(&quot;pointCut()&quot;)</div><div class="line">	public void logStart(JoinPoint joinPoint)&#123;</div><div class="line">		Object[] args = joinPoint.getArgs();</div><div class="line">		System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;运行。。。@Before:参数列表是：&#123;&quot;+Arrays.asList(args)+&quot;&#125;&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@After(&quot;com.kingge.aop.LogAspects.pointCut()&quot;)</div><div class="line">	public void logEnd(JoinPoint joinPoint)&#123;</div><div class="line">		System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;结束。。。@After&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//JoinPoint一定要出现在参数表的第一位</div><div class="line">	@AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)</div><div class="line">	public void logReturn(JoinPoint joinPoint,Object result)&#123;</div><div class="line">		System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;正常返回。。。@AfterReturning:运行结果：&#123;&quot;+result+&quot;&#125;&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)</div><div class="line">	public void logException(JoinPoint joinPoint,Exception exception)&#123;</div><div class="line">		System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;异常。。。异常信息：&#123;&quot;+exception+&quot;&#125;&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>这四个方法，都是作用在MathCalculator的add方法，那么他们的切入点表达式都是一样的，为了避免重复书写，我们一般采用抽取公共切入点的方式，抽取出来，复用。---- 使用@PoinCut注解
</code></pre><blockquote>
<p> 切面类中的方法也称为通知方法：</p>
<p>  前置通知(@Before)：在目标方法运行之前运行</p>
<p>  后置通知(@After)：在目标方法运行之后运行，即使出现异常也会运行</p>
<p>  返回通知(@AfterReturning)：在目标方法正常返回之后运行</p>
<p>  异常通知(@AfterThrowing)：在目标方法运行出现异常之后运行</p>
<p>  环绕通知(@Around)：动态代理，手动推进目标方法的运行</p>
</blockquote>
<h3 id="（4）开启spring切面自动代理"><a href="#（4）开启spring切面自动代理" class="headerlink" title="（4）开启spring切面自动代理"></a>（4）开启spring切面自动代理</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417746703.png" alt="1567417746703"></p>
<pre><code>**使用Spring的切面需要开启Spring的切面自动代理，只需要在配置类中加注解@EnableAspectJAutoProxy，Spring中有很多@EnableXxx（关于这点我们在springcloud中使用的最多，自动配置）注解，用来开启一些功能**
</code></pre><blockquote>
<pre><code>配置bean怎么区分哪个bean是切面类呢，它会看哪个类上有@Aspect注解，另外切面方法的执行仅对Spring容器中的bean起作用，对于我们自己new出来的对象是不起作用的，原因也很简单，我们自己创建的bean并没有被spring管理，也就没有为其设置切面方法等。

    通过JoinPoint对象获取调用目标方法时的信息，比如方法名、参数等，使用returning指定用通知方法的哪个入参接收返回值，使用throwing指定用哪个入参接收异常，另外如果使用JoinPoint，则必须将其放在切面方法入参的第一个位置，否则会报错
</code></pre></blockquote>
<h3 id="（5）测试"><a href="#（5）测试" class="headerlink" title="（5）测试"></a>（5）测试</h3><blockquote>
<p> 正常计算</p>
</blockquote>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417764521.png" alt="1567417764521"></p>
<blockquote>
<p>错误计算</p>
</blockquote>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567472449448.png" alt="1567472449448"></p>
<p>给一个出现异常的 1 /0 运算处理，查看日志。</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417773670.png" alt="1567417773670"></p>
<p>你会发现，无论是否出现异常 logStart 和 logEnd 都会正常输出，如果正常返回那么<code>@AfterReturning标识的方法</code>会被调用，如果运算发生异常那么<code>@AfterReturning标识的方法</code>不会被调用，而<code>@AfterThrowing标识的异常处理方法会被调用</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417705277.png" alt="1567417705277"></p>
<h2 id="2-AOP原理"><a href="#2-AOP原理" class="headerlink" title="2.  AOP原理"></a>2.  AOP原理</h2><p>通过上面的例子我们知道，实现AOP的关键点在于我么能使用@EnableAspectJAutoProxy注解，那么接下来我们查看一下这个注解到底做了什么工作</p>
<h3 id="1-查看-EnableAspectJAutoProxy注解"><a href="#1-查看-EnableAspectJAutoProxy注解" class="headerlink" title="1.查看@EnableAspectJAutoProxy注解"></a>1.查看@EnableAspectJAutoProxy注解</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417786810.png" alt="1567417786810"></p>
<p>两个属性的含义：</p>
<blockquote>
<pre><code>英文注解已经很详细了,这里简单介绍一下两个参数,一个是控制aop的具体实现方式,为true 的话使用cglib,为false的话使用java的Proxy,默认为false,第二个参数控制代理的暴露方式,解决内部调用不能使用代理的场景，默认为false
</code></pre></blockquote>
<h3 id="2-查看一下-AspectJAutoProxyRegistrar-java-到底导入了哪些类"><a href="#2-查看一下-AspectJAutoProxyRegistrar-java-到底导入了哪些类" class="headerlink" title="2.查看一下 AspectJAutoProxyRegistrar.java 到底导入了哪些类"></a>2.查看一下 AspectJAutoProxyRegistrar.java 到底导入了哪些类</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417799676.png" alt="1567417799676"></p>
<p>很明显这个类是采用了ImportBeanDefinitionRegistrar的方式注册了某些类大oIOC容器中，那么我们看一下他到底注入了什么类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">核心是这里： AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</div></pre></td></tr></table></figure>
<pre><code>一个AOP的工具类,这个工具类的主要作用是把AnnotationAwareAspectJAutoProxyCreator这个类定义为BeanDefinition放到spring容器中,这是通过实现ImportBeanDefinitionRegistrar接口来装载的,具体装载过程不是本篇的重点,这里就不赘述,我们重点看AnnotationAwareAspectJAutoProxyCreator这个类.
</code></pre><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/5C1567438805334.png" alt="1567438805334"></p>
<pre><code>从类图是可以大致了解AnnotationAwareAspectJAutoProxyCreator这个类的功能.它实现了一系列Aware的接口,在Bean装载的时候获取BeanFactory(Bean容器),Bean的ClassLoader,还实现了order接口,继承了PorxyConfig,ProxyConfig中主要封装了代理的通用处理逻辑,比如设置目标类,设置使用cglib还是java proxy等一些基础配置.

而能够让这个类参与到bean初始化功能,并为bean添加代理功能的还是因为它实现了BeanPostProcessor这个接口.这个接口的postProcessAfterInitialization方法会在bean初始化结束后(赋值完成)被调用。
</code></pre><h3 id="3-最顶部的抽象类-AbstractAutoProxyCreator"><a href="#3-最顶部的抽象类-AbstractAutoProxyCreator" class="headerlink" title="3.最顶部的抽象类:AbstractAutoProxyCreator"></a>3.最顶部的抽象类:AbstractAutoProxyCreator</h3><p>注意看bean初始化的方法</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/5C1567439298675.png" alt="1567439298675"></p>
<pre><code>当我们开启了EbableAspectJAutoProxy后,每次Bean的装配时,都会执行这段逻辑.前面主要是校验是否需要对bean进行代理(特殊的类,和已经被代理),核心逻辑在后面几行.getAdvicesAndAdvisorsForBean方法来获取所有符合条件的切面,具体的实现在子类,这里是抽象方法,获取切面后就是创建代理:
</code></pre><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/5C1567439441240.png" alt="1567439441240"></p>
<p>TargetSource中存放被代理的对象,这段代码主要是为了构建ProxyFactory,将配置信息(是否使用java proxy,是否threadlocal等),目标类,切面,传入ProxyFactory中,而在ProxyFactory中,会通过createAopProxy()方法创建代理工厂DefaultAopProxyFactory,由代理厂生成具体的代理对目标类进行代理:</p>
<p>进入<code>proxyFactory.getProxy(getProxyClassLoader());</code> 的<code>getProxy()</code>方法 </p>
<p>跳到</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/5C1567439674687.png" alt="1567439674687"></p>
<p>进入<code>createAopProxy()</code>，跳转到</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/5C1567439733523.png" alt="1567439733523"></p>
<p>我们可以查看AopProxy的都有哪些 ，在AOpProxy上按键：ctrl t，</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/5C1567439796941.png" alt="1567439796941"></p>
<p>很明显有我们熟悉的cglib和jdk、默认的实现</p>
<p>紧接着进入<code>createAopProxy(this)</code></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/5C1567439888919.png" alt="1567439888919"></p>
<p>是个接口，查看他的默认实现类。</p>
<h3 id="4-DefaultAopProxyFactory-aop代理获取类"><a href="#4-DefaultAopProxyFactory-aop代理获取类" class="headerlink" title="4. DefaultAopProxyFactory aop代理获取类"></a>4. DefaultAopProxyFactory aop代理获取类</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/C1567439971239.png" alt="1567439971239"></p>
<p>可以看到,在这里有我们在注解中设置的参数的判断逻辑,是创建java代理,还是cglib代理，有关cglib的讲解请看<a href="http://www.cnblogs.com/foreveravalon/p/8489907.html" target="_blank" rel="external">cglib的使用</a>.</p>
<p>我们主要看一下JdkDynamicAopProxy的实现，因为我们没有设置<code>@EnableAspectJAutoProxy(proxyTargetClass=true)</code> 所以我们默认使用jdk自带实现。cglib其实差不多。</p>
<h3 id="5-JdkDynamicAopProxy-默认切面代理类"><a href="#5-JdkDynamicAopProxy-默认切面代理类" class="headerlink" title="5. JdkDynamicAopProxy 默认切面代理类"></a>5. JdkDynamicAopProxy 默认切面代理类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Override</div><div class="line">    public Object getProxy() &#123;</div><div class="line">        return getProxy(ClassUtils.getDefaultClassLoader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getProxy(@Nullable ClassLoader classLoader) &#123;</div><div class="line">        if (logger.isDebugEnabled()) &#123;</div><div class="line">            logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());</div><div class="line">        &#125;</div><div class="line">        Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);</div><div class="line">        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</div><div class="line">        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>findDefinedEqualsAndHashCodeMethods方法是为了查询被代理的接口是否包括equals和hashcode方法，这会影响到下面的调用。</p>
<p>可以看到InvocationHandler的实现就是this。我们看一下invoke方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Override</div><div class="line">  @Nullable</div><div class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div></pre></td></tr></table></figure>
<p>关键代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Get the interception chain for this method.</div><div class="line">            List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div></pre></td></tr></table></figure>
<p>构建代理链，因为一个方法可能有多个切点匹配上，这个时候就需要构建一个链式的执行结构。</p>
<p>进入<code>getInterceptorsAndDynamicInterceptionAdvice（）</code>方法</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/C1567440444983.png" alt="1567440444983"></p>
<p>这里做了一个缓存，虽然new了一个对象作为key，但是对象的equals和hashcode方法都被重写了，所以没有问题，我们主要来看一下它是如何组装这个链式处理结构的：</p>
<p>进入<code>getInterceptorsAndDynamicInterceptionAdvice（）</code>方法，紧接着发现是一个接口，那么查看他的实现类</p>
<h3 id="6-DefaultAdvisorChainFactory-处理链式切点"><a href="#6-DefaultAdvisorChainFactory-处理链式切点" class="headerlink" title="6.DefaultAdvisorChainFactory 处理链式切点"></a>6.DefaultAdvisorChainFactory 处理链式切点</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/5C1567440624426.png" alt="1567440624426"></p>
<p>可以看到，它会遍历自己的所有切点，那这些advisor是从哪里来的呢：</p>
<p> 还记得最开始,我们说过,AbstractAutoProxyCreator中通过getAdvicesAndAdvisorsForBean方法来装载切面,而这个是一个抽象方法,现在来看它的实现,在AbstractAdvisorAutoProxyCreator中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Override</div><div class="line">    @Nullable</div><div class="line">    protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) &#123;</div><div class="line">        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</div><div class="line">        if (advisors.isEmpty()) &#123;</div><div class="line">            return DO_NOT_PROXY;</div><div class="line">        &#125;</div><div class="line">        return advisors.toArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123;</div><div class="line">        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</div><div class="line">        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</div><div class="line">        extendAdvisors(eligibleAdvisors);</div><div class="line">        if (!eligibleAdvisors.isEmpty()) &#123;</div><div class="line">            eligibleAdvisors = sortAdvisors(eligibleAdvisors);</div><div class="line">        &#125;</div><div class="line">        return eligibleAdvisors;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">findCandidateAdvisors又是一个抽象方法,主要功能就是找到候选的切面,为什么是候选的,因为它是加载了所有的切面,有些切面并不需要,在最底层AnnotationAwareAspectJAutoProxyCreator的实现类中也有:</div><div class="line"></div><div class="line">protected List&lt;Advisor&gt; findCandidateAdvisors() &#123;</div><div class="line">        // Add all the Spring advisors found according to superclass rules.</div><div class="line">        List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();</div><div class="line">        // Build Advisors for all AspectJ aspects in the bean factory.</div><div class="line">        if (this.aspectJAdvisorsBuilder != null) &#123;</div><div class="line">            advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());</div><div class="line">        &#125;</div><div class="line">        return advisors;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到,通过aspectJAdvisorsBuilder来将该类关心的所有的切面装载进来,并添加到父类的集合里面.aspectJAdvisorsBuilder里缓存了advisor的信息,拿到切面后,通过findAdvisorsThatCanApply方法来筛选合适的切面,之后对切面进行排序(如果实现了Order接口),然后返回切面的链表.</p>
<h1 id="8-声明式事务-Transactional注解"><a href="#8-声明式事务-Transactional注解" class="headerlink" title="8.声明式事务@Transactional注解"></a>8.声明式事务@Transactional注解</h1><h2 id="1-前言-1"><a href="#1-前言-1" class="headerlink" title="1.前言"></a>1.前言</h2><pre><code>我们知道spring的事务管理分为两大部分：声明式和编程式，两种方式均为我们提供便捷的事务管理方法，各自优劣。
</code></pre><blockquote>
<p>声明式事务</p>
</blockquote>
<pre><code>声明式的事务管理对业务代码基本0入侵，能够很好的把事务管理和业务代码剥离开来，提高代码扩展性和可读性但是控制的粒度只能是方法级别而且必须是public，同时还不能在一个类中调用等。
</code></pre><blockquote>
<p>编程式事务</p>
</blockquote>
<pre><code>编程式事务则需要通过编写具体的事务代码来获得事务的管理能力，TransactionTemplate，或者直接使用PlatformTransactionManager，好处是控制粒度小，没有太多限制，坏处就是对业务代码有入侵，如果事务需要嵌套或者事务本身很繁琐，使用编程式则会十分麻烦。
</code></pre><p>这里讲述的是声明式事务，因为他比较常用。而且两种方式的源码其实是一样的。</p>
<h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><h3 id="1-1导入相关依赖：数据源、数据库驱动、Spring-jdbc模块"><a href="#1-1导入相关依赖：数据源、数据库驱动、Spring-jdbc模块" class="headerlink" title="1.1导入相关依赖：数据源、数据库驱动、Spring-jdbc模块"></a>1.1导入相关依赖：数据源、数据库驱动、Spring-jdbc模块</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417823342.png" alt="1567417823342"></p>
<h3 id="1-2配置数据源、JdbcTemplate（Spring提供简化数据库操作的工具）操作数据"><a href="#1-2配置数据源、JdbcTemplate（Spring提供简化数据库操作的工具）操作数据" class="headerlink" title="1.2配置数据源、JdbcTemplate（Spring提供简化数据库操作的工具）操作数据"></a>1.2配置数据源、JdbcTemplate（Spring提供简化数据库操作的工具）操作数据</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417832614.png" alt="1567417832614"></p>
<h3 id="1-3新建PersonDao、PersonService"><a href="#1-3新建PersonDao、PersonService" class="headerlink" title="1.3新建PersonDao、PersonService"></a>1.3新建PersonDao、PersonService</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417847101.png" alt="1567417847101"></p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417852548.png" alt="1567417852548"></p>
<h3 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h3><p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417897324.png" alt="1567417897324"></p>
<p>插入成功</p>
<h3 id="1-5-测试事务"><a href="#1-5-测试事务" class="headerlink" title="1.5 测试事务"></a>1.5 测试事务</h3><p>修改Service方法，故意暴露一个异常</p>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417910208.png" alt="1567417910208"></p>
<p>我们运行测试，发现还是插入成功，那么怎么阻止这种行为呢？添加事务</p>
<h3 id="1-6-添加事务"><a href="#1-6-添加事务" class="headerlink" title="1.6 添加事务"></a>1.6 添加事务</h3><ol>
<li>给insertUser方法添加注解- @Transactional</li>
</ol>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417923873.png" alt="1567417923873"></p>
<ol>
<li><p>@EnableTransactionManagement 开启基于注解的事务管理功能</p>
</li>
<li><p>配置事务管理器来控制事务</p>
</li>
</ol>
<p><img src="/2019/03/14/spring注解-辅助学习springboot和springcloud/1567417943208.png" alt="1567417943208"></p>
<p>事务添加成功</p>
<h3 id="1-8-再次运行测试"><a href="#1-8-再次运行测试" class="headerlink" title="1.8 再次运行测试"></a>1.8 再次运行测试</h3><p>发现插入失败，满足事务的原子性。</p>
<h3 id="1-7-源码分析"><a href="#1-7-源码分析" class="headerlink" title="1.7 源码分析"></a>1.7 源码分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">声明式事务：</div><div class="line"> </div><div class="line">环境搭建：</div><div class="line">1、导入相关依赖</div><div class="line">		数据源、数据库驱动、Spring-jdbc模块</div><div class="line">2、配置数据源、JdbcTemplate（Spring提供的简化数据库操作的工具）操作数据</div><div class="line">3、给方法上标注 @Transactional 表示当前方法是一个事务方法；</div><div class="line">4、 @EnableTransactionManagement 开启基于注解的事务管理功能；</div><div class="line">		@EnableXXX</div><div class="line">5、配置事务管理器来控制事务;</div><div class="line">		@Bean</div><div class="line">		public PlatformTransactionManager transactionManager()</div><div class="line"> </div><div class="line"> </div><div class="line">原理：</div><div class="line">1）、@EnableTransactionManagement</div><div class="line">			利用TransactionManagementConfigurationSelector给容器中会导入组件</div><div class="line">			导入两个组件</div><div class="line">			AutoProxyRegistrar</div><div class="line">			ProxyTransactionManagementConfiguration</div><div class="line">2）、AutoProxyRegistrar：</div><div class="line">			给容器中注册一个 InfrastructureAdvisorAutoProxyCreator 组件；</div><div class="line">			InfrastructureAdvisorAutoProxyCreator：？</div><div class="line">			利用后置处理器机制在对象创建以后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链进行调用；</div><div class="line"> </div><div class="line">3）、ProxyTransactionManagementConfiguration 做了什么？</div><div class="line">			1、给容器中注册事务增强器；</div><div class="line">				1）、事务增强器要用事务注解的信息，AnnotationTransactionAttributeSource解析事务注解</div><div class="line">				2）、事务拦截器：</div><div class="line">					TransactionInterceptor；保存了事务属性信息，事务管理器；</div><div class="line">					他是一个 MethodInterceptor；</div><div class="line">					在目标方法执行的时候；</div><div class="line">						执行拦截器链；</div><div class="line">						事务拦截器：</div><div class="line">							1）、先获取事务相关的属性</div><div class="line">							2）、再获取PlatformTransactionManager，如果事先没有添加指定任何transactionmanger</div><div class="line">								最终会从容器中按照类型获取一个PlatformTransactionManager；</div><div class="line">							3）、执行目标方法</div><div class="line">								如果异常，获取到事务管理器，利用事务管理回滚操作；</div><div class="line">								如果正常，利用事务管理器，提交事务</div></pre></td></tr></table></figure>
<h2 id="3-源码深入分析"><a href="#3-源码深入分析" class="headerlink" title="3.源码深入分析"></a>3.源码深入分析</h2><p>未完待续</p>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h1><p>通过使用AOP和声明式事务，我们知道了一个套路，如果我们想使用某项功能，例如上面的aop和声明式事务、或者以后的springcloud的eureka、zull、feign等等功能，都遵循一下三点：</p>
<blockquote>
<p>1.导入功能组件相关的依赖</p>
<p>2.在配置类开启组件（@EnableXXXX）</p>
<p>3.在关键位置标示使用的地方（例如@Aspect、@Transactional）</p>
</blockquote>
<p>所以以后需要在spring中使用某个组件，一般都是遵循这样的思路</p>
<p># </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h1&gt;&lt;p&gt; 因为后面要学习sb（springboot）和sc（springcloud），所以需要学习一些相关的注解和了解他们底层代
    
    </summary>
    
      <category term="spring注解和生命周期" scheme="http://kingge.top/categories/spring%E6%B3%A8%E8%A7%A3%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
    
      <category term="spring注解" scheme="http://kingge.top/tags/spring%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="aop" scheme="http://kingge.top/tags/aop/"/>
    
      <category term="spring生命周期" scheme="http://kingge.top/tags/spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>持续集成技术总结</title>
    <link href="http://kingge.top/2019/03/08/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://kingge.top/2019/03/08/持续集成技术总结/</id>
    <published>2019-03-08T15:59:59.000Z</published>
    <updated>2019-08-25T04:37:53.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、DockerMaven插件的使用"><a href="#一、DockerMaven插件的使用" class="headerlink" title="一、DockerMaven插件的使用"></a>一、DockerMaven插件的使用</h1><p>这个插件的目的就是，能够把本地项目远程打包到docker，并生成相应的镜像。</p>
<p>微服务部署有两种方法：</p>
<p>（1）手动部署：首先基于源码打包生成jar包（或war包）,将jar包（或war包）上传至虚 拟机并拷贝至JDK容器。</p>
<p>（2）通过Maven插件自动部署。</p>
<p>对于数量众多的微服务，手动部署无疑是非常麻烦的做法，并且容易出错。所以我们这 里学习如何自动部署，这也是企业实际开发中经常使用的方法</p>
<p> 而且使用dockermaven插件自动部署项目，有两种方式，一种是编写Dockerfile方式，一种是纯xml方式。第一种方式在本人的总结的《Docker总结》第十二章有写到。下面的案例主要是讲解通过xml的方式部署项目。</p>
<p>  <strong>其实他们本质上是一样的</strong></p>
<h2 id="Maven插件自动部署步骤："><a href="#Maven插件自动部署步骤：" class="headerlink" title="Maven插件自动部署步骤："></a>Maven插件自动部署步骤：</h2><p>（1）修改宿主机的docker配置，让其可以远程访问</p>
<p>Vi  /lib/systemd/system/docker.service</p>
<p>其中ExecStart=后添加配置</p>
<p> ‐H tcp://0.0.0.0:2375 ‐H unix:///var/run/docker.sock</p>
<p>修改后如下：</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image002.jpg" alt="img"></p>
<p>（2）刷新配置，重启服务</p>
<p>systemctl daemon‐reload </p>
<p> systemctl restart docker </p>
<p> docker start registry</p>
<p>   注意：这里的registry是本人新建的本地仓库（怎么新建本地仓库以及怎么使用，参见docker的文章）-当然你也可以把镜像提交到阿里云镜像仓库中。</p>
<p><strong>使用SpringBoot2.0+DockerFile+Maven插件构建镜像并推送到阿里云仓库</strong></p>
<p><strong><a href="https://blog.csdn.net/haogexiang9700/article/details/88318867" target="_blank" rel="external">https://blog.csdn.net/haogexiang9700/article/details/88318867</a></strong></p>
<p>（3）在工程pom.xml 增加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;build&gt;         </div><div class="line">&lt;finalName&gt;app&lt;/finalName&gt;         </div><div class="line">&lt;plugins&gt;            </div><div class="line"> &lt;plugin&gt;</div><div class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 </div><div class="line">&lt;artifactId&gt;spring‐boot‐maven‐plugin&lt;/artifactId&gt;             </div><div class="line">&lt;/plugin&gt;</div><div class="line"> &lt;plugin&gt;                 </div><div class="line">&lt;groupId&gt;com.spotify&lt;/groupId&gt;                 </div><div class="line">&lt;artifactId&gt;docker‐maven‐plugin&lt;/artifactId&gt;                 </div><div class="line">&lt;version&gt;0.4.13&lt;/version&gt;                 </div><div class="line">&lt;configuration&gt;</div><div class="line">&lt;imageName&gt;192.168.1.105:5000/$&#123;project.artifactId&#125;:$&#123;project.version&#125; &lt;/imageName&gt;</div><div class="line">&lt;baseImage&gt;jdk1.8&lt;/baseImage&gt;                     </div><div class="line">&lt;entryPoint&gt;[&quot;java&quot;, &quot;‐jar&quot;,  &quot;/$&#123;project.build.finalName&#125;.jar&quot;]</div><div class="line">&lt;/entryPoint&gt;                     </div><div class="line">&lt;resources&gt;</div><div class="line"> &lt;resource&gt;</div><div class="line"> &lt;targetPath&gt;/&lt;/targetPath&gt;                             </div><div class="line">&lt;directory&gt;$&#123;project.build.directory&#125; &lt;/directory&gt;</div><div class="line">&lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;                         </div><div class="line">&lt;/resource&gt;                     </div><div class="line">&lt;/resources&gt;                     </div><div class="line">&lt;dockerHost&gt;http://192.168.1.105:2375&lt;/dockerHost&gt;                 </div><div class="line">&lt;/configuration&gt;            </div><div class="line"> &lt;/plugin&gt;         </div><div class="line">&lt;/plugins&gt;     </div><div class="line">&lt;/build&gt;</div></pre></td></tr></table></figure>
   <build>            <finalname>app</finalname>              <plugins>                  <plugin>   <groupid>org.springframework.boot</groupid>                      <artifactid>spring‐boot‐maven‐plugin</artifactid>                  </plugin>    <plugin>                      <groupid>com.spotify</groupid>                      <artifactid>docker‐maven‐plugin</artifactid>                      <version>0.4.13</version>                      <configuration>   <imagename>192.168.1.105:5000/${project.artifactId}:${project.version}   </imagename>   <baseimage>jdk1.8</baseimage>                          <entrypoint>[“java”, “‐jar”,    “/${project.build.finalName}.jar”]   </entrypoint>                          <resources>    <resource>    <targetpath>/</targetpath>                                  <directory>${project.build.directory}   </directory>   <include>${project.build.finalName}.jar</include>                              </resource>                          </resources>                          <dockerhost><a href="http://192.168.1.105:2375" target="_blank" rel="external">http://192.168.1.105:2375</a></dockerhost>                      </configuration>                  </plugin>              </plugins>          </build>   

<p>以上配置会自动生成Dockerfile</p>
<p>   FROM jdk1.8     ADD app.jar /     ENTRYPOINT [“java”,”‐jar”,”/app.jar”]   </p>
<p>创建一个镜像，继承自jdk1.8，同时拷贝本地的app.jar到镜像的根目录。在容器启动时，执行java –jar /app.jar(也就是启动项目)</p>
<p>（4）在windows的命令提示符下，进入工程app所在的目录，进行打包和上传镜像</p>
<p>mvn install</p>
<p>mvn docker:build  ‐DpushImage</p>
<p>执行后，会有如下输出，代码正在上传</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image004.jpg" alt="img"></p>
<p>（6）进入宿主机 , 查看镜像</p>
<pre><code>Docker images
</code></pre><p><img src="/2019/03/08/持续集成技术总结/clip_image006.jpg" alt="img"></p>
<p>（7）启动容器</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image008.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image009.png" alt="img"></p>
<p>访问成功！！！</p>
<h1 id="二、持续集成工具Jenkins"><a href="#二、持续集成工具Jenkins" class="headerlink" title="二、持续集成工具Jenkins"></a>二、持续集成工具Jenkins</h1><p>官网：<a href="https://jenkins.io/zh/doc/tutorials/build-a-java-app-with-maven/" target="_blank" rel="external">https://jenkins.io/zh/doc/tutorials/build-a-java-app-with-maven/</a></p>
<p>主要是解决自动化构建项目，发布项目等等问题。</p>
<p>微服务架构下，带来了运维上的额外复杂性，尤其是在服务部署和服务监控上。单体应用是集中式的，就一个单体跑在一起，部署和管理的时候非常简单。而微服务是一个网状分布的，有很多服务需要维护和管理，对它进行部署和维护的时候则比较复杂，所以就需要一个工具能够自动化的完成自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。</p>
<pre><code>**持续集成具有的特点：**
</code></pre><p>它是一个自动化的周期性的集成测试过程，从检出代码、编译构建、运行测试、结果 记录、测试统计等都是自动完成的，无需人工干预； </p>
<p>需要有专门的集成服务器来执行集成构建； </p>
<p>需要有代码托管工具支持，我们下一小节将介绍Git以及可视化界面Gogs的使用</p>
<p><strong>持续集成的作用：</strong></p>
<p>保证团队开发人员提交代码的质量，减轻了软件发布时的压力； </p>
<p>持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复 过程以节省时间、费用和工作量；</p>
<p><strong>基本思路：</strong></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image011.jpg" alt="https://www.centos.bz/wp-content/uploads/2017/11/1-17.jpg"></p>
<h2 id="1-Jenkins简介"><a href="#1-Jenkins简介" class="headerlink" title="1.Jenkins简介"></a>1.Jenkins简介</h2><p> Jenkins，原名Hudson，2011年改为现在的名字，它 是一个开源的实现持续集成的 软件工具。官方网站：<a href="http://jenkins-ci.org/。" target="_blank" rel="external">http://jenkins-ci.org/。</a></p>
<p> Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图 表的形式形象地展示项目构建的趋势和稳定性。</p>
<p> <strong>特点：</strong> </p>
<p><strong>易安装：</strong>仅仅一个 java -jar jenkins.war，从官网下载该文件后，直接运行，无需额 外的安装，更无需安装数据库； </p>
<p><strong>易配置：</strong>提供友好的GUI配置界面； </p>
<p><strong>变更支持：</strong>Jenkins能从代码仓库（Subversion/CVS）中获取并产生代码更新列表并 输出到编译输出信息中； </p>
<p><strong>支持永久链接：</strong>用户是通过web来访问Jenkins的，而这些web页面的链接地址都是 永久链接地址，因此，你可以在各种文档中直接使用该链接； </p>
<p><strong>集成E-Mail/RSS/IM：</strong>当完成一次集成时，可通过这些工具实时告诉你集成结果（据 我所知，构建一次集成需要花费一定时间，有了这个功能，你就可以在等待结果过程 中，干别的事情）；</p>
<p> <strong>JUnit/TestNG**</strong>测试报告：**也就是用以图表等形式提供详细的测试报表功能； </p>
<p><strong>支持分布式构建：</strong>Jenkins可以把集成构建等工作分发到多台计算机中完成； </p>
<p><strong>文件指纹信息：</strong>Jenkins会保存哪次集成构建产生了哪些jars文件，哪一次集成构建使 用了哪个版本的jars文件等构建记录； </p>
<p><strong>支持第三方插件：</strong>使得 Jenkins 变得越来越强大</p>
<h2 id="2-Jenkins安装"><a href="#2-Jenkins安装" class="headerlink" title="2. Jenkins安装"></a>2. Jenkins安装</h2><p>资源准备</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image013.jpg" alt="img"></p>
<p>当然你可以通过wget命令进行下载相应的rpm包</p>
<h3 id="2-1-JDK安装"><a href="#2-1-JDK安装" class="headerlink" title="2.1 JDK安装"></a>2.1 JDK安装</h3><p>（1）将jdk-8u171-linux-x64.rpm上传至服务器（虚拟机）</p>
<p>（2）执行安装命令</p>
<p>rpm ‐ivh jdk‐8u171‐linux‐x64.rpm</p>
<p>（3）查看是否安装成功</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image014.png" alt="img"></p>
<pre><code>因为rpm包已经自动为我们做了相关的环境变量配置，所以不需要额外配置（相关的命令在 /usr/bin）
</code></pre><h3 id="2-2-maven安装"><a href="#2-2-maven安装" class="headerlink" title="2.2 maven安装"></a>2.2 maven安装</h3><p>（1）将 apache‐maven‐3.5.4‐bin.tar.gz上传至服务器（虚拟机）</p>
<p>（2）解压</p>
<p>tar zxvf apache‐maven‐3.5.4‐bin.tar.gz</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image016.jpg" alt="img"></p>
<p>（3））编辑setting.xml配置文件</p>
<p>vi /opt/software/apache-maven-3.5.4/conf/settings.xml</p>
<p>   增加如下配置</p>
<localrepository>/opt/software/mavenRepostory</localrepository>



<p>（4）将开发环境（win10）的本地仓库上传至服务器（虚拟机）并移动到/opt/software/mavenRepostory</p>
<p>执行此步是为了以后在打包的时候不必重新下载，缩短打包的时间  </p>
<h3 id="2-3-Jenkins安装与启动"><a href="#2-3-Jenkins安装与启动" class="headerlink" title="2.3 Jenkins安装与启动"></a>2.3 Jenkins安装与启动</h3><p><strong>在安装jenkins之前必须要安装jdk。</strong></p>
<p>（1）下载jenkins</p>
<p>wget <a href="https://pkg.jenkins.io/redhat/jenkins‐2.83‐1.1.noarch.rpm" target="_blank" rel="external">https://pkg.jenkins.io/redhat/jenkins‐2.83‐1.1.noarch.rpm</a></p>
<p>或将应下载好的jenkins-2.83-1.1.noarch.rpm上传至服务器</p>
<p><a href="https://pkg.jenkins.io/redhat-stable/" target="_blank" rel="external">https://pkg.jenkins.io/redhat-stable/</a> 官网下载（建议下载最新版本，避免安装插件时报错 jenkins-2.187-1.1.noarch.rpm）</p>
<p>（2）安装jenkins</p>
<p>rpm ‐ivh jenkins‐2.83‐1.1.noarch.rpm</p>
<p><strong>自动安装完成之后：</strong> </p>
<p><strong>/usr/lib/jenkins/jenkins.war    WAR**</strong>包** </p>
<p><strong>/etc/sysconfig/jenkins</strong>       <strong>配置文件</strong></p>
<p><strong>/var/lib/jenkins/</strong>       <strong>默认的JENKINS_HOME目录</strong></p>
<p><strong>/var/log/jenkins/jenkins.log    Jenkins**</strong>日志文件**</p>
<p>（3）配置jenkins</p>
<p>vi /etc/sysconfig/jenkins</p>
<p>修改用户和端口</p>
<p>JENKINS_USER=”root”  JENKINS_PORT=”8888”</p>
<p>（4）启动服务</p>
<p>systemctl start Jenkins</p>
<p>（5）访问链接 <a href="http://49.234.188.74:8888" target="_blank" rel="external">http://49.234.188.74:8888</a></p>
<p>从/var/lib/jenkins/secrets/initialAdminPassword中获取初始密码串</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image018.jpg" alt="img"></p>
<p>（6）安装插件</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image020.jpg" alt="img"></p>
<p>选择推荐安装，避免漏掉一些jenkins必须依赖的插件，后面有额外需要的插件我们还可以手动安装</p>
<p>安装插件中</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image022.jpg" alt="img"></p>
<p><strong>需要注意的是，在安装插件的可能会失败，一般是因为当前jenkins版本太低的原因，可以先忽略错误，进去后更新jenkins为新的版本，插件自己会自动安装成功。</strong></p>
<p>（7）新建用户</p>
<p>完成安装进入主界面</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image024.jpg" alt="img"></p>
<h2 id="3-Jenkins插件安装"><a href="#3-Jenkins插件安装" class="headerlink" title="3. Jenkins插件安装"></a>3. Jenkins插件安装</h2><p>我们以安装maven插件为例，演示插件的安装</p>
<p>（1）点击左侧的“系统管理”菜单 ,然后点点击</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image026.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image028.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image030.jpg" alt="img"></p>
<h2 id="4-全局工具配置"><a href="#4-全局工具配置" class="headerlink" title="4.全局工具配置"></a>4.全局工具配置</h2><p>选择系统管理，全局工具配置</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image032.jpg" alt="img"></p>
<p>（1）JDK配置</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image034.jpg" alt="img"></p>
<p>设置javahome为 /usr/java/jdk1.8.0_171-amd64</p>
<p>（2）Git配置   （本地已经安装了Git软件）</p>
<p>   如果linux 没有安装过git。那么可以参考 《额外补充》第三章节进行安装。</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image036.jpg" alt="img"></p>
<p>如果不知道本地git的地址可以使用命令：whereis git 获取地址。</p>
<p>  默认在启动jenkins时，应安装好了git插件</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image038.jpg" alt="img"></p>
<p>（3）Maven配置</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image040.jpg" alt="img"></p>
<p>然后保存即可，接下来上传代码到git，然后创建任务。</p>
<h2 id="5-代码上传至Git服务器"><a href="#5-代码上传至Git服务器" class="headerlink" title="5 代码上传至Git服务器"></a>5 代码上传至Git服务器</h2><h3 id="5-1-Gogs搭建与配置"><a href="#5-1-Gogs搭建与配置" class="headerlink" title="5.1 Gogs搭建与配置"></a>5.1 Gogs搭建与配置</h3><p>Gogs 是一款极易搭建的自助 Git 服务。</p>
<p>Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语 言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包 括 Linux、Mac OS X、Windows 以及 ARM 平台</p>
<p>地址：<a href="https://gitee.com/Unknown/gogs" target="_blank" rel="external">https://gitee.com/Unknown/gogs</a></p>
<p>（1）下载镜像</p>
<p>docker pull gogs/gogs</p>
<p>（2）创建容器</p>
<p>  docker run -d -p 10022:22 -p 10080:3000 \ </p>
<p>–name=gogs \</p>
<p>-v /opt/docker/gogs/:/data \ </p>
<p>gogs/gogs</p>
<p>（3）安装gogs</p>
<p>在地址栏输入 <a href="http://49.234.188.74:3000/" target="_blank" rel="external">http://49.234.188.74: 10080/</a>，会进入首次运行安装程序页面，我们可以选择一种数据 库作为gogs数据的存储，最简单的是选择SQLite3。如果对于规模较大的公司，可以选择 MySQL  </p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image042.jpg" alt="img"></p>
<p>点击“立即安装”</p>
<p>这里的域名要设置为centos的IP地址,安装后显示主界面</p>
<p>（4）注册</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image044.jpg" alt="img"></p>
<p>（5）登录</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image046.jpg" alt="img"></p>
<p>登陆后</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image048.jpg" alt="img"></p>
<p>（6）创建仓库 </p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image050.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image052.jpg" alt="img"></p>
<h3 id="5-2-提交代码到git"><a href="#5-2-提交代码到git" class="headerlink" title="5.2 提交代码到git"></a>5.2 提交代码到git</h3><p>步骤：</p>
<p>（1）在本地安装git(Windows版本)</p>
<p>（2）在IDEA中选择菜单 :  File – settings ,  在窗口中选择Version Control –  Gi</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image054.jpg" alt="img"></p>
<p>（3）选择菜单VCS  –&gt; Enable Version Control Integration</p>
<p>（4）设置远程地址:  右键点击工程选择菜单    Git –&gt; Repository   –&gt;Remotes…</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image056.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image057.png" alt="img"></p>
<p>url填写我们之前用gogs创建的git仓库：<a href="http://49.234.188.74:10080/root/kingge.git" target="_blank" rel="external">http://49.234.188.74:10080/root/kingge.git</a></p>
<p>（5）右键点击工程选择菜单    Git –&gt; Add </p>
<p>（6）右键点击工程选择菜单    Git –&gt; Commit Directory…</p>
<p>（7）右键点击工程选择菜单    Git –&gt; Repository   –&gt; Push …</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image059.jpg" alt="img"></p>
<h2 id="6-jenkins任务的创建与执行"><a href="#6-jenkins任务的创建与执行" class="headerlink" title="6 jenkins任务的创建与执行"></a>6 jenkins任务的创建与执行</h2><p>（1）回到首页，点击新建按钮 .如下图，输入名称，选择创建一个Maven项目，点击OK</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image061.jpg" alt="img"></p>
<p>（2）源码管理，选择Git</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image063.jpg" alt="img"></p>
<p>（3）填写构建语句</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image065.jpg" alt="img"></p>
<p>clean package docker:build ‐DpushImage</p>
<p>（4）查看项目</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image067.jpg" alt="img"></p>
<p>我们点击执行后，可以看到左下角出现这个任务进度</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image068.png" alt="img"></p>
<p>这样就能够上传成功了</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>通过jenkins，我们可以很好的集成、部署了我们开发的项目，自动构建项目的镜像，这样为我们节省了很多的时间。</p>
<h1 id="三、容器管理工具Rancher"><a href="#三、容器管理工具Rancher" class="headerlink" title="三、容器管理工具Rancher"></a>三、容器管理工具Rancher</h1><p>管理docker和Kubernetes容器，通过可视化界面的方式，管理，部署，启动docker容器，同时支持分布式集群部署docekr容器。</p>
<h2 id="1-安装Rancher"><a href="#1-安装Rancher" class="headerlink" title="1.安装Rancher"></a>1.安装Rancher</h2><p>Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽 子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙…… Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应 用部署和管理</p>
<p><a href="https://www.cnrancher.com/" target="_blank" rel="external">https://www.cnrancher.com/</a> </p>
<p>（1）下载Rancher 镜像</p>
<p>docker pull rancher/server</p>
<p>（2）创建Rancher容器</p>
<p>docker run ‐di ‐‐name=rancher ‐p 9090:8080 rancher/server</p>
<p>（3）在浏览器输入地址： <a href="http://192.168.184.136:9090" target="_blank" rel="external">http://192.168.184.136:9090</a>  </p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image070.jpg" alt="img"></p>
<h2 id="2-初始化Rancher"><a href="#2-初始化Rancher" class="headerlink" title="2.初始化Rancher"></a>2.初始化Rancher</h2><h3 id="2-1-添加环境"><a href="#2-1-添加环境" class="headerlink" title="2.1 添加环境"></a>2.1 添加环境</h3><p>Rancher 支持将资源分组归属到多个环境。 每个环境具有自己独立的基础架构资源及服 务，并由一个或多个用户、团队或组织所管理。</p>
<p>例如，您可以创建独立的“开发”、“测试”及“生产”环境以确保环境之间的安全隔离，将“开 发”环境的访问权限赋予全部人员，但限制“生产”环境的访问权限给一个小的团队。</p>
<p>（1）     选择“Default –&gt;环境管理” 菜单</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image071.png" alt="img"></p>
<p>（2）填写名称，点击“创建”按钮</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image073.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image075.jpg" alt="img"></p>
<p>可以添加多个环境，分别给区分不同用户使用场景</p>
<p>（4））你可以通过点击logo右侧的菜单在各种环境下切换</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image076.png" alt="img"></p>
<h3 id="2-2-添加主机"><a href="#2-2-添加主机" class="headerlink" title="2.2 添加主机"></a>2.2 添加主机</h3><p>（1）选择基础架构–&gt;主机 菜单，点击添加主机</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image078.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image080.jpg" alt="img"></p>
<p>直接保存，当然你也可以选择其他主机（管理非当前服务器）</p>
<p>（2）拷贝脚本，主机和rancher服务建立连接</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image082.jpg" alt="img"></p>
<p>（3）在主机上运行脚本</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image084.jpg" alt="img"></p>
<p>（4）点击关闭按钮后，会看到界面中显示此主机。我们可以很方便地管理主机的每个容 器的开启和关闭</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image085.png" alt="img"></p>
<p>在这里可以看到当前主机下，已经创建好的容器</p>
<h3 id="2-3-添加应用"><a href="#2-3-添加应用" class="headerlink" title="2.3 添加应用"></a>2.3 添加应用</h3><p>（1）点击应用–&gt;全部(或用户)  ，点击“添加应用”按钮</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image086.png" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image088.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image090.jpg" alt="img"></p>
<p>应用是多个服务的载体。例如一个mysql容器就是一个服务，它提供数据库服务。例如redis也是一个服务等等。</p>
<h3 id="2-4-添加服务"><a href="#2-4-添加服务" class="headerlink" title="2.4 添加服务"></a>2.4 添加服务</h3><p><strong>相对于docker而言，添加一个服务就等同于创建一个容器</strong></p>
<h4 id="2-4-1-添加mysql服务"><a href="#2-4-1-添加mysql服务" class="headerlink" title="2.4.1 添加mysql服务"></a>2.4.1 添加mysql服务</h4><p>镜像：mysql:latest   增加mysql数据库服务</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image092.jpg" alt="img"></p>
<p>打开我们在2.3节创建的应用，然后点击创建服务</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image094.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image096.jpg" alt="img"></p>
<p>点击创建按钮，完成创建。上述操作相当于以下docker命令</p>
<p>docker run ‐di ‐‐name mysql ‐p 3306:3306 ‐e MYSQL_ROOT_PASSWORD=123456  mysql:latest</p>
<p>创建中</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image098.jpg" alt="img"></p>
<p>创建完毕</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image100.jpg" alt="img"></p>
<h4 id="2-4-2-添加RabbitMQ服务"><a href="#2-4-2-添加RabbitMQ服务" class="headerlink" title="2.4.2 添加RabbitMQ服务"></a>2.4.2 添加RabbitMQ服务</h4><p>镜像：rabbitmq:management     端口映射5671   5672  4369    15671  15672  25672</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image102.jpg" alt="img"></p>
<h4 id="2-4-3-Redis服务"><a href="#2-4-3-Redis服务" class="headerlink" title="2.4.3 Redis服务"></a>2.4.3 Redis服务</h4><p><img src="/2019/03/08/持续集成技术总结/clip_image104.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image106.jpg" alt="img"></p>
<h4 id="2-5-部署我们在第一章节dockermaven构建的app容器"><a href="#2-5-部署我们在第一章节dockermaven构建的app容器" class="headerlink" title="2.5 部署我们在第一章节dockermaven构建的app容器"></a>2.5 部署我们在第一章节dockermaven构建的app容器</h4><p><img src="/2019/03/08/持续集成技术总结/clip_image108.jpg" alt="img"></p>
<p>开始部署服务</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image110.jpg" alt="img"></p>
<p>点击创建部署中</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image112.jpg" alt="img"></p>
<p>创建成功</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image114.jpg" alt="img"></p>
<p>访问</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image115.png" alt="img"></p>
<h2 id="3-rancher的扩容与缩容"><a href="#3-rancher的扩容与缩容" class="headerlink" title="3. rancher的扩容与缩容"></a>3. rancher的扩容与缩容</h2><p>就是对某个服务（容器）进行数量的增加或者减少，因为我们知道大型的项目一个服务是部署到多台服务器的，构建成一个服务集群，是为了应变访问量的高低。所以rancher也是提供了这种功能。</p>
<p> 一下例子，以我们在上面构建的app服务为例子。</p>
<p>（1）部署app服务，不指定端口</p>
<p>  这里为什么不指定端口，因为假设我们把服务扩容到两台，那么端口号就会冲突，所以这里让docker为我们默认分配端口。</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image117.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image119.jpg" alt="img"></p>
<p>（2）在选择菜单API  –&gt;WebHooks  ，点击“添加接收器”按钮</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image121.jpg" alt="img"></p>
<p>（3）填写名称等信息，选择要扩容的服务，点击创建按钮</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image123.jpg" alt="img"></p>
<p>创建成功</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image125.jpg" alt="img"></p>
<p>提供了一个触发扩容操作的url</p>
<p><a href="http://192.168.1.105:9090/v1-webhooks/endpoint?key=ctm3rFpH6oAsbOA5mXMHvZyW7BoCkz1QQgpw00ay&amp;projectId=1a5" target="_blank" rel="external">http://192.168.1.105:9090/v1-webhooks/endpoint?key=ctm3rFpH6oAsbOA5mXMHvZyW7BoCkz1QQgpw00ay&amp;projectId=1a5</a></p>
<p>（4）测试扩容服务</p>
<p>必须使用post的方式，触发上面提供的url</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image127.jpg" alt="img"></p>
<p>在触发之前，我们先查看一下app服务的数量</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image129.jpg" alt="img"></p>
<p>是一个</p>
<p>开始触发</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image131.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image133.jpg" alt="img"></p>
<p>扩容成功，数量变成了3</p>
<p>那么这个时候，我么你会有个疑问，我们怎么访问这些服务呢？这些服务并没有提供对外暴露的端口？</p>
<p> 答案是：采用创建负载均衡服务的方式访问</p>
<h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4.负载均衡"></a>4.负载均衡</h2><p>（1）创建负载均衡服务  </p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image135.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image137.jpg" alt="img"></p>
<p>创建负载均衡服务中</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image139.jpg" alt="img"></p>
<p>创建成功</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image141.jpg" alt="img"></p>
<p>尝试访问</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image143.jpg" alt="img"></p>
<p>访问成功，他会通过轮询的方式访问这三台容器。</p>
<h1 id="四、时间序列数据库influxDB"><a href="#四、时间序列数据库influxDB" class="headerlink" title="四、时间序列数据库influxDB"></a>四、时间序列数据库influxDB</h1><p>他主要是用来存储一些实时的数据，例如下面我们将会学习的cAdvisor，监控容器的内存相关的信息，就是存储在influDB中。记住他并不是用来存储大量数据的，不是mysql这样类型的数据库。</p>
<h2 id="1-什么是influxDB"><a href="#1-什么是influxDB" class="headerlink" title="1. 什么是influxDB"></a>1. 什么是influxDB</h2><p> influxDB是一个分布式时间序列数据库。cAdvisor仅仅显示实时信息，但是不存储 监视数据。因此，我们需要提供时序数据库用于存储cAdvisor组件所提供的监控信息， 以便显示除实时信息之外的时序数据。 </p>
<h2 id="2-influxDB安装"><a href="#2-influxDB安装" class="headerlink" title="2 influxDB安装"></a>2 influxDB安装</h2><p>（1）下载镜像</p>
<p>docker pull tutum/influxdb</p>
<p>（2）创建容器</p>
<p>docker run ‐di \     </p>
<p>‐p 8083:8083 \     </p>
<p>‐p 8086:8086 \     </p>
<p>‐‐expose 8090 \     </p>
<p>‐‐expose 8099 \     </p>
<p>‐‐name influxsrv \     </p>
<p>tutum/influxdb</p>
<p>端口概述：  8083端口:web访问端口     8086:数据写入端口 （<strong>后面启动adviosr的时候会用到</strong>）</p>
<p>docker run -di -p 8083:8083 -p 8086:8086 –expose 8090 –expose 8099 –name influxsrv tutum/influxdb</p>
<p>打开浏览器   <a href="http://192.168.1.105:8083/" target="_blank" rel="external">http://192.168.1.105:8083/</a></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image145.jpg" alt="img"></p>
<h2 id="3-influxDB常用操作"><a href="#3-influxDB常用操作" class="headerlink" title="3 influxDB常用操作"></a>3 influxDB常用操作</h2><p>3.1 创建数据库 </p>
<p>CREATE DATABASE “cadvisor”</p>
<p>回车创建数据库</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image147.jpg" alt="img"></p>
<p>查看数据库 </p>
<p>SHOW DATABASES</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image149.jpg" alt="img"></p>
<p>3.2 创建用户并授权 </p>
<p>创建用户</p>
<p>CREATE USER “cadvisor” WITH PASSWORD ‘cadvisor’ WITH ALL PRIVILEGES</p>
<p>查看用户</p>
<p>SHOW USRES</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image151.jpg" alt="img"></p>
<p>用户授权</p>
<p>grant all privileges on cadvisor to cadvisor  （on后面跟的是数据库名，to后面跟的是 用户名）</p>
<p>grant WRITE on cadvisor to cadvisor  </p>
<p>grant READ on cadvisor to cadvisor</p>
<p>3.3 查看采集的数据 </p>
<p>切换到cadvisor数据库，使用以下命令查看采集的数据</p>
<p>SHOW MEASUREMENTS</p>
<p>现在我们还没有数据，如果想采集系统的数据，我们需要使用Cadvisor软件来实现</p>
<h1 id="五、容器监控工具cAdvisor"><a href="#五、容器监控工具cAdvisor" class="headerlink" title="五、容器监控工具cAdvisor"></a>五、容器监控工具cAdvisor</h1><h2 id="1-什么是cAdvisor"><a href="#1-什么是cAdvisor" class="headerlink" title="1 什么是cAdvisor"></a>1 什么是cAdvisor</h2><p> Google开源的用于监控基础设施应用的工具，它是一个强大的监控工具，不需要任何配置就可以通过运行在Docker主机上的容器来监控Docker容器，而且可以监控Docker 主机。更多详细操作和配置选项可以查看Github上的cAdvisor项目文档。 </p>
<h2 id="2-cAdvisor安装"><a href="#2-cAdvisor安装" class="headerlink" title="2 cAdvisor安装"></a>2 cAdvisor安装</h2><h3 id="（1）下载镜像"><a href="#（1）下载镜像" class="headerlink" title="（1）下载镜像"></a>（1）下载镜像</h3><p>docker pull google/cadvisor</p>
<h3 id="（2）创建容器"><a href="#（2）创建容器" class="headerlink" title="（2）创建容器"></a>（2）创建容器</h3><p>   docker run –volume=/:/rootfs:ro –volume=/var/run:/var/run:rw    –volume=/sys:/sys:ro –volume=/var/lib/docker/:/var/lib/docker:ro    –publish=8080:8080 –detach=true –link influxsrv:influxsrv    –name=cadvisor google/cadvisor    -storage_driver=influxdb    -storage_driver_db=cadvisor    -storage_driver_host=influxsrv:8086   </p>
<p>我们可以看到启动cadvisor容器时，可以看到storage_driver 指定了存储的用的数据库，storage_driver_db指定了用的数据库名称，storage_driver_host指定写入数据库地址，–link 表示连接到我们在上面创建的influxsrv容器</p>
<h3 id="（3）查看容器"><a href="#（3）查看容器" class="headerlink" title="（3）查看容器"></a>（3）查看容器</h3><p>WEB前端访问地址 <a href="http://192.168.1.105:8080/containers/" target="_blank" rel="external">http://192.168.1.105:8080/containers/</a></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image153.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image155.jpg" alt="img"></p>
<p>性能指标含义参照如下地址</p>
<p><a href="https://blog.csdn.net/ZHANG_H_A/article/details/53097084" target="_blank" rel="external">https://blog.csdn.net/ZHANG_H_A/article/details/53097084</a></p>
<h3 id="（4）查看influxsrv容器"><a href="#（4）查看influxsrv容器" class="headerlink" title="（4）查看influxsrv容器"></a>（4）查看influxsrv容器</h3><p>再次查看influxDB，发现已经有很多数据被采集进去了</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image157.jpg" alt="img"></p>
<p>可以使用select语句查询某张表的数据</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image159.jpg" alt="img"></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>经过上面的学习，cadvisor和influxsrv 的使用我们可以检测采集，以及采集数据保存到influxdb中，但是有个缺点，那就是采集到infludb的数据，通过select语句查询，不是那么直观，那么下面我们将使用grafana图表工具展示influx的数据。</p>
<h1 id="六、图表工具Grafana"><a href="#六、图表工具Grafana" class="headerlink" title="六、图表工具Grafana"></a>六、图表工具Grafana</h1><h2 id="1-什么是Grafana"><a href="#1-什么是Grafana" class="headerlink" title="1 什么是Grafana"></a>1 什么是Grafana</h2><p> Grafana是一个可视化面板（Dashboard），有着非常漂亮的图表和布局展示，功能齐全的度量仪表盘和图形编辑器。支持Graphite、zabbix、InfluxDB、Prometheus和 OpenTSDB作为数据源。 Grafana主要特性：灵活丰富的图形化选项；可以混合多种风格；支持白天和夜间模式，多个数据源。 </p>
<h2 id="2-Grafana安装"><a href="#2-Grafana安装" class="headerlink" title="2 Grafana安装"></a>2 Grafana安装</h2><h3 id="（1）下载镜像-1"><a href="#（1）下载镜像-1" class="headerlink" title="（1）下载镜像"></a>（1）下载镜像</h3><p>docker pull grafana/grafana</p>
<h3 id="（2）创建容器-1"><a href="#（2）创建容器-1" class="headerlink" title="（2）创建容器"></a>（2）创建容器</h3><p>​       </p>
<p>   docker run -d -p 3001:3000 -e INFLUXDB_HOST=influxsrv -e   INFLUXDB_PORT=8086 -e INFLUXDB_NAME=cadvisor -e INFLUXDB_USER=root -e   INFLUXDB_PASS=itcast –link influxsrv:influxsrv –name=grafana   grafana/grafana   </p>
<h3 id="（3）访问"><a href="#（3）访问" class="headerlink" title="（3）访问"></a>（3）访问</h3><p><a href="http://192.168.1.105:3001" target="_blank" rel="external">http://192.168.1.105:3001</a></p>
<p>用户名密码均为admin</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image161.jpg" alt="img"></p>
<p>登录后需要修改密码，密码修改为：123456</p>
<h3 id="（4）之后进入主页面"><a href="#（4）之后进入主页面" class="headerlink" title="（4）之后进入主页面"></a>（4）之后进入主页面</h3><p><img src="/2019/03/08/持续集成技术总结/clip_image163.jpg" alt="img"></p>
<p>（5）添加数据源</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image165.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image167.jpg" alt="img"></p>
<p>选择InfluxDB</p>
<p>（5）填写数据源信息</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image169.jpg" alt="img"></p>
<p>点击save</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image171.jpg" alt="img"></p>
<p>连接成功</p>
<h3 id="（5）添加仪表盘"><a href="#（5）添加仪表盘" class="headerlink" title="（5）添加仪表盘"></a>（5）添加仪表盘</h3><p>选择Dashboards –Manager</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image173.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image175.jpg" alt="img"></p>
<p>然后选择展示数据的图表样式</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image177.jpg" alt="img"></p>
<p>这里我们选择第一个，柱状图</p>
<p>（6）设置图表数据源</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image179.jpg" alt="img"></p>
<p>进入下个界面</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image181.jpg" alt="img"></p>
<p>点击edit</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image183.jpg" alt="img"></p>
<p>然后点击右上角保存即可</p>
<p>（6）预警通知设置</p>
<p>（1）选择菜单  alerting–&gt; Notification channels</p>
<p>（2）点击Add channel 按钮</p>
<p>（3）填写名称，选择类型为webhook  ,填写钩子地址</p>
<p>这个钩子地址是之前对base微服务扩容的地址</p>
<p>（4）点击SendTest  测试  观察基础微服务是否增加容器</p>
<p>（5）点击save保存</p>
<p>（6）按照同样的方法添加缩容地址 6.4.4 仪表盘预警设置 </p>
<p>（7）再次打开刚刚编辑的仪表盘</p>
<p>（8）点击 Create Alert </p>
<p>设置预警线</p>
<p>（9）选择通知</p>
<p>保存更改</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Influxdb和cadvisor、grafana，这三者一般都是一起使用，cadvisor负责往influxdb里面写入监控的数据，grafana负责从infuxdb中读取数据，并做可视化显示。</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image185.jpg" alt="img"></p>
<h1 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h1><h2 id="1-使用docker安装jenkins"><a href="#1-使用docker安装jenkins" class="headerlink" title="1 使用docker安装jenkins"></a>1 使用docker安装jenkins</h2><p>在第二章节中我们是使用rpm的方式安装jenkins，其实我们也是可以使用docker镜像的方式安装jenkins。<strong>但是这种方式创建数据卷会存在权限问题，所以一般也不常用</strong></p>
<p><a href="https://hub.docker.com/_/jenkins/" target="_blank" rel="external">https://hub.docker.com/_/jenkins/</a> 官网。注意查看jenkins容器启动后配置文件在容器中的位置，方便我们设置容器卷链接到本地虚拟机</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image187.jpg" alt="img"></p>
<h3 id="1-1-下载jenkins镜像"><a href="#1-1-下载jenkins镜像" class="headerlink" title="1.1 下载jenkins镜像"></a>1.1 下载jenkins镜像</h3><p>docker pull jenkins</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image189.jpg" alt="img"></p>
<h3 id="1-2-启动jenkins容器"><a href="#1-2-启动jenkins容器" class="headerlink" title="1.2 启动jenkins容器"></a>1.2 启动jenkins容器</h3><p>在镜像文档里，我们知道Jenkins访问的端口号是8080，另外还需要暴露一个tcp的端口号50000。我们使用如下命令启动Jenkins镜像</p>
<p>1.首先创建本地挂载目录并修改权限</p>
<p>创建目录赋权限</p>
<p>mkdir /home/jenkins</p>
<p>ls -nd jenkins</p>
<p>chown -R 1000:1000 jenkins/ （设置权限）</p>
<p>为什么需要修改本地数据卷文件的权限呢？</p>
<p>我们首先查看一下jenkins容器数据卷的权限信息</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image191.jpg" alt="img"></p>
<p>如果不把全权限修改一致，那么当本地数据卷信息同步到容器数据卷目录的时候，就会出现没有权限的问题。</p>
<p><a href="https://www.cnblogs.com/jackluo/p/5783116.html" target="_blank" rel="external">https://www.cnblogs.com/jackluo/p/5783116.html</a> 可以查看这篇文章。</p>
<p>\2. docker run -itd -p 6666:8080 -p 6660:50000 –name jenkins –privileged=true -v /home/jenkins:/var/jenkins_home jenkins</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image193.jpg" alt="img"></p>
<h3 id="1-3-开始安装"><a href="#1-3-开始安装" class="headerlink" title="1.3 开始安装"></a>1.3 开始安装</h3><p>访问</p>
<p><a href="http://192.168.1.105:6666" target="_blank" rel="external">http://192.168.1.105:6666</a></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image195.jpg" alt="img"></p>
<p>查看初始化密码</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image197.jpg" alt="img"></p>
<p>位置在我们关联的本地数据卷目录中</p>
<p>如果安装过程中出现下面这个错误</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image199.jpg" alt="img"></p>
<p>说明需要更换jenkin安装插件地址</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image201.jpg" alt="img"></p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image203.jpg" alt="img"></p>
<h2 id="2-Docker-Volume-之权限管理"><a href="#2-Docker-Volume-之权限管理" class="headerlink" title="2. Docker Volume 之权限管理"></a>2. Docker Volume 之权限管理</h2><p><a href="https://www.cnblogs.com/jackluo/p/5783116.html" target="_blank" rel="external">https://www.cnblogs.com/jackluo/p/5783116.html</a></p>
<p>1.启动Jenkins官方镜像，并检查日志</p>
<p>docker run -d -p 8080:8080 -p 50000:50000 –name jenkins jenkin</p>
<p>docker logs jenkins</p>
<p>我们可以发现”jenkins”容器日志显示结果一切正常</p>
<p>2.然而为了持久化Jenkins配置数据，当我们把宿主机当前目录下的data文件夹挂载到容器中的目录”/var/jenkins_home”的时候，问题出现了：</p>
<p>docker rm -f jenkins</p>
<p>docker run -d -p 8080:8080 -p 50000:50000 -v $(pwd)/data:/var/jenkins_home –name jenkins jenkins</p>
<p>docker logs jenkins</p>
<p>错误日志如下</p>
<p>touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied</p>
<p>Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?</p>
<p>\3. 我们检查一下之前启动方式的”/var/jenkins_home”目录权限，查看Jenkins容器的当前用户: 当前用户是”jenkins”而且”/var/jenkins_home”目录是属于jenkins用户拥有的</p>
<p>   docker@default:~$ docker run -ti –rm   –entrypoint=”/bin/bash” jenkins -c “whoami &amp;&amp;   id”   jenkins   uid=1000(jenkins) gid=1000(jenkins) groups=1000(jenkins)       docker@default:~$ docker run -ti –rm   –entrypoint=”/bin/bash” jenkins -c “ls -la   /var/jenkins_home”   total 20   drwxr-xr-x  2 jenkins jenkins   4096 Jun  5 08:39 .   drwxr-xr-x 28 root    root    4096 May 24 16:43 ..   -rw-r–r–  1 jenkins   jenkins  220 Nov 12  2014 .bash_logout   -rw-r–r–  1 jenkins jenkins   3515 Nov 12  2014 .bashrc   -rw-r–r–  1 jenkins   jenkins  675 Nov 12  2014 .profile   </p>
<p>而当映射本地数据卷时，/var/jenkins_home目录的拥有者变成了root用户</p>
<p>docker run -ti –rm -v $(pwd)/data:/var/jenkins_home –entrypoint=”/bin/bash” jenkins -c “ls -la /var/jenkins_home”</p>
<p>total 4</p>
<p>drwxr-sr-x  2 root staff   40 Jun  5 08:32 .</p>
<p>drwxr-xr-x 28 root root  4096 May 24 16:43 ..</p>
<p>这就解释了为什么当”jenkins”用户的进程访问”/var/jenkins_home”目录时，会出现 Permission denied 的问题</p>
<p>我们再检查一下宿主机上的数据卷目录，当前路径下”data”目录的拥有者是”root”，这是因为这个目录是Docker进程缺省创建出来的。</p>
<p>docker@default:~$ ls -la data</p>
<p>total 0</p>
<p>drwxr-sr-x    2 root     staff           40 Jun  5 08:32 ./</p>
<p>drwxr-sr-x    5 docker   staff          160 Jun  5 08:32 ../</p>
<p>发现问题之后，相应的解决方法也很简单：把当前目录的拥有者赋值给uid 1000，再启动”jenkins”容器就一切正常了。</p>
<p>sudo chown -R 1000 data</p>
<p>docker start jenkins</p>
<p>这时利用浏览器访问 “<a href="http://192.168.99.100:8080/" target="_blank" rel="external">http://192.168.99.100:8080/</a>“ 就可以看到Jenkins的Web界面了。注：如无法访问，可能需要通过docker-machine ip命令获得当前Docker宿主机的IP地址。</p>
<p>当我们再进入容器内部查看”/var/jenkins_home”目录的权限，其拥有者已经变成 “jenkins”</p>
<p>复制代码</p>
<p>docker@default:~$ docker exec jenkins ls -la /var/jenkins_home</p>
<p>total 24</p>
<p>drwxr-sr-x 11 jenkins staff  340 Jun  5 09:00 .</p>
<p>drwxr-xr-x 28 root    root  4096 May 24 16:43 ..</p>
<p>drwxr-sr-x  3 jenkins staff   60 Jun  5 08:59 .java</p>
<p>-rw-r–r–  1 jenkins staff  289 Jun  5 08:59 copy_reference_file.log</p>
<p>…</p>
<p>复制代码</p>
<p>而有趣的是在宿主机上我们看到的 “data”目录的拥有者是”docker”，这是因为”docker”用户在”boot2docker”宿主机上的uid也是”1000”。</p>
<p>docker@default:~$ ls -la data</p>
<p>total 20</p>
<p>drwxr-sr-x    2 docker   staff           40 Jun  5 11:55 ./</p>
<p>drwxr-sr-x    6 docker   staff          180 Jun  5 11:55 ../</p>
<p>…</p>
<p>这时我们已经可以知道：容器的本地数据卷中文件/目录的权限是和宿主机上一致的，只是uid/gid在Docker容器和宿主机中可能映射为不同的用户/组名称。</p>
<p>在上文，我们使用了一个常见的技巧，即在宿主机上执行chown命令时采用了uid而不是具体的用户名，这样就可以保证设置正确的拥有者。</p>
<p>问题虽然解决了，但思考并没有结束。因为当使用本地数据卷时，Jenkins容器会依赖宿主机目录权限的正确性，这会给自动化部署带来额外的工作。有没有方法让Jenkins容器为数据卷自动地设置正确的权限呢？这个问题对很多以non-root方式运行的应用也都有借鉴意义。</p>
<p>为non-root应用正确地挂载本地数据卷</p>
<p>我们可以从万能的stackoverflow.com找到很多相关的讨论，其中一个非常有借鉴意义问答如下</p>
<p><a href="http://stackoverflow.com/questions/23544282/what-is-the-best-way-to-manage-permissions-for-docker-shared-volumes" target="_blank" rel="external">http://stackoverflow.com/questions/23544282/what-is-the-best-way-to-manage-permissions-for-docker-shared-volumes</a></p>
<p>其中的基本思路有两个：</p>
<p>一个是利用Data Container的方法在容器间共享数据卷。这样就规避了解决宿主机上数据卷的权限问题。由于在1.9版本之后，Docker提供了named volume来取代纯数据容器，我们还需要真正地解决这个问题。</p>
<p>另外一个思路就是让容器中以root用户启动，在容器启动脚本中利用”chown”命令来修正数据卷文件权限，之后切换到non-root用户来执行程序</p>
<p>我们来参照第二个思路来解决这个问题</p>
<p>下面是一个基于Jenkins镜像的Dockerfile：它会切换到”root”用户并在镜像中添加”gosu”命令，和新的入口点”/entrypoint.sh”</p>
<p>   FROM jenkins:latest   USER root   RUN   GOSU_SHA=5ec5d23079e94aea5f7ed92ee8a1a34bbf64c2d4053dadf383992908a2f9dc8a \     &amp;&amp; curl -sSL -o   /usr/local/bin/gosu   “<a href="https://github.com/tianon/gosu/releases/download/1.9/gosu-$(dpkg" target="_blank" rel="external">https://github.com/tianon/gosu/releases/download/1.9/gosu-$(dpkg</a>   –print-architecture)” \     &amp;&amp; chmod +x   /usr/local/bin/gosu \     &amp;&amp; echo   “$GOSU_SHA    /usr/local/bin/gosu” | sha256sum -c -    COPY entrypoint.sh /entrypoint.sh   ENTRYPOINT [“/entrypoint.sh”]   </p>
<p>注释：gosu 是经常出现在官方Docker镜像中的一个小工具。它是”su”和”sudo”命令的轻量级替代品，并解决了它们在tty和信号传递中的一些问题。</p>
<p>新入口点的”entrypoint.sh”的内容如下：它会为”JENKINS_HOME”目录设置”jenkins”的拥有权限，并且再利用”gosu”命令切换到”jenkins”用户来执行”jenkins”应用。</p>
<p>#! /bin/bash</p>
<p>set -e</p>
<p>chown -R 1000 “$JENKINS_HOME”</p>
<p>exec gosu jenkins /bin/tini – /usr/local/bin/jenkins.sh</p>
<p>您可以直接从 <a href="https://github.com/denverdino/docker-jenkins" target="_blank" rel="external">https://github.com/denverdino/docker-jenkins</a> 获得相关代码，并构建自己的Jenkins镜像。执行命令如下：</p>
<p>git clone <a href="https://github.com/AliyunContainerService/docker-jenkins" target="_blank" rel="external">https://github.com/AliyunContainerService/docker-jenkins</a></p>
<p>cd docker-jenkins/jenkins</p>
<p>docker build -t denverdino/jenkins .</p>
<p>然后基于新镜像启动Jenkins容器</p>
<p>docker rm -f jenkins</p>
<p>docker run -d -p 8080:8080 -p 50000:50000 -v $(pwd)/data:/var/jenkins_home –name jenkins denverdino/jenkins</p>
<h2 id="3-linux安装git"><a href="#3-linux安装git" class="headerlink" title="3.linux安装git"></a>3.linux安装git</h2><h3 id="3-1-使用yum命令进行安装"><a href="#3-1-使用yum命令进行安装" class="headerlink" title="3.1 使用yum命令进行安装"></a>3.1 使用yum命令进行安装</h3><p>yum install git</p>
<p>安装简单，但是安装的git版本太老，而且版本不好控制，推荐使用下面的方式进行安装</p>
<h3 id="3-2-源码编译安装Git"><a href="#3-2-源码编译安装Git" class="headerlink" title="3.2 源码编译安装Git"></a>3.2 源码编译安装Git</h3><p>①、获取github最新的Git安装包下载链接，进入Linux服务器，执行下载，命令为： wget <a href="https://github.com/git/git/archive/v2.22.0.tar.gz" target="_blank" rel="external">https://github.com/git/git/archive/v2.22.0.tar.gz</a> ；</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image205.jpg" alt="img"></p>
<p>②、压缩包解压，命令为： tar -zxvf v2.22.0.tar.gz ；</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image206.png" alt="img"></p>
<p>③、安装编译源码所需依赖，命令为： yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker </p>
<p>耐心等待安装，出现提示输入y即可；</p>
<p>④、安装依赖时，yum自动安装了Git，需要卸载旧版本Git，命令为： yum remove git 出现提示输入y即可；</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image207.png" alt="img">很明显自己安装了一个1.8.3.1版本的git，卸载。</p>
<p>⑤、进入解压后的文件夹，命令 cd git-2.22.0 ，然后执行编译，命令为 make prefix=/usr/local/git all 耐心等待编译即可；</p>
<p>⑥、安装Git至/usr/local/git路径，命令为 make prefix=/usr/local/git install ；</p>
<p>⑦、打开环境变量配置文件，命令 vim /etc/profile ，在底部加上Git相关配置信息：</p>
<p>PATH=$PATH:/usr/local/git/bin </p>
<p>export PATH </p>
<p>然后保存，退出！</p>
<p>⑧、输入命令 git –version ，查看安装的git版本，校验通过，安装成功。</p>
<p>source /etc/profile</p>
<p><img src="/2019/03/08/持续集成技术总结/clip_image208.png" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、DockerMaven插件的使用&quot;&gt;&lt;a href=&quot;#一、DockerMaven插件的使用&quot; class=&quot;headerlink&quot; title=&quot;一、DockerMaven插件的使用&quot;&gt;&lt;/a&gt;一、DockerMaven插件的使用&lt;/h1&gt;&lt;p&gt;这个插件的目
    
    </summary>
    
      <category term="持续集成技术" scheme="http://kingge.top/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="持续集成技术" scheme="http://kingge.top/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%8A%80%E6%9C%AF/"/>
    
      <category term="容器管理" scheme="http://kingge.top/tags/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
      <category term="自动部署" scheme="http://kingge.top/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>docker个人总结</title>
    <link href="http://kingge.top/2019/02/28/docker%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://kingge.top/2019/02/28/docker个人总结/</id>
    <published>2019-02-28T13:59:59.000Z</published>
    <updated>2019-08-25T04:35:01.597Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习过docker，但是很浅显的使用，概念和流程各个方面总结的不够到位，下面根据旧版本的文档，重新的梳理。</p>
<h1 id="一、docker出现的契机"><a href="#一、docker出现的契机" class="headerlink" title="一、docker出现的契机"></a>一、docker出现的契机</h1><p>作为开发人员，我们经常会遇到一个问题，那就是环境不统一的问题。什么意思呢？自己在本地测试的项目是运行正常的，但是打包给测试或者运维人员部署使用时，经常会出现，部署报错，运行不起来，等等问题。就算是再详细的部署文档也还是会出错。</p>
<p>这个时候就产生了大量沟通的成本，通常产生这些问题的原因是部署的环境并不是开发人员的那一份环境，可能是jdk版本或者tomcat版本，数据库等等环境产生的问题。所以就需要我们开发人员打包一份连同环境和配置以及项目，交付给测试或者运维。这样就能够保证项目运行环境的一致性，也容易排查问题。<strong>这个就是docker的雏形</strong></p>
<pre><code>就好比我们在迁移一棵树的时候，尾部，总是会保留着一些原先的土，就是为了解决生长环境的不同额度适配问题。
</code></pre><p><strong>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</strong></p>
<p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</p>
<pre><code>*总的来说，以前我们是通过提交**war**包的方式，那么现在是连同**war***运行的环境***一起打包给测试或者运维。*
</code></pre><p><img src="/2019/02/28/docker个人总结/clip_image002.jpg" alt="graphic"></p>
<p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。<strong>透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间（类似于jvm的理念）的无缝接轨运作</strong>。</p>
<h2 id="1-1-理念"><a href="#1-1-理念" class="headerlink" title="1.1 理念"></a>1.1 理念</h2><p>Docker是基于Go语言实现的云开源项目。</p>
<p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“<strong>一次封装，到处运行</strong>”。</p>
<p><strong>Linux</strong> <strong>容器技术</strong>的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image004.jpg" alt="graphic"></p>
<p><strong>也就是说，我们可以把项目运行成功所需要的环境（redis，nginx，mysql）等等组件，通过编译打包的形式，打包成一个个的货仓。</strong></p>
<p><strong>项目部署到其他环境时（windowsàlinux）只需要运行这些货仓就可以安装这些环境，做到一次封装到处运行，解决了因为环境不同导致app部署或运行失败的问题</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image006.jpg" alt="img">docker的logo就阐述了这一理念，部署项目的时候直接搬运已经测试成功的app运行环境。</p>
<pre><code>**特别是在多集群的环境下，docker的作用更显而易见（避免多次安装环境）**
</code></pre><p>总的来说：<strong>解决了运行环境和配置问题软件容器（每个容器对应着一个集装箱，每个集装箱对应着项目运行所需的软件或者配置），方便做持续集成并有助于整体发布的容器虚拟化技术</strong>。</p>
<h1 id="二、docker的演化"><a href="#二、docker的演化" class="headerlink" title="二、docker的演化"></a>二、docker的演化</h1><h2 id="2-1-虚拟机技术"><a href="#2-1-虚拟机技术" class="headerlink" title="2.1 虚拟机技术"></a>2.1 虚拟机技术</h2><p><img src="/2019/02/28/docker个人总结/clip_image007.png" alt="img">一个虚拟机的结构图</p>
<p>虚拟机（virtual machine）就是<strong>带环境安装</strong>的一种解决方案。</p>
<p>带环境安装的意思是：它里面模拟了一个正常的操作系统所具备的各种环境和配置（内存、处理器、硬盘。。。。）</p>
<p><img src="/2019/02/28/docker个人总结/clip_image008.png" alt="img"></p>
<p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。  </p>
<p>​       </p>
<p>缺点：</p>
<p>\1.     启动很慢</p>
<p>\2.     资源占用多</p>
<p>\3.     冗余步骤多</p>
<p>所以docker在这之上就演化出了 <strong>容器虚拟化技术</strong></p>
<h2 id="2-2-容器虚拟化技术"><a href="#2-2-容器虚拟化技术" class="headerlink" title="2.2 容器虚拟化技术"></a>2.2 容器虚拟化技术</h2><p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：L<strong>inux</strong> <strong>容器（Linux Containers，缩写为</strong> <strong>LXC）</strong>。</p>
<p><strong>Linux</strong> <strong>容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image009.png" alt="img"></p>
<p>相比虚拟机技术的系统结构图，很明显发现，公用库api模块被移除。各个app维护自己的所依赖的api模块。好处就是，节省了资源的占用。</p>
<h2 id="2-3-总结不同"><a href="#2-3-总结不同" class="headerlink" title="2.3 总结不同"></a>2.3 总结不同</h2><p>比较了 Docker 和传统虚拟化方式的不同之处：</p>
<p>\1.     传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程</p>
<p>\2.     而容器内的应用进程<strong>直接运行于宿主的内核</strong>，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p>\3.      每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p>
<p><strong>4.</strong>     <strong>Linux虚拟机安装包可能需要4G，但是docker只需要170M。很明显这是一个很大的提升，换句话说，docker就是一个精细版的linux虚拟机</strong></p>
<h1 id="三、docker的好处"><a href="#三、docker的好处" class="headerlink" title="三、docker的好处"></a>三、docker的好处</h1><p>一次构建、随处运行</p>
<h2 id="更快速的应用交付和部署"><a href="#更快速的应用交付和部署" class="headerlink" title="更快速的应用交付和部署"></a>更快速的应用交付和部署</h2><p><img src="/2019/02/28/docker个人总结/clip_image011.jpg" alt="img"></p>
<h2 id="更便捷的升级和扩缩容"><a href="#更便捷的升级和扩缩容" class="headerlink" title="更便捷的升级和扩缩容"></a>更便捷的升级和扩缩容</h2><p><img src="/2019/02/28/docker个人总结/clip_image013.jpg" alt="img"></p>
<h2 id="更简单的系统运维"><a href="#更简单的系统运维" class="headerlink" title="更简单的系统运维"></a>更简单的系统运维</h2><p><img src="/2019/02/28/docker个人总结/clip_image015.jpg" alt="img"></p>
<h2 id="更高效的计算资源利用"><a href="#更高效的计算资源利用" class="headerlink" title="更高效的计算资源利用"></a>更高效的计算资源利用</h2><p><img src="/2019/02/28/docker个人总结/clip_image017.jpg" alt="img"></p>
<h1 id="四、安装和下载"><a href="#四、安装和下载" class="headerlink" title="四、安装和下载"></a>四、安装和下载</h1><p>docker官网：<a href="http://www.docker.com" target="_blank" rel="external">http://www.docker.com</a></p>
<p>docker中文网站： <a href="https://www.docker-cn.com/" target="_blank" rel="external">https://www.docker-cn.com/</a></p>
<p>Docker Hub官网: <a href="https://hub.docker.com/" target="_blank" rel="external">https://hub.docker.com/</a></p>
<p><code>Docker</code> 分为 <code>CE</code> 和 <code>EE</code> 两大版本。 <code>CE</code> 即社区版（免费，支持周期 <code>7</code> 个月）， <code>EE</code> 即企业版，强调安全，付费使用，支持周期 <code>24</code> 个月。下面安装的是CE版本。</p>
<h2 id="4-1-docker安装前提条件"><a href="#4-1-docker安装前提条件" class="headerlink" title="4.1 docker安装前提条件"></a>4.1 docker安装前提条件</h2><p>Docker支持以下的CentOS版本：CentOS 7 (64-bit)</p>
<p>CentOS 6.5 (64-bit) 或更高的版本</p>
<p>目前，CentOS 仅发行版本中的内核支持 Docker。</p>
<p>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。</p>
<p>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p>
<p>为了避免我们后面启动tomcat 容器做测试的时候，外部浏览器访问tomcat容器时，端口被拦截。这里先关闭虚拟机的防火墙</p>
<p>service firewalld status ；查看防火墙状态</p>
<p><img src="/2019/02/28/docker个人总结/clip_image019.jpg" alt="img"></p>
<p>service firewalld stop：关闭防火墙</p>
<h3 id="查看自己linux-内核"><a href="#查看自己linux-内核" class="headerlink" title="查看自己linux 内核"></a>查看自己linux 内核</h3><p>uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image020.png" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image022.jpg" alt="img"></p>
<h3 id="查看已安装的CentOS版本信息（CentOS6-8有，CentOS7无该命令）"><a href="#查看已安装的CentOS版本信息（CentOS6-8有，CentOS7无该命令）" class="headerlink" title="查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）"></a>查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）</h3><p><img src="/2019/02/28/docker个人总结/clip_image024.jpg" alt="img"></p>
<p>另一种方式查询</p>
<p><img src="/2019/02/28/docker个人总结/clip_image025.png" alt="img"></p>
<h2 id="4-2-docker安装"><a href="#4-2-docker安装" class="headerlink" title="4.2 docker安装"></a>4.2 docker安装</h2><p><strong>一下安装是使用yum命令进行安装，所以linux虚拟机需要能够连接互联网</strong></p>
<p><strong>官方手册：</strong></p>
<p><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#prerequisites" target="_blank" rel="external">https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#prerequisites</a></p>
<h3 id="CentOS6-8安装Docker"><a href="#CentOS6-8安装Docker" class="headerlink" title="CentOS6.8安装Docker"></a>CentOS6.8安装Docker</h3><p>\1.      yum install -y epel-release</p>
<p>  使用root用户执行改命令。</p>
<p>Docker使用EPEL发布，RHEL系的OS首先要确保已经持有EPEL仓库，否则先检查OS的版本，然后安装相应的EPEL包</p>
<p><img src="/2019/02/28/docker个人总结/clip_image027.jpg" alt="img"></p>
<p>\2.      yum install -y docker-io</p>
<p>发现这个命令在centos6.10 版本时，提示docker包找不到，于是花了另一命令：yum –y  install  docker  安装成功</p>
<p>\3.      安装后的配置文件：/etc/sysconfig/docker</p>
<p>\4.      启动Docker后台服务：service docker start</p>
<p>5.docker version验证</p>
<h3 id="CentOS7以上安装Docker（本人使用的版本）-推荐"><a href="#CentOS7以上安装Docker（本人使用的版本）-推荐" class="headerlink" title="CentOS7以上安装Docker（本人使用的版本）-推荐"></a>CentOS7以上安装Docker（本人使用的版本）-推荐</h3><p><img src="/2019/02/28/docker个人总结/clip_image029.jpg" alt="img"></p>
<p>  下面使用仓库的方式进行安装docker-ce</p>
<p>\1. cat /etc/redhat-release</p>
<p>命令查看centos版本</p>
<p><img src="/2019/02/28/docker个人总结/clip_image030.png" alt="img"></p>
<p>\2. yum安装gcc相关</p>
<p>  执行以下两条命令</p>
<p>  yum -y install gcc</p>
<p>yum -y install gcc-c++</p>
<p>3.卸载老版本（如果之前没有装过，可以忽略这一步）</p>
<p>   注意看官网的操作手册，里面有着一段命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo yum remove docker \</div><div class="line">                  docker-client \</div><div class="line">                  docker-client-latest \</div><div class="line">                  docker-common \</div><div class="line">                  docker-latest \</div><div class="line">                  docker-latest-logrotate \</div><div class="line">                  docker-logrotate \</div><div class="line">                  docker-engine</div></pre></td></tr></table></figure>
<p>   $ sudo yum remove docker \                     docker-client   \                       docker-client-latest \                     docker-common   \                     docker-latest   \                       docker-latest-logrotate \                       docker-logrotate \                     docker-engine   </p>
<p>\4. 安装需要的软件包</p>
<pre><code>yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre><p>\5. 设置stable镜像仓库</p>
<p>执行命令：</p>
<pre><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

       注意这里使用的是阿里的镜像仓库，不要使用官网推荐的仓库
</code></pre><p>​          </p>
<p>   yum-config-manager –add-repo   <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="external">https://download.docker.com/linux/centos/docker-ce.repo</a>               不能使用这条命令   </p>
<p>\6. 更新yum软件包索引</p>
<pre><code>yum makecache fast
</code></pre><p>\7. 安装DOCKER CE</p>
<pre><code>yum -y install docker-ce
</code></pre><p>\8. 启动docker</p>
<pre><code>systemctl start docker
</code></pre><p>\9. 测试</p>
<p>docker version  :查看docker版本</p>
<p>docker pull hello-world（从阿里云仓库中获取hello-world镜像）</p>
<pre><code>docker run hello-world （要先下载hello-world镜像后才能够运行）
</code></pre><p><img src="/2019/02/28/docker个人总结/clip_image032.jpg" alt="img"></p>
<p>10.卸载</p>
<pre><code>执行以下三条命令：

systemctl stop docker 

yum -y remove docker-ce

rm -rf /var/lib/docker
</code></pre><h2 id="4-3阿里云镜像加速"><a href="#4-3阿里云镜像加速" class="headerlink" title="4.3阿里云镜像加速"></a>4.3阿里云镜像加速</h2><p>因为docker官网提供的获取镜像地址（hub.docker），访问速度太过缓慢，这里改换成阿里云的镜像服务。</p>
<p>\1.     登录阿里云</p>
<p><a href="https://www.aliyun.com/" target="_blank" rel="external">https://www.aliyun.com/</a> 进入管理中心</p>
<p>\2.     搜索容器镜像服务</p>
<p><img src="/2019/02/28/docker个人总结/clip_image034.jpg" alt="img"></p>
<p>可以看到镜像加速器</p>
<p><img src="/2019/02/28/docker个人总结/clip_image036.jpg" alt="img"></p>
<p>获得加速器地址连接</p>
<p>\3. 配置本机Docker运行镜像加速器</p>
<p><strong>Centos6.8版本设置：</strong></p>
<ul>
<li>vim   /etc/sysconfig/docker      将获得的自己账户下的阿里云加速地址配置进   other_args=”–registry-mirror=<a href="https://你自己的账号加速信息.mirror.aliyuncs.com" target="_blank" rel="external">https://你自己的账号加速信息.mirror.aliyuncs.com</a>“   </li>
</ul>
<p><img src="/2019/02/28/docker个人总结/clip_image038.jpg" alt="img"></p>
<p><strong>Centos7.6版本设置：</strong></p>
<p>   sudo mkdir -p /etc/docker   sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’   {     “registry-mirrors”:   [“<a href="https://sk6o0yc78m.mirror.aliyuncs.com" target="_blank" rel="external">https://sk6o0yc78m.mirror.aliyuncs.com</a>“]   }   EOF   sudo systemctl daemon-reload   sudo systemctl restart docker   </p>
<p><img src="/2019/02/28/docker个人总结/clip_image039.png" alt="img"></p>
<p>Centos7以上的配置文件时：/etc/docker/daemon.json</p>
<p>4．检查配置是否生效</p>
<p>  Centos6.8 检查命令：</p>
<pre><code>启动docker，执行命令 ps –ef| grep docker
</code></pre><p>Centos7.6检查命令：</p>
<p><img src="/2019/02/28/docker个人总结/clip_image041.jpg" alt="img"></p>
<h2 id="4-4-设置docker开机启动"><a href="#4-4-设置docker开机启动" class="headerlink" title="4.4    设置docker开机启动"></a>4.4    设置docker开机启动</h2><p>systemctl enable docker</p>
<h1 id="五、docker组成和分析"><a href="#五、docker组成和分析" class="headerlink" title="五、docker组成和分析"></a>五、docker组成和分析</h1><h2 id="5-1-Docker组成"><a href="#5-1-Docker组成" class="headerlink" title="5.1 Docker组成"></a>5.1 Docker组成</h2><h3 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h3><p>Docker 镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image042.png" alt="graphic"></p>
<p> 一个类可以new多个对象。</p>
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h4 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h4><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p> <img src="/2019/02/28/docker个人总结/clip_image044.jpg" alt="graphic">跟花卷一样，一层一层的</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<h4 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h4><p> Docker镜像加载原理：</p>
<p>   docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 </p>
<p><img src="/2019/02/28/docker个人总结/clip_image046.jpg" alt="graphic"></p>
<p> <strong>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image048.jpg" alt="graphic"></p>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host（宿主机）的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<h4 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h4><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</p>
<p><img src="/2019/02/28/docker个人总结/clip_image050.jpg" alt="img"></p>
<p>有多个complete，说明有多个层次</p>
<h4 id="为什么-Docker-镜像要采用这种分层结构呢"><a href="#为什么-Docker-镜像要采用这种分层结构呢" class="headerlink" title="为什么 Docker 镜像要采用这种分层结构呢"></a>为什么 Docker 镜像要采用这种分层结构呢</h4><p>最大的一个好处就是 - 共享资源</p>
<p>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，</p>
<p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>Docker镜像都是只读的</p>
<p>当容器启动时，一个新的可写层被加载到镜像的顶部。</p>
<p>这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<h3 id="容器（container）鲸鱼背上的集装箱"><a href="#容器（container）鲸鱼背上的集装箱" class="headerlink" title="容器（container）鲸鱼背上的集装箱"></a>容器（container）鲸鱼背上的集装箱</h3><p><strong>Docker</strong> <strong>利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。</strong></p>
<p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>
<p><strong>可以把容器看做是一个简易版的</strong> <strong>Linux</strong> <strong>环境</strong>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，<strong>唯一区别在于容器的最上面那一层是可读可写的</strong>。</p>
<p><strong>即是：容器=镜像+可读写层</strong></p>
<h3 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h3><p>仓库（Repository）是集中存放镜像文件的场所。</p>
<p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p>
<p>最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)，" target="_blank" rel="external">https://hub.docker.com/)，</a></p>
<p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要正确的理解仓储/镜像/容器这几个概念:</p>
<p> Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>\1.     image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p>
<p>\2.     一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</p>
<p>\3.     至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</p>
<p>总结：仓库存放着很多镜像，通过使用镜像可以生成多个容器</p>
<h2 id="5-2-Docker运行流程"><a href="#5-2-Docker运行流程" class="headerlink" title="5.2 Docker运行流程"></a>5.2 Docker运行流程</h2><p><img src="/2019/02/28/docker个人总结/clip_image052.png" alt="docker-framework"></p>
<p>Docker 使用 C/S 结构，即客户端/服务器体系结构。 Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。 Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 stock 或网络接口与远程 Docker 服务端进行通信。</p>
<h3 id="执行docker-run-hello-world"><a href="#执行docker-run-hello-world" class="headerlink" title="执行docker run hello-world"></a>执行docker run hello-world</h3><p>这个例子在上面我们已经使用过了，对照docker结构图我们来分析</p>
<p>Client：客户端就是我们的linux的命令窗口，也就是执行docker run hello-world的地方</p>
<p>Docker-host： docker主机，也就是执行客户端发出请求的地方，也就是我们启动的docker进程。收到一个执行hello-world容器的命令，现在本地种查找是否存在这个容器（镜像），存在则直接运行。不存在，则在Repository中取（上面我们配置了阿里云镜像仓库），pull镜像后放到本地，然后新建一个容器执行这个hello-world镜像。</p>
<p>Repository:：仓库，存放镜像的地方</p>
<p>下次执行docker run hello-world，则会从本地中拿hello-world镜像，然后新建容器执行。</p>
<p>完整流程如图：</p>
<p><img src="/2019/02/28/docker个人总结/clip_image054.jpg" alt="img"></p>
<h1 id="六、docker常用操作命令"><a href="#六、docker常用操作命令" class="headerlink" title="六、docker常用操作命令"></a>六、docker常用操作命令</h1><h2 id="6-1-帮助命令"><a href="#6-1-帮助命令" class="headerlink" title="6.1 帮助命令"></a>6.1 帮助命令</h2><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h3><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h3><p>能够查看更详细的docker信息，比docker version命令更加详细</p>
<h3 id="docker-–help"><a href="#docker-–help" class="headerlink" title="docker –help"></a>docker –help</h3><h2 id="6-2-镜像命令"><a href="#6-2-镜像命令" class="headerlink" title="6.2       镜像命令"></a>6.2       镜像命令</h2><h3 id="6-2-1-docker-images"><a href="#6-2-1-docker-images" class="headerlink" title="6.2.1 docker images"></a>6.2.1 docker images</h3><p>列出本地主机上的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image056.jpg" alt="img"></p>
<p>各个选项说明:</p>
<p>   REPOSITORY：表示镜像的仓库源   TAG：<strong>镜像 标签</strong>   IMAGE ID：镜像ID   CREATED：镜像创建时间   SIZE：镜像大小   </p>
<p> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p><strong>如果你不指定一个镜像的版本标签，例如你只使用</strong> <strong>redis，docker</strong> <strong>将默认使用</strong> <strong>redis:latest镜像</strong></p>
<p>   OPTIONS说明：   -a :列出本地所有的镜像（含中间映像层）   -q :只显示镜像ID。   –digests :显示镜像的摘要信息   –no-trunc :显示完整的镜像信息   </p>
<h3 id="6-2-2-docker-search-某个XXX镜像名字"><a href="#6-2-2-docker-search-某个XXX镜像名字" class="headerlink" title="6.2.2 docker search 某个XXX镜像名字"></a>6.2.2 docker search 某个XXX镜像名字</h3><p><strong>需要注意，查询是从网站</strong> <a href="https://hub.docker.com" target="_blank" rel="external">https://hub.docker.com</a><strong>上进行查询，拉取镜像的时候是从阿里云上拉取</strong></p>
<p>命令： docker search [OPTIONS] 镜像名字</p>
<p>OPTIONS说明：</p>
<p>–no-trunc : 显示完整的镜像描述</p>
<p>-s : 列出收藏数不小于指定值的镜像。（<strong>就是下面的STARS数</strong>）</p>
<p>–automated : 只列出 automated build类型的镜像；</p>
<p><img src="/2019/02/28/docker个人总结/clip_image058.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image060.jpg" alt="img"></p>
<h3 id="6-2-3-docker-pull-某个XXX镜像名字"><a href="#6-2-3-docker-pull-某个XXX镜像名字" class="headerlink" title="6.2.3 docker pull 某个XXX镜像名字"></a>6.2.3 docker pull 某个XXX镜像名字</h3><p>下载镜像</p>
<p>命令：ker pull 镜像名字[:TAG]  （如果不指明标签默认下载最新版本）</p>
<h3 id="6-2-4-docker-rmi-某个XXX镜像名字ID"><a href="#6-2-4-docker-rmi-某个XXX镜像名字ID" class="headerlink" title="6.2.4 docker rmi 某个XXX镜像名字ID"></a>6.2.4 docker rmi 某个XXX镜像名字ID</h3><p>删除镜像</p>
<p>删除单个：</p>
<p>docker rmi  -f 镜像ID （不指明标签默认删除latest）</p>
<p>docker rmi  -f 镜像名称 （不指明标签默认删除latest）</p>
<p>删除多个：docker rmi -f 镜像名1:TAG 镜像名2:TAG </p>
<p>删除全部：ocker rmi -f $(docker images -qa) （<strong>docker images –qa</strong> <strong>查询当前docker中所有镜像id</strong>）</p>
<h2 id="6-3容器命令"><a href="#6-3容器命令" class="headerlink" title="6.3容器命令"></a>6.3容器命令</h2><h3 id="6-3-1有镜像才能创建容器，这是根本前提-下载一个CentOS镜像演示"><a href="#6-3-1有镜像才能创建容器，这是根本前提-下载一个CentOS镜像演示" class="headerlink" title="6.3.1有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示)"></a>6.3.1有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示)</h3><p>docker pull centos</p>
<p><img src="/2019/02/28/docker个人总结/clip_image062.jpg" alt="img"></p>
<p>所以说<strong>可以把容器看做是一个简易版的</strong> <strong>Linux</strong> <strong>环境</strong></p>
<h3 id="6-3-2新建并启动容器"><a href="#6-3-2新建并启动容器" class="headerlink" title="6.3.2新建并启动容器"></a>6.3.2新建并启动容器</h3><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p> OPTIONS说明</p>
<p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号</p>
<p>–name=”容器新名字”: 为容器指定一个名称；</p>
<p>-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</p>
<p>-i：以交互模式运行容器，通常与 -t 同时使用；</p>
<p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
<p>-P: 随机端口映射；</p>
<p>-p: 指定端口映射，有以下四种格式</p>
<pre><code>ip:hostPort:containerPort

ip::containerPort

hostPort:containerPort

containerPort
</code></pre><p>下面运行6.3.1中下载的centos</p>
<p><img src="/2019/02/28/docker个人总结/clip_image064.jpg" alt="img"></p>
<p><strong>启动交互式容器（跟下面我们所说的启动守护式容器有区别）</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image066.jpg" alt="graphic"></p>
<p>#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p>
<p><strong>docker run -it centos /bin/bash</strong> <strong>等同于</strong> <strong>docker run -it centos</strong></p>
<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p>1.从Hub上下载tomcat镜像到本地并成功运行</p>
<p>  （1）docker pull tomcat </p>
<p>  （2）docker run -it -p 8088:8080 tomcat </p>
<p>  运行tomcat，第一个端口8088表示docker对外暴露访问内部tomcat的端口，映射内部tomcat 的8080端口，什么意思呢？</p>
<p><img src="/2019/02/28/docker个人总结/clip_image068.jpg" alt="img"></p>
<p>查看运行的容器</p>
<p><img src="/2019/02/28/docker个人总结/clip_image070.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image072.jpg" alt="img"></p>
<p>访问tomcat成功，直接访问<a href="http://192.168.1.105:8080/" target="_blank" rel="external">http://49.234.188.74:8080/</a> 失败，因为我们知道，tomcat 是docker运行的一个容器，所以需要docker对外暴露后才能够访问。</p>
<p>（3）使用-P 不指名端口的方式运行tomcat</p>
<p><img src="/2019/02/28/docker个人总结/clip_image074.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image076.jpg" alt="img"></p>
<p>很明显使用大P的方式启动tomcat，docker会随机分配一个对外暴露的端口</p>
<p><img src="/2019/02/28/docker个人总结/clip_image078.jpg" alt="img"></p>
<h3 id="6-3-3列出当前所有正在运行的容器"><a href="#6-3-3列出当前所有正在运行的容器" class="headerlink" title="6.3.3列出当前所有正在运行的容器"></a>6.3.3列出当前所有正在运行的容器</h3><p>docker ps [OPTIONS]</p>
<p>OPTIONS说明（常用）：</p>
<p>-a :列出当前所有正在运行的容器+历史上运行过的</p>
<p>-l :显示最近创建的容器。</p>
<p>-n：显示最近n个创建的容器。</p>
<p>-q :静默模式，只显示容器编号。</p>
<p>–no-trunc :不截断输出。</p>
<p><strong>查看6.3.2</strong> <strong>运行的centos</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image080.jpg" alt="img"></p>
<h3 id="6-3-4退出容器"><a href="#6-3-4退出容器" class="headerlink" title="6.3.4退出容器"></a>6.3.4退出容器</h3><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>容器停止退出，销毁容器。<strong>注意，容器内的数据也会一并消失，类似java的对象，close销毁后就不会存在了。</strong></p>
<h4 id="ctrl-P-Q"><a href="#ctrl-P-Q" class="headerlink" title="ctrl+P+Q"></a>ctrl+P+Q</h4><p>容器不停止退出,回到宿主机。（<strong>那么怎么回到容器呢？-请看下面补充章节的第五小点</strong>）</p>
<h3 id="6-3-5启动容器"><a href="#6-3-5启动容器" class="headerlink" title="6.3.5启动容器"></a>6.3.5启动容器</h3><p>docker start 容器ID或者容器名 （可以启动已经关闭的容器）（docker ps –l 查看最近运行过得容器）</p>
<h3 id="6-3-6重启容器"><a href="#6-3-6重启容器" class="headerlink" title="6.3.6重启容器"></a>6.3.6重启容器</h3><p>docker restart 容器ID或者容器名</p>
<h3 id="6-3-7停止容器"><a href="#6-3-7停止容器" class="headerlink" title="6.3.7停止容器"></a>6.3.7停止容器</h3><p>docker stop 容器ID或者容器名</p>
<h3 id="6-3-8强制停止容器"><a href="#6-3-8强制停止容器" class="headerlink" title="6.3.8强制停止容器"></a>6.3.8强制停止容器</h3><p>docker kill 容器ID或者容器名</p>
<h3 id="6-3-9删除已停止的容器"><a href="#6-3-9删除已停止的容器" class="headerlink" title="6.3.9删除已停止的容器"></a>6.3.9删除已停止的容器</h3><p>docker rm 容器ID</p>
<p>一次性删除多个容器（下面两种方式）</p>
<p>docker rm -f $(docker ps -a -q)</p>
<p>docker ps -a -q | xargs docker rm</p>
<h3 id="6-3-10-迁移与备份"><a href="#6-3-10-迁移与备份" class="headerlink" title="6.3.10 迁移与备份"></a>6.3.10 迁移与备份</h3><p><img src="/2019/02/28/docker个人总结/clip_image082.jpg" alt="img"></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h4><p> 命令：docker run -d 容器名</p>
<p>   docker run -d centos       问题：然后docker ps -a 进行查看, <strong>会发现容器已经退出，也就是说没有刚才我们启动的容器</strong>       很重要的要说明的一点: <strong>Docker**</strong>容器后台运行<strong><strong>,</strong></strong>就必须有一个前台进程<strong>**.</strong>   <strong>容器运行的命令如果不是那些一直挂起的命令（比如运行**</strong>top<strong><strong>，</strong></strong>tail<strong>**），就是会自动退出的</strong>。       这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如   service nginx start   但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,   这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.   所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行   </p>
<h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><p>命令：docker logs -f -t –tail 容器ID</p>
<p> 参数解析：</p>
<p>*   -t 是加入时间戳</p>
<p>*   -f 跟随最新的日志打印</p>
<p>*   –tail 数字 显示最后多少条</p>
<p>例子：</p>
<p>  启动守护式容器（因为存在前台程序一直循环输出,那么他就不会退出）</p>
<p>docker run -d centos /bin/sh -c “while true;do echo hello kingge;sleep 2;done”</p>
<p><img src="/2019/02/28/docker个人总结/clip_image084.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image085.png" alt="img"></p>
<h4 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h4><p>docker top 容器ID</p>
<p><img src="/2019/02/28/docker个人总结/clip_image087.jpg" alt="img"></p>
<p>返回的信息时，上个例子中启动的守护式容器</p>
<h4 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h4><p>docker inspect 容器ID</p>
<p>返回一个json串的描述格式</p>
<p><img src="/2019/02/28/docker个人总结/clip_image089.jpg" alt="img"></p>
<h4 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h4><p><strong>回到以ctrl+p+q的方式退出的容器中</strong></p>
<p>第一种方式：</p>
<p>   使用命令：docker exec -it 容器ID bashShell （后面必须携带bash指令）</p>
<p><img src="/2019/02/28/docker个人总结/clip_image090.png" alt="img">登录操作</p>
<p>效果等同</p>
<p><img src="/2019/02/28/docker个人总结/clip_image091.png" alt="img"></p>
<p>例子2：</p>
<p><img src="/2019/02/28/docker个人总结/clip_image093.jpg" alt="img"></p>
<p><strong>打印后台启动的centos容器的根目录的消息，我们发现，他并没有进入后台的容器，只是把容器执行的指令的结果输出到宿主。所以他的功能是比docker attach指令还要强大的</strong></p>
<p>第二种方式：</p>
<pre><code>docker attach 容器ID
</code></pre><p>两种方式的区别：</p>
<p>attach 直接进入容器启动命令的终端，不会启动新的进程</p>
<p>exec 是在容器中打开新的终端，并且可以启动新的进程</p>
<h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><p><strong>宿主机上执行</strong></p>
<p>docker cp  容器ID:容器内路径 目的主机路径</p>
<h4 id="Docker镜像commit"><a href="#Docker镜像commit" class="headerlink" title="Docker镜像commit"></a>Docker镜像commit</h4><p>\1. commit提交容器副本使之成为一个新的镜像</p>
<p>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:[标签名]</p>
<h5 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h5><p>1.删除运行的tomcat 的文档模块，然后提交为新的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image095.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image097.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image099.jpg" alt="img"></p>
<p>这个时候再来访问tomcat容器的docs文档模块，肯定是404.</p>
<p><img src="/2019/02/28/docker个人总结/clip_image101.jpg" alt="img"></p>
<p>\2. 也即当前的tomcat运行实例是一个没有文档内容的容器，以它为模板commit一个没有doc的tomcat新镜像kingge/tomcatnodoc</p>
<p><img src="/2019/02/28/docker个人总结/clip_image103.jpg" alt="img"></p>
<p><strong>注意这个标红框的镜像id必须是某一个正在运行的容器id</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image105.jpg" alt="img"></p>
<p>3.启动重新上传的tomcat</p>
<p><img src="/2019/02/28/docker个人总结/clip_image107.jpg" alt="img"></p>
<p>查看是否存在doc目录</p>
<p><img src="/2019/02/28/docker个人总结/clip_image108.png" alt="img"></p>
<p>不存在，说明这个版本就是我们亲自提交的删除文档的tomcat版本。</p>
<p><strong>这个时候可以同时启动原先的tomcat版本，查看区别。</strong></p>
<h2 id="命令图例"><a href="#命令图例" class="headerlink" title="命令图例"></a>命令图例</h2><p><img src="/2019/02/28/docker个人总结/clip_image110.jpg" alt="graphic"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image112.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image114.jpg" alt="img"></p>
<h1 id="七、Docker容器数据卷"><a href="#七、Docker容器数据卷" class="headerlink" title="七、Docker容器数据卷"></a>七、Docker容器数据卷</h1><p>生产环境中使用Docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p>
<p> 卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性.</p>
<p> 卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷.( 数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于Linux中的mount操作)</p>
<p>​       </p>
<p>特点：</p>
<p>1：数据卷可在容器之间共享或重用数据</p>
<p>2：卷中的更改可以直接生效</p>
<p>3：数据卷中的更改不会包含在镜像的更新中</p>
<p>4：数据卷的生命周期一直持续到没有容器使用它为止</p>
<p>容器中管理数据主要有两种方式：</p>
<p>\1.     <strong>数据卷（Data Volumes）</strong>：容器内数据<strong>直接映射</strong>到本地主机环境，如何在容器内创建数据卷，并且把本地的目录或文件挂载到容器内的数据卷中。</p>
<p>\2.     <strong>数据卷容器（Data Volume Containers）</strong>：使用特定容器维护数据卷。如何使用数据卷容器在容器和主机、容器和容器之间共享数据，并实现数据的备份和恢复。</p>
<h2 id="7-1-创建数据卷"><a href="#7-1-创建数据卷" class="headerlink" title="7.1 创建数据卷"></a>7.1 创建数据卷</h2><h3 id="7-1-1-第一种方式：使用命令直接添加"><a href="#7-1-1-第一种方式：使用命令直接添加" class="headerlink" title="7.1.1 第一种方式：使用命令直接添加"></a>7.1.1 第一种方式：使用命令直接添加</h3><p>命令： docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名</p>
<pre><code>就是把宿主机的某个目录关联到容器中，两者数据共通（文件夹不存在时，自动创建）
</code></pre><p>1.使用命令创建数据卷</p>
<p><img src="/2019/02/28/docker个人总结/clip_image115.png" alt="img"></p>
<p>宿主机也创建了myHostVal目录</p>
<p><img src="/2019/02/28/docker个人总结/clip_image116.png" alt="img"></p>
<p>2.校验是否数据共通</p>
<p><img src="/2019/02/28/docker个人总结/clip_image117.png" alt="img">宿主机创建一个文本</p>
<p>查看容器是否存在hello.txt</p>
<p><img src="/2019/02/28/docker个人总结/clip_image118.png" alt="img">容器存在。</p>
<p>反之，容器创建一个文件，宿主机也会出现同样的文件。</p>
<p>尖叫提示：</p>
<p><strong>Docker挂载数据卷的默认权限是读写（rw），用户也可以通过ro指定为只读</strong></p>
<p>\3.     极端测试</p>
<p>  容器停止退出后（exit），宿主机创建或者修改文件，再重启容器（start），查看宿主机创建或者修改的文件是否有相应的变化。</p>
<p>  经测试，答案是会有相应的变化。</p>
<p>4.查看容器的内部细节</p>
<p>docker inspect 容器ID</p>
<p>   返回的json串中可以找到这样的一行描述</p>
<p><img src="/2019/02/28/docker个人总结/clip_image119.png" alt="img"></p>
<p>5.容器挂载文件夹的读写方式</p>
<p>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</p>
<p><img src="/2019/02/28/docker个人总结/clip_image120.png" alt="img"></p>
<p>经过操作我们发现，宿主机创建或者修改的文件都能够同步到容器中，但是在容器中只能够查看对应的宿主机同步过来的文件，容器中不能够新增删除修改文件，只能够查看。</p>
<p>再次使用inspect 命令查看挂载的状态</p>
<p><img src="/2019/02/28/docker个人总结/clip_image121.png" alt="img"></p>
<p>发现可读写方式变为false，只读。</p>
<h3 id="7-1-2-第二种方式：DockerFile方式添加"><a href="#7-1-2-第二种方式：DockerFile方式添加" class="headerlink" title="7.1.2 第二种方式：DockerFile方式添加"></a>7.1.2 第二种方式：DockerFile方式添加</h3><p>DockerFile就是对于一个镜像的描述文件，类似于java代码编译后形成的.class文件，他是关于一个java类的描述。</p>
<h4 id="1初探dockerfile结构"><a href="#1初探dockerfile结构" class="headerlink" title="1初探dockerfile结构"></a>1初探dockerfile结构</h4><p>打开docker hub，随便查看一个tomcat版本的dockerfile</p>
<p><img src="/2019/02/28/docker个人总结/clip_image123.jpg" alt="img"></p>
<p>打开后得到下面的代码，下面就是</p>
<p><img src="/2019/02/28/docker个人总结/clip_image125.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image126.png" alt="img"></p>
<p>这个dockerfile文件很好的阐述了tomcat镜像文件为什么这么大，而且为什么我们能够访问8080端口。</p>
<p>查看centos的dockerfile镜像描述文件</p>
<p><img src="/2019/02/28/docker个人总结/clip_image128.jpg" alt="img"></p>
<h4 id="2-创建数据卷"><a href="#2-创建数据卷" class="headerlink" title="2.创建数据卷"></a>2.创建数据卷</h4><p>可在Dockerfile中使用<strong>VOLUME</strong>指令来给镜像添加一个或多个数据卷</p>
<p>VOLUME[“/dataVolumeContainer”,”/dataVolumeContainer2”,”/dataVolumeContainer3”]</p>
<p>说明：</p>
<p>出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。</p>
<p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。（<strong>意思就是说容器中数据卷在linux01宿主机上关联的目录是myvolume1，但是如果该镜像在linux02宿主机上运行，那么容器容器启动后，可能找不到关联的myvolume1，因为你不能够保证linux02宿主机的相关目录结构是跟linux01一样的，所以使用dockerfile的方式创建数据卷的时候，单方面的指定容器中数据卷目录位置，容器启动后，会帮我们自动创建相关联的宿主机的目录</strong>）</p>
<p>   <strong>也就是说，VOLUME命令只能够单方面的在容器中创建数据卷，不能够指明对应宿主机关联的目录（但是他会自动在宿主机创建相关联的目录）</strong></p>
<p>\1.     宿主机创建dockerfile文件，依赖已经存在的centos镜像。</p>
<p>也就是说我们以现有的centos为某一层创建一个新的镜像（符合UnionFS）</p>
<p> 在宿主机创建一个文件夹，存放创建的dockerfile文件</p>
<pre><code>![img](docker个人总结\clip_image129.png)
</code></pre><p> 新建的dockerfile文件dc。内容</p>
<p><img src="/2019/02/28/docker个人总结/clip_image130.png" alt="img"></p>
<p>\2.     根据dockerfile文件dc，构建新镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image132.jpg" alt="img"></p>
<p>Docker images 查看现存在的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image134.jpg" alt="img"></p>
<p>启动我们创建的centos镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image136.jpg" alt="img"></p>
<p>确实主动给我们创建了两个数据卷，那么他们关联的宿主机的目录是什么呢？</p>
<p>  使用docekr inspect命令查看</p>
<p><img src="/2019/02/28/docker个人总结/clip_image138.jpg" alt="img"></p>
<h2 id="7-2数据卷容器"><a href="#7-2数据卷容器" class="headerlink" title="7.2数据卷容器"></a>7.2数据卷容器</h2><p>使用特定容器维护数据卷。7.1中使用的数据卷的方式是宿主机直接映射到容器进行数据传输，但是如果我们想两个容器之间共享传递数据怎么办呢？</p>
<p>就需要创建数据卷容器</p>
<h3 id="7-2-1先启动一个父容器dc01"><a href="#7-2-1先启动一个父容器dc01" class="headerlink" title="7.2.1先启动一个父容器dc01"></a>7.2.1先启动一个父容器dc01</h3><p>以上一步新建的镜像kingge/centos为模板并运行容器dc01</p>
<p><img src="/2019/02/28/docker个人总结/clip_image139.png" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image141.jpg" alt="img"></p>
<p>在创建容器卷dataVolumeContainer2新增内容，touch hello1.txt</p>
<h3 id="7-2-2-创建dc02、03继承自dc01"><a href="#7-2-2-创建dc02、03继承自dc01" class="headerlink" title="7.2.2 创建dc02、03继承自dc01"></a>7.2.2 创建dc02、03继承自dc01</h3><p>使用–volumes-from关键命令</p>
<p><img src="/2019/02/28/docker个人总结/clip_image142.png" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image144.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image146.jpg" alt="img"></p>
<p>在dc02、03的dataVolumeContainer2目录下查看是否存在dc01创建的hello1txt，很明显是可以看到的。</p>
<h3 id="7-2-3测试数据共通性"><a href="#7-2-3测试数据共通性" class="headerlink" title="7.2.3测试数据共通性"></a>7.2.3测试数据共通性</h3><p>1.dc02/dc03分别在dataVolumeContainer2各自新增内容，touch hello2.txt和touch hello3.txt</p>
<p>分别查看dc01 dc02 dc03的dataVolumeContainer2目录下是否存在hello1.txt hello2.txt hello3.txt 这三个文件，答案是：<strong>都存在这三个文件</strong></p>
<p>\2. 删除dc01，dc02修改后dc03可否访问</p>
<p><img src="/2019/02/28/docker个人总结/clip_image148.jpg" alt="img"></p>
<p>答案很明显是存在的，也就是说删除dc01并不会影响dc02和dc03的数据互通</p>
<p><strong>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</strong></p>
<h1 id="八、DockerFile解析"><a href="#八、DockerFile解析" class="headerlink" title="八、DockerFile解析"></a>八、DockerFile解析</h1><h2 id="8-1-dockerfile概念"><a href="#8-1-dockerfile概念" class="headerlink" title="8.1 dockerfile概念"></a>8.1 dockerfile概念</h2><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。通过：编写Dockerfile文件-&gt; docker build -&gt; docker run，生成一个镜像文件</p>
<p>查看centos的dockerfile镜像描述文件</p>
<p><img src="/2019/02/28/docker个人总结/clip_image149.jpg" alt="img"></p>
<p>1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数</p>
<p>2：指令按照从上到下，顺序执行</p>
<p>3：#表示注释</p>
<p>4：每条指令都会创建一个新的镜像层，并对镜像进行提交</p>
<p>（1）docker从基础镜像运行一个容器（from scratch）</p>
<p>（2）执行一条指令并对容器作出修改</p>
<p>（3）执行类似docker commit的操作提交一个新的镜像层</p>
<p>（4）docker再基于刚提交的镜像运行一个新容器</p>
<p>（5）执行dockerfile中的下一条指令直到所有指令都执行完成</p>
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>
<p>*  Dockerfile是软件的原材料</p>
<p>*  Docker镜像是软件的交付品</p>
<p>*  Docker容器则可以认为是软件的运行态。</p>
<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image151.jpg" alt="graphic"></p>
<p>1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p>
<p>2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</p>
<p>3 Docker容器，容器是直接提供服务的。</p>
<p><strong>尖叫提示</strong>：Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的<img src="/2019/02/28/docker个人总结/clip_image152.png" alt="img"></p>
<h2 id="8-2-dockerfile指令（保留字指令）"><a href="#8-2-dockerfile指令（保留字指令）" class="headerlink" title="8.2 dockerfile指令（保留字指令）"></a>8.2 dockerfile指令（保留字指令）</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><pre><code>基础镜像，当前新镜像是基于哪个镜像的
</code></pre><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><pre><code>镜像维护者的姓名和邮箱地址
</code></pre><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><pre><code>容器构建时需要运行的命令
</code></pre><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><pre><code>当前容器对外暴露出的端口
</code></pre><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p>
<p><img src="/2019/02/28/docker个人总结/clip_image154.jpg" alt="img"></p>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><pre><code>用来在构建镜像过程中设置环境变量
</code></pre><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><pre><code>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和**解压tar压缩包**
</code></pre><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>类似ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置，<strong>没有解压功能</strong></p>
<p>COPY src dest</p>
<p>COPY [“src”, “dest”]</p>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><pre><code>容器数据卷，用于数据保存和持久化工作
</code></pre><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><pre><code>指定一个容器启动时要运行的命令
</code></pre><p><strong>Dockerfile</strong> <strong>中可以有多个</strong> <strong>CMD</strong> <strong>指令，但只有最后一个生效，CMD</strong> <strong>会被</strong> <strong>docker run</strong> <strong>之后的参数替换（跟</strong>ENTRYPOINT指令的区别）</p>
<p>举个例子，查看tomcat 的dockerfile文件，我们可以发现最后是通过cmd命令启动了tomcat<img src="/2019/02/28/docker个人总结/clip_image155.png" alt="img">。那么为了证明CMD会不会被docker run后面的参数替换，请看下面例子。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image157.jpg" alt="img"></p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><pre><code>指定一个容器启动时要运行的命令
</code></pre><p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数，但是他是以追加的形式而不是覆盖</p>
<p>docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</p>
<p><img src="/2019/02/28/docker个人总结/clip_image158.png" alt="img"></p>
<p>  小总结</p>
<p><img src="/2019/02/28/docker个人总结/clip_image160.jpg" alt="graphic"></p>
<h2 id="8-3-案例"><a href="#8-3-案例" class="headerlink" title="8.3 案例"></a>8.3 案例</h2><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>需求：修改默认的centos，修改他的落脚点（默认运行centos后容器进入的根目录）和添加vim指令、ifconfig（默认centos镜像没有安装这两个组件）</p>
<p><img src="/2019/02/28/docker个人总结/clip_image162.jpg" alt="img"></p>
<p>\1.     创建dockefile镜像描述文件</p>
<p><img src="/2019/02/28/docker个人总结/clip_image163.png" alt="img"></p>
<p>内容是</p>
<p><img src="/2019/02/28/docker个人总结/clip_image165.jpg" alt="img"></p>
<p>   FROM centos   MAINTAINER kingge<a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#51;&#57;&#x33;&#50;&#49;&#53;&#x36;&#x36;&#49;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d;">&#51;&#57;&#x33;&#50;&#49;&#53;&#x36;&#x36;&#49;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d;</a>       ENV MYPATH /usr/local   WORKDIR $MYPATH       RUN yum -y install vim   RUN yum -y install net-tools       EXPOSE 80       CMD echo $MYPATH   CMD echo “success————–ok”   CMD /bin/bash   </p>
<p>\2. 根据创建的Dockerfile构建镜像</p>
<p>docker build -t 新镜像名字:TAG . （注意这里还有一个点，表示当前文件夹）</p>
<p>默认去找当前目录下名字为Dockerfile的文件构建镜像。</p>
<p>也可以用这个命令指定dockerfile：</p>
<p>docker build -f /mydockerfile/Dockerfile -t kingge/mycentos:1.1 .</p>
<p><img src="/2019/02/28/docker个人总结/clip_image166.png" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image168.jpg" alt="img"></p>
<p>很明显跟原先从docker hub上拉取下来的centos多个两百多M，因为我们安装了vim和net-tools指令。</p>
<p>\3. 列出镜像的变更历史</p>
<pre><code>docker history 镜像名（imagesid）
</code></pre><p><img src="/2019/02/28/docker个人总结/clip_image170.jpg" alt="img"></p>
<p>可以看到构建这个镜像的每一层相关的操作。</p>
<p>4.运行构建的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image171.png" alt="img"></p>
<p>可以看到容器登陆后落脚点变更为了我们设定的/usr/local，同时也支持了vim 和ifconfig命令。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image173.jpg" alt="img"></p>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>通过自定义一个tomcat的方式我们来使用一些dockerfile常用的指令</p>
<h4 id="2-1-新建一个工作目录"><a href="#2-1-新建一个工作目录" class="headerlink" title="2.1 新建一个工作目录"></a>2.1 新建一个工作目录</h4><p><img src="/2019/02/28/docker个人总结/clip_image174.png" alt="img"></p>
<p>存放待传输到容器中的压缩包（测试ADD命令专用）和一个文本文件（测试COPY指令专用）</p>
<h4 id="2-2-根据原版centos新建Dockerfile文件"><a href="#2-2-根据原版centos新建Dockerfile文件" class="headerlink" title="2.2 根据原版centos新建Dockerfile文件"></a>2.2 根据原版centos新建Dockerfile文件</h4><p><img src="/2019/02/28/docker个人总结/clip_image175.png" alt="img"></p>
<p>内容是：</p>
<p>   FROM         centos   MAINTAINER      kingge<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#51;&#57;&#51;&#50;&#x31;&#53;&#x36;&#x36;&#x31;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#51;&#57;&#51;&#50;&#x31;&#53;&#x36;&#x36;&#x31;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>   #把宿主机当前上下文的hello.txt拷贝到容器/usr/local/路径下   #并重命名为helloNewName.txt   COPY hello.txt /usr/local/helloNewName.txt   #把java与tomcat添加到容器中   ADD jdk-8u144-linux-x64.tar.gz /usr/local/   ADD apache-tomcat-9.0.21.tar.gz /usr/local/   #安装vim编辑器   RUN yum -y install vim   #设置工作访问时候的WORKDIR路径，登录落脚点   ENV MYPATH /usr/local   WORKDIR $MYPATH   #配置java与tomcat环境变量   ENV JAVA_HOME /usr/local/jdk1.8.0_144   ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar   ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.21   ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.21   ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin   #容器运行时监听的端口   EXPOSE  8080   #启动时运行tomcat   # ENTRYPOINT   [“/usr/local/apache-tomcat-9.0.21/bin/startup.sh” ]   # CMD   [“/usr/local/apache-tomcat-9.0.21/bin/catalina.sh”,”run”]   CMD /usr/local/apache-tomcat-9.0.21/bin/startup.sh &amp;&amp; tail -F   /usr/local/apache-tomcat-9.0.21/bin/logs/catalina.out   </p>
<h4 id="2-3-构建"><a href="#2-3-构建" class="headerlink" title="2.3 构建"></a>2.3 构建</h4><p><img src="/2019/02/28/docker个人总结/clip_image177.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image179.jpg" alt="img"></p>
<p>构建完成</p>
<h4 id="2-4-执行（RUN）"><a href="#2-4-执行（RUN）" class="headerlink" title="2.4 执行（RUN）"></a>2.4 执行（RUN）</h4><p>   docker run -d -p 9080:8080 –name myt9 -v   /mydockerfile/mytomcat/tomcat9/project:/usr/local/apache-tomcat-9.0.21/webapps/project   -v /mydockerfile/mytomcat/tomcat9/logs/:/usr/local/apache-tomcat-9.0.21/logs   –privileged=true mytomcat921   </p>
<p>命令的意思是：后台执行tomcat镜像，docker对外暴露8080端口，外部可以通过9080端口访问docker容器的8080端口。</p>
<p><strong>–name</strong>：启动的容器重命名为myt9 </p>
<p><strong>-v</strong>：新建两个数据卷</p>
<p><strong>–privileged=true</strong>: Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied解决办法：在挂载目录后多加一个–privileged=true参数即可</p>
<p><img src="/2019/02/28/docker个人总结/clip_image181.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image183.jpg" alt="img"></p>
<p>启动成功</p>
<h4 id="2-5-验证"><a href="#2-5-验证" class="headerlink" title="2.5 验证"></a>2.5 验证</h4><p>1.首先验证两个tar包是否已经上传到容器并解压成功，hello.txt文件是否已经copy到容器、容器登录后落脚点是否是在我们设置的/usr/local</p>
<p><img src="/2019/02/28/docker个人总结/clip_image184.png" alt="img"></p>
<p>2.查看数据卷是否创建成功</p>
<p>宿主机对应数据卷创建成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image185.png" alt="img"></p>
<p>容器数据卷创建成功，project出现</p>
<p><img src="/2019/02/28/docker个人总结/clip_image187.jpg" alt="img"></p>
<p>3.校验数据卷</p>
<p><img src="/2019/02/28/docker个人总结/clip_image189.jpg" alt="img"></p>
<h4 id="2-6-部署项目"><a href="#2-6-部署项目" class="headerlink" title="2.6 部署项目"></a>2.6 部署项目</h4><p>因为我们在创建数据卷的时候：</p>
<p>/mydockerfile/mytomcat/tomcat9/project:/usr/local/apache-tomcat-9.0.21/webapps/project</p>
<p>宿主机的/tomcat9/project目录映射到了容器的webapps/project目录，那么可以利用数据卷的数据共通原理。在宿主机的project目录上传一个项目，然后重启容器，那么就可以实现项目的发布。</p>
<p>上传解压后的项目文件</p>
<p><img src="/2019/02/28/docker个人总结/clip_image190.png" alt="img"></p>
<p>很明显会自动同步到容器的webapps/project目录下</p>
<p><img src="/2019/02/28/docker个人总结/clip_image192.jpg" alt="img"></p>
<p>重启容器</p>
<p><img src="/2019/02/28/docker个人总结/clip_image193.png" alt="img"></p>
<p>访问项目</p>
<p><img src="/2019/02/28/docker个人总结/clip_image194.png" alt="img"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2019/02/28/docker个人总结/clip_image196.jpg" alt="graphic"></p>
<h1 id="九、常用插件安装"><a href="#九、常用插件安装" class="headerlink" title="九、常用插件安装"></a>九、常用插件安装</h1><p><a href="https://www.runoob.com/docker/docker-install-mysql.html" target="_blank" rel="external">https://www.runoob.com/docker/docker-install-mysql.html</a></p>
<h2 id="9-1总体步骤"><a href="#9-1总体步骤" class="headerlink" title="9.1总体步骤"></a>9.1总体步骤</h2><p>搜索镜像、拉取镜像、查看镜像、启动镜像、停止容器、移除容器</p>
<h2 id="9-2-tomcat安装"><a href="#9-2-tomcat安装" class="headerlink" title="9.2 tomcat安装"></a>9.2 tomcat安装</h2><h3 id="9-2-1-docker-hub上面查找tomcat镜像"><a href="#9-2-1-docker-hub上面查找tomcat镜像" class="headerlink" title="9.2.1 docker hub上面查找tomcat镜像"></a>9.2.1 docker hub上面查找tomcat镜像</h3><p>  docker search tomcat</p>
<p><img src="/2019/02/28/docker个人总结/clip_image198.jpg" alt="img"></p>
<p>  或者直接使用浏览器登录docker hub查找也可以</p>
<h3 id="9-2-2-从docker-hub上拉取tomcat镜像到本地"><a href="#9-2-2-从docker-hub上拉取tomcat镜像到本地" class="headerlink" title="9.2.2 从docker hub上拉取tomcat镜像到本地"></a>9.2.2 从docker hub上拉取tomcat镜像到本地</h3><p>  docker pull tomcat</p>
<h3 id="9-2-3-docker-images查看是否有拉取到的tomcat"><a href="#9-2-3-docker-images查看是否有拉取到的tomcat" class="headerlink" title="9.2.3 docker images查看是否有拉取到的tomcat"></a>9.2.3 docker images查看是否有拉取到的tomcat</h3><p><img src="/2019/02/28/docker个人总结/clip_image200.jpg" alt="img"></p>
<p>为什么拉取下来的tomcat有五百多M?上面文章已经做了解释（因为里面包含了jdk等等，这个也就是为什么我们可以直接运行tomcat镜像而不用配置jdk环境的原因）</p>
<h3 id="9-2-4-使用tomcat镜像创建容器-也叫运行镜像"><a href="#9-2-4-使用tomcat镜像创建容器-也叫运行镜像" class="headerlink" title="9.2.4 使用tomcat镜像创建容器(也叫运行镜像)"></a>9.2.4 使用tomcat镜像创建容器(也叫运行镜像)</h3><p>  docker run -it -p 8080:8080 tomcat</p>
<pre><code>-p 主机端口:docker容器端口

-P 随机分配端口

i:交互

t:终端
</code></pre><h2 id="9-3安装mysql"><a href="#9-3安装mysql" class="headerlink" title="9.3安装mysql"></a>9.3安装mysql</h2><p><a href="https://hub.docker.com/_/mysql" target="_blank" rel="external">https://hub.docker.com/_/mysql</a>  官网文档</p>
<h3 id="9-3-1-docker-hub上面查找mysql镜像"><a href="#9-3-1-docker-hub上面查找mysql镜像" class="headerlink" title="9.3.1 docker hub上面查找mysql镜像"></a>9.3.1 docker hub上面查找mysql镜像</h3><h3 id="9-3-2-从docker-hub上-阿里云加速器-拉取mysql镜像到本地标签为5-6"><a href="#9-3-2-从docker-hub上-阿里云加速器-拉取mysql镜像到本地标签为5-6" class="headerlink" title="9.3.2 从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.6"></a>9.3.2 从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.6</h3><p><img src="/2019/02/28/docker个人总结/clip_image202.jpg" alt="img"></p>
<h3 id="9-3-3-使用mysql5-6镜像创建容器-也叫运行镜像"><a href="#9-3-3-使用mysql5-6镜像创建容器-也叫运行镜像" class="headerlink" title="9.3.3 使用mysql5.6镜像创建容器(也叫运行镜像)"></a>9.3.3 使用mysql5.6镜像创建容器(也叫运行镜像)</h3><p>   docker run -p 12345:3306 –name mysql    -v  /kingge/mysql/conf:/etc/mysql/conf.d      -v / kingge /mysql/logs:/logs    -v / kingge /mysql/data:/var/lib/mysql    -e MYSQL_ROOT_PASSWORD=123456   -d mysql:5.6   </p>
<p>   命令说明：   -p 12345:3306：将主机的12345端口映射到docker容器的3306端口。   –name mysql：运行服务名字   -v / kingge /mysql/conf:/etc/mysql/conf.d ：将主机/ kingge /mysql录下的conf/my.cnf 挂载到容器的   /etc/mysql/conf.d   -v / kingge /mysql/logs:/logs：将主机/ kingge /mysql目录下的 logs 目录挂载到容器的 /logs。   -v / kingge /mysql/data:/var/lib/mysql ：将主机/ kingge /mysql目录下的data目录挂载到容器的 /var/lib/mysql      -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。   -d mysql:5.6 : 后台程序运行mysql5.6   </p>
<p><img src="/2019/02/28/docker个人总结/clip_image204.jpg" alt="img"></p>
<p>登录测试</p>
<p>docker exec -it  954efcffa04d /bin/bash</p>
<p><img src="/2019/02/28/docker个人总结/clip_image206.jpg" alt="img"></p>
<p>成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image208.jpg" alt="img"></p>
<p>外部软件连接成功</p>
<h2 id="9-4-安装redis"><a href="#9-4-安装redis" class="headerlink" title="9.4 安装redis"></a>9.4 安装redis</h2><h3 id="9-4-1-从docker-hub上-阿里云加速器-拉取redis镜像到本地标签为3-2"><a href="#9-4-1-从docker-hub上-阿里云加速器-拉取redis镜像到本地标签为3-2" class="headerlink" title="9.4.1 从docker hub上(阿里云加速器)拉取redis镜像到本地标签为3.2"></a>9.4.1 从docker hub上(阿里云加速器)拉取redis镜像到本地标签为3.2</h3><p><img src="/2019/02/28/docker个人总结/clip_image209.png" alt="img"></p>
<h3 id="9-4-2-使用redis3-2镜像创建容器-也叫运行镜像"><a href="#9-4-2-使用redis3-2镜像创建容器-也叫运行镜像" class="headerlink" title="9.4.2 使用redis3.2镜像创建容器(也叫运行镜像)"></a>9.4.2 使用redis3.2镜像创建容器(也叫运行镜像)</h3><p>   docker run -p 6379:6379 -v   /kingge/myredis/data:/data -v   /kingge/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf  -d redis:3.2 redis-server   /usr/local/etc/redis/redis.conf –appendonly yes   </p>
<p><img src="/2019/02/28/docker个人总结/clip_image211.jpg" alt="img"></p>
<p><strong>这个时候可以直接连接redis了：</strong></p>
<p>命令：docker exec -it 运行着Rediis服务的容器ID redis-cli</p>
<p><img src="/2019/02/28/docker个人总结/clip_image212.png" alt="img"></p>
<p><strong>设置redis配置文件：</strong></p>
<p>  在主机/kingge/myredis/conf/redis.conf目录下新建redis.conf文件 vim / kingge /myredis/conf/redis.conf/redis.conf</p>
<p>Accept connections on the specified port, default is 6379 (IANA   #815344).   # If port 0 is specified Redis will not listen on a TCP socket.   port 6379   。。。。省略   </p>
<p><strong>测试持久化文件生成</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image214.jpg" alt="img"></p>
<h1 id="十、本地镜像发布到阿里云"><a href="#十、本地镜像发布到阿里云" class="headerlink" title="十、本地镜像发布到阿里云"></a>十、本地镜像发布到阿里云</h1><p><img src="/2019/02/28/docker个人总结/clip_image216.jpg" alt="graphic"></p>
<h2 id="1-镜像生成方式"><a href="#1-镜像生成方式" class="headerlink" title="1.镜像生成方式"></a>1.镜像生成方式</h2><p>（1）使用DockerFile的方式创建镜像</p>
<p>（2）根据运行的容器创建一个新的镜像 docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]] （参见6.3章节的补充模块的Docker镜像commit）</p>
<h2 id="2-将本地镜像推送到阿里云"><a href="#2-将本地镜像推送到阿里云" class="headerlink" title="2. 将本地镜像推送到阿里云"></a>2. 将本地镜像推送到阿里云</h2><h3 id="2-1-登录阿里云，创建镜像仓库"><a href="#2-1-登录阿里云，创建镜像仓库" class="headerlink" title="2.1 登录阿里云，创建镜像仓库"></a>2.1 登录阿里云，创建镜像仓库</h3><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories" target="_blank" rel="external">https://cr.console.aliyun.com/cn-hangzhou/instances/repositories</a></p>
<p><img src="/2019/02/28/docker个人总结/clip_image218.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image220.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image222.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image224.jpg" alt="img"></p>
<h3 id="2-2-创建命名空间"><a href="#2-2-创建命名空间" class="headerlink" title="2.2 创建命名空间"></a>2.2 创建命名空间</h3><p><img src="/2019/02/28/docker个人总结/clip_image225.png" alt="img"></p>
<h3 id="2-3-点击镜像仓库的管理"><a href="#2-3-点击镜像仓库的管理" class="headerlink" title="2.3 点击镜像仓库的管理"></a>2.3 点击镜像仓库的管理</h3><p><img src="/2019/02/28/docker个人总结/clip_image227.jpg" alt="img"></p>
<p>可以获取推送镜像到阿里云仓库的地址</p>
<p><img src="/2019/02/28/docker个人总结/clip_image229.jpg" alt="img"></p>
<p>   $ sudo docker login –username=393215661@qq.com   registry.cn-hangzhou.aliyuncs.com   $ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/kingge/myrepo:[镜像版本号]   $ sudo docker push registry.cn-hangzhou.aliyuncs.com/kingge/myrepo:[镜像版本号]   </p>
<h3 id="2-4-推送镜像到阿里云"><a href="#2-4-推送镜像到阿里云" class="headerlink" title="2.4 推送镜像到阿里云"></a>2.4 推送镜像到阿里云</h3><p>首先进行登录</p>
<p><img src="/2019/02/28/docker个人总结/clip_image231.jpg" alt="img"></p>
<p>标记我们需要上传的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image233.jpg" alt="img"></p>
<p>开始推送</p>
<p><img src="/2019/02/28/docker个人总结/clip_image235.jpg" alt="img"></p>
<p>推送成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image237.jpg" alt="img"></p>
<h3 id="2-5-查看是否推送成功"><a href="#2-5-查看是否推送成功" class="headerlink" title="2.5 查看是否推送成功"></a>2.5 查看是否推送成功</h3><p><img src="/2019/02/28/docker个人总结/clip_image239.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image241.jpg" alt="img"></p>
<h3 id="2-6-从阿里云下载我们推送的镜像"><a href="#2-6-从阿里云下载我们推送的镜像" class="headerlink" title="2.6 从阿里云下载我们推送的镜像"></a>2.6 从阿里云下载我们推送的镜像</h3><p><img src="/2019/02/28/docker个人总结/clip_image243.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image245.jpg" alt="img"></p>
<h1 id="十一、新建本地仓库"><a href="#十一、新建本地仓库" class="headerlink" title="十一、新建本地仓库"></a>十一、新建本地仓库</h1><p>   本质就是通过一个名字为registry的镜像，构建仓库</p>
<p>（1）拉取私有仓库镜像 </p>
<pre><code>docker pull registry
</code></pre><p>（2）启动私有仓库容器</p>
<pre><code>docker run -di --name=registry -p 5000:5000 registry
</code></pre><p>（3）打开浏览器 输入地址<a href="http://49.234.188.74:5000/v2/_catalog看到{&quot;repositories&quot;:[]}" target="_blank" rel="external">http://49.234.188.74:5000/v2/_catalog看到{&quot;repositories&quot;:[]}</a> 表示私有仓库搭建成功并且内容为空</p>
<p>或者使用crul 命令查看也可以</p>
<p><img src="/2019/02/28/docker个人总结/clip_image247.jpg" alt="img"></p>
<p>这里有个hello-world镜像，是本人之前上传的。如果没有上传过，那么这个应该返回的是{“repositories”:[]}</p>
<p>（4）修改daemon.json</p>
<pre><code>vi /etc/docker/daemon.json
</code></pre><p>添加以下内容，保存退出。</p>
<p>{“insecure-registries”:[“49.234.188.74:5000”]} </p>
<p>例如</p>
<p><img src="/2019/02/28/docker个人总结/clip_image249.jpg" alt="img"></p>
<p>此步用于让 docker信任私有仓库地址</p>
<p>（5）重启docker 服务</p>
<pre><code>systemctl restart docker
</code></pre><h2 id="上传镜像到本地仓库"><a href="#上传镜像到本地仓库" class="headerlink" title="上传镜像到本地仓库"></a>上传镜像到本地仓库</h2><p>（1）标记此镜像为私有仓库的镜像</p>
<pre><code>docker tag hello-world 49.234.188.74:5000/ hello-world （本质就是创建一个关于hello-world的引用，镜像名字更改为hello-world 49.234.188.74:5000/hello-world ）
</code></pre><p>（2）再次启动私服容器</p>
<pre><code>docker start registry
</code></pre><p>（3）上传标记的镜像</p>
<pre><code>docker push 49.234.188.74:5000/ hello-world
</code></pre><p> (4)查看是否上传成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image247.jpg" alt="img"></p>
<h2 id="其他服务器获取上传的容器"><a href="#其他服务器获取上传的容器" class="headerlink" title="其他服务器获取上传的容器"></a>其他服务器获取上传的容器</h2><p>需求：192.168.1.105 服务器需要从 49.234.188.74 服务器创建的本地仓库获取上床的hello-world镜像</p>
<p>\1.     192.168.1.105设置可信任仓库站点</p>
<pre><code>vi /etc/docker/daemon.json
</code></pre><p>添加以下内容，保存退出。</p>
<p>{“insecure-registries”:[“49.234.188.74:5000”]} </p>
<p><img src="/2019/02/28/docker个人总结/clip_image251.jpg" alt="img"></p>
<p><strong>如果不设置这一步，那么在从49.234.188.74服务器pull镜像的时候会报以下错误</strong></p>
<p>   默认不支持http请求的方式获取镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image253.jpg" alt="img"></p>
<p>\2.     拉取镜像成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image255.jpg" alt="img"></p>
<h1 id="十二、使用DockerMaven插件构建项目"><a href="#十二、使用DockerMaven插件构建项目" class="headerlink" title="十二、使用DockerMaven插件构建项目"></a>十二、使用DockerMaven插件构建项目</h1><p>微服务部署有两种方法：</p>
<p>（1）手动部署：首先基于源码打包生成jar包（或war包）,将jar包（或war包）上传至虚 拟机并拷贝至JDK容器。</p>
<p>（2）通过Maven插件自动部署。</p>
<p>对于数量众多的微服务，手动部署无疑是非常麻烦的做法，并且容易出错。</p>
<h2 id="（1）修改宿主机的docker配置，让其可以远程访问"><a href="#（1）修改宿主机的docker配置，让其可以远程访问" class="headerlink" title="（1）修改宿主机的docker配置，让其可以远程访问"></a>（1）修改宿主机的docker配置，让其可以远程访问</h2><p>Vi  /lib/systemd/system/docker.service</p>
<p>其中ExecStart=后添加配置 ‐H tcp://0.0.0.0:2375 ‐H unix:///var/run/docker.sock</p>
<p><img src="/2019/02/28/docker个人总结/clip_image257.jpg" alt="img"></p>
<h2 id="（2）刷新配置，重启服务"><a href="#（2）刷新配置，重启服务" class="headerlink" title="（2）刷新配置，重启服务"></a>（2）刷新配置，重启服务</h2><p>systemctl daemon‐reload  </p>
<p>systemctl restart docker  </p>
<p>docker start registry   （这里使用的是本地仓库）</p>
<h2 id="（3）-springboot的pom文件添加插件"><a href="#（3）-springboot的pom文件添加插件" class="headerlink" title="（3） springboot的pom文件添加插件"></a>（3） springboot的pom文件添加插件</h2><p><img src="/2019/02/28/docker个人总结/clip_image259.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image261.jpg" alt="img"></p>
<p>最后执行：mvn clean package docker:build</p>
<p>即可把镜像上传到本地仓库中</p>
<p><img src="/2019/02/28/docker个人总结/clip_image263.jpg" alt="img"></p>
<p>上面的方式是构建 项目到本地仓库的方式。如果我们自己申请了阿里云仓库，那么可以使用下面的方式将项目推送到阿里云仓库中。</p>
<p>使用SpringBoot2.0+DockerFile+Maven插件构建镜像并推送到阿里云仓库</p>
<p><a href="https://blog.csdn.net/haogexiang9700/article/details/88318867" target="_blank" rel="external">https://blog.csdn.net/haogexiang9700/article/details/88318867</a></p>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><h2 id="1-启动mysql后使用外部数据库连接工具访问时，报错"><a href="#1-启动mysql后使用外部数据库连接工具访问时，报错" class="headerlink" title="1 启动mysql后使用外部数据库连接工具访问时，报错"></a>1 启动mysql后使用外部数据库连接工具访问时，报错</h2><p>错误提示 2059 - authentication plugin ‘caching_sha2_password’”</p>
<p>通过查看本人启动mysql容器，mysql的版本是：</p>
<p><img src="/2019/02/28/docker个人总结/clip_image265.jpg" alt="img"></p>
<p>经过查询得知：出现这个问题的原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password, 解决问题方法是把mysql用户登录密码加密规则还原成mysql_native_password</p>
<p>也就是数据库访问工具还是使用mysql_native_password这样的价码规则访问数据库。</p>
<p>关键的位置是在：mysql数据库中的user表</p>
<p><img src="/2019/02/28/docker个人总结/clip_image267.jpg" alt="img"></p>
<p>解决方法：</p>
<p> 通过命令行的方式登陆数据库 mysql -uroot -p密码</p>
<p>然后分别执行以下代码</p>
<p>use mysql;</p>
<p>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘123456’;</p>
<p>ALTER USER ‘root’@’%’ IDENTIFIED WITH mysql_native_password BY ‘123456’;</p>
<p>FLUSH PRIVILEGES;</p>
<p>修改完毕</p>
<p>修改host为localhost和%(任意客户端)的密码认证方式</p>
<p>官方文档对应mysql8的更新说明</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html</a></p>
<p><img src="/2019/02/28/docker个人总结/clip_image269.jpg" alt="img"></p>
<h2 id="2-docker数据卷权限问题"><a href="#2-docker数据卷权限问题" class="headerlink" title="2.docker数据卷权限问题"></a>2.docker数据卷权限问题</h2><p>参见《持续集成和容器管理》-《额外补充》章节，启动jenkins dokcer容器时，添加数据卷权限问题。</p>
<p><a href="https://www.cnblogs.com/jackluo/p/5783116.html" target="_blank" rel="external">https://www.cnblogs.com/jackluo/p/5783116.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前学习过docker，但是很浅显的使用，概念和流程各个方面总结的不够到位，下面根据旧版本的文档，重新的梳理。&lt;/p&gt;
&lt;h1 id=&quot;一、docker出现的契机&quot;&gt;&lt;a href=&quot;#一、docker出现的契机&quot; class=&quot;headerlink&quot; title=&quot;一、d
    
    </summary>
    
      <category term="docker" scheme="http://kingge.top/categories/docker/"/>
    
    
      <category term="docker" scheme="http://kingge.top/tags/docker/"/>
    
      <category term="容器" scheme="http://kingge.top/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>springboot个人总结</title>
    <link href="http://kingge.top/2019/01/30/springboot%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://kingge.top/2019/01/30/springboot个人总结/</id>
    <published>2019-01-30T14:21:59.000Z</published>
    <updated>2019-08-25T04:05:13.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一．前言"><a href="#一．前言" class="headerlink" title="一．前言"></a>一．前言</h1><h2 id="1-1-什么是微服务？"><a href="#1-1-什么是微服务？" class="headerlink" title="1.1 什么是微服务？"></a>1.1 什么是微服务？</h2><p><strong>单服务场景</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image002.jpg" alt="img"></p>
<p><strong>开发简单，测试简单，部署简单</strong></p>
<p>下面举个例子，一种单一的服务场景：所有的模块都是打包成一个war包的形式，然后部署到tomcat中。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image004.jpg" alt="img"></p>
<p>缺点：</p>
<p>1)      只能采用同一种技术，很难用不同的语言或者语言不同版本开发不同模块；</p>
<p>2)      系统耦合性强，一旦其中一个模块有问题，整个系统就瘫痪了；一旦升级其中一个模块，整个系统就停机了；</p>
<p>3)      集群只能是复制整个系统，即使只是其中一个模块压力大。（可能整个订单处理，仅仅是支付模块压力过大， 按道理只需要升级支付模块，但是在单一场景里面是不能的）</p>
<h2 id="1-2-微服务概念"><a href="#1-2-微服务概念" class="headerlink" title="1.2 微服务概念"></a>1.2 微服务概念</h2><p><img src="/2019/01/30/springboot个人总结/clip_image006.jpg" alt="img"></p>
<p>下面是微服务（Micro-Service）架构，<strong>不同模块放到不同的进程**</strong>/<strong>**服务器上，模块之间通过网络通讯进行协作。</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image008.jpg" alt="img"></p>
<p>各个模块都部署在不同的服务器上面，模块之间可以通过http请求进行协作。例如web服务器收到请求，那么可以根据请求的业务吧请求分配到响应的处理服务器，例如短信消息服务器。</p>
<p>优点：</p>
<p>1)      可以用不同的语言或者语言不同版本开发不同模块；</p>
<p>2)      系统耦合性弱，其中一个模块有问题，可以通过“降级熔断”等手段来保证不停机；</p>
<p>3)      可以对不同模块用不同的集群策略，哪里慢集群哪里。</p>
<p>缺点：</p>
<p>1)      开发难度大，系统结构更复杂；</p>
<p>2)      运行效率低； （模块之间相互请求时间长等等）</p>
<p>  <a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="external">详细参照微服务文档</a></p>
<p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="external">https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa</a></p>
<p>所以就衍生出了 springboot和springcloud两个框架，当然springboot并不能代表微服务的概念，springcloud才是。</p>
<p>  因为springboot只是简化了单一web服务开发的流程，摒弃了大量的xml配置，提供了大量的自动化配置。</p>
<p>   那么springboot跟springcloud是什么关系呢？ SpringBoot专注于快速方便的开发单个个体微服务。SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系.</p>
<p>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</p>
<h2 id="1-3-spring的演化"><a href="#1-3-spring的演化" class="headerlink" title="1.3 spring的演化"></a>1.3 spring的演化</h2><h3 id="Spring1-x-时代"><a href="#Spring1-x-时代" class="headerlink" title="Spring1.x 时代"></a>Spring1.x 时代</h3><p>在Spring1.x时代，都是通过xml文件配置bean，随着项目的不断扩大，需要将xml配置分放到不同的配置文件中，需要频繁的在java类和xml配置文件中切换。</p>
<h3 id="Spring2-x时代"><a href="#Spring2-x时代" class="headerlink" title="Spring2.x时代"></a>Spring2.x时代</h3><p>随着JDK 1.5带来的注解支持，Spring2.x可以使用注解对Bean进行申明和注入，大大的减少了xml配置文件，同时也大大简化了项目的开发。</p>
<p>那么，问题来了，究竟是应该使用xml还是注解呢？</p>
<p>最佳实践：</p>
<p>1、  应用的基本配置用xml，比如：数据源、资源文件等；</p>
<p>2、  业务开发用注解，比如：Service中注入bean等；</p>
<h3 id="Spring3-x到Spring4-x"><a href="#Spring3-x到Spring4-x" class="headerlink" title="Spring3.x到Spring4.x"></a>Spring3.x到Spring4.x</h3><p>从Spring3.x开始提供了Java配置方式，使用Java配置方式可以更好的理解你配置的Bean，现在我们就处于这个时代，并且Spring4.x和Spring boot都推荐使用java配置的方式。</p>
<h2 id="1-4为什么要学习SpringBoot"><a href="#1-4为什么要学习SpringBoot" class="headerlink" title="1.4为什么要学习SpringBoot"></a>1.4为什么要学习SpringBoot</h2><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因主要是两点：</p>
<p>·        复杂的配置</p>
<p>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。</p>
<p>·        混乱的依赖管理</p>
<p><strong>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这也是件棘手的问题。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手</strong>。</p>
<p>而SpringBoot让这一切成为过去！</p>
<h1 id="二．-什么是springboot"><a href="#二．-什么是springboot" class="headerlink" title="二． 什么是springboot"></a>二． 什么是springboot</h1><p><img src="/2019/01/30/springboot个人总结/clip_image010.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image012.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image014.jpg" alt="img"></p>
<h1 id="三．Springboot使用"><a href="#三．Springboot使用" class="headerlink" title="三．Springboot使用"></a>三．Springboot使用</h1><p>这里开发工具使用的是sts和idea，他们两者开发springboot 的方式没有什么区别，所以下面两种方式我都会嵌套使用。下面的工程采用springboot版本是：1.5.9。</p>
<h2 id="3-1-使用maven方式手动搭建sb项目"><a href="#3-1-使用maven方式手动搭建sb项目" class="headerlink" title="3.1 使用maven方式手动搭建sb项目"></a>3.1 使用maven方式手动搭建sb项目</h2><p>Idea maven环境配置</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image016.png" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image018.png" alt="img"></p>
<p>编码设置：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image020.png" alt="img"></p>
<p>需求：浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p>
<h3 id="1、创建一个maven工程"><a href="#1、创建一个maven工程" class="headerlink" title="1、创建一个maven工程"></a>1、创建一个maven工程</h3><h3 id="2、导入spring-boot相关的依赖"><a href="#2、导入spring-boot相关的依赖" class="headerlink" title="2、导入spring boot相关的依赖"></a>2、导入spring boot相关的依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</div><div class="line">&lt;/parent&gt;</div><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<pre><code>&lt;parent&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;             &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;       &lt;/parent&gt;       &lt;dependencies&gt;           &lt;dependency&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;           &lt;/dependency&gt;       &lt;/dependencies&gt;   
</code></pre><h3 id="3、-编写一个主程序；启动Spring-Boot应用"><a href="#3、-编写一个主程序；启动Spring-Boot应用" class="headerlink" title="3、        编写一个主程序；启动Spring Boot应用"></a>3、        编写一个主程序；启动Spring Boot应用</h3><p>   /<em>*    </em>  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用    */   @SpringBootApplication   public class HelloWorldMainApplication {       public static void   main(String[] args) {           // Spring应用启动起来           SpringApplication.run(HelloWorldMainApplication.class,args);       }   }   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> *  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用</div><div class="line"> */</div><div class="line">@SpringBootApplication</div><div class="line">public class HelloWorldMainApplication &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // Spring应用启动起来</div><div class="line">      SpringApplication.run(HelloWorldMainApplication.class,args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、编写相关的Controller、Service"><a href="#4、编写相关的Controller、Service" class="headerlink" title="4、编写相关的Controller、Service"></a>4、编写相关的Controller、Service</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Controller</div><div class="line">public class HelloController &#123;</div><div class="line">    @ResponseBody</div><div class="line">    @RequestMapping(&quot;/hello&quot;)</div><div class="line">    public String hello()&#123;</div><div class="line">        return &quot;Hello World!&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   @Controller   public class HelloController {       @ResponseBody         @RequestMapping(“/hello”)       public String hello(){           return “Hello   World!”;       }   }   </p>
<h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><p>直接运行HelloWorldMainApplication的main方法，启动sb程序。</p>
<p>在浏览器输入 127.0.0.1:8080/hello 可看到输出 Hello World!</p>
<h3 id="6、打包成嵌入式web的可执行jar包"><a href="#6、打包成嵌入式web的可执行jar包" class="headerlink" title="6、打包成嵌入式web的可执行jar包"></a>6、打包成嵌入式web的可执行jar包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</div><div class="line">    &lt;build&gt;</div><div class="line">        &lt;plugins&gt;</div><div class="line">            &lt;plugin&gt;</div><div class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">            &lt;/plugin&gt;</div><div class="line">        &lt;/plugins&gt;</div><div class="line">    &lt;/build&gt;</div></pre></td></tr></table></figure>
<p>运行maven的 mvn package 打包命令，可以看到生成的jar包。</p>
<p>直接使用java -jar的命令进行执行，效果同 5 。</p>
<h2 id="3-2-使用Spring-Initializer快速创建Spring-Boot项目-推荐"><a href="#3-2-使用Spring-Initializer快速创建Spring-Boot项目-推荐" class="headerlink" title="3.2 使用Spring Initializer快速创建Spring Boot项目-推荐"></a>3.2 使用Spring Initializer快速创建Spring Boot项目-推荐</h2><h3 id="3-2-1-sts编译器方式"><a href="#3-2-1-sts编译器方式" class="headerlink" title="3.2.1 sts编译器方式"></a>3.2.1 sts编译器方式</h3><p>STS工具下创建CRUD的步骤（IDEA相同的步骤）</p>
<h4 id="1-主菜单：File→New→Spring-Starter-Project。"><a href="#1-主菜单：File→New→Spring-Starter-Project。" class="headerlink" title="1.主菜单：File→New→Spring Starter Project。"></a>1.主菜单：File→New→Spring Starter Project。</h4><p>在Type中选Maven，Package选War</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image022.jpg" alt="img"></p>
<pre><code>下一步中搜索勾选Web。
</code></pre><p><img src="/2019/01/30/springboot个人总结/clip_image024.jpg" alt="img"></p>
<pre><code>点击【Finish】会创建项目，第一次创建完成后会进行maven包的下载等，需要几分钟。项目创建成功后，他会生成一个springboot的启动类。后面就是靠他来启动springboot
</code></pre><h4 id="2-新建一个Controller"><a href="#2-新建一个Controller" class="headerlink" title="2.新建一个Controller"></a>2.新建一个Controller</h4><p><img src="/2019/01/30/springboot个人总结/clip_image026.jpg" alt="img"></p>
<h4 id="3-新建一个index-html"><a href="#3-新建一个index-html" class="headerlink" title="3.新建一个index.html"></a>3.新建一个index.html</h4><p>  需要注意的是，界面要放置在 resouces – templates 目录下（不是放在我们以前的webroot下面了）</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image027.png" alt="img"></p>
<h4 id="4-启动程序，访问。"><a href="#4-启动程序，访问。" class="headerlink" title="4.启动程序，访问。"></a>4.启动程序，访问。</h4><p><img src="/2019/01/30/springboot个人总结/clip_image029.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image031.jpg" alt="img"></p>
<p>可以看到，他非常的简单。不需要配置一大堆文件</p>
<h3 id="3-2-2-IDEA编译器方式"><a href="#3-2-2-IDEA编译器方式" class="headerlink" title="3.2.2  IDEA编译器方式"></a>3.2.2  IDEA编译器方式</h3><p>方式同上</p>
<p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p>
<p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p>
<p>默认生成的Spring Boot项目；</p>
<p>- 主程序已经生成好了，我们只需要我们自己的逻辑</p>
<p>- resources文件夹中目录结构</p>
<p>  - static：保存所有的静态资源； js css  images；</p>
<p>  - templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</p>
<p>  - application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；例如修改服务器端口号</p>
<h1 id="四-Springboot核心"><a href="#四-Springboot核心" class="headerlink" title="四.  Springboot核心"></a>四.  Springboot核心</h1><p>下面分析根据helloworld 源码。</p>
<h2 id="4-1、POM文件"><a href="#4-1、POM文件" class="headerlink" title="4.1、POM文件"></a>4.1、POM文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;2.1.5.RELEASE&lt;/version&gt;</div><div class="line">	&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">&lt;/parent&gt;</div></pre></td></tr></table></figure>
<pre><code>&lt;parent&gt;                 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                 &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;                 &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;                 &lt;relativePath/&gt;   &lt;!-- lookup parent from repository --&gt;          &lt;/parent&gt;   
</code></pre><p>单击进去查看，发现他的父项目是：</p>
<pre><code>&lt;parent&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;         &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;         &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;     &lt;/parent&gt;   
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;</div><div class="line">  &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;</div><div class="line">&lt;/parent&gt;</div></pre></td></tr></table></figure>
<p>再单击进去发现</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image032.png" alt="img"></p>
<p>它里面配置了很多properties,定义了各种依赖的版本。<strong><em>也就是说他是用来真正管理Spring Boot应用里面的所有依赖版本，Spring Boot的版本仲裁中心；以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号-）</em></strong></p>
<h3 id="4-2、web启动器"><a href="#4-2、web启动器" class="headerlink" title="4.2、web启动器"></a>4.2、web启动器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<pre><code>&lt;dependency&gt;                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;                 &lt;/dependency&gt;   
</code></pre><p>spring-boot-starter-web：</p>
<pre><code>spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；
</code></pre><p><img src="/2019/01/30/springboot个人总结/clip_image033.png" alt="img"></p>
<p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>
<h2 id="4-2、主程序类，主入口类"><a href="#4-2、主程序类，主入口类" class="headerlink" title="4.2、主程序类，主入口类"></a>4.2、主程序类，主入口类</h2><p>   /<em>*    </em>  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用    */   @SpringBootApplication   public class HelloWorldMainApplication {       public static void main(String[]   args) {           // Spring应用启动起来             SpringApplication.run(HelloWorldMainApplication.class,args);       }   }   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> *  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用</div><div class="line"> */</div><div class="line">@SpringBootApplication</div><div class="line">public class HelloWorldMainApplication &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // Spring应用启动起来</div><div class="line">        SpringApplication.run(HelloWorldMainApplication.class,args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-注解分析-SpringBootApplication"><a href="#1-注解分析-SpringBootApplication" class="headerlink" title="1 注解分析-@SpringBootApplication"></a>1 注解分析-@SpringBootApplication</h3><p>@SpringBootApplication:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image035.jpg" alt="img"></p>
<h4 id="1．-SpringBootConfiguration"><a href="#1．-SpringBootConfiguration" class="headerlink" title="1．@SpringBootConfiguration"></a>1．@SpringBootConfiguration</h4><p><img src="/2019/01/30/springboot个人总结/clip_image036.png" alt="img"></p>
<p>@SpringBootConfiguration:Spring Boot的配置类，sb自定义的一个注解，标注在某个类上，表示这是一个Spring Boot的配置类。</p>
<p>点进去发现实际上他是使用spring的@Configuration来注解的，而@Configuration的上一层是@Component。</p>
<p>在Spring Boot项目中推荐使用@ SpringBootConfiguration替代@Configuration</p>
<pre><code>**总的来说：这个注解的作用是把当前启动类加入到spring容器中，同时当做一个配置类来使用。**
</code></pre><h4 id="2-EnableAutoConfiguration"><a href="#2-EnableAutoConfiguration" class="headerlink" title="2. @EnableAutoConfiguration"></a>2. @<strong>EnableAutoConfiguration</strong></h4><p><img src="/2019/01/30/springboot个人总结/clip_image037.png" alt="img"></p>
<p>@<strong>EnableAutoConfiguration</strong>：<strong>开启自动配置功能</strong>，以前我们需要配置的东西，Spring Boot帮我们自动配置；例如：我们添加了spring-boot-starter-web的依赖，项目中也就会引入SpringMVC的依赖，Spring Boot就会自动配置tomcat和SpringMVC，下面我们查看这个注解具体的作用。</p>
<h5 id="AutoConfigurationPackage：自动配置包"><a href="#AutoConfigurationPackage：自动配置包" class="headerlink" title="@AutoConfigurationPackage：自动配置包"></a>@AutoConfigurationPackage：自动配置包</h5><p><img src="/2019/01/30/springboot个人总结/clip_image038.png" alt="img"></p>
<p>利用Spring的底层注解@Import，给IOC容器中导入组件，导入的组件由AutoConfigurationPackages.Registrar.class来控制。</p>
<blockquote>
<p>额外提示：</p>
</blockquote>
<p><strong>可以参见在网站上发布的《spring注解》文章，关于@import注解导入bean的三种方式</strong></p>
<p><strong>（1）源码分析</strong></p>
<p>查看AutoConfigurationPackages的内部类Registrar，他实现了ImportBeanDefinitionRegistrar接口。通过这个接口的重载方法registerBeanDefinitions（），控制导入IOC容器的bean。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static class Registrar implements ImportBeanDefinitionRegistrar,</div><div class="line">DeterminableImports &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void registerBeanDefinitions(AnnotationMetadata metadata,</div><div class="line">			BeanDefinitionRegistry registry) &#123;</div><div class="line">	1.	register(registry, new PackageImport(metadata).getPackageName());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;</div><div class="line">		return Collections.singleton(new PackageImport(metadata));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>static class Registrar   implements ImportBeanDefinitionRegistrar,    DeterminableImports {                     @Override                 public void   registerBeanDefinitions(AnnotationMetadata metadata,                               BeanDefinitionRegistry   registry) {                 1.    register(registry, new   PackageImport(metadata).getPackageName());                 }                     @Override                 public   Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) {                        return   Collections.singleton(new PackageImport(metadata));                 }              }   
</code></pre><p>会去调用registerBeanDefinitions方法注册bean，紧接着registerBeanDefinitions方法调用register方法。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image040.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/5C1566700814119.png" alt="1566700814119"></p>
<p>该方法会首先判断，IOC容器中是否存在</p>
<p>org.springframework.boot.autoconfigure.AutoConfigurationPackages 类，不存在则把该类注册到容器中，不存在则创建</p>
<blockquote>
<p>在1处打个断点</p>
</blockquote>
<p><strong>发现获取的metadata元数据信息是HelloWorldMainApplication的。计算new PackageImport(metadata).getPackageName()的值得出的是HelloWorldMainApplication所在包的包名。Registry是IOC容器实例</strong></p>
<blockquote>
<p>  总结：</p>
</blockquote>
<p><strong>@AutoConfigurationPackage注解的作用是将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器，也就是说，如果controller，service等等类不在这个包下的话，是不会注册到spring容器中的，所以需要注意。</strong></p>
<blockquote>
<p>尖叫提示：</p>
</blockquote>
<p><strong>我们知道spring启动的时候会默认扫描启动类所在的包下面的所有类，注入springioc容器中，但是如果我们需要注入ioc容器的类不在启动类包下，那么我们可以通过这个@ImportResource(locations = {“classpath:beans.xml”})</strong><br><strong>注解进行注入额外的类（注解加在 启动类上）</strong></p>
<p><strong>注解进行注入额外的类（注解加在</strong> <strong>启动类上）</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image042.jpg" alt="img"></p>
<h5 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h5><p><strong>（1）整体结构分析</strong></p>
<p><a href="mailto:还是利用了@import注解导入了AutoConfigurationImportSelector.class" target="_blank" rel="external">还是利用了@import注解导入了AutoConfigurationImportSelector.class</a> 类，</p>
<p>查看他的继承结构。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image044.jpg" alt="img"></p>
<blockquote>
<pre><code>题外话：
</code></pre></blockquote>
<p><strong>可以看到很多组件都实现了Aware接口，关于实现Aware的作用是，我们可以在自定义组件中使用Spring底层的一些组件，例如创建一个bean时候，我们想查看IOC容器的信息或者查看当前系统的信息，那么这个时候就需要用到Aware接口，注入这些底层组件，供自定义组件调用。</strong></p>
<hr>
<blockquote>
<p><strong>可以参见在网站上发布的《spring注解》文章，关于Aware接口</strong></p>
<p>关键代码</p>
</blockquote>
<p><img src="/2019/01/30/springboot个人总结/clip_image046.jpg" alt="img"></p>
<p><strong>selectImports方法，返回的是需要导入到IOC容器的bean的全类名</strong>。类似</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image048.jpg" alt="img"></p>
<p><strong>(2)详细分析</strong></p>
<ol>
<li>查看selectImport()，可以看到最终返回的是自动配置实体类autoConfigurationEntry. getConfigurations()方法的返回值，就是一个List<string></string></li>
</ol>
<p><img src="/2019/01/30/springboot个人总结/clip_image050.jpg" alt="img"></p>
<p>那么很明显获取自动配置实体类的代码是接下来我们所要关注的重点。</p>
<p>2.进入AutoConfigurationImportSelector.getAutoConfigurationEntry()方法</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image052.jpg" alt="img"></p>
<p>同理可得，关键代码是：List<string> configurations</string></p>
<p>3.接着看getCandidateConfigurations方法里面的关键代码段。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image054.jpg" alt="img"></p>
<p> 关键代码：loadFactoryNames()方法，他的第一个参数通过debug我们可以得知，也就是getSpringFactoriesLoaderFactoryClass()方法的值是：</p>
<p>EnableAutoConfiguration.class –&gt; org.springframework.boot.autoconfigure.EnableAutoConfiguration </p>
<p><strong>SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)**</strong>；**</p>
<p>深入查看loadFactoryNames方法可知。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image056.jpg" alt="img"></p>
<p>他是通过</p>
<p>最终loadFactoryNames()方法的返回值是：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image058.jpg" alt="img"></p>
<p><strong>（3）总结：</strong></p>
<p>@Import(AutoConfigurationImportSelector.class)注解的作用是，通过以key为</p>
<p>org.springframework.boot.autoconfigure.EnableAutoConfiguration，然后在META-INF/spring.factories文件中，获取key对应的value值，然后打包成一个值是全类名的List<string>，最终返回到selectImport()方法，然后调用IOC容器把这些List<string>里面bean，注册到IOC容器中，完成自动配置。</string></string></p>
<p>META-INF/spring.factories文件的位置。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image060.png" alt="img"></p>
<p><strong>J2EE**</strong>的整体整合解决方案和自动配置都在<strong>**spring-boot-autoconfigure-2.0.5.RELEASE.jar</strong></p>
<p><strong>关于自动配置：下面的5.12章节也会阐述到。</strong></p>
<h4 id="3-ComponentScan"><a href="#3-ComponentScan" class="headerlink" title="3. @ComponentScan"></a>3. @ComponentScan</h4><p><img src="/2019/01/30/springboot个人总结/clip_image062.jpg" alt="img"></p>
<h2 id="4-3-关闭自动配置"><a href="#4-3-关闭自动配置" class="headerlink" title="4.3 关闭自动配置"></a>4.3 关闭自动配置</h2><p>通过上述，我们得知，Spring Boot会根据项目中的jar包依赖，自动做出配置，Spring Boot支持的自动配置如下（非常多）：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image064.jpg" alt="img"></p>
<p>如果我们不需要Spring Boot自动配置，想关闭某一项的自动配置，该如何设置呢？</p>
<p>比如：我们不想自动配置Redis，想手动配置。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image066.jpg" alt="img"></p>
<p>当然了，其他的配置就类似了。</p>
<h2 id="4-4-自定义Banner-了解即可-没什么用"><a href="#4-4-自定义Banner-了解即可-没什么用" class="headerlink" title="4.4 自定义Banner-了解即可-没什么用"></a>4.4 自定义Banner-了解即可-没什么用</h2><p>启动Spring Boot项目后会看到这样的图案：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image068.jpg" alt="img"></p>
<p>这个图片其实是可以自定义的：</p>
<p>\1.       打开网站：</p>
<p><a href="http://patorjk.com/software/taag/#p=display&amp;h=3&amp;v=3&amp;f=4Max&amp;t=itcast%20Spring%20Boot" target="_blank" rel="external">http://patorjk.com/software/taag/#p=display&amp;h=3&amp;v=3&amp;f=4Max&amp;t=itcast%20Spring%20Boot</a><br> <img src="/2019/01/30/springboot个人总结/clip_image070.jpg" alt="img">拷贝生成的字符到一个文本文件中，并且将该文件命名为banner.txt</p>
<p>\2.       将banner.txt拷贝到项目的resources目录中：<br> <img src="/2019/01/30/springboot个人总结/clip_image071.png" alt="img"></p>
<p>\3.       重新启动程序，查看效果：</p>
<p>如果不想看到任何的banner，也是可以将其关闭的：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image073.jpg" alt="img"></p>
<h2 id="4-5全局配置文件"><a href="#4-5全局配置文件" class="headerlink" title="4.5全局配置文件"></a>4.5全局配置文件</h2><p>Spring Boot项目使用一个全局的配置文件application.properties或者是application.yml，在resources目录下或者类路径下的/config下，一般我们放到resources下。</p>
<p>1、  修改tomcat的端口为8088<br> <img src="/2019/01/30/springboot个人总结/clip_image074.png" alt="img"><br> 重新启动应用，查看效果：<br> <img src="/2019/01/30/springboot个人总结/clip_image076.jpg" alt="img"></p>
<p>2、  修改进入DispatcherServlet的规则为：*.html<br> <img src="/2019/01/30/springboot个人总结/clip_image077.png" alt="img"><br> 测试：<br> <img src="/2019/01/30/springboot个人总结/clip_image078.png" alt="img"><br> <img src="/2019/01/30/springboot个人总结/clip_image080.jpg" alt="img"></p>
<h1 id="五-配置文件"><a href="#五-配置文件" class="headerlink" title="五. 配置文件"></a>五. 配置文件</h1><p><strong>SpringBoot使用一个全局的配置文件，配置文件名是固定的（名字不能更改否则无效）</strong></p>
<p>•application.properties （默认生成）</p>
<p>•application.yml</p>
<p><strong>而且通过观察发现</strong> <strong>application.properties</strong> <strong>的优先级别比</strong> <strong>application.yml</strong> <strong>高，同样的属性配置，**</strong>properties<strong><strong>会覆盖</strong></strong>yml<strong>**的配置</strong></p>
<p>配置文件的作用：修改SpringBoot自动配置的默认值，SpringBoot在底层都给我们自动配置好。</p>
<h2 id="5-1-YAML"><a href="#5-1-YAML" class="headerlink" title="5.1 YAML"></a>5.1 YAML</h2><p>他是一种标记语言</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image082.jpg" alt="img"></p>
<h2 id="5-2YAML语法"><a href="#5-2YAML语法" class="headerlink" title="5.2YAML语法"></a>5.2YAML语法</h2><p><img src="/2019/01/30/springboot个人总结/clip_image084.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image086.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image088.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image090.jpg" alt="img"></p>
<h2 id="5-3配置文件值注入"><a href="#5-3配置文件值注入" class="headerlink" title="5.3配置文件值注入"></a>5.3配置文件值注入</h2><p><img src="/2019/01/30/springboot个人总结/clip_image092.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image094.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image096.jpg" alt="img"></p>
<h2 id="5-4-Value获取值和-ConfigurationProperties获取值比较"><a href="#5-4-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="5.4 @Value获取值和@ConfigurationProperties获取值比较"></a>5.4 @Value获取值和@ConfigurationProperties获取值比较</h2><p><img src="/2019/01/30/springboot个人总结/clip_image098.jpg" alt="img"></p>
<h2 id="5-5、配置文件注入值数据校验"><a href="#5-5、配置文件注入值数据校验" class="headerlink" title="5.5、配置文件注入值数据校验"></a>5.5、配置文件注入值数据校验</h2><p><img src="/2019/01/30/springboot个人总结/clip_image100.jpg" alt="img"></p>
<h2 id="5-6、-PropertySource-amp-ImportResource-amp-Bean"><a href="#5-6、-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="5.6、@PropertySource&amp;@ImportResource&amp;@Bean"></a>5.6、@PropertySource&amp;@ImportResource&amp;@Bean</h2><p><strong>1. @PropertySource：加载指定的配置文件；</strong></p>
<p>应用场景，我们知道application.properties是项目的整体配置文件，但是如果存在大量跟项目关系不是那么密切的配置信息，我们是可以配置到其他的配置的文件中去，避免造成application.peoperties文件的大小过大。这个时候就需要PropertySource注解进行指定。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image102.jpg" alt="img"></p>
<p><strong>2.</strong> <strong>@ImportResource**</strong>：**</p>
<p>导入Spring的配置文件，让配置文件里面的内容生效，Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别，想让Spring的配置文件生效，加载进来，@<strong>ImportResource</strong>标注在一个配置类上。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image104.jpg" alt="img"></p>
<p><strong>3.@bean</strong></p>
<p>Bean注解一般是配合着@Configure注解使用</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image106.jpg" alt="img"></p>
<h2 id="5-7比较application-properties和application-yml和自定义properti的优先级别"><a href="#5-7比较application-properties和application-yml和自定义properti的优先级别" class="headerlink" title="5.7比较application.properties和application.yml和自定义properti的优先级别"></a>5.7比较application.properties和application.yml和自定义properti的优先级别</h2><p>同样的属性配置 ：  application.properties &gt; application.yml &gt; 自定义properties</p>
<p><strong>前者会覆盖后者</strong></p>
<h2 id="5-8、配置文件占位符"><a href="#5-8、配置文件占位符" class="headerlink" title="5.8、配置文件占位符"></a>5.8、配置文件占位符</h2><p><img src="/2019/01/30/springboot个人总结/clip_image108.jpg" alt="img"></p>
<h2 id="5-9、Profile"><a href="#5-9、Profile" class="headerlink" title="5.9、Profile"></a>5.9、Profile</h2><p>使用场景，针对于配置文件。例如我们在开发过程中使用的是开发环境的properties，那么生产使用的是生产的properties。那么我们怎么指定呢？ spring提供了profile功能</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image110.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image112.jpg" alt="img"></p>
<h2 id="5-10、配置文件加载位置-Important"><a href="#5-10、配置文件加载位置-Important" class="headerlink" title="5.10、配置文件加载位置(Important)"></a>5.10、配置文件加载位置(Important)</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<p>–file:./config/    （在项目的的根目录下新建config）</p>
<p>–file:./                  （在项目的的根目录下）</p>
<p>–classpath:/config/  （项目的resource目录下新建config）</p>
<p>–classpath:/     （默认生成的application.properties是在类路径下面的）</p>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image114.jpg" alt="img"></p>
<h2 id="5-11、外部配置加载顺序"><a href="#5-11、外部配置加载顺序" class="headerlink" title="5.11、外部配置加载顺序"></a>5.11、外部配置加载顺序</h2><p><img src="/2019/01/30/springboot个人总结/clip_image116.jpg" alt="img"></p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="external">参考官方文档</a></p>
<h2 id="5-11-bookstrap-yml"><a href="#5-11-bookstrap-yml" class="headerlink" title="5.11 bookstrap.yml"></a>5.11 bookstrap.yml</h2><p>其实还有一个系统级别的配置文件，这个是springcloud的在使用configserver组件的时候使用的，详情可查看后续的springcloud文章-springcloud的配置中心。</p>
<h2 id="5-12、自动配置原理"><a href="#5-12、自动配置原理" class="headerlink" title="5.12、自动配置原理"></a>5.12、自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="external">配置文件能配置的属性参照</a></p>
<h3 id="1、自动配置原理"><a href="#1、自动配置原理" class="headerlink" title="1、自动配置原理"></a>1、<strong>自动配置原理</strong></h3><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能通过这个注解@EnableAutoConfiguration</p>
<p><strong>2）、@EnableAutoConfiguration作用：</strong></p>
<p>·        利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</p>
<p>·        可以查看selectImports()方法的内容；</p>
<p>·        List<string> configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置</string></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SpringFactoriesLoader.loadFactoryNames()</div><div class="line"></div><div class="line">扫描所有jar包类路径下  META-INF/spring.factories</div><div class="line"></div><div class="line">把扫描到的这些文件的内容包装成properties对象</div><div class="line"></div><div class="line">从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</div></pre></td></tr></table></figure>
<p><strong>将</strong> <strong>类路径下</strong> <strong>META-INF/spring.factories</strong> <strong>里面配置的所有**</strong>EnableAutoConfiguration<strong>**的值加入到了容器中</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Auto Configure</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</div><div class="line"></div><div class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAu</div><div class="line">。。。。。。。。。。。。。。。。等等</div></pre></td></tr></table></figure>
<p>每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p>
<p>3）、每一个自动配置类进行自动配置功能；</p>
<p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration   //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</div><div class="line"></div><div class="line">@EnableConfigurationProperties(HttpEncodingProperties.class)  //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@ConditionalOnClass(CharacterEncodingFilter.class)  //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)  //判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</div><div class="line"></div><div class="line">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</div><div class="line"></div><div class="line">public class HttpEncodingAutoConfiguration &#123;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line">    //他已经和SpringBoot的配置文件映射了</div><div class="line"></div><div class="line">    private final HttpEncodingProperties properties;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line">   //只有一个有参构造器的情况下，参数的值就会从容器中拿</div><div class="line"></div><div class="line">    public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123;</div><div class="line"></div><div class="line">        this.properties = properties;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line">    @Bean   //给容器中添加一个组件，这个组件的某些值需要从properties中获取</div><div class="line"></div><div class="line">    @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？</div><div class="line"></div><div class="line">    public CharacterEncodingFilter characterEncodingFilter() &#123;</div><div class="line"></div><div class="line">        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();</div><div class="line"></div><div class="line">        filter.setEncoding(this.properties.getCharset().name());</div><div class="line"></div><div class="line">        filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));</div><div class="line"></div><div class="line">        filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));</div><div class="line"></div><div class="line">        return filter;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>根据当前不同的条件判断，决定这个配置类是否生效？</p>
<p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p>
<p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者。配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)  //从配置文件中获取指定的值和bean的属性进行绑定</div><div class="line"></div><div class="line">public class HttpEncodingProperties &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);</div></pre></td></tr></table></figure>
<p><strong>精髓：</strong></p>
<p> <strong>1**</strong>）、<strong><strong>SpringBoot</strong></strong>启动会加载大量的自动配置类**</p>
<p> <strong>2**</strong>）、我们看我们需要的功能有没有<strong><strong>SpringBoot</strong></strong>默认写好的自动配置类；**</p>
<p> <strong>3**</strong>）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）**</p>
<p> <strong>4**</strong>）、给容器中自动配置类添加组件的时候，会从<strong><strong>properties</strong></strong>类中获取某些属性。我们就可以在配置文件中指定这些属性的值；**</p>
<p>xxxxAutoConfigurartion：自动配置类；</p>
<p>给容器中添加组件</p>
<p>xxxxProperties:封装配置文件中相关属性；</p>
<h3 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h3><h4 id="1、-Conditional派生注解（Spring注解版原生的-Conditional作用）"><a href="#1、-Conditional派生注解（Spring注解版原生的-Conditional作用）" class="headerlink" title="1、@Conditional派生注解（Spring注解版原生的@Conditional作用）"></a>1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</h4><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<table>
<thead>
<tr>
<th><strong>@Conditional**</strong>扩展注解**</th>
<th><strong>作用（判断是否满足当前指定条件）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody>
</table>
<p><strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p>我们怎么知道哪些自动配置类生效；</p>
<p><strong>==**</strong>我们可以通过在<strong><strong>application.properties</strong></strong>中启用<strong> </strong>debug=true<strong><strong>属性；来让控制台打印自动配置报告</strong></strong>==**，这样我们就可以很方便的知道哪些自动配置类生效；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">=========================</div><div class="line"></div><div class="line">AUTO-CONFIGURATION REPORT</div><div class="line"></div><div class="line">=========================</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Positive matches:（自动配置类启用的）</div><div class="line"></div><div class="line">-----------------</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   DispatcherServletAutoConfiguration matched:</div><div class="line"></div><div class="line">      - @ConditionalOnClass found required class &apos;org.springframework.web.servlet.DispatcherServlet&apos;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)</div><div class="line"></div><div class="line">      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)</div><div class="line"></div><div class="line">        </div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">Negative matches:（没有启动，没有匹配成功的自动配置类）</div><div class="line"></div><div class="line">-----------------</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   ActiveMQAutoConfiguration:</div><div class="line"></div><div class="line">      Did not match:</div><div class="line"></div><div class="line">         - @ConditionalOnClass did not find required classes &apos;javax.jms.ConnectionFactory&apos;, &apos;org.apache.activemq.ActiveMQConnectionFactory&apos; (OnClassCondition)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">   AopAutoConfiguration:</div><div class="line"></div><div class="line">      Did not match:</div><div class="line"></div><div class="line">         - @ConditionalOnClass did not find required classes &apos;org.aspectj.lang.annotation.Aspect&apos;, &apos;org.aspectj.lang.reflect.Advice&apos; (OnClassCondition)</div></pre></td></tr></table></figure>
<h1 id="六．日志"><a href="#六．日志" class="headerlink" title="六．日志"></a>六．日志</h1><h1 id="七-springboot的web开发"><a href="#七-springboot的web开发" class="headerlink" title="七 springboot的web开发"></a>七 springboot的web开发</h1><h2 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h2><p>使用SpringBoot；</p>
<p><strong>1**</strong>）、创建<strong><strong>SpringBoot</strong></strong>应用，选中我们需要的模块；**</p>
<p><strong>2**</strong>）、<strong><strong>SpringBoot</strong></strong>已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来**</p>
<p><strong>3**</strong>）、自己编写业务代码；**</p>
<p>我们知道sb框架已经给我们自动配置了很多相关的配置，我们只需要着重于业务代码的编写，但是有些细则还是需要了解的，例如我们打包的sb程序成jar包的形式，那么我们网站的css js等等资源是放置在那个目录呢？换言说，静态资源的访问是个怎么流程呢？</p>
<h2 id="7-2、SpringBoot对静态资源的映射规则"><a href="#7-2、SpringBoot对静态资源的映射规则" class="headerlink" title="7.2、SpringBoot对静态资源的映射规则"></a>7.2、SpringBoot对静态资源的映射规则</h2><p><strong>1.Web**</strong>开发的自动配置类**</p>
<p>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</p>
<p>查看关键代码</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image118.jpg" alt="img"></p>
<h3 id="7-2-1-查看第一层映射关系"><a href="#7-2-1-查看第一层映射关系" class="headerlink" title="7.2.1 查看第一层映射关系"></a>7.2.1 查看第一层映射关系</h3><p>这段代码的意思是：所有/webjars/**的请求 ，都去classpath:/META-INF/resources/webjars/ 找资源。</p>
<p>例如请求jauery的请求 localhost:8080/webjars/jquery/3.3.1/jquery.js </p>
<p><strong>1.**</strong>什么是<strong><strong>webjars</strong></strong>？**</p>
<p>以jar包的方式引入静态资源，可登陆这个网址了解<a href="http://www.webjars.org/" target="_blank" rel="external">http://www.webjars.org/</a></p>
<p>也就是说，网站需要的jq等等资源你可以通过maven的方式导入到项目中。</p>
   <!--引入jquery-webjar-->在访问的时候只需要写webjars下面资源的名称即可                 <dependency>                        <groupid>org.webjars</groupid>                        <artifactid>jquery</artifactid>                        <version>3.3.1</version>                 </dependency><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.webjars&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;jquery&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;3.3.1&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>导入到sb项目后查看依赖</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image119.png" alt="img"></p>
<p>启动项目请求：localhost:8080/webjars/jquery/3.3.1/jquery.js。  输出jquery内容。</p>
<p>总结：</p>
<p>也就是说，如果我们需要引用网上相关的资源可以使用webjars的方式导入相关的组件，<strong>但是有个问题，那就是如果我们项目中已经存在某些**</strong>css<strong><strong>和</strong></strong>js<strong><strong>，那么怎么引用到</strong></strong>sb<strong>**项目中呢（也就是请求不满足第一层映射关系）</strong>？</p>
<p>例如：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image120.png" alt="img"></p>
<h3 id="7-2-2-第二层映射关系"><a href="#7-2-2-第二层映射关系" class="headerlink" title="7.2.2 第二层映射关系"></a>7.2.2 第二层映射关系</h3><p><img src="/2019/01/30/springboot个人总结/clip_image122.jpg" alt="img"></p>
<p>查看staticPathPattern的值：staticPathPattern = “/<strong>“。</strong>也就是说改代码块匹配访问当前项目任何资源的请求**</p>
<p>那么他是去哪里寻找资源回应请求呢？</p>
<p>查看getStaticLocations()方法，通过查看发现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;</div><div class="line">		&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,</div><div class="line">		&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;</div></pre></td></tr></table></figure>
<pre><code>private static final String[] CLASSPATH_RESOURCE_LOCATIONS   = {                        &quot;classpath:/META-INF/resources/&quot;,   &quot;classpath:/resources/&quot;,                        &quot;classpath:/static/&quot;,   &quot;classpath:/public/&quot; };   
</code></pre><p>也就是说，请求会去类路径的根路径下的这个几个目录寻找相应的资源响应。</p>
<p>类路径是指：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image123.png" alt="img">例如sbp项目中，java和resources都是属于类路径的根路径。静态资源，我们可以在resources下创建 resources目录存放，或者创建public目录存放，<strong>static**</strong>目录默认已经创建**</p>
<h4 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h4><p><img src="/2019/01/30/springboot个人总结/clip_image124.png" alt="img"></p>
<p>我们把一些样式文件放置到static目录下</p>
<p>启动sb项目，访问静态资源。<a href="http://127.0.0.1:8080/asserts/img/4D74191A.jpg" target="_blank" rel="external">http://127.0.0.1:8080/asserts/img/4D74191A.jpg</a></p>
<p>访问成功。<strong>很明显不满足第一层映射关系，走的是第二层映射关系的逻辑</strong></p>
<h3 id="7-2-3-欢迎页配置"><a href="#7-2-3-欢迎页配置" class="headerlink" title="7.2.3 欢迎页配置"></a>7.2.3 欢迎页配置</h3><p><img src="/2019/01/30/springboot个人总结/clip_image126.jpg" alt="img"></p>
<p>通过查看他也是从7.2.2章节中静态资源存放目录下寻找index.html。</p>
<p>localhost:8080/ 找index页面</p>
<h3 id="7-2-4-网站图标"><a href="#7-2-4-网站图标" class="headerlink" title="7.2.4 网站图标"></a>7.2.4 网站图标</h3><p>所有的 **/favicon.ico 都是在静态资源文件下找；==（也是从7.2.2章节中静态资源存放目录下）</p>
<h3 id="7-2-5-修改静态资源文件夹路径"><a href="#7-2-5-修改静态资源文件夹路径" class="headerlink" title="7.2.5 修改静态资源文件夹路径"></a>7.2.5 修改静态资源文件夹路径</h3><p><img src="/2019/01/30/springboot个人总结/clip_image128.jpg" alt="img"></p>
<h2 id="7-3、模板引擎"><a href="#7-3、模板引擎" class="headerlink" title="7.3、模板引擎"></a>7.3、模板引擎</h2><p>常用的模板引擎有JSP、Velocity、Freemarker、Thymeleaf。核心理念是，通过传入模板代码和需要替换的数据到模板引擎中，模板引擎自动转化成静态的界面显示</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image130.jpg" alt="img"></p>
<p>SpringBoot推荐的Thymeleaf，语法更简单，功能更强大；</p>
<h3 id="1、引入thymeleaf"><a href="#1、引入thymeleaf" class="headerlink" title="1、引入thymeleaf"></a>1、引入thymeleaf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>我这里默认导入的是3.011版本。</p>
<p>如果你们想要修改导入版本，那么也是可以的：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image132.jpg" alt="img"></p>
<p>Pom.xml文件中添加版本覆盖即可</p>
<h3 id="2、Thymeleaf使用"><a href="#2、Thymeleaf使用" class="headerlink" title="2、Thymeleaf使用"></a>2、Thymeleaf使用</h3><p>我们通过查看他的自动配置源码来了解一下他的加载结构：</p>
<p>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration</p>
<p>的ThymeleafProperties 属性</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image134.jpg" alt="img"></p>
<p>发下它默认加载类路径下的templates目录下的后缀为html的文件。</p>
<p><strong>只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</strong></p>
<h4 id="2-1-案例1（常规使用）"><a href="#2-1-案例1（常规使用）" class="headerlink" title="2.1 案例1（常规使用）"></a>2.1 案例1（常规使用）</h4><p>（1）    在templates目录下新建ok.html界面</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image135.png" alt="img"></p>
<p>（2）    在controller中添加请求处理，最终是跳转到ok.html界面</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image136.png" alt="img"></p>
<p>（3）启动sb项目，并访问<a href="http://127.0.0.1:8080/ok" target="_blank" rel="external">http://127.0.0.1:8080/ok</a> </p>
<h4 id="2-2-动态赋值"><a href="#2-2-动态赋值" class="headerlink" title="2.2 动态赋值"></a>2.2 动态赋值</h4><p>1.修改ok.html界面 </p>
<p><img src="/2019/01/30/springboot个人总结/clip_image138.jpg" alt="img"></p>
<p>2.修改请求处理方法 ok()</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image139.png" alt="img"></p>
<p>3.启动sb项目，并访问<a href="http://127.0.0.1:8080/ok" target="_blank" rel="external">http://127.0.0.1:8080/ok</a></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image140.png" alt="img"></p>
<p>总结：</p>
<p>这里建议给html界面加上命名空间，这样在使用thyeleaf语法时会有提示</p>
   <html lang="en" xmlns:th="http://www.thymeleaf.org">   









<h3 id="4-Thymeleaf语法"><a href="#4-Thymeleaf语法" class="headerlink" title="4.     Thymeleaf语法"></a>4.     Thymeleaf语法</h3><p><a href="https://www.thymeleaf.org/" target="_blank" rel="external">https://www.thymeleaf.org/</a> 官方地址</p>
<p>1）、th:text；改变当前元素里面的文本内容；</p>
<p> th：任意html属性；来替换原生属性的值</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image142.jpg" alt="img"></p>
<p>2）、表达式？</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image144.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image146.jpg" alt="img"></p>
<h2 id="7-4、SpringMVC自动配置"><a href="#7-4、SpringMVC自动配置" class="headerlink" title="7.4、SpringMVC自动配置"></a>7.4、SpringMVC自动配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-auto-configuration" target="_blank" rel="external">https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-auto-configuration</a> 官方文档</p>
<h3 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h3><p>通过查看官方文档查看springboot为springmvc自动配置了那些工作</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image148.jpg" alt="img"></p>
<p>逐句分析：</p>
<p>Spring Boot 自动配置好了SpringMVC</p>
<p>以下是SpringBoot对SpringMVC的默认配置:关键类WebMvcAutoConfiguration</p>
<p><strong>1 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.</strong></p>
<p>  - 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发或者重定向））</p>
<p>  - ContentNegotiatingViewResolver：组合所有的视图解析器的；</p>
<p>  - <strong>如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来</strong></p>
<p><strong>2.Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</strong></p>
<p><strong>3.Static index.html support.</strong> <strong>静态首页访问</strong></p>
<p><strong>4.Custom Favicon support (see below).  favicon.ico</strong></p>
<p><strong>5.自动注册了</strong> <strong>of Converter, GenericConverter, Formatter beans.</strong></p>
<p>  - Converter：转换器；  public String hello(User user)：类型转换使用Converter</p>
<p>  - Formatter  格式化器；  2017.12.17===Date；</p>
<p>关键代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Bean</div><div class="line">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)//在文件中配置日期格式化的规则</div><div class="line">public Formatter&lt;Date&gt; dateFormatter() &#123;</div><div class="line">	return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>@Bean                 @ConditionalOnProperty(prefix =   &quot;spring.mvc&quot;, name = &quot;date-format&quot;)//在文件中配置日期格式化的规则                 public Formatter&lt;Date&gt; dateFormatter() {                        return new   DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件                 }   
</code></pre><p><strong>自己添加的格式化器转换器，我们只需要放在容器中即可</strong></p>
<p><strong>6**</strong>.Support for HttpMessageConverters (see below).**</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image150.jpg" alt="img"></p>
<p><strong>7**</strong>. Automatic registration of MessageCodesResolver (see below).<strong>**定义错误代码生成规则</strong></p>
<p><strong>8**</strong>. Automatic use of a ConfigurableWebBindingInitializer bean (see below).**</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image152.jpg" alt="img"></p>
<h3 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h3><p>虽然springboot框架给我们自动配置了很多组件，但是在真实的应用场景中，肯定还需要自己实现一些组件，来扩展我们的springboot程序，例如我们需要定义一个拦截器和一个特定功能的视图解析器。那么就需要扩展了。</p>
<p>官方文档有段话，给我们阐述了如果扩展：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image154.jpg" alt="img"></p>
<p><strong>总的来说：编写一个配置类（@Configuration），是WebMvcConfigurer类型，不能标注@EnableWebMvc，即可实现扩展功能。</strong></p>
<pre><code>**尖叫提示：有些文档还是使用WebMvcConfigurerAdapter。**
</code></pre><p><strong>需要注意的是：在springboot2.0版本以上，WebMvcConfigurerAdapter类已经过时，需要使用WebMvcConfigurer 接口或者WebMvcConfigurationSupport</strong></p>
<p>   过时原因：原因是springboot2.0以后，引用的是spring5.0，而spring5.0取消了<strong>WebMvcConfigurerAdapter</strong> </p>
<h4 id="2-1-案例"><a href="#2-1-案例" class="headerlink" title="2.1 案例"></a>2.1 案例</h4><p>实现一个视图解析器，将请求是/no时，直接重定向到success界面(<strong>也就是说不用编写controller**</strong>方法**)。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image156.jpg" alt="img"></p>
<p>访问请求：<a href="http://127.0.0.1:8080/no" target="_blank" rel="external">http://127.0.0.1:8080/no</a> </p>
<h4 id="重要总结"><a href="#重要总结" class="headerlink" title="重要总结"></a>重要总结</h4><p><strong>总结：建议以后所有关于**</strong>mvc<strong><strong>扩展的自定义的功能组件（视图解析器，国际化，拦截器等等），都放在某一个自实现的</strong></strong>mvcConfig<strong><strong>中（例如上面的</strong></strong>MyViewConfig<strong><strong>），方便管理，也可以实现多个扩展的</strong></strong>webMvcConfig,<strong>**按照功能放置自定义的组件。</strong></p>
<h4 id="2-2-扩展mvc原理"><a href="#2-2-扩展mvc原理" class="headerlink" title="2.2 扩展mvc原理"></a>2.2 扩展mvc原理</h4><p>查看<strong>WebMvcAutoConfiguration**</strong>代码的适配器代码，可以知道关键代码是<strong>**@Import(EnableWebMvcConfiguration.class)</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image158.jpg" alt="img"></p>
<p>点进去 <strong>EnableWebMvcConfiguration.class**</strong>，发现他还是<strong><strong>WebMvcAutoConfiguration</strong></strong>的一个内部类。**</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image160.jpg" alt="img"></p>
<p><strong>查看</strong> <strong>DelegatingWebMvcConfiguration</strong> <strong>类。</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image162.jpg" alt="img"></p>
<p><strong>可以看到他是加载了容器中所有**</strong>WebMvcConfigurer<strong><strong>类型的配置类，然后逐个调用。这里也可以证明了，我们自定义的扩展类仅仅只是扩展了</strong></strong>mvc<strong>**的功能而已，并没有让其他自动配置功能失效。</strong></p>
<h3 id="3、全面接管SpringMVC"><a href="#3、全面接管SpringMVC" class="headerlink" title="3、全面接管SpringMVC"></a>3、全面接管SpringMVC</h3><p>全面接管也就意味着：<strong>SpringBoot**</strong>对<strong><strong>SpringMVC</strong></strong>的自动配置不需要了，所有都是我们自己配置，所有的<strong><strong>SpringMVC</strong></strong>的自动配置都会失效。**</p>
<p><strong>我们需要在配置类中添加**</strong>@EnableWebMvc<strong>**即可</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image164.jpg" alt="img"></p>
<p>访问：发现提示界面找不到了。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image166.jpg" alt="img"></p>
<p>加上注解，启动springboot项目，我们通过控制台输出的日志中我们发现少了一些filter。然后我们对于静态资源的默认访问路径等等都失效了。也就是说，访问html界面等等都行不通了。</p>
<p><strong>这些代码都会失效，所以请求访问不到静态界面</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image168.jpg" alt="img"></p>
<h4 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h4><p><strong>1**</strong>）<strong><strong>@EnableWebMvc</strong></strong>的核心**</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image170.jpg" alt="img"></p>
<p>可以看到他的核心是导入一个类 DelegatingWebMvcConfiguration</p>
<p><strong>2**</strong>）<strong><strong>DelegatingWebMvcConfiguration</strong></strong>类**</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image172.jpg" alt="img"></p>
<p>这个类就是我们上面2.2节查看注册各种适配器的关键代码，那么这里并没有什么代码控制 <strong>mvc**</strong>自动配置失效** </p>
<p><strong>发现它继承</strong> <strong>WebMvcConfigurationSupport</strong> <strong>，这个类我们好像在那里看见过</strong></p>
<p><strong>2**</strong>）查看<strong>**WebMvcAutoConfiguration</strong></p>
<p>让我们回过头查看mvc自动配置类</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image174.jpg" alt="img"></p>
<p>注意到一段代码：@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</p>
<p>意思是：当WebMvcConfigurationSupport类在容器中找不到时，执行自动配置类。</p>
<p>那么我们加上了<strong>@EnableWebMvc**</strong>注解，就相当于把<strong><strong>WebMvcConfigurationSupport</strong></strong>类注入到了容器中，所以<strong><strong>WebMvcAutoConfiguration</strong></strong>自动配置类失效。**</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>3**</strong>）、<strong><strong>@EnableWebMvc</strong></strong>将<strong><strong>WebMvcConfigurationSupport</strong></strong>组件导入进来；**</p>
<p><strong>4**</strong>）、导入的<strong><strong>WebMvcConfigurationSupport</strong></strong>只是<strong><strong>SpringMVC</strong></strong>最基本的功能；**</p>
<h2 id="7-5-默认访问首页"><a href="#7-5-默认访问首页" class="headerlink" title="7.5 默认访问首页"></a>7.5 默认访问首页</h2><p>通过查看WebMVCAutoConfiguration源代码可以知道，默认的”/”请求是会定向到类路径</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image175.png" alt="img"></p>
<p>下的index.html界面，那么我们可不可以手动控制他呢？</p>
<p>很明显是可以的。</p>
<h3 id="1-实现方式1"><a href="#1-实现方式1" class="headerlink" title="1.实现方式1"></a>1.实现方式1</h3><p>实现一个controller，映射”/”请求</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image177.jpg" alt="img"></p>
<p>​    </p>
<h3 id="2-实现方式2"><a href="#2-实现方式2" class="headerlink" title="2.实现方式2"></a>2.实现方式2</h3><p><img src="/2019/01/30/springboot个人总结/clip_image179.jpg" alt="img"></p>
<h2 id="7-6-国际化"><a href="#7-6-国际化" class="headerlink" title="7.6 国际化"></a>7.6 国际化</h2><p><strong>1**</strong>）、编写国际化配置文件；**</p>
<p>2）、使用ResourceBundleMessageSource管理国际化资源文件</p>
<p>3）、在页面使用fmt:message取出国际化内容</p>
<p>步骤：</p>
<p>1）、编写国际化配置文件，抽取页面需要显示的国际化消息</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image180.png" alt="img"></p>
<p>第一个properties表示是在没有指定语言的情况下，默认的显示值</p>
<p>2）、SpringBoot自动配置好了管理国际化资源文件的组件；</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image182.jpg" alt="img"></p>
<p>3）、配置国际化基础名</p>
<p>   在application.properties中设置</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image184.jpg" alt="img"></p>
<p>3）、去页面获取国际化的值；</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image186.jpg" alt="img"></p>
<p>效果：根据浏览器语言设置的信息切换了国际化；</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>国际化的核心是：</p>
<p> 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p>
<p>查看默认的区域信息解析器：</p>
<p>在WebMvcAutoConfiguration中</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image188.jpg" alt="img"></p>
<p>初始化了一个区域信息解析器，查看获取区域信息相关带代码</p>
<p>AcceptHeaderLocaleResolver ，看到这个类，我们可以猜测他是通过请求头中获取区域编码</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image190.jpg" alt="img"></p>
<p>看到 Accept-Language 说明上面我们的猜测是正确的。</p>
<p><strong>也就是说，国际化的区域信息，默认是通过请求头中获取。而且需要注意的是当**</strong>spring<strong><strong>容器中如果缺失</strong></strong>LocaleResolver<strong><strong>这个</strong></strong>bean<strong>**实例，那么才会去加载默认的，区域化信息解析器。（下面的点击链接切换国际化就是很好的利用了这个注解）</strong></p>
<h3 id="点击链接切换国际化"><a href="#点击链接切换国际化" class="headerlink" title="点击链接切换国际化"></a>点击链接切换国际化</h3><p>知道了上的原理，我们就可以手动的控制，切换语言环境。</p>
<p>1.实现一个区域信息解析器，通过获取请求中l的值，设定响应的语言环境。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image192.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">因为我们自定义实现了LocalResolver，那么根据@ConditionalOnMissingBean这个注解</div></pre></td></tr></table></figure>
<p><img src="/2019/01/30/springboot个人总结/clip_image193.png" alt="img"></p>
<p>那么springboot默认的区域化解析器就会失效。</p>
<p>\2. 实例化到spring容器中</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image195.jpg" alt="img"></p>
<p><strong>上面的两个步骤可以整合在一起，最终实现：</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image197.jpg" alt="img"></p>
<p>在自定义的LocaleResolver中直接注入到spring容器中。<strong>注意需要指明**</strong>bean<strong><strong>的</strong></strong>id<strong><strong>是</strong></strong>localeResolver**</p>
<p>3.通过链接实现</p>
<p><a href="http://127.0.0.1:8080/login.html?i=en_US" target="_blank" rel="external">http://127.0.0.1:8080/login.html?i=en_US</a></p>
<p><a href="http://127.0.0.1:8080/login.html?i=en_US" target="_blank" rel="external">http://127.0.0.1:8080/login.html?i=en_US</a></p>
<h2 id="7-7-themleaf关闭缓存"><a href="#7-7-themleaf关闭缓存" class="headerlink" title="7.7 themleaf关闭缓存"></a>7.7 themleaf关闭缓存</h2><p>Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力，但是在开发期间模板引擎页面修改以后，要实时生效，所以我们开发阶段可以关掉缓存使用</p>
<p>1）、禁用模板引擎的缓存</p>
<pre><code>\# 禁用缓存

spring.thymeleaf.cache=false 
</code></pre><p>2）、页面修改完成以后ctrl+f9：重新编译；</p>
<h2 id="7-8-自定义拦截器"><a href="#7-8-自定义拦截器" class="headerlink" title="7.8 自定义拦截器"></a>7.8 自定义拦截器</h2><p><img src="/2019/01/30/springboot个人总结/clip_image199.jpg" alt="img"></p>
<h3 id="1-第一种实现方式"><a href="#1-第一种实现方式" class="headerlink" title="1. 第一种实现方式"></a>1. 第一种实现方式</h3><p>继承WebMvcConfigurerAdapter</p>
<p>1.定义一个拦截器实现HandlerInterceptor接口</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image201.jpg" alt="img"></p>
<p>2.注册到容器中</p>
<p>我们把扩展mvc的组件都放在自定义mvc扩展类中：MyMvcConfig</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image203.jpg" alt="img"></p>
<h3 id="2-第二种方式（常见）"><a href="#2-第二种方式（常见）" class="headerlink" title="2. 第二种方式（常见）"></a>2. 第二种方式（常见）</h3><p>1.</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image205.jpg" alt="img"></p>
<p>\2. 然后定义配置类，注册拦截器</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image207.jpg" alt="img"></p>
<p>3.运行输出</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image208.png" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image209.png" alt="img"></p>
<p>接下来运行并查看日志：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image211.jpg" alt="img"></p>
<p>你会发现日志中只有这些打印信息，springMVC的日志信息都没有，因为springMVC记录的log级别是debug，springboot默认是显示info以上，我们需要进行配置。</p>
<p>SpringBoot通过logging.level.<em>=debug来配置日志级别，</em>填写包名</p>
<p># 设置org.springframework包的日志级别为debug</p>
<p>logging.level.org.springframework=debug</p>
<p>设置完后，访问请求，查看输出</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image213.jpg" alt="img"></p>
<p>相比springmvc，springboot已经帮我们做好了静态资源的映射访问，所以不需要额外处理。</p>
<h2 id="7-9-springmvc默认日期类型转化"><a href="#7-9-springmvc默认日期类型转化" class="headerlink" title="7.9 springmvc默认日期类型转化"></a>7.9 springmvc默认日期类型转化</h2><p>例如从前台传回一个时间字符串，后台通过date日期类型进行映射获取。那么如果前台日期格式是：2017/12/12 ，那么mvc会自动转化为date类型，因为他的默认时间转换器是以/ 进行分割的。</p>
<p>   如果是2017-12-12、2017.12.12   这样的日期格式，那么就需要我们自己实现日期转换器</p>
<p>  通过查看WebMvcAutoConfiguration的源码得知：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image215.jpg" alt="img"></p>
<p>默认的日期格式是使用反斜杠来分割。</p>
<p>–修改默认的日期格式化：</p>
<p> 只需要在applicatio.proeprties文件中，覆盖默认的日期格式即可</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image216.png" alt="img"></p>
<h2 id="7-10-post-get请求转化为put或其他"><a href="#7-10-post-get请求转化为put或其他" class="headerlink" title="7.10 post/get请求转化为put或其他"></a>7.10 post/get请求转化为put或其他</h2><p>我们知道html的form表单只支持get/post两种请求，那么我们使用restful url进行请求数据的时候，那么需要使用到put请求，那么怎么转化呢？</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image218.jpg" alt="img"></p>
<h2 id="7-11错误处理机制"><a href="#7-11错误处理机制" class="headerlink" title="7.11错误处理机制"></a>7.11错误处理机制</h2><h3 id="1）、SpringBoot默认的错误处理机制"><a href="#1）、SpringBoot默认的错误处理机制" class="headerlink" title="1）、SpringBoot默认的错误处理机制"></a>1）、SpringBoot默认的错误处理机制</h3><p>当我们访问一个不存在的资源时，那么springboot默认帮我们跳转到一个错误界面</p>
<p>1.使用pc浏览器访问</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image220.jpg" alt="img"></p>
<p>2.使用其他工具访问（postman）</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image222.jpg" alt="img"></p>
<p>我们不难发现，他返回错误的形式都是不一样的，前者返回一个html界面，后者返回的是一个json字符串。为什么会有两种错误请求返回方式呢？接下来看源码就知道了。</p>
<p>原理：</p>
<pre><code>  可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；

给容器中添加了以下四个组件

  1、DefaultErrorAttributes：
</code></pre><p><img src="/2019/01/30/springboot个人总结/clip_image224.jpg" alt="img"></p>
<pre><code>2、BasicErrorController：他是一个基本的错误控制类。处理默认/error请求
</code></pre><p><img src="/2019/01/30/springboot个人总结/clip_image226.jpg" alt="img"></p>
<p>是一个controller，处理/error请求</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image228.jpg" alt="img"></p>
<p><strong>这里就解释了为什么会出现，两种错误请求响应方式（**</strong>html<strong><strong>和</strong></strong>josn<strong>**）</strong></p>
<p><strong>那么会产生另一个问题，他是怎么知道客户端是**</strong>pc<strong><strong>还是其他访问工具呢？究竟怎么选择返回哪种格式的错误消息</strong></strong>??????????**</p>
<p>  很明显是通过请求头进行区分的。</p>
<p>1.通过postman发出的请求，请求头是：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image230.jpg" alt="img"></p>
<p>2.通过浏览器发出的请求，请求头是：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image231.png" alt="img"></p>
<p>3、ErrorPageCustomizer：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image233.jpg" alt="img"></p>
<p>查看getpath()，</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image235.jpg" alt="img"></p>
<p>总的来说：系统出现错误以后来到error请求进行处理；（类似我们在web.xml注册的错误页面规则-根据不同的错误码，响应不同的错误界面：使用<error-page>标签）</error-page></p>
<p>4、DefaultErrorViewResolver：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image237.jpg" alt="img"></p>
<p>主要解析代码：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image239.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image241.jpg" alt="img"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><pre><code>步骤：




        一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理；




        1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的；
</code></pre><p><img src="/2019/01/30/springboot个人总结/clip_image243.jpg" alt="img"></p>
<h3 id="2）、如果定制错误响应："><a href="#2）、如果定制错误响应：" class="headerlink" title="2）、如果定制错误响应："></a>2）、如果定制错误响应：</h3><h4 id="1）、如何定制错误的页面；"><a href="#1）、如何定制错误的页面；" class="headerlink" title="1）、如何定制错误的页面；"></a>1）、如何定制错误的页面；</h4><p><strong>1**</strong>）、有模板引擎的情况下**；error/状态码; 【将错误页面命名为  错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到对应的页面；</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image244.png" alt="img"></p>
<p>那么就会存在一个缺点，那就是如果我想把所有4开头的错误码都定向到一个错误界面怎么办呢？</p>
<p>我们回过头查看DefaultErrorViewResolver 源代码发现，他默认注册了两个规则4xx和5xx。</p>
<p><strong>我们可以使用**</strong>4xx<strong><strong>和</strong></strong>5xx<strong><strong>作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码</strong></strong>.html<strong>**）；</strong>        </p>
<p>页面能获取的信息（我们可以在自定义的错误界面获取到这些信息，参见DefaultErrorAttributes源码）</p>
<p>timestamp：时间戳</p>
<p>status：状态码</p>
<p>error：错误提示</p>
<p>exception：异常对象</p>
<p>message：异常消息</p>
<p>errors：JSR303数据校验的错误都在这里</p>
<p>2）、<strong>没有模板引擎</strong>（模板引擎找不到这个错误页面），静态资源文件夹（static）下找</p>
<p>3）、<strong>以上都没有错误页面</strong>，就是默认来到SpringBoot默认的错误提示页面</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image246.jpg" alt="img"></p>
<h4 id="2）、如何定制错误的json数据；"><a href="#2）、如何定制错误的json数据；" class="headerlink" title="2）、如何定制错误的json数据；"></a>2）、如何定制错误的json数据；</h4><p>1）、自定义异常处理&amp;返回定制json数据；</p>
<p>实现一个异常处理controller</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image248.jpg" alt="img"></p>
<p>只要是UserNotExistEception的异常都交由此方法处理，并返回自己自己定制json信息。</p>
<p>   缺点: 永远返回json格式信息，没有html界面（7.11.1.1）。</p>
<p>2）、转发到/error进行自适应响应效果处理</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image250.jpg" alt="img"></p>
<p>缺点：自定义的map错误数据，没有携带过去。</p>
<h4 id="3）、将我们的定制数据携带出去；"><a href="#3）、将我们的定制数据携带出去；" class="headerlink" title="3）、将我们的定制数据携带出去；"></a>3）、将我们的定制数据携带出去；</h4><p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；</p>
<p>1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中（<strong>这种方式太过麻烦不推荐</strong>）</p>
<p>2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到（<strong>推荐这种方法</strong>）</p>
<p>容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；</p>
<p>自定义ErrorAttributes</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image252.jpg" alt="img"></p>
<h1 id="八-默认嵌套的Servlet服务器"><a href="#八-默认嵌套的Servlet服务器" class="headerlink" title="八. 默认嵌套的Servlet服务器"></a>八. 默认嵌套的Servlet服务器</h1><p><img src="/2019/01/30/springboot个人总结/clip_image254.jpg" alt="img"></p>
<p>打开springboot项目的pom文件，查看依赖。</p>
<h2 id="8-1如何定制和修改Servlet容器的相关配置"><a href="#8-1如何定制和修改Servlet容器的相关配置" class="headerlink" title="8.1如何定制和修改Servlet容器的相关配置"></a>8.1如何定制和修改Servlet容器的相关配置</h2><p>1、修改和server有关的配置（ServerProperties也是EmbeddedServletContainerCustomizer的实现）-<strong>第一种方式</strong></p>
<p>就是我们直接在application.properties文件中的修改操作</p>
<p>   server.port=8081   server.context-path=/crud   server.tomcat.uri-encoding=UTF-8   </p>
<p>2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 – <strong>第二种方式</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image256.jpg" alt="img"></p>
<h2 id="8-2-替换为其他嵌入式Servlet容器"><a href="#8-2-替换为其他嵌入式Servlet容器" class="headerlink" title="8.2 替换为其他嵌入式Servlet容器"></a>8.2 替换为其他嵌入式Servlet容器</h2><p>Springboot 完美的集成了下面这三款servlet容器，只需要做一些小改动即可切换使用。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image258.jpg" alt="img"></p>
<p>具体实现的容器工厂类。</p>
<h3 id="1-默认使用tomcat"><a href="#1-默认使用tomcat" class="headerlink" title="1. 默认使用tomcat"></a>1. 默认使用tomcat</h3><p><img src="/2019/01/30/springboot个人总结/clip_image260.jpg" alt="img"></p>
<h3 id="2-Jetty"><a href="#2-Jetty" class="headerlink" title="2. Jetty"></a>2. Jetty</h3><p><img src="/2019/01/30/springboot个人总结/clip_image262.jpg" alt="img"></p>
<p>做法其实很简单，那就是一出web模块自动装配的tomcat 组件，然后引入jetty组件即可。Jetty适合在开发长连接的项目中使用（例如聊天类的项目）</p>
<h3 id="3-Undertow"><a href="#3-Undertow" class="headerlink" title="3. Undertow"></a>3. Undertow</h3><p><img src="/2019/01/30/springboot个人总结/clip_image264.jpg" alt="img"></p>
<p>Undertow不支持jsp界面</p>
<h2 id="8-3-嵌入式Servlet容器自动配置原理"><a href="#8-3-嵌入式Servlet容器自动配置原理" class="headerlink" title="8.3 嵌入式Servlet容器自动配置原理"></a>8.3 嵌入式Servlet容器自动配置原理</h2><h3 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1. 源码分析"></a>1. 源码分析</h3><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置</p>
<p>  <img src="/2019/01/30/springboot个人总结/clip_image266.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image268.jpg" alt="img"></p>
<p>可以看到容器的切换，是通过注解来进行控制。<strong>通过容器工厂进行创建相应的容器</strong></p>
<p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image270.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image272.jpg" alt="img"></p>
<p>通过 getEmbeddedServletContainer()获得相应的servlet容器。</p>
<p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image274.jpg" alt="img"></p>
<p>总的来说：通过servlet容器工厂类来创建相应的servlet容器</p>
<h3 id="2-以tomcat容器工厂为例，分析流程"><a href="#2-以tomcat容器工厂为例，分析流程" class="headerlink" title="2.以tomcat容器工厂为例，分析流程"></a>2.以tomcat容器工厂为例，分析流程</h3><p> 1.查看<strong>TomcatEmbeddedServletContainerFactory</strong></p>
<pre><code>**重点是：****getEmbeddedServletContainer****方法**
</code></pre><p><img src="/2019/01/30/springboot个人总结/clip_image276.jpg" alt="img"></p>
<h3 id="3-ServerProperties、EmbeddedServletContainerCustomizer"><a href="#3-ServerProperties、EmbeddedServletContainerCustomizer" class="headerlink" title="3. ServerProperties、EmbeddedServletContainerCustomizer"></a>3. ServerProperties、EmbeddedServletContainerCustomizer</h3><p>我们知道我们修改application.properties都是映射成ServerProperties</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image278.jpg" alt="img"></p>
<p>他实现了EmbeddedServletContainerCustomizer接口，所以衍生出了，第二种修改servlet容器的配置的方法：</p>
<pre><code>自定义实现EmbeddedServletContainerCustomizer：
</code></pre><p><img src="/2019/01/30/springboot个人总结/clip_image279.jpg" alt="img"></p>
<p>那么这些改动是怎么样生效的呢?</p>
<p>容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image281.jpg" alt="img"></p>
<p>步骤：</p>
<p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p>
<p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p>
<p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p>
<p>3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法</p>
<h2 id="8-4-嵌入式Servlet容器启动原理"><a href="#8-4-嵌入式Servlet容器启动原理" class="headerlink" title="8.4 嵌入式Servlet容器启动原理"></a>8.4 嵌入式Servlet容器启动原理</h2><p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p>
<p>获取嵌入式的Servlet容器工厂：</p>
<p>1）、SpringBoot应用启动运行run方法</p>
<p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p>
<p>3）、refresh(context);<strong>刷新刚才创建好的**</strong>ioc<strong>**容器；</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image283.jpg" alt="img"></p>
<p>4）、 onRefresh(); web的ioc容器重写了onRefresh方法</p>
<p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p>
<p><strong>6**</strong>）、获取嵌入式的<strong><strong>Servlet</strong></strong>容器工厂：**</p>
<p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p>
<p> 从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p>
<p>7）、<strong>使用容器工厂获取嵌入式的**</strong>Servlet<strong>**容器</strong>：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer());</p>
<p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p>
<p><strong>先启动嵌入式的**</strong>Servlet<strong><strong>容器，再将</strong></strong>ioc<strong>**容器中剩下没有创建出的对象获取出来；</strong></p>
<p><strong>==IOC**</strong>容器启动创建嵌入式的<strong><strong>Servlet</strong></strong>容器<strong>**==</strong></p>
<h1 id="九．-springboot注册三大组件"><a href="#九．-springboot注册三大组件" class="headerlink" title="九． springboot注册三大组件"></a>九． springboot注册三大组件</h1><p>三大组件：servlet、filter、listenner</p>
<p>传统的web项目，我们可以在webroot/WEB_INFO/web.xml 中配置我们三大组件，但是springboot打包方式采用jar的方式，内嵌servlet容器，那么我们应该在哪里注册这三大组件呢？</p>
<h2 id="9-1-注册servle"><a href="#9-1-注册servle" class="headerlink" title="9.1 注册servle"></a>9.1 注册servle</h2><p>1.首先自定义一个servler</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image285.jpg" alt="img"></p>
<p>2.通过ServletRegistrationBean注册自定义servle</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image287.jpg" alt="img"></p>
<p> 注意：<strong>如果存在一个**</strong>controller<strong><strong>同时映射了</strong></strong>/myServlet<strong> </strong>请求，那么就会失效（被自定义<strong><strong>servlet</strong></strong>所覆盖）。**</p>
<h2 id="9-2-注册filter"><a href="#9-2-注册filter" class="headerlink" title="9.2 注册filter"></a>9.2 注册filter</h2><p>1.首先自定义一个filter</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image289.jpg" alt="img"></p>
<p>2.FilterRegistrationBean</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image291.jpg" alt="img"></p>
<h2 id="9-3-注册listenner"><a href="#9-3-注册listenner" class="headerlink" title="9.3 注册listenner"></a>9.3 注册listenner</h2><p>1.首先自定义一个listenner</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image293.jpg" alt="img"></p>
<p>2.ServletListenerRegistrationBean</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image295.jpg" alt="img"></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p>
<p>DispatcherServletAutoConfiguration中：</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image297.jpg" alt="img"></p>
<h1 id="10-使用外置的Servlet容器"><a href="#10-使用外置的Servlet容器" class="headerlink" title="10 使用外置的Servlet容器"></a>10 使用外置的Servlet容器</h1><p>嵌入式Servlet容器：应用打成可执行的jar</p>
<pre><code>优点：简单、便携

缺点：默认不支持JSP、优化定制比较复杂（虽然可以使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】等方式修改配置，但是还是在需要通读代码的情况下才能够修改）
</code></pre><p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1）、必须创建一个项目打包类型为war的项目；（利用idea创建好目录结构，因为默认生成的springboot项目是没有webapp和web.xml等文件，需要手动创建）</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image299.jpg" alt="img"></p>
<p>下一步</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image301.jpg" alt="img"></p>
<p>完成</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image303.jpg" alt="img"></p>
<p><strong>很明显没有生成相应的**</strong>webapp<strong><strong>目录，同时</strong></strong>tomcat<strong><strong>的作用域修改为了运行时使用，打包不使用，这个也就是为我们使用外置</strong></strong>servlet<strong>**容器打下基础。</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image305.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image307.jpg" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image309.jpg" alt="img"></p>
<p><strong>项目最终目录结构</strong></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image311.jpg" alt="img"></p>
<p>2）、将嵌入式的Tomcat指定为provided；</p>
<p><strong>Springboot**</strong>默认已经帮我们完成**</p>
<p>3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法</p>
<pre><code>**Springboot****默认已经帮我们完成**
</code></pre><p>4）、启动服务器就可以使用</p>
<p>   可以编写一个jsp界面，访问测试</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image312.png" alt="img"></p>
<p><img src="/2019/01/30/springboot个人总结/clip_image313.png" alt="img"></p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器</p>
<p>war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器</p>
<p>实现方式：Servlet3.0是一次Java EE规范</p>
<p><a href="https://blog.csdn.net/f641385712/article/details/87474907" target="_blank" rel="external">https://blog.csdn.net/f641385712/article/details/87474907</a> 相关连接</p>
<h3 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h3><pre><code>1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例

2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名

3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类
</code></pre><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><p>1）、启动Tomcat</p>
<p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</p>
<p>Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer</p>
<p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set<class<?>&gt;；为这些WebApplicationInitializer类型的类创建实例；</class<?></p>
<p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image314.png" alt="img"></p>
<p>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p>
<p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image316.jpg" alt="img"></p>
<p>7）、Spring的应用就启动并且创建IOC容器</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image318.jpg" alt="img"></p>
<p><strong>==**</strong>启动<strong><strong>Servlet</strong></strong>容器，再启动<strong><strong>SpringBoot</strong></strong>应用<strong>**==</strong></p>
<h1 id="十一、Springboot整合其他技术"><a href="#十一、Springboot整合其他技术" class="headerlink" title="十一、Springboot整合其他技术"></a>十一、Springboot整合其他技术</h1><h2 id="11-1-整合Mybatis"><a href="#11-1-整合Mybatis" class="headerlink" title="11.1 整合Mybatis"></a>11.1 整合Mybatis</h2><h3 id="1-Idea创建一个springboot项目并选择以下依赖"><a href="#1-Idea创建一个springboot项目并选择以下依赖" class="headerlink" title="1.Idea创建一个springboot项目并选择以下依赖"></a>1.Idea创建一个springboot项目并选择以下依赖</h3><p><img src="/2019/01/30/springboot个人总结/clip_image320.jpg" alt="img"></p>
<p>点击下一步完成项目创建，查看项目的pom文件</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image322.jpg" alt="img"></p>
<h3 id="2-完善项目的目录结构（MVC结构）"><a href="#2-完善项目的目录结构（MVC结构）" class="headerlink" title="2.完善项目的目录结构（MVC结构）"></a>2.完善项目的目录结构（MVC结构）</h3><p><img src="/2019/01/30/springboot个人总结/clip_image324.jpg" alt="img"></p>
<p><strong>在资源文件夹中新建**</strong>application.yml<strong>**文件</strong></p>
<h3 id="3-在application-yml文件中书写数据库配置"><a href="#3-在application-yml文件中书写数据库配置" class="headerlink" title="3.在application.yml文件中书写数据库配置"></a>3.在application.yml文件中书写数据库配置</h3><p><img src="/2019/01/30/springboot个人总结/clip_image326.jpg" alt="img"></p>
<p>   spring:     profiles:       active: dev   mybatis:     type-aliases-package: com.kingge.entity     mapper-locations: classpath:mapper/*.xml           —   spring:     profiles: dev         datasource:       url:   jdbc:mysql://127.0.0.1:3306/test?serverTimezone=GMT       driver-class-name: com.mysql.cj.jdbc.Driver       username: root       password: 123   #com.mysql.jdbc.Driver 注意这个已经过时，推荐使用上面那个   </p>
<h3 id="4-编写entity、dao、service、serviceimpl、xml、conrtoller"><a href="#4-编写entity、dao、service、serviceimpl、xml、conrtoller" class="headerlink" title="4.编写entity、dao、service、serviceimpl、xml、conrtoller"></a>4.编写entity、dao、service、serviceimpl、xml、conrtoller</h3><p>4.1 User</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image328.jpg" alt="img"></p>
<p>4.2 dao</p>
<p>需要注意，配置文件没有配置mapper接口扫描包，因此我们需要给每一个Mapper/dao接口添加@Mapper注解，才能被识别。</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image330.jpg" alt="img"></p>
<p>4.3  service</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image332.jpg" alt="img"></p>
<p>4.4 serviceimpl</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image334.jpg" alt="img"></p>
<p>4.5 mapper.xml</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image336.jpg" alt="img"></p>
<p>4.6 controller</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image338.jpg" alt="img"></p>
<p>完整目录结构展示</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image340.jpg" alt="img"></p>
<h3 id="5-运行项目访问请求"><a href="#5-运行项目访问请求" class="headerlink" title="5.     运行项目访问请求"></a>5.     运行项目访问请求</h3><p><img src="/2019/01/30/springboot个人总结/clip_image342.jpg" alt="img"></p>
<p>访问成功！！！！！！</p>
<h3 id="6-通过junit方式测试"><a href="#6-通过junit方式测试" class="headerlink" title="6.通过junit方式测试"></a>6.通过junit方式测试</h3><p><img src="/2019/01/30/springboot个人总结/clip_image344.jpg" alt="img"></p>
<h2 id="11-2-整合Spring-Data-JPA"><a href="#11-2-整合Spring-Data-JPA" class="headerlink" title="11.2.整合Spring Data JPA"></a>11.2.整合Spring Data JPA</h2><h3 id="1-添加Spring-Data-JPA的起步依赖"><a href="#1-添加Spring-Data-JPA的起步依赖" class="headerlink" title="1 添加Spring Data JPA的起步依赖"></a>1 添加Spring Data JPA的起步依赖</h3><pre><code>&lt;!-- springBoot JPA的起步依赖 --&gt;       &lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;       &lt;/dependency&gt;   
</code></pre><h3 id="2-添加数据库驱动依赖"><a href="#2-添加数据库驱动依赖" class="headerlink" title="2 添加数据库驱动依赖"></a>2 添加数据库驱动依赖</h3><pre><code>&lt;!-- MySQL连接驱动 --&gt;

&lt;dependency&gt;

    &lt;groupId&gt;mysql&lt;/groupId&gt;

    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;

&lt;/dependency&gt;
</code></pre><h3 id="3-在application-properties中配置数据库和jpa的相关属性"><a href="#3-在application-properties中配置数据库和jpa的相关属性" class="headerlink" title="3 在application.properties中配置数据库和jpa的相关属性"></a>3 在application.properties中配置数据库和jpa的相关属性</h3><p>DB   Configuration:   spring.datasource.driverClassName=com.mysql.jdbc.Driver   spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8   spring.datasource.username=root   spring.datasource.password=root       #JPA   Configuration:   spring.jpa.database=MySQL   spring.jpa.show-sql=true   spring.jpa.generate-ddl=true   spring.jpa.hibernate.ddl-auto=update   spring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy   </p>
<h3 id="4-创建实体配置实体"><a href="#4-创建实体配置实体" class="headerlink" title="4 创建实体配置实体"></a>4 创建实体配置实体</h3><p>   @Entity   public   class User {       // 主键       @Id       @GeneratedValue(strategy =   GenerationType.IDENTITY)       private Long id;       // 用户名       private String username;       // 密码       private String password;       // 姓名       private String name;       //此处省略setter和getter方法… …   }   </p>
<h3 id="5-编写UserRepository"><a href="#5-编写UserRepository" class="headerlink" title="5 编写UserRepository"></a>5 编写UserRepository</h3><pre><code>public interface UserRepository extends JpaRepository&lt;User,Long&gt;{

    public List&lt;User&gt; findAll();

}
</code></pre><h3 id="6-编写测试类"><a href="#6-编写测试类" class="headerlink" title="6 编写测试类"></a>6 编写测试类</h3><p>   @RunWith(SpringRunner.class)   @SpringBootTest(classes=MySpringBootApplication.class)   public class JpaTest {           @Autowired       private UserRepository userRepository;       @Test       public void test(){           List<user> users =   userRepository.findAll();           System.out.println(users);       }   }   </user></p>
<h3 id="7-控制台打印信息"><a href="#7-控制台打印信息" class="headerlink" title="7 控制台打印信息"></a>7 控制台打印信息</h3><p><img src="/2019/01/30/springboot个人总结/clip_image346.jpg" alt="img"></p>
<p>注意：如果是jdk9，执行报错如下：</p>
<p>原因：jdk缺少相应的jar</p>
<p>解决方案：手动导入对应的maven坐标，如下：</p>
<pre><code>&lt;!--jdk9需要导入如下坐标--&gt;

&lt;dependency&gt;

    &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;

    &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;

    &lt;version&gt;2.3.0&lt;/version&gt;

&lt;/dependency&gt;
</code></pre><h1 id="11-3-整合redis"><a href="#11-3-整合redis" class="headerlink" title="11.3 整合redis"></a>11.3 整合redis</h1><h2 id="1-添加redis的起步依赖"><a href="#1-添加redis的起步依赖" class="headerlink" title="1 添加redis的起步依赖"></a>1 添加redis的起步依赖</h2><p>   <!-- 配置使用redis启动器 -->   <dependency>         <groupid>org.springframework.boot</groupid>         <artifactid>spring-boot-starter-data-redis</artifactid>   </dependency>   </p>
<h2 id="2-配置redis的连接信息"><a href="#2-配置redis的连接信息" class="headerlink" title="2 配置redis的连接信息"></a>2 配置redis的连接信息</h2><p>#Redis</p>
<p>spring.redis.host=127.0.0.1</p>
<p>spring.redis.port=6379</p>
<h2 id="3-注入RedisTemplate测试redis操作"><a href="#3-注入RedisTemplate测试redis操作" class="headerlink" title="3 注入RedisTemplate测试redis操作"></a>3 注入RedisTemplate测试redis操作</h2><p>   @RunWith(SpringRunner.class)   @SpringBootTest(classes = SpringbootJpaApplication.class)   public class RedisTest {           @Autowired       private UserRepository userRepository;       @Autowired       private RedisTemplate<string, string=""> redisTemplate;           @Test       public void test() throws   JsonProcessingException {             //从redis缓存中获得指定的数据           String userListData =   redisTemplate.boundValueOps(“user.findAll”).get();           //如果redis中没有数据的话           if(null==userListData){               //查询数据库获得数据               List<user> all =   userRepository.findAll();               //转换成json格式字符串               ObjectMapper om = new   ObjectMapper();               userListData =   om.writeValueAsString(all);               //将数据存储到redis中，下次在查询直接从redis中获得数据，不用在查询数据库                 redisTemplate.boundValueOps(“user.findAll”).set(userListData);                 System.out.println(“===============从数据库获得数据===============”);           }else{                 System.out.println(“===============从redis缓存中获得数据===============”);           }           System.out.println(userListData);       }   }   </user></string,></p>
<h1 id="十二、springboot运行流程回顾"><a href="#十二、springboot运行流程回顾" class="headerlink" title="十二、springboot运行流程回顾"></a>十二、springboot运行流程回顾</h1><h2 id="1-启动柜springboot程序"><a href="#1-启动柜springboot程序" class="headerlink" title="1.启动柜springboot程序"></a>1.启动柜springboot程序</h2><p><img src="/2019/01/30/springboot个人总结/clip_image348.jpg" alt="img"></p>
<p>断点进入-step into 发现</p>
<p><img src="/2019/01/30/springboot个人总结/clip_image350.jpg" alt="img"></p>
<p>停在了这里，也就是说他会首先创建SpringApplication对象</p>
<h2 id="2-创建SpringApplication对象"><a href="#2-创建SpringApplication对象" class="headerlink" title="2. 创建SpringApplication对象"></a>2. 创建SpringApplication对象</h2><p>创建SpringApplication对象运行run方法</p>
<p>继续进入方法</p>
</html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一．前言&quot;&gt;&lt;a href=&quot;#一．前言&quot; class=&quot;headerlink&quot; title=&quot;一．前言&quot;&gt;&lt;/a&gt;一．前言&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是微服务？&quot;&gt;&lt;a href=&quot;#1-1-什么是微服务？&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="SpringBoot" scheme="http://kingge.top/categories/SpringBoot/"/>
    
    
      <category term="分布式" scheme="http://kingge.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="springboot" scheme="http://kingge.top/tags/springboot/"/>
    
      <category term="微服务" scheme="http://kingge.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>dubbo分布式服务框架</title>
    <link href="http://kingge.top/2019/01/05/dubbo%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"/>
    <id>http://kingge.top/2019/01/05/dubbo分布式服务框架/</id>
    <published>2019-01-05T02:21:59.000Z</published>
    <updated>2019-08-25T02:24:55.615Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo分布式服务框架**</p>
<h1 id="一、分布式概念"><a href="#一、分布式概念" class="headerlink" title="一、分布式概念"></a>一、分布式概念</h1><p>分布式的概念：某个业务逻辑的完成，拆分成几个功能/服务来实现，这些服务部署在不同的机器上。</p>
<blockquote>
<p>官方解释：</p>
<p>分布式系统是由一组<strong>通过网络</strong>进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。</p>
<p>　　首先需要明确的是，<strong>只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统</strong>。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。</p>
</blockquote>
<p>​    随着互联网的发展，网站应用的规模不断扩大，常规的<strong>垂直应用架构</strong>已无法应对，分布式服务架构以及流动计算架构势在必行，需一个治理系统确保架构有条不紊的演进。</p>
<h2 id="1-1分布式的演化"><a href="#1-1分布式的演化" class="headerlink" title="1.1分布式的演化"></a>1.1分布式的演化</h2><p><img src="/2019/01/05/dubbo分布式服务框架/1566286104187.png" alt="1566286104187"></p>
<h3 id="1-1-1单一应用架构"><a href="#1-1-1单一应用架构" class="headerlink" title="1.1.1单一应用架构"></a>1.1.1单一应用架构</h3><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起(例如)，以减少部署节点和成本。</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566287100179.png" alt="1566287100179"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566287125516.png" alt="1566287125516"></p>
<p><strong>总的来说，一个项目就打包成一个war包，然后订单业务处理、商品等等所有业务都在这个war包里。</strong></p>
<p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<p>1、性能扩展比较难</p>
<p>2、存在重复性开发的代码</p>
<p>3、不利于升级维护</p>
<p>4、 只能采用同一种技术，很难用不同的语言或者语言不同版本开发不同模块；</p>
<p>5、系统耦合性强，一旦其中一个模块有问题，整个系统就瘫痪了；一旦升级其中一个模块，整个系统就停机了；</p>
<p>6、 集群只能是复制整个系统，即使只是其中一个模块压力大。（可能整个订单处理，仅仅是支付模块压力过大， 按道理只需要升级支付模块，但是在单一场景里面是不能的）</p>
<p>最直观问题就是，</p>
<blockquote>
<p>1.代码不够整洁，多个业务的功能都堆在一个包中，例如UserService、OrderService等等功能都放在com.kingge.service包中。当功能增多时，这个包会变得更加臃肿，代码阅读性很差。</p>
<p>2.服务之间依赖错综复杂不够清晰。</p>
<p>3.只能够通过部署集群来提高系统性能，资源浪费</p>
</blockquote>
<h3 id="1-1-2垂直应用架构"><a href="#1-1-2垂直应用架构" class="headerlink" title="1.1.2垂直应用架构"></a>1.1.2垂直应用架构</h3><p>​    当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用<strong>拆成互不相干</strong>的几个应用，以提升效率，<strong>这样就可以单独修改某个模块而不用重启或者影响其他模块，同时也可以给某个访问量剧增的模块，单独添加服务器</strong>。</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566287183867.png" alt="1566287183867"></p>
<p>​    通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p>
<p>缺点： 公用模块无法重复利用，开发性的浪费</p>
<p>面对突变的应用场景，可能某个模块对于web界面会频繁修改，但是模块业务功能没有变化，这样会造成单个应用频繁修改。所以需要<strong>界面+业务逻辑的实现分离。</strong></p>
<p>没有处理好应用之间的交互问题，例如订单模块可能会需要查询商品模块的信息。</p>
<h3 id="1-1-3分布式服务架构"><a href="#1-1-3分布式服务架构" class="headerlink" title="1.1.3分布式服务架构"></a>1.1.3分布式服务架构</h3><p>​    当垂直应用越来越多，<strong>应用之间交互不可避免</strong>，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架(RPC)</strong>是关键（例如Dubbo）。（<strong>springcloud比他更全面，Dubbo只是相当于Spring Cloud中的Eureka模块</strong>）</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566289053579.png" alt="1566289053579"></p>
<p><strong>分布式服务框架很好的解决了垂直应用架构的缺点，实现界面和服务的分离，实现界面和服务，以及服务与服务之间的调度。</strong></p>
<p><strong>但是存在一个问题，那就是没有</strong>一个基于访问压力的调度中心和服务注册中心，容易造成资源浪费，什么意思呢？假设用户服务部署了200台服务器，但是在某个时间段，他的访问压力很小，订单服务的访问压力剧增，服务器不够用。那么就会造成资源浪费和倾斜，存在服务器闲置或者请求量少的情况。</p>
<h3 id="1-1-4流动计算架构"><a href="#1-1-4流动计算架构" class="headerlink" title="1.1.4流动计算架构"></a>1.1.4流动计算架构</h3><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键</strong>。</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566289240354.png" alt="1566289240354"></p>
<p>很好的解决了分布式架构的缺点。</p>
<p>SOA解决了服务的管理和注册，但是还是缺少服务容灾处理，网关处理以及全局配置模块等等（分别对应springcloud的hystrix、zuul、config）</p>
<h3 id="1-1-5-微服务架构"><a href="#1-1-5-微服务架构" class="headerlink" title="1.1.5 微服务架构"></a>1.1.5 微服务架构</h3><p>其实SOA架构跟微服务架构是很接近的，其实我也不是那么清晰的能够分别这种两种架构，所以这一章节暂缺。</p>
<p>但是他提供了比SOA架构更加细致化的服务拆分和管理，一般常用restful的方式进行数据的传输，SOA架构的传输技术是比较复杂多样的。</p>
<p>他的实现，见springcloud架构</p>
<h2 id="1-2-RPC"><a href="#1-2-RPC" class="headerlink" title="1.2 RPC"></a>1.2 RPC</h2><h3 id="1-2-1什么叫RPC"><a href="#1-2-1什么叫RPC" class="headerlink" title="1.2.1什么叫RPC"></a>1.2.1什么叫RPC</h3><p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<h3 id="1-2-2RPC基本原理"><a href="#1-2-2RPC基本原理" class="headerlink" title="1.2.2RPC基本原理"></a>1.2.2RPC基本原理</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566289474934.png" alt="1566289474934"></p>
<p>​    模型中多了一个stub的组件，这个是约定的接口，也就是server提供的服务。注意这里的”接口”，不是指JAVA中的interface，因为RPC是跨平台跨语言的，用JAVA写的客户端，应该能够调用用C语言提供的过程</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566289516712.png" alt="1566289516712"></p>
<p>一次完整的RPC调用流程（同步调用，异步另说）如下：<br>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。</p>
<p><strong>RPC两个核心模块：通讯，序列化。</strong></p>
<p>也就是说决定RPC连接效率的核心因素了，服务之间通讯的速度，以及消息序列化和反序列化的速度（<strong>这个就是为什么hadoop会采用自己的反序列化机制而不是java的反序列化，Java的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带很多额外的信息（各种校验信息，header，继承体系等），不便于在网络中高效传输。所以，hadoop自己开发了一套序列化机制（Writable），精简、高效</strong>）</p>
<p>常用的RPC框架：dubbo，gRPC，thrift。HSF</p>
<h1 id="二、Dubbo概念和理解"><a href="#二、Dubbo概念和理解" class="headerlink" title="二、Dubbo概念和理解"></a>二、Dubbo概念和理解</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><p>官网：</p>
<p><a href="http://dubbo.apache.org/" target="_blank" rel="external">[http://dubbo.apache.org/]{}</a></p>
<p>Apache Dubbo 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：<strong>面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</strong>。<strong>即是：提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案</strong></p>
<p>Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，后来Dubbo 进入 Apache 孵化器。</p>
<p>Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 <a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html" target="_blank" rel="external">Spring 的 Schema 扩展</a> 进行加载。</p>
<p>如果不想使用 Spring 配置，可以通过 <a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/api.html" target="_blank" rel="external">API 的方式</a> 进行调用。</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290381952.png" alt="1566290381952"></p>
<p>官方文档</p>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="external">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a></p>
<h2 id="2-2-dubbo结构"><a href="#2-2-dubbo结构" class="headerlink" title="2.2 dubbo结构"></a>2.2 dubbo结构</h2><p><img src="/2019/01/05/dubbo分布式服务框架/1566290406638.png" alt="1566290406638"></p>
<p><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者（Consumer）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>
<p><strong>监控中心（Monitor）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>
<blockquote>
<p>调用关系说明</p>
</blockquote>
<ul>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回<strong>服务提供者地址列表</strong>给消费者，<strong>如果有变更，注册中心将基于长连接推送变更数据给消费者</strong>。</li>
<li>服务消费者，从提供者地址列表中，基于<strong>软负载均衡算法（不是硬件级别的负载均衡）</strong>，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ul>
<h2 id="2-3-dubbo架构"><a href="#2-3-dubbo架构" class="headerlink" title="2.3 dubbo架构"></a>2.3 dubbo架构</h2><p>Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。</p>
<blockquote>
<p>连通性</p>
</blockquote>
<ul>
<li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li>
<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li>
<li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li>
<li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li>
<li><strong>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</strong></li>
<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li>
</ul>
<blockquote>
<p>健壮性</p>
</blockquote>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<blockquote>
<p>伸缩性</p>
</blockquote>
<ul>
<li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li>
<li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li>
</ul>
<blockquote>
<p>升级性</p>
</blockquote>
<p>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/C1566315977504.png" alt="1566315977504"></p>
<blockquote>
<p>节点角色说明</p>
</blockquote>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Deployer</code></td>
<td>自动部署服务的本地代理</td>
</tr>
<tr>
<td><code>Repository</code></td>
<td>仓库用于存储服务应用发布包</td>
</tr>
<tr>
<td><code>Scheduler</code></td>
<td>调度中心基于访问压力自动增减服务提供者</td>
</tr>
<tr>
<td><code>Admin</code></td>
<td>统一管理控制台</td>
</tr>
<tr>
<td><code>Registry</code></td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td><code>Monitor</code></td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
</tbody>
</table>
<h1 id="三、Dubbo环境搭建"><a href="#三、Dubbo环境搭建" class="headerlink" title="三、Dubbo环境搭建"></a>三、Dubbo环境搭建</h1><h2 id="3-1-windows下搭建dubbo环境"><a href="#3-1-windows下搭建dubbo环境" class="headerlink" title="3.1 windows下搭建dubbo环境"></a>3.1 windows下搭建dubbo环境</h2><h3 id="3-1-1-安装zookeeper"><a href="#3-1-1-安装zookeeper" class="headerlink" title="3.1.1 安装zookeeper"></a>3.1.1 安装zookeeper</h3><p>Dubbo推荐使用zookeeper作为注册中心</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290541231.png" alt="1566290541231"></p>
<h4 id="1-登录zookeeper官网下载zookeeper"><a href="#1-登录zookeeper官网下载zookeeper" class="headerlink" title="1.登录zookeeper官网下载zookeeper"></a>1.登录zookeeper官网下载zookeeper</h4><p><a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/" target="_blank" rel="external">[https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/]{.underline}</a></p>
<p>这里以zookeeper-3.4.13为例</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290557194.png" alt="1566290557194"></p>
<h4 id="2-下载后解压修改zoo-cfg配置文件"><a href="#2-下载后解压修改zoo-cfg配置文件" class="headerlink" title="2.下载后解压修改zoo.cfg配置文件"></a>2.下载后解压修改zoo.cfg配置文件</h4><p>将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。</p>
<p>注意几个重要位置：</p>
<p>dataDir=./ 临时数据存储的目录（可写相对路径）</p>
<p>clientPort=2181 zookeeper的端口号</p>
<p>修改完成后启动zookeeper</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290595424.png" alt="1566290595424"></p>
<p>在zookeeeper目录下新建zooData目录保存数据</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290609336.png" alt="1566290609336"></p>
<h4 id="3-运行zkServer-cmd"><a href="#3-运行zkServer-cmd" class="headerlink" title="3. 运行zkServer.cmd"></a>3. 运行zkServer.cmd</h4><p>启动成功后，使用zkCli.cmd测试</p>
<p>ls /：列出zookeeper根目录下保存的所有节点</p>
<p>create  -e /kingge 123：创建一个临时的kingge节点，值为123 </p>
<p>get / kingge：获取/ kingge节点的值</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/5C1566316581085.png" alt="1566316581085"></p>
<h3 id="3-1-2安装dubbo-admin管理控制台"><a href="#3-1-2安装dubbo-admin管理控制台" class="headerlink" title="3.1.2安装dubbo-admin管理控制台"></a>3.1.2安装dubbo-admin管理控制台</h3><p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p>
<h5 id="1、下载dubbo-admin"><a href="#1、下载dubbo-admin" class="headerlink" title="1、下载dubbo-admin"></a>1、下载dubbo-admin</h5><p><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="external">[https://github.com/apache/incubator-dubbo-ops]{.underline}</a></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290668291.png" alt="1566290668291"></p>
<p>下载下来后解压</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290676682.png" alt="1566290676682"></p>
<h5 id="2、进入目录，修改dubbo-admin配置"><a href="#2、进入目录，修改dubbo-admin配置" class="headerlink" title="2、进入目录，修改dubbo-admin配置"></a>2、进入目录，修改dubbo-admin配置</h5><p>修改 src\main\resources\application.properties 指定zookeeper地址</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290697445.png" alt="1566290697445"></p>
<h5 id="3、打包dubbo-admin（maven环境已经配置好）"><a href="#3、打包dubbo-admin（maven环境已经配置好）" class="headerlink" title="3、打包dubbo-admin（maven环境已经配置好）"></a>3、打包dubbo-admin（maven环境已经配置好）</h5><p>mvn clean package -Dmaven.test.skip=true</p>
<h5 id="4、运行dubbo-admin"><a href="#4、运行dubbo-admin" class="headerlink" title="4、运行dubbo-admin"></a>4、运行dubbo-admin</h5><p>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar （springboot方式启动项目）</p>
<p><strong>注意：【有可能控制台看着启动了，但是网页打不开，需要在控制台按下ctrl+c即可】</strong></p>
<p>默认使用root/root 登陆</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290717831.png" alt="1566290717831"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290725111.png" alt="1566290725111"></p>
<h2 id="3-2-linux下搭建dubbo环境"><a href="#3-2-linux下搭建dubbo环境" class="headerlink" title="3.2 linux下搭建dubbo环境"></a>3.2 linux下搭建dubbo环境</h2><h3 id="3-2-1安装zookeeper"><a href="#3-2-1安装zookeeper" class="headerlink" title="3.2.1安装zookeeper"></a>3.2.1安装zookeeper</h3><h4 id="1、安装jdk"><a href="#1、安装jdk" class="headerlink" title="1、安装jdk"></a>1、安装jdk</h4><h5 id="1、下载jdk"><a href="#1、下载jdk" class="headerlink" title="1、下载jdk"></a>1、下载jdk</h5><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">[http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html]{.underline}</a></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290751589.png" alt="1566290751589"></p>
<p>不要使用wget命令获取jdk链接，这是默认不同意，导致下载来的jdk压缩内容错误</p>
<h5 id="2、上传到服务器并解压"><a href="#2、上传到服务器并解压" class="headerlink" title="2、上传到服务器并解压"></a>2、上传到服务器并解压</h5><p><img src="/2019/01/05/dubbo分布式服务框架/1566290768923.png" alt="1566290768923"></p>
<h5 id="3、设置环境变量"><a href="#3、设置环境变量" class="headerlink" title="3、设置环境变量"></a>3、设置环境变量</h5><p>/usr/local/java/jdk1.8.0_171</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290797058.png" alt="1566290797058"></p>
<p>文件末尾加入下面配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_171</div><div class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</div><div class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</div><div class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</div></pre></td></tr></table></figure>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290830224.png" alt="1566290830224"></p>
<h5 id="4、使环境变量生效-amp-测试JDK"><a href="#4、使环境变量生效-amp-测试JDK" class="headerlink" title="4、使环境变量生效&amp;测试JDK"></a>4、使环境变量生效&amp;测试JDK</h5><p><img src="/2019/01/05/dubbo分布式服务框架/1566290857129.png" alt="1566290857129"></p>
<h4 id="2、安装zookeeper"><a href="#2、安装zookeeper" class="headerlink" title="2、安装zookeeper"></a>2、安装zookeeper</h4><h5 id="1、下载zookeeper"><a href="#1、下载zookeeper" class="headerlink" title="1、下载zookeeper"></a>1、下载zookeeper</h5><p>网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/" target="_blank" rel="external">[https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/]{.underline}</a></p>
<p>wget <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz" target="_blank" rel="external">[https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz]{.underline}</a></p>
<h5 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h5><p><img src="/2019/01/05/dubbo分布式服务框架/1566290893977.png" alt="1566290893977"></p>
<h5 id="3、移动到指定位置并改名为zookeeper"><a href="#3、移动到指定位置并改名为zookeeper" class="headerlink" title="3、移动到指定位置并改名为zookeeper"></a>3、移动到指定位置并改名为zookeeper</h5><p><img src="/2019/01/05/dubbo分布式服务框架/1566290917596.png" alt="1566290917596"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290924377.png" alt="1566290924377"></p>
<h4 id="3、开机启动zookeeper（可选）"><a href="#3、开机启动zookeeper（可选）" class="headerlink" title="3、开机启动zookeeper（可选）"></a>3、开机启动zookeeper（可选）</h4><p>1）-复制如下脚本</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290945358.png" alt="1566290945358"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">#chkconfig:2345 20 90</div><div class="line">#description:zookeeper</div><div class="line">#processname:zookeeper</div><div class="line">ZK_PATH=/usr/local/zookeeper</div><div class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_171</div><div class="line">case $1 in</div><div class="line">         start) sh  $ZK_PATH/bin/zkServer.sh start;;</div><div class="line">         stop)  sh  $ZK_PATH/bin/zkServer.sh stop;;</div><div class="line">         status) sh  $ZK_PATH/bin/zkServer.sh status;;</div><div class="line">         restart) sh $ZK_PATH/bin/zkServer.sh restart;;</div><div class="line">         *)  echo &quot;require start|stop|status|restart&quot;  ;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>2）-把脚本注册为Service</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290980024.png" alt="1566290980024"></p>
<p>3）-增加权限</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566290989654.png" alt="1566290989654"></p>
<h4 id="4、配置zookeeper"><a href="#4、配置zookeeper" class="headerlink" title="4、配置zookeeper"></a>4、配置zookeeper</h4><h5 id="1、初始化zookeeper配置文件"><a href="#1、初始化zookeeper配置文件" class="headerlink" title="1、初始化zookeeper配置文件"></a>1、初始化zookeeper配置文件</h5><p>拷贝/usr/local/zookeeper/conf/zoo_sample.cfg</p>
<p>到同一个目录下改个名字叫zoo.cfg</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291008251.png" alt="1566291008251"></p>
<h5 id="2、启动zookeeper"><a href="#2、启动zookeeper" class="headerlink" title="2、启动zookeeper"></a>2、启动zookeeper</h5><p><img src="/2019/01/05/dubbo分布式服务框架/1566291018179.png" alt="1566291018179"></p>
<h3 id="3-2-2安装dubbo-admin管理控制台"><a href="#3-2-2安装dubbo-admin管理控制台" class="headerlink" title="3.2.2安装dubbo-admin管理控制台"></a>3.2.2安装dubbo-admin管理控制台</h3><h4 id="1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）"><a href="#1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）" class="headerlink" title="1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）"></a>1、安装Tomcat8（旧版dubbo-admin是war，新版是jar不需要安装Tomcat）</h4><h5 id="1、下载Tomcat8并解压"><a href="#1、下载Tomcat8并解压" class="headerlink" title="1、下载Tomcat8并解压"></a>1、下载Tomcat8并解压</h5><p><a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="external">[https://tomcat.apache.org/download-80.cgi]{.underline}</a></p>
<p>wget<a href="http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz" target="_blank" rel="external">[http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz]{.underline}</a></p>
<p>提供两种访问方式</p>
<h5 id="2、解压移动到指定位置"><a href="#2、解压移动到指定位置" class="headerlink" title="2、解压移动到指定位置"></a>2、解压移动到指定位置</h5><p><img src="/2019/01/05/dubbo分布式服务框架/1566291034045.png" alt="1566291034045"></p>
<h5 id="3、开机启动tomcat8"><a href="#3、开机启动tomcat8" class="headerlink" title="3、开机启动tomcat8"></a>3、开机启动tomcat8</h5><p><img src="/2019/01/05/dubbo分布式服务框架/1566291058211.png" alt="1566291058211"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">复制如下脚本</div><div class="line">#!/bin/bash</div><div class="line">#chkconfig:2345 21 90</div><div class="line">#description:apache-tomcat-8</div><div class="line">#processname:apache-tomcat-8</div><div class="line">CATALANA_HOME=/opt/apache-tomcat-8.5.32</div><div class="line">export JAVA_HOME=/opt/java/jdk1.8.0_171</div><div class="line">case $1 in</div><div class="line">start)</div><div class="line">    echo &quot;Starting Tomcat...&quot;  </div><div class="line">    $CATALANA_HOME/bin/startup.sh</div><div class="line">    ;;</div><div class="line"></div><div class="line">stop)</div><div class="line">    echo &quot;Stopping Tomcat...&quot;  </div><div class="line">    $CATALANA_HOME/bin/shutdown.sh</div><div class="line">    ;;</div><div class="line"></div><div class="line">restart)</div><div class="line">    echo &quot;Stopping Tomcat...&quot;  </div><div class="line">    $CATALANA_HOME/bin/shutdown.sh</div><div class="line">    sleep 2</div><div class="line">    echo  </div><div class="line">    echo &quot;Starting Tomcat...&quot;  </div><div class="line">    $CATALANA_HOME/bin/startup.sh</div><div class="line">    ;;</div><div class="line">*)</div><div class="line">    echo &quot;Usage: tomcat &#123;start|stop|restart&#125;&quot;  </div><div class="line">    ;; esac</div></pre></td></tr></table></figure>
<h5 id="4、注册服务-amp-添加权限"><a href="#4、注册服务-amp-添加权限" class="headerlink" title="4、注册服务&amp;添加权限"></a>4、注册服务&amp;添加权限</h5><p><img src="/2019/01/05/dubbo分布式服务框架/1566291080594.png" alt="1566291080594"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291085955.png" alt="1566291085955"></p>
<h5 id="5、启动服务-amp-访问tomcat测试"><a href="#5、启动服务-amp-访问tomcat测试" class="headerlink" title="5、启动服务&amp;访问tomcat测试"></a>5、启动服务&amp;访问tomcat测试</h5><p><img src="/2019/01/05/dubbo分布式服务框架/1566291099386.png" alt="1566291099386"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291105871.png" alt="1566291105871"></p>
<h4 id="2、安装dubbo-admin"><a href="#2、安装dubbo-admin" class="headerlink" title="2、安装dubbo-admin"></a>2、安装dubbo-admin</h4><p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p>
<h5 id="1、下载dubbo-admin-1"><a href="#1、下载dubbo-admin-1" class="headerlink" title="1、下载dubbo-admin"></a>1、下载dubbo-admin</h5><p><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="external">[https://github.com/apache/incubator-dubbo-ops]{.underline}</a></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/Users\Administrator\AppData\Roaming\Typora\typora-user-images\1566291121104.png" alt="1566291121104"></p>
<h5 id="2、进入目录，修改dubbo-admin配置-1"><a href="#2、进入目录，修改dubbo-admin配置-1" class="headerlink" title="2、进入目录，修改dubbo-admin配置"></a>2、进入目录，修改dubbo-admin配置</h5><p>修改 src\main\resources\application.properties 指定zookeeper地址</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291151295.png" alt="1566291151295"></p>
<h5 id="3、打包dubbo-admin"><a href="#3、打包dubbo-admin" class="headerlink" title="3、打包dubbo-admin"></a>3、打包dubbo-admin</h5><p>mvn clean package -Dmaven.test.skip=true</p>
<h5 id="4、运行dubbo-admin-1"><a href="#4、运行dubbo-admin-1" class="headerlink" title="4、运行dubbo-admin"></a>4、运行dubbo-admin</h5><p>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</p>
<p>默认使用root/root 登陆</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291170915.png" alt="1566291170915"></p>
<h2 id="3-3-测试dubbo（dubbo-hello）"><a href="#3-3-测试dubbo（dubbo-hello）" class="headerlink" title="3.3 测试dubbo（dubbo-hello）"></a>3.3 测试dubbo（dubbo-hello）</h2><p><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="external">[http://dubbo.apache.org/zh-cn/docs/user/quick-start.html]{.underline}</a> 官方例子</p>
<h3 id="4-1）、提出需求"><a href="#4-1）、提出需求" class="headerlink" title="4.1）、提出需求"></a>4.1）、提出需求</h3><p>某个电商系统，订单服务需要调用用户服务获取某个用户的所有地址；</p>
<p>我们现在 需要创建两个服务模块进行测试</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>订单服务web模块</td>
<td>创建订单等</td>
</tr>
<tr>
<td>用户服务service模块</td>
<td>查询用户地址等</td>
</tr>
</tbody>
</table>
<p>测试预期结果：</p>
<p>订单服务web模块在A服务器，用户服务模块在B服务器，A可以远程调用B的功能。</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291213865.png" alt="1566291213865"></p>
<h3 id="4-2）、工程架构"><a href="#4-2）、工程架构" class="headerlink" title="4.2）、工程架构"></a>4.2）、工程架构</h3><p>根据 dubbo《服务化最佳实践》</p>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/best-practice.html" target="_blank" rel="external">http://dubbo.apache.org/zh-cn/docs/user/best-practice.html</a></p>
<h4 id="1、分包（就是抽取公共的接口或者实体类到一个工程）"><a href="#1、分包（就是抽取公共的接口或者实体类到一个工程）" class="headerlink" title="1、分包（就是抽取公共的接口或者实体类到一个工程）"></a>1、分包（就是抽取公共的接口或者实体类到一个工程）</h4><p>​    建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：重用发布等价原则(REP)，共同重用原则(CRP)。</p>
<p>​    如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：com/alibaba/china/xxx/dubbo-reference.xml。</p>
<p>​    <strong>就是为了避免重复书写某些代码，抽取公共部分代码形成一个模块（例如下面的common-interface），其他模块需要用到时，添加依赖即可（pom文件）</strong></p>
<h4 id="2、粒度"><a href="#2、粒度" class="headerlink" title="2、粒度"></a>2、粒度</h4><p>​    服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291645433.png" alt="1566291645433"></p>
<h3 id="4-3）、创建模块"><a href="#4-3）、创建模块" class="headerlink" title="4.3）、创建模块"></a>4.3）、创建模块</h3><h4 id="1、common-interface：公共接口层（model，service，exception…）（符合分包理念）"><a href="#1、common-interface：公共接口层（model，service，exception…）（符合分包理念）" class="headerlink" title="1、common-interface：公共接口层（model，service，exception…）（符合分包理念）"></a>1、common-interface：公共接口层（model，service，exception…）（符合分包理念）</h4><p>作用：定义公共接口，也可以导入公共依赖，保存服务提供者和服务消费者的接口</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291490450.png" alt="1566291490450"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291499745.png" alt="1566291499745"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291506690.png" alt="1566291506690"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291515781.png" alt="1566291515781"></p>
<p>好处就是，可以让服务生产者和消费者同时依赖这个公共接口层maven项目，避免书写重复代码。</p>
<h4 id="2、user-module：用户模块（对用户接口的实现，服务提供者）"><a href="#2、user-module：用户模块（对用户接口的实现，服务提供者）" class="headerlink" title="2、user-module：用户模块（对用户接口的实现，服务提供者）"></a>2、user-module：用户模块（对用户接口的实现，服务提供者）</h4><ol>
<li>pom.xml (引用公共接口层)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">	  &lt;groupId&gt;com.kingge.common&lt;/groupId&gt;</div><div class="line">	  &lt;artifactId&gt;common-interface&lt;/artifactId&gt;</div><div class="line">	  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;	</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ol>
<li>用户接口实现</li>
</ol>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291685692.png" alt="1566291685692"></p>
<p><strong>这里为了快速演示，就做了一些虚拟数据，不会去连接数据库。</strong></p>
<p>到时候订单模块只需要调用即可</p>
<h4 id="4、order-module：订单模块（调用用户模块）"><a href="#4、order-module：订单模块（调用用户模块）" class="headerlink" title="4、order-module：订单模块（调用用户模块）"></a>4、order-module：订单模块（调用用户模块）</h4><p>1. pom.xml (引用公共接口层)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">	  &lt;groupId&gt;com.kingge.common&lt;/groupId&gt;</div><div class="line">	  &lt;artifactId&gt;common-interface&lt;/artifactId&gt;</div><div class="line">	  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;	</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>2. 订单接口实现</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291757761.png" alt="1566291757761"></p>
<p><strong>现在这样是无法进行调用的。我们order-module引入了common-interface，但是common-interface公用模块里的用户接口的具体实现在user-module，我们并没有引入user-module模块，所以上诉代码调用肯定是失败的。而且user-module模块可能还在别的服务器中（不在同一个进程中）</strong>。</p>
<p>​    <strong>所以我们需要把user-module模块的用户接口的实现类暴露出去，供order-module模块使用。</strong></p>
<p>接下来使用dubbo来实现这样的功能。</p>
<h3 id="4-4）、使用dubbo改造"><a href="#4-4）、使用dubbo改造" class="headerlink" title="4.4）、使用dubbo改造"></a>4.4）、使用dubbo改造</h3><h4 id="1、改造user-module作为服务提供者"><a href="#1、改造user-module作为服务提供者" class="headerlink" title="1、改造user-module作为服务提供者"></a>1、改造user-module作为服务提供者</h4><p>（1）引入dubbo （pom.xml引入依赖）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">	&lt;!-- 引入dubbo --&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;dubbo&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;2.6.2&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</div><div class="line">dubbo 2.6以前的版本引入zkclient操作zookeeper </div><div class="line">dubbo 2.6及以后的版本引入curator操作zookeeper</div><div class="line">下面两个zk客户端根据dubbo版本2选1即可</div><div class="line">--&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.101tec&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;zkclient&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;0.10&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;!-- curator-framework --&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;2.12.0&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>（2）配置提供者（新建provider.xml文件）</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291871894.png" alt="1566291871894"></p>
<blockquote>
<p>内容如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</div><div class="line">	&lt;dubbo:application name=&quot;user-module&quot;&gt;&lt;/dubbo:application&gt;</div><div class="line">&lt;!-- 2、指定注册中心的位置 --&gt;</div><div class="line">&lt;!-- &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;  这种方式也可以 --&gt;</div><div class="line">	&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;    &lt;!--使用dubbo协议，将服务暴露在20880端口 consumer和provider连接的协议，协议由提供方指定，消费方被动接受 --&gt;</div><div class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</div><div class="line">&lt;!-- 指定需要暴露的服务 --&gt;</div><div class="line"></div><div class="line">&lt;dubbo:service interface=&quot;com.kingge.common.service.UserService&quot; ref=&quot;userServiceImpl&quot; &gt;&lt;/dubbo:service&gt;</div><div class="line"></div><div class="line">	&lt;!-- 服务的实现 --&gt;</div><div class="line">&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.kingge.user.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566291960341.png" alt="1566291960341"></p>
<p>dubbo支持多种传输协议</p>
<p>（3）启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">public class MainApplication &#123;</div><div class="line">	public static void main(String[] args) throws IOException &#123;</div><div class="line">		ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);</div><div class="line">		ioc.start();</div><div class="line">		System.in.read();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后，打开我们之前配置的dubbo-admin</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292031775.png" alt="1566292031775"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292041006.png" alt="1566292041006"></p>
<h4 id="2、改造order-module作为服务消费者"><a href="#2、改造order-module作为服务消费者" class="headerlink" title="2、改造order-module作为服务消费者"></a>2、改造order-module作为服务消费者</h4><p>（1）引入dubbo （pom.xml引入依赖）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">	&lt;!-- 引入dubbo --&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;dubbo&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;2.6.2&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;!-- 由于我们使用zookeeper作为注册中心，所以需要操作zookeeper</div><div class="line">dubbo 2.6以前的版本引入zkclient操作zookeeper </div><div class="line">dubbo 2.6及以后的版本引入curator操作zookeeper</div><div class="line">下面两个zk客户端根据dubbo版本2选1即可</div><div class="line">--&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.101tec&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;zkclient&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;0.10&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;!-- curator-framework --&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;2.12.0&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>（2）配置消费者信息</p>
<p>新建consumer.xml文件</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292086774.png" alt="1566292086774"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!—配置包扫描 --&gt;</div><div class="line">&lt;context:component-scan base-package=&quot;com.kingge.order.service.impl&quot;&gt;&lt;/context:component-scan&gt;</div><div class="line">&lt;!-- 应用名 --&gt;</div><div class="line">	&lt;dubbo:application name=&quot;order-module&quot;&gt;&lt;/dubbo:application&gt;</div><div class="line">&lt;!-- 指定注册中心地址 --&gt;</div><div class="line">	&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&gt;</div><div class="line">&lt;!-- 生成远程服务代理，可以和本地bean一样使用userService --&gt;</div><div class="line">&lt;dubbo:reference interface=&quot;com.kingge.common.service.UserService&quot; id=&quot;userService&quot; &gt;&lt;/dubbo:reference&gt;</div></pre></td></tr></table></figure>
<p>（3）修改OrderServiceImpl</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292128737.png" alt="1566292128737"></p>
<p>（4）创建启动类，启动consumer</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292167651.png" alt="1566292167651"></p>
<h4 id="3、测试调用"><a href="#3、测试调用" class="headerlink" title="3、测试调用"></a>3、测试调用</h4><p>调用成功</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292239959.png" alt="1566292239959"></p>
<p>查看dubbo admin</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292253424.png" alt="1566292253424"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292258292.png" alt="1566292258292"></p>
<h2 id="3-4-配置dubbo监控中心"><a href="#3-4-配置dubbo监控中心" class="headerlink" title="3.4 配置dubbo监控中心"></a>3.4 配置dubbo监控中心</h2><h3 id="3-4-1-dubbo-admin"><a href="#3-4-1-dubbo-admin" class="headerlink" title="3.4.1 dubbo-admin"></a>3.4.1 dubbo-admin</h3><p>图形化的服务管理页面；安装时需要指定注册中心地址，即可从注册中心中获取到所有的提供者/消费者进行配置管理</p>
<p>安装和使用方式在上面我们已经说过了，这里就不在阐述。</p>
<h3 id="3-4-2-dubbo-monitor-simple"><a href="#3-4-2-dubbo-monitor-simple" class="headerlink" title="3.4.2 dubbo-monitor-simple"></a>3.4.2 dubbo-monitor-simple</h3><p>简单的监控中心；</p>
<h4 id="1、下载-dubbo-ops"><a href="#1、下载-dubbo-ops" class="headerlink" title="1、下载 dubbo-ops"></a>1、下载 dubbo-ops</h4><p><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="external">https://github.com/apache/incubator-dubbo-ops</a></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292295799.png" alt="1566292295799"></p>
<h4 id="2、修改配置指定注册中心地址"><a href="#2、修改配置指定注册中心地址" class="headerlink" title="2、修改配置指定注册中心地址"></a>2、修改配置指定注册中心地址</h4><p>进入 dubbo-monitor-simple\src\main\resources\conf</p>
<p>修改 dubbo.properties文件</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292309213.png" alt="1566292309213"></p>
<h4 id="3、打包dubbo-monitor-simple"><a href="#3、打包dubbo-monitor-simple" class="headerlink" title="3、打包dubbo-monitor-simple"></a>3、打包dubbo-monitor-simple</h4><p>mvn clean package -Dmaven.test.skip=true</p>
<p>打包完成后，打开target目录，解压下面的tar.gz包</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292325687.png" alt="1566292325687"></p>
<p>他跟3.4.1 的dubbo-admin不一样，不是一个springboot项目，不能够直接使用java –jar命令执行。</p>
<p>打开解压后的目录</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292337531.png" alt="1566292337531"></p>
<p>Conf目录存放就是我们的dubbo.properties</p>
<p>assembly.bin目录存放运行dubbo-monitor-simple 的可执行文件</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292359272.png" alt="1566292359272"></p>
<p>双击 start.bat 执行</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292369604.png" alt="1566292369604"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292380240.png" alt="1566292380240"></p>
<h4 id="4-在项目中使用simple监控中心"><a href="#4-在项目中使用simple监控中心" class="headerlink" title="4.在项目中使用simple监控中心"></a>4.在项目中使用simple监控中心</h4><p><img src="/2019/01/05/dubbo分布式服务框架/1566292395114.png" alt="1566292395114"></p>
<p>以3.3的例子为例：</p>
<p>分别在provider.xml和consumer.xml中添加以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dubbo:monitor protocol=&quot;registry&quot;&gt;&lt;/dubbo:monitor&gt; </div><div class="line">&lt;!-- &lt;dubbo:monitor address=&quot;127.0.0.1:7070&quot;&gt;&lt;/dubbo:monitor&gt;--&gt;</div></pre></td></tr></table></figure>
<p>然后重新运行项目，再查看</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292420989.png" alt="1566292420989"></p>
<h1 id="四、dubbo整合springboot"><a href="#四、dubbo整合springboot" class="headerlink" title="四、dubbo整合springboot"></a>四、dubbo整合springboot</h1><p>改造4.3章节普通的maven项目为springboot项目，关键代码没有变化，主要是一些配置和依赖发生了变化</p>
<p>关于idea怎么创建多模块项目这里就不阐述了，详情可参见一下网址</p>
<p><a href="https://blog.csdn.net/tiantangdizhibuxiang/article/details/81130297" target="_blank" rel="external">[https://blog.csdn.net/tiantangdizhibuxiang/article/details/81130297]{.underline}</a></p>
<p><a href="https://www.cnblogs.com/zjfjava/p/9696086.html" target="_blank" rel="external">https://www.cnblogs.com/zjfjava/p/9696086.html</a></p>
<h2 id="4-1-新建boot-common-interface：公共接口层（model，service，exception…）（符合分包理念）"><a href="#4-1-新建boot-common-interface：公共接口层（model，service，exception…）（符合分包理念）" class="headerlink" title="4.1 新建boot-common-interface：公共接口层（model，service，exception…）（符合分包理念）"></a>4.1 新建boot-common-interface：公共接口层（model，service，exception…）（符合分包理念）</h2><p><img src="/2019/01/05/dubbo分布式服务框架/1566292452656.png" alt="1566292452656"></p>
<p>一路next完成。</p>
<p>复制4.3.1 章节common-interface的相关代码到此工程</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292474717.png" alt="1566292474717"></p>
<h2 id="4-2-新建boot-user-module：用户模块"><a href="#4-2-新建boot-user-module：用户模块" class="headerlink" title="4.2 新建boot-user-module：用户模块"></a>4.2 新建boot-user-module：用户模块</h2><h3 id="4-2-1-新建模块"><a href="#4-2-1-新建模块" class="headerlink" title="4.2.1 新建模块"></a>4.2.1 新建模块</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566292489020.png" alt="1566292489020"></p>
<p>一路next创建即可。</p>
<h3 id="4-2-2-代码实现"><a href="#4-2-2-代码实现" class="headerlink" title="4.2.2 代码实现"></a>4.2.2 代码实现</h3><p>4.2.2同理复制章节4.3.2 user-module项目代码到此项目并修改pom.xml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">添加一下依赖</div><div class="line"></div><div class="line">		&lt;!--引用公用模块--&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.kingge&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;boot-common-interface&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;!--引入dubbo starter--&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;0.2.0&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p><strong>需要注意的是：</strong></p>
<p><strong>注意springboot的starter版本跟dubbo版本适配：</strong></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292539737.png" alt="1566292539737"></p>
<p><strong>因为本人使用的是springboot2.1.6版本，故使用0.2.0版本dubbo starter</strong></p>
<h3 id="4-2-3修改application-proeprties文件"><a href="#4-2-3修改application-proeprties文件" class="headerlink" title="4.2.3修改application.proeprties文件"></a>4.2.3修改application.proeprties文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dubbo.application.name=boot-user-module</div><div class="line">dubbo.registry.protocol=zookeeper</div><div class="line">dubbo.registry.address=127.0.0.1:2181</div><div class="line"></div><div class="line">#开启包扫描，可替代 @EnableDubbo 注解</div><div class="line">#dubbo.scan.base-packages=com.kingge.order</div><div class="line">dubbo.protocol.name=dubbo</div><div class="line">dubbo.protocol.port=20880</div><div class="line"></div><div class="line">dubbo.monitor.protocol=registry</div></pre></td></tr></table></figure>
<p>application.name就是服务名，不能跟别的dubbo提供端重复</p>
<p>registry.protocol 是指定注册中心协议</p>
<p>registry.address 是注册中心的地址加端口号</p>
<p>protocol.name 是分布式固定是dubbo,不要改。</p>
<p>dubbo.scan.base-packages 需要暴露的接口的实现类所在的包（跟启动类在同一个包或者子包下都不需要配置这个属性的值，因为springboot启动类会扫描注入。）</p>
<p>dubbo.monitor.protocol 开启simple检测中心</p>
<h3 id="4-2-4-配置需要暴露的服务（通过注解方式）"><a href="#4-2-4-配置需要暴露的服务（通过注解方式）" class="headerlink" title="4.2.4 配置需要暴露的服务（通过注解方式）"></a>4.2.4 配置需要暴露的服务（通过注解方式）</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566292610602.png" alt="1566292610602"></p>
<h3 id="4-2-5-boot启动类开启dubbo功能"><a href="#4-2-5-boot启动类开启dubbo功能" class="headerlink" title="4.2.5 boot启动类开启dubbo功能"></a>4.2.5 boot启动类开启dubbo功能</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566292619945.png" alt="1566292619945"></p>
<h3 id="4-2-6-完整项目结构和启动服务提供者"><a href="#4-2-6-完整项目结构和启动服务提供者" class="headerlink" title="4.2.6 完整项目结构和启动服务提供者"></a>4.2.6 完整项目结构和启动服务提供者</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566292632557.png" alt="1566292632557"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292639565.png" alt="1566292639565"></p>
<h2 id="4-3-新建boot-order-module：订单模块"><a href="#4-3-新建boot-order-module：订单模块" class="headerlink" title="4.3 新建boot-order-module：订单模块"></a>4.3 新建boot-order-module：订单模块</h2><p>4.3.1 因为我们打算通过web的方式访问controller，再去调用暴露的接口，所以需要引入web依赖</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292654499.png" alt="1566292654499"></p>
<p>一路next即可</p>
<h3 id="4-3-2-代码实现"><a href="#4-3-2-代码实现" class="headerlink" title="4.3.2 代码实现"></a>4.3.2 代码实现</h3><p>4.3.2 同理复制章节4.3.3 order-module项目代码到此项目并修改pom.xml文件</p>
<p>添加一下依赖</p>
<pre><code>&lt;!--引用公用模块--&gt;
&lt;dependency&gt;
       &lt;groupId&gt;com.kingge&lt;/groupId&gt;
       &lt;artifactId&gt;boot-common-interface&lt;/artifactId&gt;
       &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--引入dubbo starter--&gt;
&lt;dependency&gt;
       &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;
       &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
       &lt;version&gt;0.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="4-3-3-修改application-proeprties文件"><a href="#4-3-3-修改application-proeprties文件" class="headerlink" title="4.3.3 修改application.proeprties文件"></a>4.3.3 修改application.proeprties文件</h3><p>dubbo.application.name=boot-order-module</p>
<p>dubbo.registry.address= zookeeper://127.0.0.1:2181</p>
<p>dubbo.monitor.protocol=registry</p>
<h3 id="4-3-4-service使用-reference调用暴露接口"><a href="#4-3-4-service使用-reference调用暴露接口" class="headerlink" title="4.3.4 service使用@reference调用暴露接口"></a>4.3.4 service使用@reference调用暴露接口</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566292707472.png" alt="1566292707472"></p>
<h3 id="4-3-5-实现一个controller，接受请求"><a href="#4-3-5-实现一个controller，接受请求" class="headerlink" title="4.3.5 实现一个controller，接受请求"></a>4.3.5 实现一个controller，接受请求</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566292718314.png" alt="1566292718314"></p>
<h3 id="4-3-6-boot启动类开启dubbo功能"><a href="#4-3-6-boot启动类开启dubbo功能" class="headerlink" title="4.3.6 boot启动类开启dubbo功能"></a>4.3.6 boot启动类开启dubbo功能</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566292727605.png" alt="1566292727605"></p>
<h3 id="4-3-7-启动工程，并访问请求"><a href="#4-3-7-启动工程，并访问请求" class="headerlink" title="4.3.7 启动工程，并访问请求"></a>4.3.7 启动工程，并访问请求</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566292736852.png" alt="1566292736852"></p>
<p>服务调用成功</p>
<h2 id="4-4-补充"><a href="#4-4-补充" class="headerlink" title="4.4 补充"></a>4.4 补充</h2><p>整合dubbo的三种方式：官网</p>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/api.html" target="_blank" rel="external">[http://dubbo.apache.org/zh-cn/docs/user/configuration/api.html]{.underline}</a></p>
<p>* SpringBoot与dubbo整合的三种方式：</p>
<p>* 1）、导入dubbo-starter，在application.properties配置属性，使用\@Service【暴露服务】使用@Reference【引用服务】使用\@EnableDubbo，开启dubbo注解功能（<strong>上面例子我们使用的就是这种方式</strong>）</p>
<p>* 2）、保留dubbo xml配置文件</p>
<p>* 导入dubbo-starter，使用\@ImportResource导入dubbo的配置文件即可</p>
<p>* 3）、使用注解API的方式：</p>
<p>* 将每一个组件手动创建到容器中,让dubbo来扫描其他的组件</p>
<p>第二种整合方式解决：</p>
<p>如果我们需要在boot-user-module服务提供者配置方法级别的超时时间，那么有没有响应的注解配置呢？ 答案是没有的，那么就需要我们使用xml的方式进行配置。</p>
<p>1. 首先去掉@Service、@Reference、@EnableDubbo等注解</p>
<p>2. @ImportResource(locations=\”classpath:provider.xml\”) 使用</p>
<p>ImportResource注解导入外部xml文件</p>
<h1 id="五、Dubbo配置"><a href="#五、Dubbo配置" class="headerlink" title="五、Dubbo配置"></a>五、Dubbo配置</h1><p><a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/annotation.html" target="_blank" rel="external">[http://dubbo.apache.org/zh-cn/docs/user/configuration/annotation.html]{.underline}</a></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292811339.png" alt="1566292811339"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292823850.png" alt="1566292823850"></p>
<p>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</p>
<p>XML（<strong>springboot项目中对应的是application.properties文件</strong>） 次之，如果在 XML 中有配置，则 dubbo.properties 和代码中的相应配置项无效。</p>
<p>使用代码设置的方式优先级排在第三。</p>
<p>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p>
<h1 id="六、Dubbo官方提供的例子（功能）"><a href="#六、Dubbo官方提供的例子（功能）" class="headerlink" title="六、Dubbo官方提供的例子（功能）"></a>六、Dubbo官方提供的例子（功能）</h1><p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html" target="_blank" rel="external">[http://dubbo.apache.org/zh-cn/docs/user/demos/preflight-check.html]{.underline}</a></p>
<h2 id="6-1启动时检查"><a href="#6-1启动时检查" class="headerlink" title="6.1启动时检查"></a>6.1启动时检查</h2><p><img src="/2019/01/05/dubbo分布式服务框架/1566292846979.png" alt="1566292846979"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292857963.png" alt="1566292857963"></p>
<h2 id="6-2-服务超时调用和重试次数"><a href="#6-2-服务超时调用和重试次数" class="headerlink" title="6.2 服务超时调用和重试次数"></a>6.2 服务超时调用和重试次数</h2><p>1. timeout属性</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292871305.png" alt="1566292871305"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292882714.png" alt="1566292882714"></p>
<p>2. retries 属性</p>
<p>默认重试2次，也就是说一共会调用提供者服务三次（第一次调用不计次数）</p>
<p>如果在注册中心，提供者有三个（a1、a2、a3），那么消费者(b1)在重试获取服务的时候，这三个都会可能去调用。</p>
<p>b1请求a1服务超时，发现注册中心存在相同的服务a2、a3那么b1会去请求a2或者a3，当然也有可能再次请求a1</p>
<p>那么什么时候使用这个字段。建议在<strong>“幂等”</strong>的业务场景下使用，不要在非幂等的场景下使用。</p>
<p>幂等：就是提供者提供的服务，调用多次跟调用一次的起到的作用是一致的（例如对数据库的delete某条数据的操作）</p>
<p>非幂等：单次调用和多次调用的结果是不一样的（数据库的insert操作）</p>
<p>设置为0，表示不进行重试，直接报异常</p>
<h2 id="6-3标签属性配置优先级"><a href="#6-3标签属性配置优先级" class="headerlink" title="6.3标签属性配置优先级"></a>6.3标签属性配置优先级</h2><p><img src="/2019/01/05/dubbo分布式服务框架/1566292898332.png" alt="1566292898332"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292904601.png" alt="1566292904601"></p>
<h2 id="6-4多版本"><a href="#6-4多版本" class="headerlink" title="6.4多版本"></a>6.4多版本</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>
<p>可以按照以下的步骤进行版本迁移：</p>
<blockquote>
<p>1.在低压力时间段，先升级一半提供者为新版本</p>
<p>2.再将所有消费者升级为新版本</p>
<p>3.然后将剩下的一半提供者升级为新版本</p>
</blockquote>
<p>使用场景：新版接口需要替代旧版接口时。</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292919156.png" alt="1566292919156"></p>
<p>Version=”*“表示任何调用新旧版本</p>
<p>举个例子：</p>
<p>使用第四章节的例子：</p>
<p>1.boot-user-module模块，添加一个新的UserService接口实现类，作为新接口的实现</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292938701.png" alt="1566292938701"></p>
<p>给两个接口添加版本标识（标识新旧接口）</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292947114.png" alt="1566292947114"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292954668.png" alt="1566292954668"></p>
<p>2.修改boot-order-module模块消费者消费接口版本</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292966487.png" alt="1566292966487"></p>
<p>通过version属性实现新旧接口的调用</p>
<h2 id="6-5本地存根"><a href="#6-5本地存根" class="headerlink" title="6.5本地存根"></a>6.5本地存根</h2><p><img src="/2019/01/05/dubbo分布式服务框架/1566292979159.png" alt="1566292979159"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566292986964.png" alt="1566292986964"></p>
<h2 id="6-6-更多用法参见官网的事例"><a href="#6-6-更多用法参见官网的事例" class="headerlink" title="6.6 更多用法参见官网的事例"></a>6.6 更多用法参见官网的事例</h2><h1 id="七、Dubbo高可用"><a href="#七、Dubbo高可用" class="headerlink" title="七、Dubbo高可用"></a>七、Dubbo高可用</h1><h2 id="7-1、zookeeper宕机与dubbo直连"><a href="#7-1、zookeeper宕机与dubbo直连" class="headerlink" title="7.1、zookeeper宕机与dubbo直连"></a>7.1、zookeeper宕机与dubbo直连</h2><p>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。</p>
<p>原因：</p>
<p>健壮性</p>
<ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li><strong>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</strong></li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<p>高可用：通过设计，减少系统不能提供服务的时间；</p>
<p>直连dubbo：因为我们知道zookeeper注册中心保存的信息主要是消息提供者的位置，那么我们消费者可以通过url的方式直接访问消息提供者提供的服务地址也是可以的。</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293000779.png" alt="1566293000779"></p>
<h2 id="7-2、集群下dubbo负载均衡配置"><a href="#7-2、集群下dubbo负载均衡配置" class="headerlink" title="7.2、集群下dubbo负载均衡配置"></a>7.2、集群下dubbo负载均衡配置</h2><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>
<p>负载均衡策略</p>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html" target="_blank" rel="external">http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html</a></p>
<p><strong>1.Random LoadBalance</strong></p>
<p>随机，按权重设置随机概率。</p>
<p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293015243.png" alt="1566293015243"></p>
<p>可以在Dubbo-admin设置某个服务的权重</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293025840.png" alt="1566293025840"></p>
<p><strong>2.RoundRobin LoadBalance</strong></p>
<p>轮循，按公约后的权重设置轮循比率。</p>
<p>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
<p><strong>3.LeastActive LoadBalance</strong></p>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p>
<p>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
<p>在消费服务的时候，总是查询上一个服务处理请求处理最快的那一台服务器</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293037414.png" alt="1566293037414"></p>
<p>很明显请求会发到一号服务器，因为他处理最快。每次都记录请求处理的时间。</p>
<p><strong>4.ConsistentHash LoadBalance</strong></p>
<p>一致性 Hash，相同参数的请求总是发到同一提供者。</p>
<p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：<a href="http://en.wikipedia.org/wiki/Consistent\_hashing" target="_blank" rel="external">http://en.wikipedia.org/wiki/Consistent\_hashing</a></p>
<p>缺省只对第一个参数 Hash，如果要修改，请配置 \<dubbo:parameter key="\" hash.arguments\""="" value="\" 0,1\""="" \=""></dubbo:parameter></p>
<p>缺省用 160 份虚拟节点，如果要修改，请配置 \<dubbo:parameter key="\" hash.nodes\""="" value="\" 320\""="" \=""></dubbo:parameter></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293053652.png" alt="1566293053652"></p>
<h2 id="7-3、整合hystrix，服务熔断与降级处理"><a href="#7-3、整合hystrix，服务熔断与降级处理" class="headerlink" title="7.3、整合hystrix，服务熔断与降级处理"></a>7.3、整合hystrix，服务熔断与降级处理</h2><h3 id="1、服务降级"><a href="#1、服务降级" class="headerlink" title="1、服务降级"></a>1、服务降级</h3><p><strong>什么是服务降级？</strong></p>
<p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong></p>
<p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>
<p>向注册中心写入动态配置覆盖规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RegistryFactory registryFactory =</div><div class="line"> ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</div><div class="line">Registry registry =</div><div class="line"> registryFactory.getRegistry(URL.valueOf(&quot;zookeeper://10.20.153.10:2181&quot;));</div><div class="line">registry.register(URL.valueOf(&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;));</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>mock=force:return+null 表示消费方对<strong>该服务的方法调用都直接返回 null 值</strong>，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</li>
</ul>
<blockquote>
<p>相当于在dubbo-admin中设置如下：</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293085820.png" alt="1566293085820"></p>
</blockquote>
<ul>
<li>还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li>
</ul>
<blockquote>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293099118.png" alt="1566293099118"></p>
</blockquote>
<h3 id="2、集群容错"><a href="#2、集群容错" class="headerlink" title="2、集群容错"></a>2、集群容错</h3><p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="external">[http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html]{.underline}</a></p>
<p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<p><strong>集群容错模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Failover Cluster</div><div class="line">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。</div><div class="line"></div><div class="line">重试次数配置如下：</div><div class="line">&lt;dubbo:service retries=&quot;2&quot; /&gt;</div><div class="line">或</div><div class="line">&lt;dubbo:reference retries=&quot;2&quot; /&gt;</div><div class="line">或</div><div class="line">&lt;dubbo:reference&gt;</div><div class="line">    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;</div><div class="line">&lt;/dubbo:reference&gt;</div><div class="line"></div><div class="line">Failfast Cluster</div><div class="line">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</div><div class="line"></div><div class="line">Failsafe Cluster</div><div class="line">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</div><div class="line"></div><div class="line">Failback Cluster</div><div class="line">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</div><div class="line"></div><div class="line">Forking Cluster</div><div class="line">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</div><div class="line"></div><div class="line">Broadcast Cluster</div><div class="line">广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</div><div class="line"></div><div class="line">集群模式配置</div><div class="line">按照以下示例在服务提供方和消费方配置集群模式</div><div class="line">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</div><div class="line">或</div><div class="line">&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</div></pre></td></tr></table></figure>
<h3 id="3、整合hystrix"><a href="#3、整合hystrix" class="headerlink" title="3、整合hystrix"></a>3、整合hystrix</h3><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能</p>
<h4 id="1、配置spring-cloud-starter-netflix-hystrix"><a href="#1、配置spring-cloud-starter-netflix-hystrix" class="headerlink" title="1、配置spring-cloud-starter-netflix-hystrix"></a>1、配置spring-cloud-starter-netflix-hystrix</h4><p>spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>然后在Application类上增加\@EnableHystrix来启用hystrix starter：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableHystrix</div><div class="line">public class ProviderApplication &#123;</div></pre></td></tr></table></figure>
<h4 id="2、配置Provider端"><a href="#2、配置Provider端" class="headerlink" title="2、配置Provider端"></a>2、配置Provider端</h4><p>在Dubbo的Provider上增加\@HystrixCommand配置，这样子调用就会经过Hystrix代理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@com.alibaba.dubbo.config.annotation.Service (version = &quot;1.0.0&quot;)</div><div class="line">public class HelloServiceImpl implements HelloService &#123;</div><div class="line">    @HystrixCommand(commandProperties = &#123;</div><div class="line">     @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),</div><div class="line">     @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;2000&quot;) &#125;)</div><div class="line">    @Override</div><div class="line">    public String sayHello(String name) &#123;</div><div class="line">        // System.out.println(&quot;async provider received: &quot; + name);</div><div class="line">        // return &quot;annotation: hello, &quot; + name;</div><div class="line">        throw new RuntimeException(&quot;Exception to show hystrix enabled.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、配置Consumer端"><a href="#3、配置Consumer端" class="headerlink" title="3、配置Consumer端"></a>3、配置Consumer端</h4><p>对于Consumer端，则可以增加一层method调用，并在method上配置@HystrixCommand。当调用出错时，会走到fallbackMethod = \”reliable\”的调用里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Reference(version = &quot;1.0.0&quot;)</div><div class="line">private HelloService demoService;</div><div class="line"></div><div class="line">@HystrixCommand(fallbackMethod = &quot;reliable&quot;)</div><div class="line">public String doSayHello(String name) &#123;</div><div class="line">    return demoService.sayHello(name);</div><div class="line">&#125;</div><div class="line">public String reliable(String name) &#123;</div><div class="line">    return &quot;hystrix fallback value&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="八、Dubbo原理"><a href="#八、Dubbo原理" class="headerlink" title="八、Dubbo原理"></a>八、Dubbo原理</h1><h2 id="1、RPC原理"><a href="#1、RPC原理" class="headerlink" title="1、RPC原理"></a>1、RPC原理</h2><p><img src="/2019/01/05/dubbo分布式服务框架/1566293222964.png" alt="1566293222964"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">一次完整的RPC调用流程（同步调用，异步另说）如下： </div><div class="line">1）服务消费方（client）调用以本地调用方式调用服务； </div><div class="line">2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </div><div class="line">3）client stub找到服务地址，并将消息发送到服务端； </div><div class="line">4）server stub收到消息后进行解码； </div><div class="line">5）server stub根据解码结果调用本地的服务； </div><div class="line">6）本地服务执行并将结果返回给server stub； </div><div class="line">7）server stub将返回结果打包成消息并发送至消费方； </div><div class="line">8）client stub接收到消息，并进行解码； </div><div class="line">9）服务消费方得到最终结果。</div><div class="line">RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</div></pre></td></tr></table></figure>
<h2 id="2、netty通信原理"><a href="#2、netty通信原理" class="headerlink" title="2、netty通信原理"></a>2、netty通信原理</h2><p>Netty是一个异步事件驱动的网络应用程序框架， 用于快速开发可维护的高性能协议服务器和客户端。它极大地简化并简化了TCP和UDP套接字服务器等网络编程。</p>
<p>BIO：(Blocking IO)</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293252955.png" alt="1566293252955"></p>
<p>NIO (Non-Blocking IO)</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293263838.png" alt="1566293263838"></p>
<p>Selector 一般称 为<strong>选择器</strong> ，也可以翻译为 <strong>多路复用器，</strong></p>
<p>Connect（连接就绪）、Accept（接受就绪）、Read（读就绪）、Write（写就绪）</p>
<p>Netty基本原理：</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293279559.png" alt="1566293279559"></p>
<h2 id="3、dubbo原理"><a href="#3、dubbo原理" class="headerlink" title="3、dubbo原理"></a>3、dubbo原理</h2><h3 id="1、dubbo原理-框架设计"><a href="#1、dubbo原理-框架设计" class="headerlink" title="1、dubbo原理 -框架设计"></a>1、dubbo原理 -框架设计</h3><p><a href="http://dubbo.apache.org/zh-cn/docs/dev/design.html" target="_blank" rel="external">[http://dubbo.apache.org/zh-cn/docs/dev/design.html]{.underline}</a></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293295570.png" alt="1566293295570"></p>
<ul>
<li>config 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<h3 id="2、dubbo原理-启动解析、加载配置信息"><a href="#2、dubbo原理-启动解析、加载配置信息" class="headerlink" title="2、dubbo原理 -启动解析、加载配置信息"></a>2、dubbo原理 -启动解析、加载配置信息</h3><p>我们知道spring加载配置文件，是通过BeanDefinitionparser这个接口的实现类进行绑定的</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293308924.png" alt="1566293308924"></p>
<p>调用parse方法，解析标签</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293318845.png" alt="1566293318845"></p>
<p>根据xml文件的每一行进行处理解析</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293328013.png" alt="1566293328013"></p>
<p>不同的标签处理逻辑是不一样的</p>
<p>那么每一个标签对应的类是哪一个。这个是哪里定义的呢？</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293340338.png" alt="1566293340338"></p>
<p>通过DubboNamespaceHandler来定义标签对应的解析类</p>
<h3 id="3、dubbo原理-服务暴露"><a href="#3、dubbo原理-服务暴露" class="headerlink" title="3、dubbo原理 -服务暴露"></a>3、dubbo原理 -服务暴露</h3><p>通过上面的配置文件解析，我们知道服务相关的信息是通过解析后存放在ServiceBean中</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class ServiceBean&lt;T&gt; extends ServiceConfig&lt;T&gt; implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener&lt;ContextRefreshedEvent&gt;, BeanNameAware &#123;</div></pre></td></tr></table></figure>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293383877.png" alt="1566293383877"></p>
<p>关键的两个接口</p>
<p>InitializingBean Spring的接口,当组件创建完对象之后, 组件属性设置完成，会调用InitializingBean中的afterPropertiesSet方法</p>
<p>ApplicationListener应用监听器 监听IOC容器的刷新事件.当IOC容器中，所有对象都创建完成会回调onApplicationEvent方法</p>
<p>设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()</p>
<p>没有设置延迟或者延迟为-1，dubbo会在Spring实例化完bean之后，在刷新容器最后一步发布ContextRefreshEvent事件的时候，通知实现了ApplicationListener的类进行回调onApplicationEvent</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293404027.png" alt="1566293404027"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293411759.png" alt="1566293411759"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293420019.png" alt="1566293420019"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293437832.png" alt="1566293437832"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293450707.png" alt="1566293450707"></p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293459991.png" alt="1566293459991"></p>
<p>总的调用接口如下：</p>
<p><img src="/2019/01/05/dubbo分布式服务框架/1566293466646.png" alt="1566293466646"></p>
<h3 id="4、dubbo原理-服务引用"><a href="#4、dubbo原理-服务引用" class="headerlink" title="4、dubbo原理 -服务引用"></a>4、dubbo原理 -服务引用</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566293477806.png" alt="1566293477806"></p>
<h3 id="5、dubbo原理-服务调用"><a href="#5、dubbo原理-服务调用" class="headerlink" title="5、dubbo原理 -服务调用"></a>5、dubbo原理 -服务调用</h3><p><img src="/2019/01/05/dubbo分布式服务框架/1566293490630.png" alt="1566293490630"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dubbo分布式服务框架**&lt;/p&gt;
&lt;h1 id=&quot;一、分布式概念&quot;&gt;&lt;a href=&quot;#一、分布式概念&quot; class=&quot;headerlink&quot; title=&quot;一、分布式概念&quot;&gt;&lt;/a&gt;一、分布式概念&lt;/h1&gt;&lt;p&gt;分布式的概念：某个业务逻辑的完成，拆分成几个功能/服务来
    
    </summary>
    
      <category term="dubbo" scheme="http://kingge.top/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://kingge.top/tags/dubbo/"/>
    
      <category term="分布式" scheme="http://kingge.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="rpc" scheme="http://kingge.top/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息队列</title>
    <link href="http://kingge.top/2018/09/03/RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://kingge.top/2018/09/03/RabbitMQ消息队列/</id>
    <published>2018-09-03T12:53:09.000Z</published>
    <updated>2019-09-03T13:00:57.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h1><p>​         MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced MessageQueue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开</p>
<p>​    发中应用非常广泛。RabbitMQ官方地址：<a href="http://www.rabbitmq.com/" target="_blank" rel="external">http://www.rabbitmq.com/</a></p>
<blockquote>
<p>开发中消息队列通常有如下应用场景：</p>
</blockquote>
<p>1、任务异步处理。<br>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p>
<p>2、应用程序解耦合<br>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p>
<blockquote>
<p>市场上还有哪些消息队列？</p>
</blockquote>
<p>ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ、Redis。</p>
<p>为什么使用RabbitMQ呢？<br>1、使得简单，功能强大。<br>2、基于AMQP协议。<br>3、社区活跃，文档完善。<br>4、高并发性能好，这主要得益于Erlang语言。<br>5、Spring Boot默认已集成RabbitMQ</p>
<h2 id="其它相关知识"><a href="#其它相关知识" class="headerlink" title="其它相关知识"></a>其它相关知识</h2><blockquote>
<p>AMQP是什么 ？</p>
</blockquote>
<p>​    AMQP是一套公开的消息队列协议，最早在2003年被提出，它旨在从协议层定义消息通信数据的标准格式，<br>为的就是解决MQ市场上协议不统一的问题。RabbitMQ就是遵循AMQP标准协议开发的MQ服务。</p>
<p>官方：<a href="http://www.amqp.org/" target="_blank" rel="external">http://www.amqp.org/</a></p>
<blockquote>
<p>JMS是什么？</p>
</blockquote>
<p>​    JMS是java提供的一套消息服务API标准，其目的是为所有的java应用程序提供统一的消息通信的标准，类似java的jdbc，只要遵循jms标准的应用程序之间都可以进行消息通信。它和AMQP有什么 不同，jms是java语言专属的消息服务标准，它是在api层定义标准，并且只能用于java应用；而AMQP是在协议层定义的标准，是跨语言的 。</p>
<h2 id="RabbitMQ的工作原理"><a href="#RabbitMQ的工作原理" class="headerlink" title="RabbitMQ的工作原理"></a>RabbitMQ的工作原理</h2><p><img src="/2018/09/03/RabbitMQ消息队列/1567148945077.png" alt="1567148945077"></p>
<p>组成部分说明如下：</p>
<ul>
<li>Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。</li>
</ul>
<p>​        Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。</p>
<p>​        Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。</p>
<ul>
<li>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。</li>
<li>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。</li>
</ul>
<blockquote>
<p>消息发布接收流程：</p>
</blockquote>
<p>—–发送消息—–<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）</p>
<p>—-接收消息—–<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。</p>
<h1 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>​     RabbitMQ由Erlang语言开发，Erlang语言用于并发及分布式系统的开发，在电信领域应用广泛，OTP（Open<br>Telecom Platform）作为Erlang语言的一部分，包含了很多基于Erlang开发的中间件及工具库，安装RabbitMQ需<br>要安装Erlang/OTP，并保持版本匹配，如下图：</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567149365706.png" alt="1567149365706"></p>
<p>RabbitMQ的下载地址：<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="external">http://www.rabbitmq.com/download.html</a></p>
<p>erlang的下载地址：<a href="http://erlang.org/download/otp_win64_20.3.exe" target="_blank" rel="external">http://erlang.org/download/otp_win64_20.3.exe</a></p>
<p><strong>这里使用：Erlang/OTP 20.3版本和RabbitMQ3.7.3版本。</strong></p>
<blockquote>
<p>特别提示</p>
<ul>
<li>安装erlang和rabbitMQ以管理员身份运行。</li>
<li>当卸载重新安装时会出现RabbitMQ服务注册失败，此时需要进入注册表清理erlang搜索RabbitMQ、ErlSrv，将对应的项全部删除。</li>
</ul>
</blockquote>
<h3 id="安装erlang"><a href="#安装erlang" class="headerlink" title="安装erlang"></a>安装erlang</h3><p>下载完成后，右键管理员运行安装，都是下一步安装完成即可。</p>
<p>配置erlang环境变量：  ERLANG_HOME=D:\erl9.3  在path中添<br>加%ERLANG_HOME%\bin;</p>
<h3 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h3><p>以管理员方式运行此文件，安装。</p>
<h2 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h2><p>安装成功后会自动创建RabbitMQ服务并且启动。</p>
<p>1）从开始菜单启动RabbitMQ</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567149729197.png" alt="1567149729197"></p>
<blockquote>
<p>RabbitMQ Service-install :安装服务<br>RabbitMQ Service-remove 删除服务<br>RabbitMQ Service-start 启动<br>RabbitMQ Service-stop 启动</p>
</blockquote>
<p>2）通过命令启动RabbitMQ</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567149795884.png" alt="1567149795884"></p>
<p>1.安装并运行服务<br>        rabbitmq-service.bat install 安装服务 </p>
<p>​        rabbitmq-service.bat stop 停止服务 </p>
<p>​        rabbitmq-service.bat start 启动服务</p>
<p>2.安装管理插件<br>    安装rabbitMQ的管理插件，方便在浏览器端管理RabbitMQ<br>    管理员身份运行命令： rabbitmq-plugins.bat enable rabbitmq_management</p>
<p>3.启动成功 登录RabbitMQ</p>
<p>​        进入浏览器，输入：<a href="http://localhost:15672" target="_blank" rel="external">http://localhost:15672</a></p>
<p>​        <strong>初始账号和密码：guest/guest</strong></p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567149894028.png" alt="1567149894028"></p>
<h2 id="官方-Hello-World-入门例子"><a href="#官方-Hello-World-入门例子" class="headerlink" title="官方 Hello World 入门例子"></a>官方 Hello World 入门例子</h2><p>官方各个语言集成RabbitMQ说明：<strong><a href="https://www.rabbitmq.com/devtools.html" target="_blank" rel="external">https://www.rabbitmq.com/devtools.html</a></strong></p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567152640556.png" alt="1567152640556"></p>
<p>下面的例子我们暂时使用，javaClient的方式，通过导入<a href="http://repo1.maven.org/maven2/com/rabbitmq/amqp-client/5.7.2/amqp-client-5.7.2.jar" target="_blank" rel="external">amqp-client-5.7.2.jar</a>完成例子的使用</p>
<p>我们先用 rabbitMQ官方提供的java client测试，目的是对RabbitMQ的交互过程有个清晰的认识。<br>参考 ：<a href="https://github.com/rabbitmq/rabbitmq-java-client/" target="_blank" rel="external">https://github.com/rabbitmq/rabbitmq-java-client/</a></p>
<p>官网例子地址：<a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="external">https://www.rabbitmq.com/getstarted.html</a></p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567150030457.png" alt="1567150030457"></p>
<h3 id="创建maven工程-这里为了方面后面的集成，直接创建springboot项目"><a href="#创建maven工程-这里为了方面后面的集成，直接创建springboot项目" class="headerlink" title="创建maven工程-这里为了方面后面的集成，直接创建springboot项目"></a>创建maven工程-这里为了方面后面的集成，直接创建springboot项目</h3><p>创建生产者工程和消费者工程，分别加入RabbitMQ java client的依赖。</p>
<p>test-rabbitmq-producer：生产者工程<br>test-rabbitmq-consumer：消费者工程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;amqp‐client&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.3&lt;/version&gt;&lt;!‐‐此版本与spring boot 1.5.9版本匹配‐‐&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring‐boot‐starter‐logging&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>完整项目目录：</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567152933030.png" alt="1567152933030"></p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>在生产者工程下的test中创建测试类如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.rabbitmq.client.Channel;</div><div class="line">import com.rabbitmq.client.Connection;</div><div class="line">import com.rabbitmq.client.ConnectionFactory;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line">public class Producer01 &#123;</div><div class="line"></div><div class="line">    //队列</div><div class="line">    private static final String QUEUE = &quot;helloworld&quot;;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        Connection connection = null;</div><div class="line">        Channel channel = null;</div><div class="line">        try &#123;</div><div class="line">            //建立新连接</div><div class="line">            connection = connectionFactory.newConnection();</div><div class="line">            //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">            channel = connection.createChannel();</div><div class="line">            //声明队列，如果队列在mq 中没有则要创建</div><div class="line">            //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</div><div class="line">            /**</div><div class="line">             * 参数明细</div><div class="line">             * 1、queue 队列名称</div><div class="line">             * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">             * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">             * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">             * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">             */</div><div class="line">            channel.queueDeclare(QUEUE,true,false,false,null);</div><div class="line">            //发送消息</div><div class="line">            //参数：String exchange, String routingKey, BasicProperties props, byte[] body</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为&quot;&quot;）</div><div class="line">             * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</div><div class="line">             * 3、props，消息的属性</div><div class="line">             * 4、body，消息内容</div><div class="line">             */</div><div class="line">            //消息内容</div><div class="line">            String message = &quot;hello world kingge发送消息2&quot;;</div><div class="line">            channel.basicPublish(&quot;&quot;,QUEUE,null,message.getBytes());</div><div class="line">            System.out.println(&quot;send to mq &quot;+message);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            //关闭连接</div><div class="line">            //先关闭通道</div><div class="line">            try &#123;</div><div class="line">                channel.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (TimeoutException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">import com.rabbitmq.client.*;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line">public class Consumer01 &#123;</div><div class="line"></div><div class="line">    //队列</div><div class="line">    private static final String QUEUE = &quot;helloworld&quot;;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        //建立新连接</div><div class="line">        Connection connection = connectionFactory.newConnection();</div><div class="line">        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        //监听队列</div><div class="line">        //声明队列，如果队列在mq 中没有则要创建</div><div class="line">        //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</div><div class="line">        /**</div><div class="line">         * 参数明细</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">         */</div><div class="line">        channel.queueDeclare(QUEUE,true,false,false,null);</div><div class="line"></div><div class="line">        //实现消费方法</div><div class="line">        DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 当接收到消息后此方法将被调用</div><div class="line">             * @param consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</div><div class="line">             * @param envelope 信封，通过envelope</div><div class="line">             * @param properties 消息属性</div><div class="line">             * @param body 消息内容</div><div class="line">             * @throws IOException</div><div class="line">             */</div><div class="line">            @Override</div><div class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">                //交换机</div><div class="line">                String exchange = envelope.getExchange();</div><div class="line">                //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收（因为如果下面的autoAck设置为false就需要自行回复mq消息已经接受）</div><div class="line">                long deliveryTag = envelope.getDeliveryTag();</div><div class="line">                //消息内容</div><div class="line">                String message= new String(body,&quot;utf-8&quot;);</div><div class="line">                System.out.println(&quot;receive message:&quot;+message);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        //监听队列</div><div class="line">        //参数：String queue, boolean autoAck, Consumer callback</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</div><div class="line">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</div><div class="line">         */</div><div class="line">        channel.basicConsume(QUEUE,true,defaultConsumer);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>（1）启动消费者：发送消息</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567153167144.png" alt="1567153167144"></p>
<p>（2）查询RabbitMQ后台管理浏览器</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567153233103.png" alt="1567153233103"></p>
<p>（3）启动消费者</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567153297099.png" alt="1567153297099"></p>
<p>消息消费成功</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567153329648.png" alt="1567153329648"></p>
<p>已经变为了0</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>1、发送端操作流程</p>
</blockquote>
<p> 1）创建连接</p>
<p> 2）创建通道</p>
<p> 3）声明队列</p>
<p> 4）发送消息</p>
<blockquote>
<p>2、接收端</p>
</blockquote>
<p> 1）创建连接</p>
<p> 2）创建通道</p>
<p> 3）声明队列</p>
<p> 4）监听队列</p>
<p> 5）接收消息</p>
<p> 6）ack回复</p>
<p>通过代码我们不难发现，生产者和消费者的代码，其实前半段都是一模一样的。（创建连接工厂，创建连接，创建通道，声明队列）</p>
<h1 id="RabbitMQ工作模式"><a href="#RabbitMQ工作模式" class="headerlink" title="RabbitMQ工作模式"></a>RabbitMQ工作模式</h1><p>RabbitMQ有以下几种工作模式 ：<br><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="external">https://www.rabbitmq.com/getstarted.html</a></p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567153810391.png" alt="1567153810391"></p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567153833818.png" alt="1567153833818"></p>
<p><strong>每后一个模式都能够实现前一个模式的功能</strong></p>
<h2 id="Work-queues"><a href="#Work-queues" class="headerlink" title="Work queues"></a>Work queues</h2><p>​    work queues与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息，而且它支持负载均衡的方式消费消息。</p>
<p>应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度（<strong>开启多个消费者消费同一个队列，处理相应的业务</strong>）。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1、使用入门程序，启动多个消费者（启动多次即可）。</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567154096753.png" alt="1567154096753"></p>
<p>这里启动了两个消费者，都是监听helloworld队列。</p>
<p>2、生产者发送多个消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">修改入门例子：</div><div class="line"></div><div class="line">            for(int i=0;i&lt;5;i++)&#123;</div><div class="line">                //消息内容</div><div class="line">                String message = &quot;this is a msg&quot;;</div><div class="line">                channel.basicPublish(&quot;&quot;,QUEUE,null,message.getBytes());</div><div class="line">                System.out.println(&quot;send to mq &quot;+message);</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>运行生产者</p>
<p>3.查看消费者输出</p>
<p>第一个消费者：</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567154325689.png" alt="1567154325689"></p>
<p>第二个消费者：</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567154340959.png" alt="1567154340959"></p>
<blockquote>
<p>结果：</p>
</blockquote>
<p>1、一条消息只会被一个消费者接收。<br>2、rabbit采用轮询的方式将消息是平均发送给消费者的。<br>3、消费者在处理完某条消息后，才会收到下一条消息。</p>
<h2 id="Publish-subscribe"><a href="#Publish-subscribe" class="headerlink" title="Publish/subscribe"></a>Publish/subscribe</h2><p><img src="/2018/09/03/RabbitMQ消息队列/1567154410506.png" alt="1567154410506"></p>
<p>发布订阅模式：<br>1、每个消费者监听自己的队列。<br>2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收<br>到消息（<strong>也就是说，生产者发出的消息，每个队列都会收到。例如发出五个消息，那么每个队列都会收到五个</strong>）</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>用户通知消费通知。<strong>当用户充值成功或转账完成系统通知用户，通知方式有短信、邮件多种方法 。</strong></p>
<h4 id="1-生产者代码"><a href="#1-生产者代码" class="headerlink" title="1.生产者代码"></a>1.生产者代码</h4><p>声明Exchange_fanout_inform交换机，声明两个队列并且绑定到此交换机，绑定时不需要指定routingkey，发送消息时不需要指定routingkey</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">import com.rabbitmq.client.BuiltinExchangeType;</div><div class="line">import com.rabbitmq.client.Channel;</div><div class="line">import com.rabbitmq.client.Connection;</div><div class="line">import com.rabbitmq.client.ConnectionFactory;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line">public class Producer02_publish &#123;</div><div class="line">    //队列名称</div><div class="line">    private static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;;</div><div class="line">    private static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;;</div><div class="line">    private static final String EXCHANGE_FANOUT_INFORM=&quot;exchange_fanout_inform&quot;;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        Connection connection = null;</div><div class="line">        Channel channel = null;</div><div class="line">        try &#123;</div><div class="line">            //建立新连接</div><div class="line">            connection = connectionFactory.newConnection();</div><div class="line">            //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">            channel = connection.createChannel();</div><div class="line">            //声明队列，如果队列在mq 中没有则要创建</div><div class="line">            //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</div><div class="line">            /**</div><div class="line">             * 参数明细</div><div class="line">             * 1、queue 队列名称</div><div class="line">             * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">             * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">             * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">             * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">             */</div><div class="line">            channel.queueDeclare(QUEUE_INFORM_EMAIL,true,false,false,null);</div><div class="line">            channel.queueDeclare(QUEUE_INFORM_SMS,true,false,false,null);</div><div class="line">            //声明一个交换机</div><div class="line">            //参数：String exchange, String type</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、交换机的名称</div><div class="line">             * 2、交换机的类型</div><div class="line">             * fanout：对应的rabbitmq的工作模式是 publish/subscribe</div><div class="line">             * direct：对应的Routing	工作模式</div><div class="line">             * topic：对应的Topics工作模式</div><div class="line">             * headers： 对应的headers工作模式</div><div class="line">             */</div><div class="line">            channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT);</div><div class="line">            //进行交换机和队列绑定</div><div class="line">            //参数：String queue, String exchange, String routingKey</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、queue 队列名称</div><div class="line">             * 2、exchange 交换机名称</div><div class="line">             * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串</div><div class="line">             */</div><div class="line">            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_FANOUT_INFORM,&quot;&quot;);</div><div class="line">            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_FANOUT_INFORM,&quot;&quot;);</div><div class="line">            //发送消息</div><div class="line">            //参数：String exchange, String routingKey, BasicProperties props, byte[] body</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为&quot;&quot;）</div><div class="line">             * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</div><div class="line">             * 3、props，消息的属性</div><div class="line">             * 4、body，消息内容</div><div class="line">             */</div><div class="line">            for(int i=0;i&lt;5;i++)&#123;</div><div class="line">                //消息内容</div><div class="line">                String message = &quot;send inform message to user&quot;;</div><div class="line">                channel.basicPublish(EXCHANGE_FANOUT_INFORM,&quot;&quot;,null,message.getBytes());</div><div class="line">                System.out.println(&quot;send to mq &quot;+message);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            //关闭连接</div><div class="line">            //先关闭通道</div><div class="line">            try &#123;</div><div class="line">                channel.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (TimeoutException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-邮件发送消费者"><a href="#2-邮件发送消费者" class="headerlink" title="2.邮件发送消费者"></a>2.邮件发送消费者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">import com.rabbitmq.client.*;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer02_subscribe_email &#123;</div><div class="line">    //队列名称</div><div class="line">    private static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;;</div><div class="line">    private static final String EXCHANGE_FANOUT_INFORM=&quot;exchange_fanout_inform&quot;;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        //建立新连接</div><div class="line">        Connection connection = connectionFactory.newConnection();</div><div class="line">        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 参数明细</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">         */</div><div class="line">        channel.queueDeclare(QUEUE_INFORM_EMAIL,true,false,false,null);</div><div class="line">        //声明一个交换机</div><div class="line">        //参数：String exchange, String type</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、交换机的名称</div><div class="line">         * 2、交换机的类型</div><div class="line">         * fanout：对应的rabbitmq的工作模式是 publish/subscribe</div><div class="line">         * direct：对应的Routing	工作模式</div><div class="line">         * topic：对应的Topics工作模式</div><div class="line">         * headers： 对应的headers工作模式</div><div class="line">         */</div><div class="line">        channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT);</div><div class="line">        //进行交换机和队列绑定</div><div class="line">        //参数：String queue, String exchange, String routingKey</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、exchange 交换机名称</div><div class="line">         * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串</div><div class="line">         */</div><div class="line">        channel.queueBind(QUEUE_INFORM_EMAIL, EXCHANGE_FANOUT_INFORM, &quot;&quot;);</div><div class="line"></div><div class="line">        //实现消费方法</div><div class="line">        DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 当接收到消息后此方法将被调用</div><div class="line">             * @param consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</div><div class="line">             * @param envelope 信封，通过envelope</div><div class="line">             * @param properties 消息属性</div><div class="line">             * @param body 消息内容</div><div class="line">             * @throws IOException</div><div class="line">             */</div><div class="line">            @Override</div><div class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">                //交换机</div><div class="line">                String exchange = envelope.getExchange();</div><div class="line">                //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</div><div class="line">                long deliveryTag = envelope.getDeliveryTag();</div><div class="line">                //消息内容</div><div class="line">                String message= new String(body,&quot;utf-8&quot;);</div><div class="line">                System.out.println(&quot;receive message:&quot;+message);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        //监听队列</div><div class="line">        //参数：String queue, boolean autoAck, Consumer callback</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</div><div class="line">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</div><div class="line">         */</div><div class="line">        channel.basicConsume(QUEUE_INFORM_EMAIL,true,defaultConsumer);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-短信发送消费者"><a href="#3-短信发送消费者" class="headerlink" title="3.短信发送消费者"></a>3.短信发送消费者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">import com.rabbitmq.client.*;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer02_subscribe_sms &#123;</div><div class="line">    //队列名称</div><div class="line">    private static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;;</div><div class="line">    private static final String EXCHANGE_FANOUT_INFORM=&quot;exchange_fanout_inform&quot;;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        //建立新连接</div><div class="line">        Connection connection = connectionFactory.newConnection();</div><div class="line">        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 参数明细</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">         */</div><div class="line">        channel.queueDeclare(QUEUE_INFORM_SMS,true,false,false,null);</div><div class="line">        //声明一个交换机</div><div class="line">        //参数：String exchange, String type</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、交换机的名称</div><div class="line">         * 2、交换机的类型</div><div class="line">         * fanout：对应的rabbitmq的工作模式是 publish/subscribe</div><div class="line">         * direct：对应的Routing	工作模式</div><div class="line">         * topic：对应的Topics工作模式</div><div class="line">         * headers： 对应的headers工作模式</div><div class="line">         */</div><div class="line">        channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT);</div><div class="line">        //进行交换机和队列绑定</div><div class="line">        //参数：String queue, String exchange, String routingKey</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、exchange 交换机名称</div><div class="line">         * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串</div><div class="line">         */</div><div class="line">        channel.queueBind(QUEUE_INFORM_SMS, EXCHANGE_FANOUT_INFORM, &quot;&quot;);</div><div class="line"></div><div class="line">        //实现消费方法</div><div class="line">        DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 当接收到消息后此方法将被调用</div><div class="line">             * @param consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</div><div class="line">             * @param envelope 信封，通过envelope</div><div class="line">             * @param properties 消息属性</div><div class="line">             * @param body 消息内容</div><div class="line">             * @throws IOException</div><div class="line">             */</div><div class="line">            @Override</div><div class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">                //交换机</div><div class="line">                String exchange = envelope.getExchange();</div><div class="line">                //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</div><div class="line">                long deliveryTag = envelope.getDeliveryTag();</div><div class="line">                //消息内容</div><div class="line">                String message= new String(body,&quot;utf-8&quot;);</div><div class="line">                System.out.println(&quot;receive message:&quot;+message);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        //监听队列</div><div class="line">        //参数：String queue, boolean autoAck, Consumer callback</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</div><div class="line">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</div><div class="line">         */</div><div class="line">        channel.basicConsume(QUEUE_INFORM_SMS,true,defaultConsumer);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h4><h5 id="1-启动消息生产者，发送消息"><a href="#1-启动消息生产者，发送消息" class="headerlink" title="1.启动消息生产者，发送消息"></a>1.启动消息生产者，发送消息</h5><p><img src="/2018/09/03/RabbitMQ消息队列/1567154904126.png" alt="1567154904126"></p>
<h5 id="2-RabbitMQ的管理界面"><a href="#2-RabbitMQ的管理界面" class="headerlink" title="2.RabbitMQ的管理界面"></a>2.RabbitMQ的管理界面</h5><p>查看交换机</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567154956089.png" alt="1567154956089"></p>
<p>单击进去</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567154981512.png" alt="1567154981512"></p>
<p>可以看到他绑定了两个队列</p>
<p>查看队列信息：</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567155028986.png" alt="1567155028986"></p>
<p>两个队列各有五条消息。</p>
<h4 id="3-启动两个消费者"><a href="#3-启动两个消费者" class="headerlink" title="3.启动两个消费者"></a>3.启动两个消费者</h4><p><img src="/2018/09/03/RabbitMQ消息队列/1567155261815.png" alt="1567155261815"></p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567155244606.png" alt="1567155244606"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>1.使用生产者发送若干条消息，每条消息都转发到各各队列，每消费者都接收到了消息。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><blockquote>
<p>publish/subscribe与work queues有什么区别和相似点。</p>
</blockquote>
<p>区别：<br>1）work queues不用定义交换机（使用默认的交换机），而publish/subscribe需要定义交换机。<br>2）publish/subscribe的生产方是面向交换机发送消息，work queues的生产方是面向队列发送消息(底层使用默认交换机)。<br>3）publish/subscribe需要设置队列和交换机的绑定，work queues不需要设置，实质上work queues会将队列绑<br>定到默认的交换机 。</p>
<p>相同点：<br>    两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。</p>
<p>建议使用 publish/subscribe，发布订阅模式比工作队列模式更强大，并且发布订阅模式可以指定自己专用的交换<br>机。同时发布订阅模式，可以实现工作队列模式的功能（<strong>我们可以启动两个Consumer02_subscribe_sms消费者，然后他们都监听queue_inform_sms队列，当queue_inform_sms收到消息时他们会采用工作队列模式的轮循方式消费消息</strong>）</p>
<h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>路由模式：</p>
<p>1、每个消费者监听自己的队列，并且设置routingkey。<br>2、生产者将消息发给交换机，由<strong>交换机根据routingkey来转发消息到指定的队列。</strong></p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567155625094.png" alt="1567155625094"></p>
<p>也就是说相比于发布订阅模式，他多了路由这个功能。</p>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>通过rootingkey分别发送五条消息到sms队列和email队列</p>
<h4 id="1-生产者代码-1"><a href="#1-生产者代码-1" class="headerlink" title="1.生产者代码"></a>1.生产者代码</h4><p>声明exchange_routing_inform交换机，声明两个队列并且绑定到此交换机，绑定时需要指定routingkey发送消息时需要指定routingkey</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">import com.rabbitmq.client.BuiltinExchangeType;</div><div class="line">import com.rabbitmq.client.Channel;</div><div class="line">import com.rabbitmq.client.Connection;</div><div class="line">import com.rabbitmq.client.ConnectionFactory;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"></div><div class="line">public class Producer03_routing &#123;</div><div class="line">    //队列名称</div><div class="line">    private static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;;</div><div class="line">    private static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;;</div><div class="line">    //路由交换机名称</div><div class="line">    private static final String EXCHANGE_ROUTING_INFORM=&quot;exchange_routing_inform&quot;;</div><div class="line">    //两个队列对应的rootingkey</div><div class="line">    private static final String ROUTINGKEY_EMAIL=&quot;inform_email&quot;;</div><div class="line">    private static final String ROUTINGKEY_SMS=&quot;inform_sms&quot;;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        Connection connection = null;</div><div class="line">        Channel channel = null;</div><div class="line">        try &#123;</div><div class="line">            //建立新连接</div><div class="line">            connection = connectionFactory.newConnection();</div><div class="line">            //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">            channel = connection.createChannel();</div><div class="line">            //声明队列，如果队列在mq 中没有则要创建</div><div class="line">            //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</div><div class="line">            /**</div><div class="line">             * 参数明细</div><div class="line">             * 1、queue 队列名称</div><div class="line">             * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">             * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">             * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">             * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">             */</div><div class="line">            channel.queueDeclare(QUEUE_INFORM_EMAIL,true,false,false,null);</div><div class="line">            channel.queueDeclare(QUEUE_INFORM_SMS,true,false,false,null);</div><div class="line">            //声明一个交换机</div><div class="line">            //参数：String exchange, String type</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、交换机的名称</div><div class="line">             * 2、交换机的类型</div><div class="line">             * fanout：对应的rabbitmq的工作模式是 publish/subscribe</div><div class="line">             * direct：对应的Routing	工作模式</div><div class="line">             * topic：对应的Topics工作模式</div><div class="line">             * headers： 对应的headers工作模式</div><div class="line">             */</div><div class="line">            channel.exchangeDeclare(EXCHANGE_ROUTING_INFORM, BuiltinExchangeType.DIRECT);</div><div class="line">            //进行交换机和队列绑定</div><div class="line">            //参数：String queue, String exchange, String routingKey</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、queue 队列名称</div><div class="line">             * 2、exchange 交换机名称</div><div class="line">             * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串</div><div class="line">             */</div><div class="line">            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_ROUTING_INFORM,ROUTINGKEY_EMAIL);</div><div class="line">    </div><div class="line">            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_ROUTING_INFORM,ROUTINGKEY_SMS);</div><div class="line"></div><div class="line">            //发送消息</div><div class="line">            //参数：String exchange, String routingKey, BasicProperties props, byte[] body</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为&quot;&quot;）</div><div class="line">             * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</div><div class="line">             * 3、props，消息的属性</div><div class="line">             * 4、body，消息内容</div><div class="line">             */</div><div class="line">            for(int i=0;i&lt;5;i++)&#123;</div><div class="line">                //发送消息的时候指定routingKey</div><div class="line">                String message = &quot;send email inform message to user&quot;;</div><div class="line">                channel.basicPublish(EXCHANGE_ROUTING_INFORM,ROUTINGKEY_EMAIL,null,message.getBytes());</div><div class="line">                System.out.println(&quot;send to mq &quot;+message);</div><div class="line">            &#125;</div><div class="line">            for(int i=0;i&lt;5;i++)&#123;</div><div class="line">                //发送消息的时候指定routingKey</div><div class="line">                String message = &quot;send sms inform message to user&quot;;</div><div class="line">                channel.basicPublish(EXCHANGE_ROUTING_INFORM,ROUTINGKEY_SMS,null,message.getBytes());</div><div class="line">                System.out.println(&quot;send to mq &quot;+message);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            //关闭连接</div><div class="line">            //先关闭通道</div><div class="line">            try &#123;</div><div class="line">                channel.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (TimeoutException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟发布订阅模式的生产者相比代码的区别：</p>
<p>1.声明一个交换机时候，类型修改为BuiltinExchangeType.DIRECT 路由工作模式</p>
<p>2.在进行交换机和队列绑定的时候（channel.queueBind）多出了指明队列指定的rootingkey这一参数</p>
<p>3.发消息时，需要指明消息发送的rootingkey（也即是要发送到哪一个队列）</p>
<h4 id="2-邮件消费者"><a href="#2-邮件消费者" class="headerlink" title="2.邮件消费者"></a>2.邮件消费者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.rabbitmq.client.*;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line">public class Consumer03_routing_email &#123;</div><div class="line">    //队列名称</div><div class="line">    private static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;;</div><div class="line">    private static final String EXCHANGE_ROUTING_INFORM=&quot;exchange_routing_inform&quot;;</div><div class="line">    private static final String ROUTINGKEY_EMAIL=&quot;inform_email&quot;;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        //建立新连接</div><div class="line">        Connection connection = connectionFactory.newConnection();</div><div class="line">        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 参数明细</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">         */</div><div class="line">        channel.queueDeclare(QUEUE_INFORM_EMAIL,true,false,false,null);</div><div class="line">        //声明一个交换机</div><div class="line">        //参数：String exchange, String type</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、交换机的名称</div><div class="line">         * 2、交换机的类型</div><div class="line">         * fanout：对应的rabbitmq的工作模式是 publish/subscribe</div><div class="line">         * direct：对应的Routing	工作模式</div><div class="line">         * topic：对应的Topics工作模式</div><div class="line">         * headers： 对应的headers工作模式</div><div class="line">         */</div><div class="line">        channel.exchangeDeclare(EXCHANGE_ROUTING_INFORM, BuiltinExchangeType.DIRECT);</div><div class="line">        //进行交换机和队列绑定</div><div class="line">        //参数：String queue, String exchange, String routingKey</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、exchange 交换机名称</div><div class="line">         * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串</div><div class="line">         */</div><div class="line">        channel.queueBind(QUEUE_INFORM_EMAIL, EXCHANGE_ROUTING_INFORM,ROUTINGKEY_EMAIL);</div><div class="line"></div><div class="line">        //实现消费方法</div><div class="line">        DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 当接收到消息后此方法将被调用</div><div class="line">             * @param consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</div><div class="line">             * @param envelope 信封，通过envelope</div><div class="line">             * @param properties 消息属性</div><div class="line">             * @param body 消息内容</div><div class="line">             * @throws IOException</div><div class="line">             */</div><div class="line">            @Override</div><div class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">                //交换机</div><div class="line">                String exchange = envelope.getExchange();</div><div class="line">                //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</div><div class="line">                long deliveryTag = envelope.getDeliveryTag();</div><div class="line">                //消息内容</div><div class="line">                String message= new String(body,&quot;utf-8&quot;);</div><div class="line">                System.out.println(&quot;receive message:&quot;+message);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        //监听队列</div><div class="line">        //参数：String queue, boolean autoAck, Consumer callback</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</div><div class="line">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</div><div class="line">         */</div><div class="line">        channel.basicConsume(QUEUE_INFORM_EMAIL,true,defaultConsumer);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-短信消费者"><a href="#3-短信消费者" class="headerlink" title="3.短信消费者"></a>3.短信消费者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.rabbitmq.client.*;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer03_routing_sms &#123;</div><div class="line">    //队列名称</div><div class="line">    private static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;;</div><div class="line">    private static final String EXCHANGE_ROUTING_INFORM=&quot;exchange_routing_inform&quot;;</div><div class="line">    private static final String ROUTINGKEY_SMS=&quot;inform_sms&quot;;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        //建立新连接</div><div class="line">        Connection connection = connectionFactory.newConnection();</div><div class="line">        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 参数明细</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">         */</div><div class="line">        channel.queueDeclare(QUEUE_INFORM_SMS,true,false,false,null);</div><div class="line">        //声明一个交换机</div><div class="line">        //参数：String exchange, String type</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、交换机的名称</div><div class="line">         * 2、交换机的类型</div><div class="line">         * fanout：对应的rabbitmq的工作模式是 publish/subscribe</div><div class="line">         * direct：对应的Routing	工作模式</div><div class="line">         * topic：对应的Topics工作模式</div><div class="line">         * headers： 对应的headers工作模式</div><div class="line">         */</div><div class="line">        channel.exchangeDeclare(EXCHANGE_ROUTING_INFORM, BuiltinExchangeType.DIRECT);</div><div class="line">        //进行交换机和队列绑定</div><div class="line">        //参数：String queue, String exchange, String routingKey</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、exchange 交换机名称</div><div class="line">         * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串</div><div class="line">         */</div><div class="line">        channel.queueBind(QUEUE_INFORM_SMS, EXCHANGE_ROUTING_INFORM,ROUTINGKEY_SMS);</div><div class="line"></div><div class="line">        //实现消费方法</div><div class="line">        DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 当接收到消息后此方法将被调用</div><div class="line">             * @param consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</div><div class="line">             * @param envelope 信封，通过envelope</div><div class="line">             * @param properties 消息属性</div><div class="line">             * @param body 消息内容</div><div class="line">             * @throws IOException</div><div class="line">             */</div><div class="line">            @Override</div><div class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">                //交换机</div><div class="line">                String exchange = envelope.getExchange();</div><div class="line">                //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</div><div class="line">                long deliveryTag = envelope.getDeliveryTag();</div><div class="line">                //消息内容</div><div class="line">                String message= new String(body,&quot;utf-8&quot;);</div><div class="line">                System.out.println(&quot;receive message:&quot;+message);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        //监听队列</div><div class="line">        //参数：String queue, boolean autoAck, Consumer callback</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</div><div class="line">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</div><div class="line">         */</div><div class="line">        channel.basicConsume(QUEUE_INFORM_SMS,true,defaultConsumer);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-测试-1"><a href="#4-测试-1" class="headerlink" title="4.测试"></a>4.测试</h4><p>1.启动生产者，打开RabbitMQ的管理界面，观察交换机绑定情况：</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567156445998.png" alt="1567156445998"></p>
<p>​    使用生产者发送若干条消息，交换机根据routingkey转发消息到指定的队列。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>Routing模式和Publish/subscibe的区别</p>
</blockquote>
<p>Routing模式要求队列在绑定交换机时要指定routingkey，消息会转发到符合routingkey的队列。</p>
<h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><p><img src="/2018/09/03/RabbitMQ消息队列/1567156552085.png" alt="1567156552085"></p>
<p>我们可以称它为加强版的Routing模式：</p>
<p>1、每个消费者监听自己的队列，并且设置带统配符的routingkey。<br>2、生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。</p>
<ul>
<li><p>(星号) 只能替换 1 个条件。</p>
</li>
<li><p>(井号) 可替换 0 或多个条件。</p>
</li>
</ul>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><p>​    根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种通知类型都接收的则两种通知都有效。</p>
<h4 id="1-生产者代码-2"><a href="#1-生产者代码-2" class="headerlink" title="1.生产者代码"></a>1.生产者代码</h4><p>声明交换机，指定topic类型：</p>
<blockquote>
<p>关键代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 声明交换机</div><div class="line"> * param1：交换机名称</div><div class="line"> * param2:交换机类型 四种交换机类型：direct、fanout、topic、headers</div><div class="line"> */</div><div class="line"> channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);</div><div class="line">//Email通知</div><div class="line">channel.basicPublish(EXCHANGE_TOPICS_INFORM, &quot;inform.email&quot;, null, message.getBytes());</div><div class="line">//sms通知</div><div class="line">channel.basicPublish(EXCHANGE_TOPICS_INFORM, &quot;inform.sms&quot;, null, message.getBytes());</div><div class="line">//两种都通知</div><div class="line">channel.basicPublish(EXCHANGE_TOPICS_INFORM, &quot;inform.sms.email&quot;, null, message.getBytes());</div></pre></td></tr></table></figure>
<blockquote>
<p>完整代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.rabbitmq.client.BuiltinExchangeType;</div><div class="line">import com.rabbitmq.client.Channel;</div><div class="line">import com.rabbitmq.client.Connection;</div><div class="line">import com.rabbitmq.client.ConnectionFactory;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"></div><div class="line">public class Producer04_topics &#123;</div><div class="line">    //队列名称</div><div class="line">    private static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;;</div><div class="line">    private static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;;</div><div class="line">    //交换机名称</div><div class="line">    private static final String EXCHANGE_TOPICS_INFORM=&quot;exchange_topics_inform&quot;;</div><div class="line">    //路由通配符</div><div class="line">    private static final String ROUTINGKEY_EMAIL=&quot;inform.#.email.#&quot;;</div><div class="line">    private static final String ROUTINGKEY_SMS=&quot;inform.#.sms.#&quot;;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        Connection connection = null;</div><div class="line">        Channel channel = null;</div><div class="line">        try &#123;</div><div class="line">            //建立新连接</div><div class="line">            connection = connectionFactory.newConnection();</div><div class="line">            //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">            channel = connection.createChannel();</div><div class="line">            //声明队列，如果队列在mq 中没有则要创建</div><div class="line">            //参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</div><div class="line">            /**</div><div class="line">             * 参数明细</div><div class="line">             * 1、queue 队列名称</div><div class="line">             * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">             * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">             * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">             * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">             */</div><div class="line">            channel.queueDeclare(QUEUE_INFORM_EMAIL,true,false,false,null);</div><div class="line">            channel.queueDeclare(QUEUE_INFORM_SMS,true,false,false,null);</div><div class="line">            //声明一个交换机</div><div class="line">            //参数：String exchange, String type</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、交换机的名称</div><div class="line">             * 2、交换机的类型</div><div class="line">             * fanout：对应的rabbitmq的工作模式是 publish/subscribe</div><div class="line">             * direct：对应的Routing	工作模式</div><div class="line">             * topic：对应的Topics工作模式</div><div class="line">             * headers： 对应的headers工作模式</div><div class="line">             */</div><div class="line">            channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);</div><div class="line">            //进行交换机和队列绑定</div><div class="line">            //参数：String queue, String exchange, String routingKey</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、queue 队列名称</div><div class="line">             * 2、exchange 交换机名称</div><div class="line">             * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串</div><div class="line">             */</div><div class="line">            channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_TOPICS_INFORM,ROUTINGKEY_EMAIL);</div><div class="line">            channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_TOPICS_INFORM,ROUTINGKEY_SMS);</div><div class="line">            //发送消息</div><div class="line">            //参数：String exchange, String routingKey, BasicProperties props, byte[] body</div><div class="line">            /**</div><div class="line">             * 参数明细：</div><div class="line">             * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为&quot;&quot;）</div><div class="line">             * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</div><div class="line">             * 3、props，消息的属性</div><div class="line">             * 4、body，消息内容</div><div class="line">             */</div><div class="line">            for(int i=0;i&lt;5;i++)&#123;</div><div class="line">                //发送消息的时候指定routingKey</div><div class="line">                String message = &quot;send email inform message to user&quot;;</div><div class="line">                channel.basicPublish(EXCHANGE_TOPICS_INFORM,&quot;inform.email&quot;,null,message.getBytes());</div><div class="line">                System.out.println(&quot;send to mq &quot;+message);</div><div class="line">            &#125;</div><div class="line">            for(int i=0;i&lt;5;i++)&#123;</div><div class="line">                //发送消息的时候指定routingKey</div><div class="line">                String message = &quot;send sms inform message to user&quot;;</div><div class="line">                channel.basicPublish(EXCHANGE_TOPICS_INFORM,&quot;inform.sms&quot;,null,message.getBytes());</div><div class="line">                System.out.println(&quot;send to mq &quot;+message);</div><div class="line">            &#125;</div><div class="line">            for(int i=0;i&lt;5;i++)&#123;</div><div class="line">                //发送消息的时候指定routingKey</div><div class="line">                String message = &quot;send sms and email inform message to user&quot;;</div><div class="line">                channel.basicPublish(EXCHANGE_TOPICS_INFORM,&quot;inform.sms.email&quot;,null,message.getBytes());</div><div class="line">                System.out.println(&quot;send to mq &quot;+message);</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            //关闭连接</div><div class="line">            //先关闭通道</div><div class="line">            try &#123;</div><div class="line">                channel.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (TimeoutException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析一下规则：</p>
<p>在上面的代码中我们定义了下面两个通配符规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  //路由通配符</div><div class="line">private static final String ROUTINGKEY_EMAIL=&quot;inform.#.email.#&quot;;</div><div class="line">private static final String ROUTINGKEY_SMS=&quot;inform.#.sms.#&quot;;</div></pre></td></tr></table></figure>
<p><code>#</code> 可以匹配多个词，符号*可以匹配一个词语。</p>
<p>  举例子：</p>
<p>   inform.email 和 inform.sms 分别满足上面的ROUTINGKEY_EMAIL和ROUTINGKEY_SMS，所以消息各自发送到sms队列和email队列，因为#在这里是0个。</p>
<p>那么当inform.sms.email时，同时满足ROUTINGKEY_EMAIL和ROUTINGKEY_SMS，也就是说他把消息<strong>同时发送到</strong>sms队列和email队列。</p>
<h4 id="2-邮件消费者-1"><a href="#2-邮件消费者-1" class="headerlink" title="2.邮件消费者"></a>2.邮件消费者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.rabbitmq.client.*;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer04_topics_email &#123;</div><div class="line">    //队列名称</div><div class="line">    private static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;;</div><div class="line">    private static final String EXCHANGE_TOPICS_INFORM=&quot;exchange_topics_inform&quot;;</div><div class="line">    private static final String ROUTINGKEY_EMAIL=&quot;inform.#.email.#&quot;;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        //建立新连接</div><div class="line">        Connection connection = connectionFactory.newConnection();</div><div class="line">        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 参数明细</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">         */</div><div class="line">        channel.queueDeclare(QUEUE_INFORM_EMAIL,true,false,false,null);</div><div class="line">        //声明一个交换机</div><div class="line">        //参数：String exchange, String type</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、交换机的名称</div><div class="line">         * 2、交换机的类型</div><div class="line">         * fanout：对应的rabbitmq的工作模式是 publish/subscribe</div><div class="line">         * direct：对应的Routing	工作模式</div><div class="line">         * topic：对应的Topics工作模式</div><div class="line">         * headers： 对应的headers工作模式</div><div class="line">         */</div><div class="line">        channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);</div><div class="line">        //进行交换机和队列绑定</div><div class="line">        //参数：String queue, String exchange, String routingKey</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、exchange 交换机名称</div><div class="line">         * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串</div><div class="line">         */</div><div class="line">        channel.queueBind(QUEUE_INFORM_EMAIL, EXCHANGE_TOPICS_INFORM,ROUTINGKEY_EMAIL);</div><div class="line"></div><div class="line">        //实现消费方法</div><div class="line">        DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 当接收到消息后此方法将被调用</div><div class="line">             * @param consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</div><div class="line">             * @param envelope 信封，通过envelope</div><div class="line">             * @param properties 消息属性</div><div class="line">             * @param body 消息内容</div><div class="line">             * @throws IOException</div><div class="line">             */</div><div class="line">            @Override</div><div class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">                //交换机</div><div class="line">                String exchange = envelope.getExchange();</div><div class="line">                //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</div><div class="line">                long deliveryTag = envelope.getDeliveryTag();</div><div class="line">                //消息内容</div><div class="line">                String message= new String(body,&quot;utf-8&quot;);</div><div class="line">                System.out.println(&quot;receive message:&quot;+message);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        //监听队列</div><div class="line">        //参数：String queue, boolean autoAck, Consumer callback</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</div><div class="line">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</div><div class="line">         */</div><div class="line">        channel.basicConsume(QUEUE_INFORM_EMAIL,true,defaultConsumer);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-短信消费者-1"><a href="#3-短信消费者-1" class="headerlink" title="3.短信消费者"></a>3.短信消费者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.rabbitmq.client.*;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"></div><div class="line">public class Consumer04_topics_sms &#123;</div><div class="line">    //队列名称</div><div class="line">    private static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;;</div><div class="line">    private static final String EXCHANGE_TOPICS_INFORM=&quot;exchange_topics_inform&quot;;</div><div class="line">    private static final String ROUTINGKEY_SMS=&quot;inform.#.sms.#&quot;;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</div><div class="line">        //通过连接工厂创建新的连接和mq建立连接</div><div class="line">        ConnectionFactory connectionFactory = new ConnectionFactory();</div><div class="line">        connectionFactory.setHost(&quot;127.0.0.1&quot;);</div><div class="line">        connectionFactory.setPort(5672);//端口</div><div class="line">        connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">        connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line">        //设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</div><div class="line">        connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line"></div><div class="line">        //建立新连接</div><div class="line">        Connection connection = connectionFactory.newConnection();</div><div class="line">        //创建会话通道,生产者和mq服务所有通信都在channel通道中完成</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 参数明细</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</div><div class="line">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</div><div class="line">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</div><div class="line">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</div><div class="line">         */</div><div class="line">        channel.queueDeclare(QUEUE_INFORM_SMS,true,false,false,null);</div><div class="line">        //声明一个交换机</div><div class="line">        //参数：String exchange, String type</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、交换机的名称</div><div class="line">         * 2、交换机的类型</div><div class="line">         * fanout：对应的rabbitmq的工作模式是 publish/subscribe</div><div class="line">         * direct：对应的Routing	工作模式</div><div class="line">         * topic：对应的Topics工作模式</div><div class="line">         * headers： 对应的headers工作模式</div><div class="line">         */</div><div class="line">        channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);</div><div class="line">        //进行交换机和队列绑定</div><div class="line">        //参数：String queue, String exchange, String routingKey</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、exchange 交换机名称</div><div class="line">         * 3、routingKey 路由key，作用是交换机根据路由key的值将消息转发到指定的队列中，在发布订阅模式中调协为空字符串</div><div class="line">         */</div><div class="line">        channel.queueBind(QUEUE_INFORM_SMS, EXCHANGE_TOPICS_INFORM,ROUTINGKEY_SMS);</div><div class="line"></div><div class="line">        //实现消费方法</div><div class="line">        DefaultConsumer defaultConsumer = new DefaultConsumer(channel)&#123;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 当接收到消息后此方法将被调用</div><div class="line">             * @param consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</div><div class="line">             * @param envelope 信封，通过envelope</div><div class="line">             * @param properties 消息属性</div><div class="line">             * @param body 消息内容</div><div class="line">             * @throws IOException</div><div class="line">             */</div><div class="line">            @Override</div><div class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">                //交换机</div><div class="line">                String exchange = envelope.getExchange();</div><div class="line">                //消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</div><div class="line">                long deliveryTag = envelope.getDeliveryTag();</div><div class="line">                //消息内容</div><div class="line">                String message= new String(body,&quot;utf-8&quot;);</div><div class="line">                System.out.println(&quot;receive message:&quot;+message);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        //监听队列</div><div class="line">        //参数：String queue, boolean autoAck, Consumer callback</div><div class="line">        /**</div><div class="line">         * 参数明细：</div><div class="line">         * 1、queue 队列名称</div><div class="line">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</div><div class="line">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</div><div class="line">         */</div><div class="line">        channel.basicConsume(QUEUE_INFORM_SMS,true,defaultConsumer);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-测试-2"><a href="#4-测试-2" class="headerlink" title="4.测试"></a>4.测试</h4><p>1.启动生产者</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567157217159.png" alt="1567157217159"></p>
<p>查看浏览器控制台</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567157243650.png" alt="1567157243650"></p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567157280899.png" alt="1567157280899"></p>
<p>查看生产者代码解释为什么各自有10条消息</p>
<p><img src="/2018/09/03/RabbitMQ消息队列/1567157785810.png" alt="1567157785810"></p>
<p>使用生产者发送若干条消息，交换机根据routingkey统配符匹配并转发消息到指定的队列。所以这里两个队列各拥有10条消息。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>本案例的需求使用Routing工作模式能否实现</p>
</blockquote>
<p>​    上面的案例的本质就是通过通配符的方式。我们可以使用Routing精确匹配也可实现。</p>
<p>使用Routing模式也可以实现本案例，共设置三个 routingkey，分别是email、sms、all，email队列绑定email和all，sms队列绑定sms和all，这样就可以实现上边案例的功能，实现过程比topics复杂。</p>
<p>Topic模式更多加强大，它可以实现Routing、publish/subscirbe模式的功能。</p>
<h2 id="Header模式"><a href="#Header模式" class="headerlink" title="Header模式"></a>Header模式</h2><p> header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。</p>
<h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><p>根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种<br>通知类型都接收的则两种通知都有效。</p>
<h4 id="1-生产者代码-3"><a href="#1-生产者代码-3" class="headerlink" title="1.生产者代码"></a>1.生产者代码</h4><p>队列与交换机绑定的代码与之前不同，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Map&lt;String, Object&gt; headers_email = new Hashtable&lt;String, Object&gt;();</div><div class="line">headers_email.put(&quot;inform_type&quot;, &quot;email&quot;);</div><div class="line">Map&lt;String, Object&gt; headers_sms = new Hashtable&lt;String, Object&gt;();</div><div class="line">headers_sms.put(&quot;inform_type&quot;, &quot;sms&quot;);</div><div class="line">channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,&quot;&quot;,headers_email);</div><div class="line">channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_HEADERS_INFORM,&quot;&quot;,headers_sms);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">String message = &quot;email inform to user&quot;+i;</div><div class="line">Map&lt;String,Object&gt; headers =  new Hashtable&lt;String, Object&gt;();</div><div class="line">headers.put(&quot;inform_type&quot;, &quot;email&quot;);//匹配email通知消费者绑定的header</div><div class="line">//headers.put(&quot;inform_type&quot;, &quot;sms&quot;);//匹配sms通知消费者绑定的header</div><div class="line">AMQP.BasicProperties.Builder properties = new AMQP.BasicProperties.Builder();</div><div class="line">properties.headers(headers);</div><div class="line">//Email通知</div><div class="line">channel.basicPublish(EXCHANGE_HEADERS_INFORM, &quot;&quot;, properties.build(), message.getBytes());</div></pre></td></tr></table></figure>
<h4 id="2-邮件消费者-2"><a href="#2-邮件消费者-2" class="headerlink" title="2.邮件消费者"></a>2.邮件消费者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">channel.exchangeDeclare(EXCHANGE_HEADERS_INFORM, BuiltinExchangeType.HEADERS);</div><div class="line">Map&lt;String, Object&gt; headers_email = new Hashtable&lt;String, Object&gt;();</div><div class="line">headers_email.put(&quot;inform_email&quot;, &quot;email&quot;);</div><div class="line">//交换机和队列绑定</div><div class="line">channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,&quot;&quot;,headers_email);</div><div class="line">//指定消费队列</div><div class="line">channel.basicConsume(QUEUE_INFORM_EMAIL, true, consumer);</div></pre></td></tr></table></figure>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><img src="/2018/09/03/RabbitMQ消息队列/1567158140946.png" alt="1567158140946"></p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><img src="/2018/09/03/RabbitMQ消息队列/1567158158985.png" alt="1567158158985"></p>
<p>RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现，流程如下：<br>1、客户端即是生产者就是消费者，向RPC请求队列发送RPC调用消息，同时监听RPC响应队列。<br>2、服务端监听RPC请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果<br>3、服务端将RPC方法 的结果发送到RPC响应队列<br>4、客户端（RPC调用方）监听RPC响应队列，接收到RPC调用结果。</p>
<h1 id="Spring整合RibbitMQ"><a href="#Spring整合RibbitMQ" class="headerlink" title="Spring整合RibbitMQ"></a>Spring整合RibbitMQ</h1><p>我们选择基于Spring-Rabbit去操作RabbitMQ</p>
<p><a href="https://github.com/spring-projects/spring-amqp" target="_blank" rel="external">https://github.com/spring-projects/spring-amqp</a></p>
<p>使用spring-boot-starter-amqp会自动添加spring-rabbit依赖，所以注释掉我们上面使用的java client方式引入的amqp-client依赖。</p>
<h2 id="生产者修改"><a href="#生产者修改" class="headerlink" title="生产者修改"></a>生产者修改</h2><h3 id="pom文件修改为"><a href="#pom文件修改为" class="headerlink" title="pom文件修改为"></a>pom文件修改为</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    &lt;dependencies&gt;</div><div class="line">&lt;!--        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;4.0.3&lt;/version&gt;&amp;lt;!&amp;ndash;此版本与spring boot 1.5.9版本匹配&amp;ndash;&amp;gt;</div><div class="line">        &lt;/dependency&gt;--&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">    &lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<h3 id="application-yml配置文件"><a href="#application-yml配置文件" class="headerlink" title="application.yml配置文件"></a>application.yml配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 44004</div><div class="line">spring:</div><div class="line">  application:</div><div class="line">    name: test-rabbitmq-consumer</div><div class="line">  rabbitmq:</div><div class="line">    host: 127.0.0.1</div><div class="line">    port: 5672</div><div class="line">    username: guest</div><div class="line">    password: guest</div><div class="line">    virtualHost: /</div></pre></td></tr></table></figure>
<h3 id="定义RabbitConﬁg类，配置Exchange、Queue、及绑定交换机"><a href="#定义RabbitConﬁg类，配置Exchange、Queue、及绑定交换机" class="headerlink" title="定义RabbitConﬁg类，配置Exchange、Queue、及绑定交换机"></a>定义RabbitConﬁg类，配置Exchange、Queue、及绑定交换机</h3><p>这里以配置Topics模式为例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.springframework.amqp.core.*;</div><div class="line">import org.springframework.beans.factory.annotation.Qualifier;</div><div class="line">import org.springframework.context.annotation.Bean;</div><div class="line">import org.springframework.context.annotation.Configuration;</div><div class="line"></div><div class="line">@Configuration</div><div class="line">public class RabbitmqConfig &#123;</div><div class="line">    public static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;;</div><div class="line">    public static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;;</div><div class="line">    public static final String EXCHANGE_TOPICS_INFORM=&quot;exchange_topics_inform&quot;;</div><div class="line">    public static final String ROUTINGKEY_EMAIL=&quot;inform.#.email.#&quot;;</div><div class="line">    public static final String ROUTINGKEY_SMS=&quot;inform.#.sms.#&quot;;</div><div class="line"></div><div class="line">    //声明交换机</div><div class="line">    @Bean(EXCHANGE_TOPICS_INFORM)</div><div class="line">    public Exchange EXCHANGE_TOPICS_INFORM()&#123;</div><div class="line">        //durable(true) 持久化，mq重启之后交换机还在</div><div class="line">        return ExchangeBuilder.topicExchange(EXCHANGE_TOPICS_INFORM).durable(true).build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //声明QUEUE_INFORM_EMAIL队列</div><div class="line">    @Bean(QUEUE_INFORM_EMAIL)</div><div class="line">    public Queue QUEUE_INFORM_EMAIL()&#123;</div><div class="line">        return new Queue(QUEUE_INFORM_EMAIL);</div><div class="line">    &#125;</div><div class="line">    //声明QUEUE_INFORM_SMS队列</div><div class="line">    @Bean(QUEUE_INFORM_SMS)</div><div class="line">    public Queue QUEUE_INFORM_SMS()&#123;</div><div class="line">        return new Queue(QUEUE_INFORM_SMS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //ROUTINGKEY_EMAIL队列绑定交换机，指定routingKey</div><div class="line">    @Bean</div><div class="line">    public Binding BINDING_QUEUE_INFORM_EMAIL(@Qualifier(QUEUE_INFORM_EMAIL) Queue queue,</div><div class="line">                                              @Qualifier(EXCHANGE_TOPICS_INFORM) Exchange exchange)&#123;</div><div class="line">        return BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY_EMAIL).noargs();</div><div class="line">    &#125;</div><div class="line">    //ROUTINGKEY_SMS队列绑定交换机，指定routingKey</div><div class="line">    @Bean</div><div class="line">    public Binding BINDING_ROUTINGKEY_SMS(@Qualifier(QUEUE_INFORM_SMS) Queue queue,</div><div class="line">                                              @Qualifier(EXCHANGE_TOPICS_INFORM) Exchange exchange)&#123;</div><div class="line">        return BindingBuilder.bind(queue).to(exchange).with(ROUTINGKEY_SMS).noargs();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p>使用RarbbitTemplate发送消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.alibaba.fastjson.JSON;</div><div class="line">import com.xuecheng.test.rabbitmq.config.RabbitmqConfig;</div><div class="line">import org.junit.Test;</div><div class="line">import org.junit.runner.RunWith;</div><div class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</div><div class="line">import org.springframework.beans.factory.annotation.Autowired;</div><div class="line">import org.springframework.boot.test.context.SpringBootTest;</div><div class="line">import org.springframework.test.context.junit4.SpringRunner;</div><div class="line"></div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line"></div><div class="line"></div><div class="line">@SpringBootTest</div><div class="line">@RunWith(SpringRunner.class)</div><div class="line">public class Producer05_topics_springboot &#123;</div><div class="line">    @Autowired</div><div class="line">    RabbitTemplate rabbitTemplate;</div><div class="line"></div><div class="line">    //使用rabbitTemplate发送消息</div><div class="line">    @Test</div><div class="line">    public void testSendEmail()&#123;</div><div class="line"></div><div class="line">        String message = &quot;send email message to user&quot;;</div><div class="line">        /**</div><div class="line">         * 参数：</div><div class="line">         * 1、交换机名称</div><div class="line">         * 2、routingKey</div><div class="line">         * 3、消息内容</div><div class="line">         */</div><div class="line">        rabbitTemplate.convertAndSend(RabbitmqConfig.EXCHANGE_TOPICS_INFORM,&quot;inform.email&quot;,message);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="消费端者修改"><a href="#消费端者修改" class="headerlink" title="消费端者修改"></a>消费端者修改</h2><h3 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    &lt;dependencies&gt;</div><div class="line">&lt;!--        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;4.0.3&lt;/version&gt;&amp;lt;!&amp;ndash;此版本与spring boot 1.5.9版本匹配&amp;ndash;&amp;gt;</div><div class="line">        &lt;/dependency&gt;--&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">        &lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</div><div class="line">        &lt;/dependency&gt;</div><div class="line">    &lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<h3 id="使用-RabbitListener注解监听队列"><a href="#使用-RabbitListener注解监听队列" class="headerlink" title="使用@RabbitListener注解监听队列"></a>使用@RabbitListener注解监听队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Component</div><div class="line">public class ReceiveHandler &#123;</div><div class="line"></div><div class="line">    @RabbitListener(queues = &#123;RabbitmqConfig.QUEUE_INFORM_EMAIL&#125;)</div><div class="line">    public void receive_email(String msg,Message message,Channel channel)&#123;</div><div class="line">        System.out.println(&quot;receive message is:&quot;+msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RabbitMQ-简介&quot;&gt;&lt;a href=&quot;#RabbitMQ-简介&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 简介&quot;&gt;&lt;/a&gt;RabbitMQ 简介&lt;/h1&gt;&lt;p&gt;​         MQ全称为Message Queue，即消息队列
    
    </summary>
    
      <category term="消息队列" scheme="http://kingge.top/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="RabbitMq" scheme="http://kingge.top/tags/RabbitMq/"/>
    
      <category term="消息队列" scheme="http://kingge.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="分布式通信" scheme="http://kingge.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>hive总结</title>
    <link href="http://kingge.top/2018/05/16/hive%E6%80%BB%E7%BB%93/"/>
    <id>http://kingge.top/2018/05/16/hive总结/</id>
    <published>2018-05-15T16:00:00.000Z</published>
    <updated>2020-05-09T09:39:59.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Hive基本概念"><a href="#一-Hive基本概念" class="headerlink" title="一 Hive基本概念"></a>一 Hive基本概念</h1><h2 id="1-1-什么是Hive"><a href="#1-1-什么是Hive" class="headerlink" title="1.1 什么是Hive"></a>1.1 什么是Hive</h2><p>Hive：由Facebook开源<strong>用于解决海量结构化日志的数据统计</strong>。</p>
<p>Hive是基于Hadoop的一个<strong>数据仓库工具</strong>，可以将<strong>结构化的数据文件映射为一张表</strong>，并提供类SQL查询功能。</p>
<p>本质是：<strong>将HQL转化成MapReduce程序（所说他是基于Hadoop）</strong></p>
<p>1）Hive处理的数据存储在HDFS（hive元数据存储在用户配置的数据库里面）</p>
<p>2）Hive分析数据底层的实现是MapReduce</p>
<p>3）执行程序运行在Yarn上</p>
<h2 id="1-2-Hive的优缺点"><a href="#1-2-Hive的优缺点" class="headerlink" title="1.2 Hive的优缺点"></a>1.2 Hive的优缺点</h2><h3 id="1-2-1-优点"><a href="#1-2-1-优点" class="headerlink" title="1.2.1 优点"></a>1.2.1 优点</h3><p>1）操作接口采用类SQL语法，提供快速开发的能力（简单、容易上手）</p>
<p>2）避免了去写MapReduce，减少开发人员的学习成本。</p>
<p>3）Hive的执行延迟比较高，<strong>因此Hive常用于数据分析，对实时性要求不高的场合；（mysql实时性就比较快，但是如果数据量很大-上亿，那么mysql就会崩溃-所以一般业务场景是hive和mysql 配合使用）</strong></p>
<p>4）Hive优势在于处理大数据，<strong>对于处理小数据没有优势，因为Hive的执行延迟比较高。</strong></p>
<p>5）Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。</p>
<h3 id="1-2-2-缺点"><a href="#1-2-2-缺点" class="headerlink" title="1.2.2 缺点"></a>1.2.2 缺点</h3><p>1）Hive的HQL表达能力有限（<strong><em>也就是说，部分复杂的业务场景，需要用户自己实现***</em></strong>MapReduce***）</p>
<p>（1）迭代式算法无法表达</p>
<p>（2）数据挖掘方面不擅长</p>
<p>2）Hive的效率比较低</p>
<p>（1）Hive自动生成的MapReduce作业，通常情况下不够智能化</p>
<p>（2）Hive调优比较困难，粒度较粗</p>
<h2 id="1-3-Hive架构原理（图要记住）"><a href="#1-3-Hive架构原理（图要记住）" class="headerlink" title="1.3 Hive架构原理（图要记住）"></a>1.3 Hive架构原理（图要记住）</h2><p>​         <img src="/2018/05/16/hive总结/image-20200509172339054.png" alt="image-20200509172339054">       </p>
<p>​    如图中所示，Hive通过给用户提供的一系列交互接口，接收到用户的指令(SQL)，使用自己的Driver，结合元数据(MetaStore)，将这些指令翻译成MapReduce，提交到Hadoop中执行，最后，将执行返回的结果输出到用户交互接口。</p>
<p>1）用户接口：Client</p>
<p>CLI（hive shell）、JDBC/ODBC(java访问hive)、WEBUI（浏览器访问hive）</p>
<p>2）元数据：Metastore</p>
<p>元数据包括：表名、表所属的数据库（默认是default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等；</p>
<p><strong>默认存储在自带的derby数据库中，推荐使用MySQL存储Metastore</strong></p>
<p>3）Hadoop</p>
<p>使用HDFS进行存储，使用MapReduce进行计算。</p>
<p>4）驱动器：Driver</p>
<p>（1）解析器（SQL Parser）：将SQL字符串转换成抽象语法树AST，这一步一般都用第三方工具库完成，比如antlr；对AST进行语法分析，比如表是否存在、字段是否存在、SQL语义是否有误。</p>
<p>（2）编译器（Physical Plan）：将AST编译生成逻辑执行计划。</p>
<p>（3）优化器（Query Optimizer）：对逻辑执行计划进行优化。</p>
<p>（4）执行器（Execution）：把逻辑执行计划转换成可以运行的物理计划。对于Hive来说，就是MR/Spark。</p>
<h2 id="1-4-Hive和数据库比较"><a href="#1-4-Hive和数据库比较" class="headerlink" title="1.4 Hive和数据库比较"></a>1.4 Hive和数据库比较</h2><p>由于 Hive 采用了类似SQL 的查询语言 HQL(Hive Query Language)，因此很容易将 Hive 理解为数据库。其实从结构上来看，Hive 和数据库除了拥有类似的查询语言，再无类似之处。本文将从多个方面来阐述 Hive 和数据库的差异。数据库可以用在 Online 的应用中，但是Hive 是为数据仓库而设计的，清楚这一点，有助于从应用角度理解 Hive 的特性。</p>
<h3 id="1-4-1-查询语言"><a href="#1-4-1-查询语言" class="headerlink" title="1.4.1 查询语言"></a>1.4.1 查询语言</h3><p>由于SQL被广泛的应用在数据仓库中，因此，专门针对Hive的特性设计了类SQL的查询语言HQL。熟悉SQL开发的开发者可以很方便的使用Hive进行开发。</p>
<h3 id="1-4-2-数据存储位置"><a href="#1-4-2-数据存储位置" class="headerlink" title="1.4.2 数据存储位置"></a>1.4.2 数据存储位置</h3><p>Hive 是建立在 Hadoop 之上的，所有 Hive 的数据都是存储在 HDFS 中的。而数据库则可以将数据保存在块设备或者本地文件系统中。</p>
<h3 id="1-4-3-数据更新"><a href="#1-4-3-数据更新" class="headerlink" title="1.4.3 数据更新"></a>1.4.3 数据更新</h3><p>由于Hive是针对数据仓库应用设计的，而<strong>数据仓库的内容是读多写少的</strong>。因此，<strong>Hive中不支持对数据的改写和添加，所有的数据都是在加载的时候确定好的</strong>。而数据库中的数据通常是需要经常进行修改的，因此可以使用 INSERT INTO … VALUES 添加数据，使用 UPDATE … SET修改数据。</p>
<h3 id="1-4-4-索引"><a href="#1-4-4-索引" class="headerlink" title="1.4.4 索引"></a>1.4.4 索引</h3><p>Hive在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此也没有对数据中的某些Key建立索引。<strong><em>Hive***</em></strong>要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高*<strong>。由于 MapReduce 的引入， Hive 可以并行访问数据，因此即使没有索引，对于<a href="http://lib.csdn.net/base/hadoop" target="_blank" rel="external">大数据</a>量的访问，Hive 仍然可以体现出优势。数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。*</strong>由于数据的访问延迟较高，决定了*<strong> *</strong>Hive*<strong> *</strong>不适合在线数据查询。***</p>
<h3 id="1-4-5-执行"><a href="#1-4-5-执行" class="headerlink" title="1.4.5 执行"></a>1.4.5 执行</h3><p>Hive中大多数查询的执行是通过 Hadoop 提供的 MapReduce 来实现的。而数据库通常有自己的执行引擎。</p>
<h3 id="1-4-6-执行延迟"><a href="#1-4-6-执行延迟" class="headerlink" title="1.4.6 执行延迟"></a>1.4.6 执行延迟</h3><p>Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致 Hive 执行延迟高的因素是 MapReduce框架。由于MapReduce 本身具有较高的延迟，因此在利用MapReduce 执行Hive查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。</p>
<h3 id="1-4-7-可扩展性"><a href="#1-4-7-可扩展性" class="headerlink" title="1.4.7 可扩展性"></a>1.4.7 可扩展性</h3><p>由于Hive是建立在Hadoop之上的，因此Hive的可扩展性是和Hadoop的可扩展性是一致的（世界上最大的Hadoop 集群在 Yahoo!，2009年的规模在4000 台节点左右）。而数据库由于 ACID 语义的严格限制，扩展行非常有限。目前最先进的并行数据库 <a href="http://lib.csdn.net/base/oracle" target="_blank" rel="external">Oracle</a> 在理论上的扩展能力也只有100台左右。</p>
<h3 id="1-4-8-数据规模"><a href="#1-4-8-数据规模" class="headerlink" title="1.4.8 数据规模"></a>1.4.8 数据规模</h3><p>由于Hive建立在集群上并可以利用MapReduce进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。</p>
<h3 id="1-4-9-hive元数据"><a href="#1-4-9-hive元数据" class="headerlink" title="1.4.9 hive元数据"></a>1.4.9 hive元数据</h3><p><a href="https://blog.csdn.net/xjp8587/article/details/81411879" target="_blank" rel="external">https://blog.csdn.net/xjp8587/article/details/81411879</a></p>
<p><a href="https://www.cnblogs.com/qingyunzong/p/8710356.html" target="_blank" rel="external">https://www.cnblogs.com/qingyunzong/p/8710356.html</a></p>
<p>Hive 的元数据信息通常存储在关系型数据库中，常用MySQL数据库作为元数据库管理（因为使用默认的derby数据库，只能提供给一个client使用-参见2.4）</p>
<p>里面存储了，hive数据库仓库相关的信息，例如，hive版本信息，创建了那些表，数据库或者表数据在hdfs存储的位置等等。</p>
<h1 id="二-Hive安装环境准备"><a href="#二-Hive安装环境准备" class="headerlink" title="二 Hive安装环境准备"></a>二 Hive安装环境准备</h1><h2 id="2-1-Hive安装地址"><a href="#2-1-Hive安装地址" class="headerlink" title="2.1 Hive安装地址"></a>2.1 Hive安装地址</h2><p>1）Hive官网地址：</p>
<p><a href="http://hive.apache.org/" target="_blank" rel="external">http://hive.apache.org/</a></p>
<p>2）文档查看地址：</p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/GettingStarted</a></p>
<p>3）下载地址：</p>
<p><a href="http://archive.apache.org/dist/hive/" target="_blank" rel="external">http://archive.apache.org/dist/hive/</a></p>
<p>4）github地址：</p>
<p><a href="https://github.com/apache/hive" target="_blank" rel="external">https://github.com/apache/hive</a></p>
<h2 id="2-2-Hive安装部署"><a href="#2-2-Hive安装部署" class="headerlink" title="2.2 Hive安装部署"></a>2.2 Hive安装部署</h2><p>1）Hive安装及配置</p>
<p>（1）把apache-hive-1.2.1-bin.tar.gz上传到linux的/opt/software目录下</p>
<p>（2）解压apache-hive-1.2.1-bin.tar.gz到/opt/module/目录下面</p>
<p>[kingge@hadoop102 software]$ tar -zxvf apache-hive-1.2.1-bin.tar.gz -C /opt/module/</p>
<p>（3）修改apache-hive-1.2.1-bin.tar.gz的名称为hive</p>
<p>[kingge@hadoop102 module]$ mv apache-hive-1.2.1-bin/ hive</p>
<p>（4）修改/opt/module/hive/conf目录下的hive-env.sh.template名称为hive-env.sh</p>
<p>[kingge@hadoop102 conf]$ mv hive-env.sh.template hive-env.sh</p>
<p>​    （5）配置hive-env.sh文件</p>
<p>​    （a）配置HADOOP_HOME路径</p>
<p>export HADOOP_HOME=/opt/module/hadoop-2.7.2</p>
<p>​    （b）配置HIVE_CONF_DIR路径</p>
<p>export HIVE_CONF_DIR=/opt/module/hive/conf</p>
<p>2）Hadoop集群配置</p>
<p>（1）必须启动hdfs和yarn</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ sbin/start-dfs.sh</p>
<p>[kingge@hadoop103 hadoop-2.7.2]$ sbin/start-yarn.sh</p>
<p>（2）在HDFS上创建/tmp和/user/hive/warehouse两个目录并修改他们的同组权限可写</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -mkdir /tmp</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -mkdir -p /user/hive/warehouse</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -chmod g+w /tmp</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -chmod g+w /user/hive/warehouse</p>
<p>3）Hive基本操作（<strong><em>默认操作***</em></strong>hive*<strong>*</strong>创建的default*<strong>*</strong>数据库***）</p>
<p>（1）启动hive</p>
<p>​    [kingge@hadoop102 hive]$ bin/hive</p>
<p>​    （2）查看数据库</p>
<p>​    hive&gt;show databases;</p>
<p>（3）打开默认数据库</p>
<p>​    hive&gt;use default;</p>
<p>（4）显示default数据库中的表</p>
<p>​    hive&gt;show tables;</p>
<p>（5）创建一张表</p>
<p>​    hive&gt; create table student(id int, name string) ;</p>
<p>（6）显示数据库中有几张表</p>
<p>​    hive&gt;show tables;</p>
<p>（7）查看表的结构</p>
<p>​    hive&gt;desc student;</p>
<p>（8）向表中插入数据</p>
<p>hive&gt; insert into student values(1000,”ss”);</p>
<p>（9）查询表中数据</p>
<p>​    hive&gt; select * from student;</p>
<p>（10）退出hive</p>
<p>​    hive&gt; quit;</p>
<p>你会发现，执行inset操作的时候实际上他是启动了一个mr程序-<strong><em>任何sql***</em></strong>操作都会转化成MapReduce*<strong>*</strong>来进行。***</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172559212.png" alt="image-20200509172559212"></p>
<h2 id="2-3-将本地文件导入Hive案例"><a href="#2-3-将本地文件导入Hive案例" class="headerlink" title="2.3 将本地文件导入Hive案例"></a>2.3 将本地文件导入Hive案例</h2><p><strong>需求</strong>：将本地/opt/module/datas/student.txt这个目录下的数据导入到hive的student(id int, name string)表中。</p>
<p>1）数据准备：在/opt/module/datas/student.txt这个目录下准备数据</p>
<p>（1）在/opt/module/目录下创建datas</p>
<p>​    [kingge@hadoop102 module]$ mkdir datas</p>
<p>（2）在/opt/module/datas/目录下创建student.txt文件并添加数据</p>
<p>​    [kingge@hadoop102 datas]$ touch student.txt</p>
<p>[kingge@hadoop102 datas]$ vi student.txt</p>
<p>1001    zhangshan</p>
<p>1002    lishi</p>
<p>1003    zhaoliu</p>
<p>注意以tab键间隔。</p>
<p>2）Hive实际操作</p>
<p>（1）启动hive</p>
<p>​    [kingge@hadoop102 hive]$ bin/hive</p>
<p>（2）显示数据库</p>
<p>hive&gt;show databases;</p>
<p>（3）使用default数据库</p>
<p>​    hive&gt;use default;</p>
<p>（4）显示default数据库中的表</p>
<p>​    hive&gt;show tables;</p>
<p>（5）删除已创建的student表</p>
<p>hive&gt; drop table student;</p>
<p>（6）创建student表, 并声明文件分隔符’\t’</p>
<p>​    hive&gt; create table student(id int, name string) ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘\t’;</p>
<p>（7）加载/opt/module/datas/student.txt 文件到student数据库表中。</p>
<p>​    hive&gt; load data local inpath ‘/opt/module/datas/student.txt’ into table student;</p>
<p>（8）Hive查询结果</p>
<p>hive&gt; select * from student;</p>
<p>OK</p>
<p>1001    zhangshan</p>
<p>1002    lishi</p>
<p>1003    zhaoliu</p>
<p>Time taken: 0.266 seconds, Fetched: 3 row(s)</p>
<h2 id="2-4-遇到的问题（默认Derby数据库）"><a href="#2-4-遇到的问题（默认Derby数据库）" class="headerlink" title="2.4 遇到的问题（默认Derby数据库）"></a>2.4 遇到的问题（默认Derby数据库）</h2><p>再打开一个客户端窗口启动hive，会产生java.sql.SQLException异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</div><div class="line">        at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:522)</div><div class="line">        at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:677)</div><div class="line">        at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:621)</div><div class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</div><div class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">        at java.lang.reflect.Method.invoke(Method.java:606)</div><div class="line">        at org.apache.hadoop.util.RunJar.run(RunJar.java:221)</div><div class="line">        at org.apache.hadoop.util.RunJar.main(RunJar.java:136)</div><div class="line">Caused by: java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</div><div class="line">        at org.apache.hadoop.hive.metastore.MetaStoreUtils.newInstance(MetaStoreUtils.java:1523)</div><div class="line">        at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.&lt;init&gt;(RetryingMetaStoreClient.java:86)</div><div class="line">        at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.getProxy(RetryingMetaStoreClient.java:132)</div><div class="line">        at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.getProxy(RetryingMetaStoreClient.java:104)</div><div class="line">        at org.apache.hadoop.hive.ql.metadata.Hive.createMetaStoreClient(Hive.java:3005)</div><div class="line">        at org.apache.hadoop.hive.ql.metadata.Hive.getMSC(Hive.java:3024)</div><div class="line">        at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:503)</div><div class="line">        ... 8 more</div></pre></td></tr></table></figure>
<p>原因是，Metastore默认存储在自带的derby数据库中，推荐使用MySQL存储Metastore;</p>
<p>官方文档已经说明，这个默认数据库仅限于测试使用，而且只能够允许一个客户端访问</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172636573.png" alt="image-20200509172636573"></p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+Metastore+3.0+Administration#AdminManualMetastore3.0Administration-Option2:ExternalRDBMS" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/AdminManual+Metastore+3.0+Administration#AdminManualMetastore3.0Administration-Option2:ExternalRDBMS</a></p>
<h2 id="2-4-MySql安装"><a href="#2-4-MySql安装" class="headerlink" title="2.4 MySql安装"></a>2.4 MySql安装</h2><h3 id="2-4-1-安装包准备"><a href="#2-4-1-安装包准备" class="headerlink" title="2.4.1 安装包准备"></a>2.4.1 安装包准备</h3><p>1）查看mysql是否安装，如果安装了，卸载mysql</p>
<p>​    （1）查看</p>
<p>​    [root@hadoop102 桌面]# rpm -qa|grep mysql</p>
<p>mysql-libs-5.1.73-7.el6.x86_64</p>
<p>​    （2）卸载</p>
<p>​    [root@hadoop102 桌面]# rpm -e –nodeps mysql-libs-5.1.73-7.el6.x86_64</p>
<p>2）解压mysql-libs.zip文件到当前目录</p>
<p>[root@hadoop102 software]# unzip mysql-libs.zip</p>
<p>​    [root@hadoop102 software]# ls</p>
<p>mysql-libs.zip</p>
<p>mysql-libs         </p>
<p>3）进入到mysql-libs文件夹下，并设置当前用户执行权限</p>
<p>[root@hadoop102 mysql-libs]# ll</p>
<p>总用量 76048</p>
<p>-rw-r–r–. 1 root root 18509960 3月 26 2015 MySQL-client-5.6.24-1.el6.x86_64.rpm</p>
<p>-rw-r–r–. 1 root root 3575135 12月 1 2013 mysql-connector-java-5.1.27.tar.gz</p>
<p>-rw-r–r–. 1 root root 55782196 3月 26 2015 MySQL-server-5.6.24-1.el6.x86_64.rpm</p>
<p>[root@hadoop102 mysql-libs]# chmod u+x ./*</p>
<p>[root@hadoop102 mysql-libs]# ll</p>
<p>总用量 76048</p>
<p>-rwxr–r–. 1 root root 18509960 3月 26 2015 MySQL-client-5.6.24-1.el6.x86_64.rpm</p>
<p>-rwxr–r–. 1 root root 3575135 12月 1 2013 mysql-connector-java-5.1.27.tar.gz</p>
<p>-rwxr–r–. 1 root root 55782196 3月 26 2015 MySQL-server-5.6.24-1.el6.x86_64.rpm</p>
<h3 id="2-4-2-安装MySql服务器（建议使用root用户进行操作-涉及到某些目录）"><a href="#2-4-2-安装MySql服务器（建议使用root用户进行操作-涉及到某些目录）" class="headerlink" title="2.4.2 安装MySql服务器（建议使用root用户进行操作-涉及到某些目录）"></a>2.4.2 安装MySql服务器（<em>建议使用<strong>root</strong>用户进行操作<strong>-</strong>涉及到某些目录</em>）</h3><p>1）安装mysql服务端</p>
<p>[<strong><em>root\</em></strong>@hadoop102 mysql-libs]# rpm -ivh MySQL-server-5.6.24-1.el6.x86_64.rpm</p>
<p>2）查看产生的随机密码</p>
<p>[<strong><em>root\</em></strong>@hadoop102 mysql-libs]# cat /root/.mysql_secret</p>
<p>​    OEXaQuS8IWkG19Xs</p>
<p>3）查看mysql状态</p>
<p>​    [root@hadoop102 mysql-libs]# service mysql status</p>
<p>4）启动mysql</p>
<p>​    [root@hadoop102 mysql-libs]# service mysql start</p>
<h3 id="2-4-3-安装MySql客户端"><a href="#2-4-3-安装MySql客户端" class="headerlink" title="2.4.3 安装MySql客户端"></a>2.4.3 安装MySql客户端</h3><p>1）安装mysql客户端</p>
<p>​    [root@hadoop102 mysql-libs]# rpm -ivh MySQL-client-5.6.24-1.el6.x86_64.rpm</p>
<p>2）链接mysql</p>
<p>​    [root@hadoop102 mysql-libs]# mysql -uroot -pOEXaQuS8IWkG19Xs</p>
<p>3）修改密码</p>
<p>​    mysql&gt;SET PASSWORD=PASSWORD(‘000000’);</p>
<p>4）退出mysql</p>
<p>mysql&gt;exit</p>
<h3 id="2-4-4-MySql中user表中主机配置"><a href="#2-4-4-MySql中user表中主机配置" class="headerlink" title="2.4.4 MySql中user表中主机配置"></a>2.4.4 MySql中user表中主机配置</h3><p><strong><em>配置只要是root***</em></strong>用户+*<strong>*</strong>密码，在任何主机上都能登录MySQL*<strong>*</strong>数据库。***</p>
<p><strong><em>详情参见这个网址： <a href="https://blog.csdn.net/lthirdonel/article/details/79011033\" target="_blank" rel="external">https://blog.csdn.net/lthirdonel/article/details/79011033\</a></em></strong></p>
<p>1）进入mysql</p>
<p>[root@hadoop102 mysql-libs]# mysql -uroot -p000000</p>
<p>2）显示数据库</p>
<p>mysql&gt;show databases;</p>
<p>3）使用mysql数据库</p>
<p>mysql&gt;use mysql;</p>
<p>4）展示mysql数据库中的所有表</p>
<p>mysql&gt;show tables;</p>
<p>5）展示user表的结构</p>
<p>​    mysql&gt;desc user;</p>
<p>6）查询user表</p>
<p>mysql&gt;select User, Host, Password from user;</p>
<p>7）修改user表，把Host表内容修改为%</p>
<p>​    mysql&gt;update user set host=’%’ where host=’localhost’;</p>
<p>8）删除root用户的其他host</p>
<p>mysql&gt;delete from user where Host=’hadoop102 ‘;</p>
<p>mysql&gt;delete from user where Host=’127.0.0.1’;</p>
<p>mysql&gt;delete from user where Host=’::1’;</p>
<p>9）刷新</p>
<p>​    mysql&gt;flush privileges;</p>
<p>10）退出</p>
<p>mysql&gt; quit;</p>
<h2 id="2-5-Hive元数据配置到MySql"><a href="#2-5-Hive元数据配置到MySql" class="headerlink" title="2.5 Hive元数据配置到MySql"></a>2.5 Hive元数据配置到MySql</h2><h3 id="2-5-1-驱动拷贝"><a href="#2-5-1-驱动拷贝" class="headerlink" title="2.5.1 驱动拷贝"></a>2.5.1 驱动拷贝</h3><p>1）在/opt/software/mysql-libs目录下解压mysql-connector-java-5.1.27.tar.gz驱动包</p>
<p>​    [root@hadoop102 mysql-libs]# tar -zxvf mysql-connector-java-5.1.27.tar.gz</p>
<p>2）拷贝/opt/software/mysql-libs/mysql-connector-java-5.1.27目录下的</p>
<p>mysql-connector-java-5.1.27-bin.jar到/opt/module/hive/lib/</p>
<p>[root@hadoop102 mysql-connector-java-5.1.27]# cp mysql-connector-java-5.1.27-bin.jar /opt/module/hive/lib/</p>
<h3 id="2-5-2-配置Metastore到MySql"><a href="#2-5-2-配置Metastore到MySql" class="headerlink" title="2.5.2 配置Metastore到MySql"></a>2.5.2 配置Metastore到MySql</h3><p>1）在/opt/module/hive/conf目录下创建一个hive-site.xml</p>
<p>[kingge@hadoop102 conf]$ touch hive-site.xml</p>
<p>[kingge@hadoop102 conf]$ vi hive-site.xml</p>
<p>2）根据官方文档配置参数，拷贝数据到hive-site.xml文件中。</p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+MetastoreAdmin" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/AdminManual+MetastoreAdmin</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">	  &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</div><div class="line">	  &lt;value&gt;jdbc:mysql://hadoop102:3306/metastore?createDatabaseIfNotExist=true&lt;/value&gt;</div><div class="line">	  &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line"></div><div class="line">	&lt;property&gt;</div><div class="line">	  &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</div><div class="line">	  &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</div><div class="line">	  &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line"></div><div class="line">	&lt;property&gt;</div><div class="line">	  &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</div><div class="line">	  &lt;value&gt;root&lt;/value&gt;</div><div class="line">	  &lt;description&gt;username to use against metastore database&lt;/description&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line"></div><div class="line">	&lt;property&gt;</div><div class="line">	  &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</div><div class="line">	  &lt;value&gt;000000&lt;/value&gt;</div><div class="line">	  &lt;description&gt;password to use against metastore database&lt;/description&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<p>3）配置完毕后，如果启动hive异常，可以重新启动虚拟机。（重启后，别忘了启动hadoop集群）</p>
<h3 id="2-5-3-多窗口启动Hive测试"><a href="#2-5-3-多窗口启动Hive测试" class="headerlink" title="2.5.3 多窗口启动Hive测试"></a>2.5.3 多窗口启动Hive测试</h3><p>1）先启动MySQL</p>
<p>[kingge@hadoop102 mysql-libs]$ mysql -uroot -p000000</p>
<p>​    查看有几个数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; show databases;</div><div class="line"></div><div class="line">+--------------------+</div><div class="line"></div><div class="line">| Database      |</div><div class="line"></div><div class="line">+--------------------+</div><div class="line"></div><div class="line">| information_schema |</div><div class="line"></div><div class="line">| mysql       |</div><div class="line"></div><div class="line">| performance_schema |</div><div class="line"></div><div class="line">| test        |</div><div class="line"></div><div class="line">+-----------</div><div class="line">---------+</div></pre></td></tr></table></figure>
<p>2）再次打开多个窗口，分别启动hive</p>
<p>[kingge@hadoop102 hive]$ bin/hive</p>
<p>3）启动hive后，回到MySQL窗口查看数据库，显示增加了metastore数据库</p>
<p>​    mysql&gt; show databases;</p>
<p>+——————–+</p>
<p>| Database      |</p>
<p>+——————–+</p>
<p>| information_schema |</p>
<p>| metastore     |</p>
<p>| mysql       |</p>
<p>| performance_schema |</p>
<p>| test        |</p>
<p>+——————–+</p>
<h2 id="2-6-Hive常用交互命令"><a href="#2-6-Hive常用交互命令" class="headerlink" title="2.6 Hive常用交互命令"></a>2.6 Hive常用交互命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[kingge@hadoop102 hive]$ bin/hive -help</div><div class="line">usage: hive</div><div class="line"> -d,--define &lt;key=value&gt;          Variable subsitution to apply to hive</div><div class="line">                                  commands. e.g. -d A=B or --define A=B</div><div class="line">    --database &lt;databasename&gt;     Specify the database to use</div><div class="line"> -e &lt;quoted-query-string&gt;         SQL from command line</div><div class="line"> -f &lt;filename&gt;                    SQL from files</div><div class="line"> -H,--help                        Print help information</div><div class="line">    --hiveconf &lt;property=value&gt;   Use value for given property</div><div class="line">    --hivevar &lt;key=value&gt;         Variable subsitution to apply to hive</div><div class="line">                                  commands. e.g. --hivevar A=B</div><div class="line"> -i &lt;filename&gt;                    Initialization SQL file</div><div class="line"> -S,--silent                      Silent mode in interactive shell</div><div class="line"> -v,--verbose                     Verbose mode (echo executed SQL to the console)</div></pre></td></tr></table></figure>
<p>1）“-e”不进入hive的交互窗口执行sql语句</p>
<p>[kingge@hadoop102 hive]$ bin/hive -e “select id from student;”</p>
<p>2）“-f”执行脚本中sql语句</p>
<p>​    （1）在/opt/module/datas目录下创建hivef.sql文件</p>
<p>​       [kingge@hadoop102 datas]$ touch hivef.sql</p>
<p>​       文件中写入正确的sql语句</p>
<p>​       select *from student;</p>
<p>​    （2）执行文件中的sql语句</p>
<p>[kingge@hadoop102 hive]$ bin/hive -f /opt/module/datas/hivef.sql</p>
<p>（3）执行文件中的sql语句并将结果写入文件中</p>
<p>[kingge@hadoop102 hive]$ bin/hive -f /opt/module/datas/hivef.sql &gt; /opt/module/datas/hive_result.txt</p>
<h2 id="2-7-Hive其他命令操作"><a href="#2-7-Hive其他命令操作" class="headerlink" title="2.7 Hive其他命令操作"></a>2.7 Hive其他命令操作</h2><p>1）退出hive窗口：   </p>
<p>hive(default)&gt;exit;</p>
<p>hive(default)&gt;quit;</p>
<p>在新版的oracle中没区别了，在以前的版本是有的：</p>
<p>exit:先隐性提交数据，再退出；</p>
<p>quit:不提交数据，退出；</p>
<p>2）在hive cli命令窗口中如何查看hdfs文件系统</p>
<p>​    hive(default)&gt;dfs -ls /;</p>
<p>3）在hive cli命令窗口中如何查看hdfs本地系统</p>
<p>hive(default)&gt;! ls /opt/module/datas;</p>
<p>4）查看在hive中输入的所有历史命令</p>
<p>​    （1）进入到当前用户的根目录/root或/home/kingge</p>
<p>​    （2）查看. hivehistory文件</p>
<p>[kingge@hadoop102 ~]$ cat .hivehistory</p>
<h2 id="2-8-Hive常见属性配置（重要）"><a href="#2-8-Hive常见属性配置（重要）" class="headerlink" title="2.8 Hive常见属性配置（重要）"></a>2.8 Hive常见属性配置（<em>重要</em>）</h2><h3 id="2-8-1-Hive数据仓库位置配置"><a href="#2-8-1-Hive数据仓库位置配置" class="headerlink" title="2.8.1 Hive数据仓库位置配置"></a>2.8.1 Hive数据仓库位置配置</h3><p>​    1）Default数据仓库的最原始位置是在hdfs上的：/user/hive/warehouse路径下</p>
<p>​     <strong><em>Hive***</em></strong>默认创建了一个名字为“default*<strong>*</strong>”的数据库，如果没有指明具体操作那个数据库，那么所有的操作针对的都是Default*<strong>*</strong>。所以我们在操作书写sql*<strong>*</strong>时，最好使用 use*<strong> *</strong>命令指明操作那个数据库。***</p>
<p>​    2）在仓库目录下，没有对默认的数据库default创建文件夹。如果某张表属于default数据库，直接在数据仓库目录下创建一个文件夹。</p>
<p>   这句话的意思是：</p>
<p>\1.    我们如果在default数据库创建了一张表，那么实际上就是在/user/hive/warehouse路径下，创建了一个以<strong><em>表名为名称的文件\</em></strong>。 <strong><em>Insert***</em></strong>如数据库表的数据会在该文件夹下面生成一个文件存储。每insert*<strong>*</strong>一次就会生成一个（名字一般是000000_0*<strong>*</strong>）,*<strong>*</strong>如果通过load*<strong>*</strong>的方式导入数据，那么存储数据文件就是load*<strong>*</strong>数据的那个文件名。***</p>
<p>例如 load data local inpath ‘/opt/module/datas/studentnto table default.student</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172852105.png" alt="image-20200509172852105"></p>
<p>\2.    如果我们创建了一个数据库，那么就会在 /user/hive/warehouse路径下创建</p>
<p>一个名字为数据库在HDFS上的默认存储路径是/user/hive/warehouse/数据库名.db。 的文件夹。</p>
<p>​    3）修改default数据仓库原始位置（将hive-default.xml.template如下配置信息拷贝到hive-site.xml文件中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;</div><div class="line">&lt;value&gt;/user/hive/warehouse&lt;/value&gt;</div><div class="line">&lt;description&gt;location of default database for the warehouse&lt;/description&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>配置同组用户有执行权限</p>
<p>bin/hdfs dfs -chmod g+w /user/hive/warehouse</p>
<h3 id="2-8-2-查询后信息显示配置"><a href="#2-8-2-查询后信息显示配置" class="headerlink" title="2.8.2 查询后信息显示配置"></a>2.8.2 查询后信息显示配置</h3><p>1）在hive-site.xml文件中添加如下配置信息，就可以实现显示当前数据库，以及查询表的头信息配置。（<strong><em>通过这项配置我们一颗额外的指导，启动***</em></strong>hive*<strong>*</strong>后默认*<strong>*</strong>use default*<strong> *</strong>数据库***）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">	&lt;name&gt;hive.cli.print.header&lt;/name&gt;</div><div class="line">	&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">	&lt;name&gt;hive.cli.print.current.db&lt;/name&gt;</div><div class="line">	&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>​    2）重新启动hive，对比配置前后差异</p>
<p>（1）配置前</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172928250.png" alt="image-20200509172928250"></p>
<p>（2）配置后</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172937505.png" alt="image-20200509172937505"></p>
<h3 id="2-8-3-Hive运行日志信息配置"><a href="#2-8-3-Hive运行日志信息配置" class="headerlink" title="2.8.3 Hive运行日志信息配置"></a>2.8.3 Hive运行日志信息配置</h3><p>1）Hive的log默认存放在/tmp/kingge/hive.log目录下（当前用户名下）。</p>
<p>2）修改hive的log存放日志到/opt/module/hive/logs</p>
<p>​    （1）修改/opt/module/hive/conf/hive-log4j.properties.template文件名称为</p>
<p>hive-log4j.properties</p>
<p>[kingge@hadoop102 conf]$ pwd</p>
<p>/opt/module/hive/conf</p>
<p>​       [kingge@hadoop102 conf]$ mv hive-log4j.properties.template hive-log4j.properties</p>
<p>​    （2）在hive-log4j.properties文件中修改log存放位置</p>
<p>hive.log.dir=/opt/module/hive/logs</p>
<h3 id="2-8-4-参数配置方式"><a href="#2-8-4-参数配置方式" class="headerlink" title="2.8.4 参数配置方式"></a>2.8.4 参数配置方式</h3><p>1）查看当前所有的配置信息</p>
<p>​    hive&gt;set;</p>
<p>2）参数的配置三种方式</p>
<p>​    （1）配置文件方式</p>
<p>默认配置文件：hive-default.xml</p>
<p>用户自定义配置文件：hive-site.xml</p>
<p>​    注意：用户自定义配置会覆盖默认配置。另外，Hive也会读入Hadoop的配置，因为Hive是作为Hadoop的客户端启动的，Hive的配置会覆盖Hadoop的配置。配置文件的设定<strong><em>对本机启动\</em></strong>的所有Hive进程都有效。</p>
<p>（2）命令行参数方式</p>
<p>启动Hive时，可以在命令行添加-hiveconf param=value来设定参数。</p>
<p>例如：</p>
<p>[kingge@hadoop103 hive]$ bin/hive -hiveconf mapred.reduce.tasks=10;</p>
<p>注意：仅对本次hive启动有效（退出当前hive client客户端，失效并恢复默认值）</p>
<p>查看参数设置：</p>
<p>hive (default)&gt; set mapred.reduce.tasks;</p>
<p>（3）参数声明方式</p>
<p>可以在HQL中使用SET关键字设定参数</p>
<p>例如：</p>
<p>hive (default)&gt; set mapred.reduce.tasks=100;</p>
<p>注意：仅对本次hive启动有效。（退出当前hive client客户端，失效并恢复默认值）</p>
<p>查看参数设置</p>
<p>hive (default)&gt; set mapred.reduce.tasks;</p>
<p>上述三种设定方式的优先级依次递增。即<strong><em>配置文件***</em></strong>&lt;*<strong>*</strong>命令行参数*<strong>*</strong>&lt;*<strong>*</strong>参数声明*<strong>。*</strong>注意某些系统级的参数，例如*<strong>*</strong>log4j*<strong>*</strong>相关的设定，必须用前两种方式设定，因为那些参数的读取在会话建立以前已经完成了。***</p>
<h1 id="三-Hive数据类型"><a href="#三-Hive数据类型" class="headerlink" title="三 Hive数据类型"></a>三 Hive数据类型</h1><h2 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h2><table>
<thead>
<tr>
<th>Hive数据类型</th>
<th>Java数据类型</th>
<th>长度</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>byte</td>
<td>1byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>SMALINT</td>
<td>short</td>
<td>2byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>INT</td>
<td>int</td>
<td>4byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BIGINT</td>
<td>long</td>
<td>8byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>boolean</td>
<td>布尔类型，true或者false</td>
<td>TRUE FALSE</td>
</tr>
<tr>
<td>FLOAT</td>
<td>float</td>
<td>单精度浮点数</td>
<td>3.14159</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>double</td>
<td>双精度浮点数</td>
<td>3.14159</td>
</tr>
<tr>
<td>STRING</td>
<td>string</td>
<td>字符系列。可以指定字符集。可以使用单引号或者双引号。</td>
<td>‘now is the  time’ “for all good men”</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td></td>
<td>时间类型</td>
<td></td>
</tr>
<tr>
<td>BINARY</td>
<td></td>
<td>字节数组</td>
</tr>
</tbody>
</table>
<p>​      对于Hive的String类型相当于数据库的varchar类型，该类型是一个可变的字符串，不过它不能声明其中最多能存储多少个字符，理论上它可以存储2GB的字符数。</p>
<h2 id="3-2-集合数据类型"><a href="#3-2-集合数据类型" class="headerlink" title="3.2 集合数据类型"></a>3.2 集合数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>语法示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRUCT</td>
<td>和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last STRING},那么第1个元素可以通过字段.first来引用。</td>
<td>struct()</td>
</tr>
<tr>
<td>MAP</td>
<td>MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值对是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段名[‘last’]获取最后一个元素</td>
<td>map()</td>
</tr>
<tr>
<td>ARRAY</td>
<td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’, ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。</td>
<td>Array()</td>
</tr>
</tbody>
</table>
<p>Hive有三种复杂数据类型ARRAY、MAP 和 STRUCT。ARRAY和MAP与Java中的Array和Map类似，而STRUCT与C语言中的Struct类似，它封装了一个命名字段集合，复杂数据类型允许任意层次的嵌套。</p>
<p>案例实操</p>
<p>1）假设某表有如下一行，我们用JSON格式来表示其数据结构。在Hive下访问的格式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;songsong&quot;,</div><div class="line">    &quot;friends&quot;: [&quot;bingbing&quot; , &quot;lili&quot;] ,       //列表Array, </div><div class="line">    &quot;children&quot;: &#123;                      //键值Map,</div><div class="line">        &quot;xiao song&quot;: 18 ,</div><div class="line">        &quot;xiaoxiao song&quot;: 19</div><div class="line">    &#125;</div><div class="line">    &quot;address&quot;: &#123;                      //结构Struct,</div><div class="line">        &quot;street&quot;: &quot;hui long guan&quot; ,</div><div class="line">        &quot;city&quot;: &quot;beijing&quot; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2）基于上述数据结构，我们在Hive里创建对应的表，并导入数据。 </p>
<p>创建本地测试文件test.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">songsong,bingbing_lili,xiao song:18_xiaoxiao song:19,hui long guan_beijing</div><div class="line">yangyang,caicai_susu,xiao yang:18_xiaoxiao yang:19,chao yang_beijing</div></pre></td></tr></table></figure>
<p>注意，MAP，STRUCT和ARRAY里的元素间关系都可以用同一个字符表示，这里用“_”。</p>
<p>3）Hive上创建测试表test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create table test(</div><div class="line">name string,</div><div class="line">friends array&lt;string&gt;,</div><div class="line">children map&lt;string, int&gt;,</div><div class="line">address struct&lt;street:string, city:string&gt;</div><div class="line">)</div><div class="line">row format delimited fields terminated by &apos;,&apos;</div><div class="line">collection items terminated by &apos;_&apos;</div><div class="line">map keys terminated by &apos;:&apos;</div><div class="line">lines terminated by &apos;\n&apos;;</div></pre></td></tr></table></figure>
<p>字段解释：</p>
<p>row format delimited fields terminated by ‘,’ – 列分隔符</p>
<p>collection items terminated by ‘_’    –MAP STRUCT 和 ARRAY 的分隔符(数据分割符号)</p>
<p>map keys terminated by ‘:’             – MAP中的key与value的分隔符</p>
<p>lines terminated by ‘\n’;               – 行分隔符</p>
<p>4）导入文本数据到测试表</p>
<p>  hive  (default)&gt; load data local inpath ‘/opt/module/datas/test.txt’ into table  test;  </p>
<p>5）访问三种集合列里的数据，以下分别是ARRAY，MAP，STRUCT的访问方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive (default)&gt; select friends[1],children[&apos;xiao song&apos;],address.city from test where name=&quot;songsong&quot;;</div><div class="line">OK</div><div class="line">_c0     _c1     city</div><div class="line">lili    18      beijing</div><div class="line">Time taken: 0.076 seconds, Fetched: 1 row(s)</div></pre></td></tr></table></figure>
<h2 id="3-3-类型转化"><a href="#3-3-类型转化" class="headerlink" title="3.3 类型转化"></a>3.3 类型转化</h2><p>Hive的原子数据类型是可以进行隐式转换的，类似于Java的类型转换，例如某表达式使用INT类型，TINYINT会自动转换为INT类型，但是Hive不会进行反向转化，例如，某表达式使用TINYINT类型，INT不会自动转换为TINYINT类型，它会返回错误，除非使用CAST操作。</p>
<p>1）隐式类型转换规则如下。</p>
<p>（1）任何整数类型都可以隐式地转换为一个范围更广的类型，如TINYINT可以转换成INT，INT可以转换成BIGINT。</p>
<p>（2）所有整数类型、FLOAT和STRING类型都可以隐式地转换成DOUBLE。</p>
<p>（3）TINYINT、SMALLINT、INT都可以转换为FLOAT。</p>
<p>（4）BOOLEAN类型不可以转换为任何其它的类型。</p>
<p>2）可以使用CAST操作显示进行数据类型转换，例如CAST(‘1’ AS INT)将把字符串’1’ 转换成整数1；如果强制类型转换失败，如执行CAST(‘X’ AS INT)，表达式返回空值 NULL。</p>
<h1 id="四-DDL数据定义"><a href="#四-DDL数据定义" class="headerlink" title="四 DDL数据定义"></a>四 DDL数据定义</h1><h2 id="4-1-创建数据库"><a href="#4-1-创建数据库" class="headerlink" title="4.1 创建数据库"></a>4.1 创建数据库</h2><p>1）创建一个数据库，数据库在HDFS上的默认存储路径是/user/hive/warehouse/*.db。</p>
<p>hive (default)&gt; create database db_hive;   //最终在HDFS中是/user/hive/warehouse/ db_hive.db。</p>
<p>2）避免要创建的数据库已经存在错误，增加if not exists判断。（标准写法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive&gt; create database db_hive;</div><div class="line">FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. Database db_hive already exi</div><div class="line">Sts</div><div class="line">hive (default)&gt; create database if not exists db_hive;</div></pre></td></tr></table></figure>
<p>3）创建一个数据库，指定数据库在HDFS上存放的位置</p>
<p>hive (default)&gt; create database db_hive2 location ‘/db_hive2.db’;</p>
<p>create database db_hive2 location ‘/ ‘; 不指明生成的文件夹名称，那么也会创建成功，只不过他没有像上面那样生成了一个文件夹（也就是访问HDFS根目录时，发现是空的），但是数据库已经创建成功。当你使用该数据库创建一张表的时候。会在根目录下直接生成以表名为名称的文件夹。保存表的数据（跟之前的一样）–<strong><em>所以推荐还是指明创建的数据库名称\</em></strong></p>
<h2 id="4-2-修改数据库（只能修改数据库描述信息，其他数据不能修改）"><a href="#4-2-修改数据库（只能修改数据库描述信息，其他数据不能修改）" class="headerlink" title="4.2 修改数据库（只能修改数据库描述信息，其他数据不能修改）"></a>4.2 修改数据库（只能修改数据库描述信息，其他数据不能修改）</h2><p>用户可以使用ALTER DATABASE命令为某个数据库的DBPROPERTIES设置键-值对属性值，来描述这个数据库的属性信息。数据库的其他元数据信息都是不可更改的，包括数据库名和数据库所在的目录位置。（<strong><em>跟***</em></strong>mysql*<strong>*</strong>的差别***）</p>
<p>hive (default)&gt; alter database db_hive set dbproperties(‘createtime’=’20170830’);</p>
<p>在mysql中查看修改结果</p>
<p>hive&gt; desc database extended db_hive;</p>
<p>db_name comment location    owner_name   owner_type   parameters</p>
<p>db_hive     hdfs://hadoop102:8020/user/hive/warehouse/db_hive.db  kingge USER  {createtime=20170830}</p>
<h2 id="4-3-查询数据库"><a href="#4-3-查询数据库" class="headerlink" title="4.3 查询数据库"></a>4.3 查询数据库</h2><h3 id="4-3-1-显示数据库"><a href="#4-3-1-显示数据库" class="headerlink" title="4.3.1 显示数据库"></a>4.3.1 显示数据库</h3><p>1）显示数据库</p>
<p>hive&gt; show databases;</p>
<p>2）过滤显示查询的数据库</p>
<p>​    hive&gt; show databases like ‘db_hive*’;</p>
<p>OK</p>
<p>db_hive</p>
<p>db_hive_1</p>
<h3 id="4-3-2-查看数据库详情"><a href="#4-3-2-查看数据库详情" class="headerlink" title="4.3.2 查看数据库详情"></a>4.3.2 查看数据库详情</h3><p>1）显示数据库信息</p>
<p>hive&gt; desc database db_hive;</p>
<p>OK</p>
<p>db_hive     hdfs://hadoop102:8020/user/hive/warehouse/db_hive.db   kinggeUSER </p>
<p>2）显示数据库详细信息，extended</p>
<p>hive&gt; desc database extended db_hive;</p>
<p>OK</p>
<p>db_hive     hdfs://hadoop102:8020/user/hive/warehouse/db_hive.db   kinggeUSER </p>
<h3 id="4-3-3-切换当前数据库"><a href="#4-3-3-切换当前数据库" class="headerlink" title="4.3.3 切换当前数据库"></a>4.3.3 切换当前数据库</h3><p>hive (default)&gt; use db_hive;</p>
<h2 id="4-4-删除数据库"><a href="#4-4-删除数据库" class="headerlink" title="4.4 删除数据库"></a>4.4 删除数据库</h2><p>1）删除空数据库</p>
<p>hive&gt;drop database db_hive2;</p>
<p>2）如果删除的数据库不存在，最好采用 if exists判断数据库是否存在</p>
<p>  hive&gt; drop  database db_hive2;  FAILED:  SemanticException [Error 10072]: Database does not exist: db_hive  </p>
<p>hive&gt; drop database if exists db_hive2;</p>
<p>3）如果数据库不为空，可以采用cascade命令，强制删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive&gt; drop database db_hive;</div><div class="line">FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. InvalidOperationException(message:Database db_hive is not empty. One or more tables exist.)</div></pre></td></tr></table></figure>
<p>hive&gt; drop database db_hive cascade;</p>
<h2 id="4-5-创建表"><a href="#4-5-创建表" class="headerlink" title="4.5 创建表"></a>4.5 创建表</h2><p>1）建表语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name </div><div class="line">[(col_name data_type [COMMENT col_comment], ...)] </div><div class="line">[COMMENT table_comment] </div><div class="line">[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] </div><div class="line">[CLUSTERED BY (col_name, col_name, ...) </div><div class="line">[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] </div><div class="line">[ROW FORMAT row_format] </div><div class="line">[STORED AS file_format] </div><div class="line">[LOCATION hdfs_path]</div></pre></td></tr></table></figure>
<p>2）字段解释说明：</p>
<p>（1）CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXISTS 选项来忽略这个异常。</p>
<p>（2）EXTERNAL关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION），Hive创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</p>
<p>（3）COMMENT：为表和列添加注释。</p>
<p>（4）PARTITIONED BY创建分区表</p>
<p>（5）CLUSTERED BY创建分桶表</p>
<p>（6）SORTED BY不常用</p>
<p>（7）ROW FORMAT </p>
<p>DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char] </p>
<p>​    [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] </p>
<p>  | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, …)]</p>
<p>用户在建表的时候可以自定义SerDe或者使用自带的SerDe。如果没有指定ROW FORMAT 或者ROW FORMAT DELIMITED，将会使用自带的SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的SerDe，Hive通过SerDe确定表的具体的列的数据。</p>
<p>（8）<strong><em>STORED AS***</em></strong>指定存储文件类型（默认是txt*<strong>*</strong>）***</p>
<p>常用的存储文件类型：SEQUENCEFILE（二进制序列文件）、TEXTFILE（文本）、RCFILE（列式存储格式文件）</p>
<p>如果文件数据是纯文本，可以使用STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p>
<p>（9）LOCATION ：指定表在HDFS上的存储位置。</p>
<p>（10）LIKE允许用户复制现有的表结构，但是不复制数据。</p>
<h3 id="4-5-1-管理表"><a href="#4-5-1-管理表" class="headerlink" title="4.5.1 管理表"></a>4.5.1 管理表</h3><p>1）理论</p>
<p><strong><em>默认创建的表都是所谓的管理表，有时也被称为内部表\</em></strong>。因为这种表，Hive会（或多或少地）控制着数据的生命周期。Hive默认情况下会将这些表的数据存储在由配置项hive.metastore.warehouse.dir(例如，/user/hive/warehouse)所定义的目录的子目录下。    当我们删除一个管理表时，Hive也会删除这个表中数据（删除HDFS存储的目录和数据）。管理表不适合和其他工具共享数据。</p>
<p><strong>2**</strong>）案例实操**</p>
<p>（1）普通创建表</p>
<p>  create table if not  exists student2(  id int, name string  )  row format  delimited fields terminated by ‘\t’  stored as textfile  location  ‘/user/hive/warehouse/student2’;  </p>
<p>（2）根据查询结果创建表（查询的结果会添加到新创建的表中）</p>
<p>  create table if not exists student3  as select id, name from student;  </p>
<p>（3）根据已经存在的表结构创建表（只拷贝student结构，没有获取student数据）</p>
<p>  create table if not exists student4 like student;  </p>
<p>（4）查询表的类型</p>
<p>hive (default)&gt; desc formatted student2;</p>
<p>Table Type:       MANAGED_TABLE </p>
<h3 id="4-5-2-外部表"><a href="#4-5-2-外部表" class="headerlink" title="4.5.2 外部表"></a>4.5.2 外部表</h3><p>1）理论</p>
<p>因为表是外部表，所以Hive并非认为其完全拥有这份数据。删除该表并不会删除掉这份数据（即在hdfs中还保存着数据库的数据），不过描述表的元数据信息会被删除掉。（mysql中关于该表的元数据信息就会被删除）</p>
<p>2）管理表和外部表的使用场景：</p>
<p>每天将收集到的网站日志定期流入HDFS文本文件。在外部表（原始日志表）的基础上做大量的统计分析，用到的中间表、结果表使用内部表存储，数据通过SELECT+INSERT进入内部表。</p>
<p>3）案例实操</p>
<p>分别创建部门和员工外部表，并向表中导入数据。</p>
<p>（1）原始数据</p>
<p>​             </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dept.txt </div><div class="line">10	ACCOUNTING	1700</div><div class="line">20	RESEARCH	1800</div><div class="line">30	SALES	1900</div><div class="line">40	OPERATIONS	1700</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">emp.txt</div><div class="line"></div><div class="line">7369	SMITH	CLERK	7902	1980-12-17	800.00		20</div><div class="line">7499	ALLEN	SALESMAN	7698	1981-2-20	1600.00	300.00	30</div><div class="line">7521	WARD	SALESMAN	7698	1981-2-22	1250.00	500.00	30</div><div class="line">7566	JONES	MANAGER	7839	1981-4-2	2975.00		20</div><div class="line">7654	MARTIN	SALESMAN	7698	1981-9-28	1250.00	1400.00	30</div><div class="line">7698	BLAKE	MANAGER	7839	1981-5-1	2850.00		30</div><div class="line">7782	CLARK	MANAGER	7839	1981-6-9	2450.00		10</div><div class="line">7788	SCOTT	ANALYST	7566	1987-4-19	3000.00		20</div><div class="line">7839	KING	PRESIDENT		1981-11-17	5000.00		10</div><div class="line">7844	TURNER	SALESMAN	7698	1981-9-8	1500.00	0.00	30</div><div class="line">7876	ADAMS	CLERK	7788	1987-5-23	1100.00		20</div><div class="line">7900	JAMES	CLERK	7698	1981-12-3	950.00		30</div><div class="line">7902	FORD	ANALYST	7566	1981-12-3	3000.00		20</div><div class="line">7934	MILLER	CLERK	7782	1982-1-23	1300.00		10</div></pre></td></tr></table></figure>
<p>​    （2）建表语句</p>
<p>​       创建部门表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create external table if not exists default.dept(</div><div class="line">deptno int,</div><div class="line">dname string,</div><div class="line">loc int</div><div class="line">)</div><div class="line">row format delimited fields terminated by &apos;\t&apos;;</div></pre></td></tr></table></figure>
<p>​       创建员工表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create external table if not exists default.emp(</div><div class="line">empno int,</div><div class="line">ename string,</div><div class="line">job string,</div><div class="line">mgr int,</div><div class="line">hiredate string, </div><div class="line">sal double, </div><div class="line">comm double,</div><div class="line">deptno int)</div><div class="line">row format delimited fields terminated by &apos;\t&apos;;</div></pre></td></tr></table></figure>
<p>（3）查看创建的表</p>
<p>hive (default)&gt; show tables;</p>
<p>OK</p>
<p>tab_name</p>
<p>dept</p>
<p>emp</p>
<p>​    （4）向外部表中导入数据</p>
<p>​       导入数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept;</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/emp.txt’ into table default.emp;</p>
<p>查询结果</p>
<p>hive (default)&gt; select * from emp;</p>
<p>hive (default)&gt; select * from dept;</p>
<p>​    （5）查看表格式化数据</p>
<p>hive (default)&gt; desc formatted dept;</p>
<p>Table Type:       EXTERNAL_TABLE</p>
<h2 id="4-6-分区表"><a href="#4-6-分区表" class="headerlink" title="4.6 分区表"></a>4.6 分区表</h2><p>分区表实际上就是<strong><em>对应一个***</em></strong>HDFS*<strong>*</strong>文件系统上的独立的文件夹***，该文件夹下是该分区所有的数据文件。Hive中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过WHERE子句中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。</p>
<p>举个例子：我们知道项目日志框架会根据日期每天生成一个日志文件，这样方便我们查看，也方便存储的打开。因为如果把所有的日志信息都输入到一个文件中，那么查阅的时候就很不方便。所以分区表的含义也是如此，根据某些关键字把数据库表的数据拆分成多个文件夹存储。</p>
<p><strong><em>需要注意，假设创建的是分区表，那么插入数据的时候（insert***</em></strong>或者load*<strong>*</strong>的方式），都需要指明partition*<strong>*</strong>字段的值，否则会报错。***</p>
<p><strong><em>如果某张表是分区表。那么每个分区的定义，其实就表现为了这张表的数据存储目录下的一个子目录，如果是分区表。那么数据文件一定要存储在某个分区中，而不能直接存储在表中。\</em></strong></p>
<h3 id="4-6-1-分区表基本操作"><a href="#4-6-1-分区表基本操作" class="headerlink" title="4.6.1 分区表基本操作"></a>4.6.1 分区表基本操作</h3><p>1）引入分区表（需要根据日期对日志进行管理）</p>
<p>​    /user/hive/warehouse/log_partition/20170702/20170702.log</p>
<p>​    /user/hive/warehouse/log_partition/20170703/20170703.log</p>
<p>/user/hive/warehouse/log_partition/20170704/20170704.log</p>
<p>2）创建分区表语法<strong><em>（注意如果在创建表时不指定分区，那么后面就不能够使用分区相关特性，例如\</em></strong> <strong><em>load***</em></strong>数据时不能够指定load*<strong>*</strong>到哪个分区）***</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive (default)&gt; create table dept_partition(</div><div class="line">               deptno int, dname string, loc string</div><div class="line">               )</div><div class="line">               partitioned by (month string)</div><div class="line">               row format delimited fields terminated by &apos;\t&apos;;</div></pre></td></tr></table></figure>
<p>3）加载数据到分区表中</p>
<p>测试直接导入dep数据：发现报错</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173442759.png" alt="image-20200509173442759"></p>
<p>必须指明partition 字段</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept_partition partition(month=’201709’);</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept_partition partition(month=’201708’);</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept_partition partition(month=’201707’);</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173508986.png" alt="image-20200509173508986"></p>
<p>4）查询分区表中数据</p>
<p>查询所有分区</p>
<p>select * from dept_partition</p>
<p>​    单分区查询</p>
<p>hive (default)&gt; select * from dept_partition where month=’201709’;</p>
<p>多分区联合查询</p>
<p>hive (default)&gt; select * from dept_partition where month=’201709’</p>
<p>​       union</p>
<p>​       select * from dept_partition where month=’201708’</p>
<p>​       union</p>
<p>​       select * from dept_partition where month=’201707’;</p>
<p>_u3.deptno   _u3.dname    _u3.loc _u3.month</p>
<p>10   ACCOUNTING   NEW YORK    201707</p>
<p>10   ACCOUNTING   NEW YORK    201708</p>
<p>10   ACCOUNTING   NEW YORK    201709</p>
<p>20   RESEARCH    DALLAS 201707</p>
<p>20   RESEARCH    DALLAS 201708</p>
<p>20   RESEARCH    DALLAS 201709</p>
<p>30   SALES  CHICAGO 201707</p>
<p>30   SALES  CHICAGO 201708</p>
<p>30   SALES  CHICAGO 201709</p>
<p>40   OPERATIONS   BOSTON 201707</p>
<p>40   OPERATIONS   BOSTON 201708</p>
<p>40   OPERATIONS   BOSTON 201709</p>
<p>5）增加分区</p>
<p>​    创建单个分区（也就是在hdfs中创建文件夹month=201706）</p>
<p>hive (default)&gt; alter table dept_partition add partition(month=’201706’) ;</p>
<p>​    同时创建多个分区</p>
<p>hive (default)&gt; alter table dept_partition add partition(month=’201705’) partition(month=’201704’);</p>
<p>6）删除分区</p>
<p>​    删除单个分区</p>
<p>hive (default)&gt; alter table dept_partition drop partition (month=’201704’);</p>
<p>同时删除多个分区</p>
<p>hive (default)&gt; alter table dept_partition drop partition (month=’201705’)<strong>,</strong> partition (month=’201706’);</p>
<p>7）查看分区表有多少分区</p>
<p>hive&gt;show partitions dept_partition;</p>
<p>8）查看分区表结构</p>
<p>​    hive&gt;desc formatted dept_partition;</p>
<p># Partition Information     </p>
<p># col_name       data_type        comment       </p>
<p>month          string  </p>
<h3 id="4-6-2-分区表注意事项"><a href="#4-6-2-分区表注意事项" class="headerlink" title="4.6.2 分区表注意事项"></a>4.6.2 分区表注意事项</h3><p>1）创建二级分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive (default)&gt; create table dept_partition2(</div><div class="line">               deptno int, dname string, loc string</div><div class="line">               )</div><div class="line">               partitioned by (month string, day string)</div><div class="line">               row format delimited fields terminated by &apos;\t&apos;;</div></pre></td></tr></table></figure>
<p>2）正常的加载数据</p>
<p>（1）加载数据到二级分区表中</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept_partition2 partition(month=’201709’, day=’13’);</p>
<p>（2）查询分区数据</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’13’;</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173552490.png" alt="image-20200509173552490"></p>
<p>3）把数据直接上传到分区目录上，让分区表和数据产生关联的两种方式</p>
<p>​    （1）方式一：上传数据后修复</p>
<p>​    上传数据</p>
<p>hive (default)&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=12;</p>
<p>​    查询数据（查询不到刚上传的数据）</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’12’;</p>
<p>执行修复命令</p>
<p>​    hive&gt;msck repair table dept_partition2;</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173610908.png" alt="image-20200509173610908"></p>
<p>添加数据的元数据信息到mysql中，关联表</p>
<p>再次查询数据</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’12’;</p>
<p>​    （2）方式二：上传数据后添加分区</p>
<p>​    上传数据</p>
<p>hive (default)&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=11;</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=11;</p>
<p>​    执行添加分区</p>
<p>​    hive (default)&gt; alter table dept_partition2 add partition(month=’201709’, day=’11’);</p>
<p>​    查询数据</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’11’;</p>
<p>​    （3）方式三：上传数据后load数据到分区</p>
<p>​       创建目录</p>
<p>hive (default)&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=10;</p>
<p>上传数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table dept_partition2 partition(month=’201709’,day=’10’);</p>
<p>查询数据</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’10’;</p>
<h2 id="4-7-修改表（不支持删除某个字段）"><a href="#4-7-修改表（不支持删除某个字段）" class="headerlink" title="4.7 修改表（不支持删除某个字段）"></a>4.7 修改表（不支持删除某个字段）</h2><h3 id="4-7-1-重命名表"><a href="#4-7-1-重命名表" class="headerlink" title="4.7.1 重命名表"></a>4.7.1 重命名表</h3><p>​    （1）语法</p>
<p>  ALTER TABLE  table_name RENAME TO new_table_name  </p>
<p>​    （2）实操案例</p>
<p>hive (default)&gt; alter table dept_partition2 rename to dept_partition3;</p>
<h3 id="4-7-2-增加、修改和删除表分区"><a href="#4-7-2-增加、修改和删除表分区" class="headerlink" title="4.7.2 增加、修改和删除表分区"></a>4.7.2 增加、修改和删除表分区</h3><p>详见4.6.1分区表基本操作。</p>
<h3 id="4-7-3-增加-修改-替换列信息"><a href="#4-7-3-增加-修改-替换列信息" class="headerlink" title="4.7.3 增加/修改/替换列信息"></a>4.7.3 增加/修改/替换列信息</h3><p>1）语法</p>
<p>​    更新列</p>
<p>  ALTER TABLE table_name CHANGE [COLUMN]  col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER  column_name]  </p>
<p>增加和替换列</p>
<p>  ALTER TABLE table_name ADD|REPLACE  COLUMNS (col_name data_type [COMMENT col_comment], …)   </p>
<p>注：ADD是代表新增一字段，字段位置在所有列后面(partition列前)，REPLACE则是表示替换表中所有字段。</p>
<p>2）实操案例</p>
<p>（1）查询表结构</p>
<p>hive&gt;desc dept_partition;</p>
<p>（2）添加列</p>
<p>hive (default)&gt; alter table dept_partition add columns(deptdesc string);</p>
<p>（3）查询表结构</p>
<p>hive&gt;desc dept_partition;</p>
<p>（4）更新列</p>
<p>hive (default)&gt; alter table dept_partition change column deptdesc desc int;</p>
<p>（5）查询表结构</p>
<p>hive&gt;desc dept_partition;</p>
<p>（6）替换列</p>
<p>hive (default)&gt; alter table dept_partition replace columns(deptno string, dname string, loc string); （全局改变表的列，只保留指定的列）</p>
<p>（7）查询表结构</p>
<p>hive&gt;desc dept_partition;</p>
<h2 id="4-8-删除表"><a href="#4-8-删除表" class="headerlink" title="4.8 删除表"></a>4.8 删除表</h2><p>hive (default)&gt; drop table dept_partition;</p>
<h1 id="五-DML数据操作"><a href="#五-DML数据操作" class="headerlink" title="五 DML数据操作"></a>五 DML数据操作</h1><h2 id="5-1-数据导入"><a href="#5-1-数据导入" class="headerlink" title="5.1 数据导入"></a>5.1 数据导入</h2><h3 id="5-1-1-向表中装载数据（Load）"><a href="#5-1-1-向表中装载数据（Load）" class="headerlink" title="5.1.1 向表中装载数据（Load）"></a>5.1.1 向表中装载数据（Load）</h3><p>1）语法</p>
<p>hive&gt;load data [local] inpath ‘/opt/module/datas/student.txt’ [overwrite] into table student [partition (partcol1=val1,…)];</p>
<p>（1）load data:表示加载数据</p>
<p>（2）local:表示从本地加载数据到hive表；否则从HDFS加载数据到hive表</p>
<p>（3）inpath:表示加载数据的路径</p>
<p>（4）overwrite:表示覆盖表中已有数据，否则表示追加</p>
<p>（5）into table:表示加载到哪张表</p>
<p>（6）student:表示具体的表</p>
<p>（7）partition:表示上传到指定分区</p>
<p>2）实操案例</p>
<p>​    （0）创建一张表</p>
<p>hive (default)&gt; create table student(id string, name string) row format delimited fields terminated by ‘\t’;</p>
<p>（1）加载本地文件到hive</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/student.txt’ into table default.student;</p>
<p>​    （2）加载HDFS文件到hive中</p>
<p>​    上传文件到HDFS</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/student.txt /user/kingge/hive;</p>
<p>加载HDFS上数据</p>
<p>hive (default)&gt;load data inpath ‘/user/kingge/hive/student.txt’ into table default.student;</p>
<p><strong><em>需要注意的是：/user/kingge/hive/student.txt\</em></strong> <strong><em>这个文件就不存在的，因为他是通过剪切的方式把数据 load***</em></strong>到了 /user/kingge/hive/student*<strong> *</strong>目录下***</p>
<p>​    （3）加载数据覆盖表中已有的数据</p>
<p>​    上传文件到HDFS</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/student.txt /user/kingge/hive;</p>
<p>加载数据覆盖表中已有的数据</p>
<p>hive (default)&gt;load data inpath ‘/user/kingge/hive/student.txt’ overwrite into table default.student;</p>
<h3 id="5-1-2-通过查询语句向表中插入数据（Insert）"><a href="#5-1-2-通过查询语句向表中插入数据（Insert）" class="headerlink" title="5.1.2 通过查询语句向表中插入数据（Insert）"></a>5.1.2 通过查询语句向表中插入数据（Insert）</h3><p>1）创建一张分区表</p>
<p>hive (default)&gt; create table student(id int, name string) partitioned by (month string) row format delimited fields terminated by ‘\t’;</p>
<p>2）基本插入数据</p>
<p>  hive (default)&gt; insert  into table student partition(month=’201709’)  values(1,’wangwu’);  </p>
<p>3）基本模式插入（根据单张表查询结果）</p>
<p>hive (default)&gt; insert overwrite table student partition(month=’201708’)</p>
<p>​       select id, name from student where month=’201709’;</p>
<p>4）多插入模式（根据多张表查询结果）</p>
<p>hive (default)&gt; from student</p>
<p>​       insert overwrite table student partition(month=’201707’)</p>
<p>​       select id, name where month=’201709’</p>
<p>​       insert overwrite table student partition(month=’201706’)</p>
<p>​       select id, name where month=’201709’;</p>
<h3 id="5-1-3-查询语句中创建表并加载数据（As-Select）"><a href="#5-1-3-查询语句中创建表并加载数据（As-Select）" class="headerlink" title="5.1.3 查询语句中创建表并加载数据（As Select）"></a>5.1.3 查询语句中创建表并加载数据（As Select）</h3><p>详见4.5.1章创建表。</p>
<p>根据查询结果创建表（查询的结果会添加到新创建的表中）</p>
<p>  create table if not exists student3  as select id,  name from student;  </p>
<h3 id="5-1-4-创建表时通过Location指定加载数据路径"><a href="#5-1-4-创建表时通过Location指定加载数据路径" class="headerlink" title="5.1.4 创建表时通过Location指定加载数据路径"></a>5.1.4 创建表时通过Location指定加载数据路径</h3><p>1）创建表，并指定在<strong><em>hdfs\</em></strong>上的位置</p>
<p>hive (default)&gt; create table if not exists student5(</p>
<p>​       id int, name string</p>
<p>​       )</p>
<p>​       row format delimited fields terminated by ‘\t’</p>
<p>​       location ‘/user/hive/warehouse/student5’;</p>
<p>2）上传数据到hdfs上</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/student.txt /user/hive/warehouse/student5;</p>
<p>3）查询数据</p>
<p>hive (default)&gt; select * from student5;</p>
<h3 id="5-1-5-Import数据到指定Hive表中"><a href="#5-1-5-Import数据到指定Hive表中" class="headerlink" title="5.1.5 Import数据到指定Hive表中"></a>5.1.5 Import数据到指定Hive表中</h3><p>注意：先用export导出后，再将数据导入。（数据来源hdfs）</p>
<p>  hive (default)&gt; import table  student2 partition(month=’201709’) from ‘/user/hive/warehouse/export/student’;  </p>
<h2 id="5-2-数据导出"><a href="#5-2-数据导出" class="headerlink" title="5.2 数据导出"></a>5.2 数据导出</h2><h3 id="5-2-1-Insert导出"><a href="#5-2-1-Insert导出" class="headerlink" title="5.2.1 Insert导出"></a>5.2.1 Insert导出</h3><p>1）将查询的结果导出到本地</p>
<p>  hive (default)&gt; insert  overwrite local directory ‘/opt/module/datas/export/student’         </p>
<p> select * from student;  </p>
<p>2）将查询的结果格式化导出到本地</p>
<p>  hive (default)&gt; insert  overwrite local directory ‘/opt/module/datas/export/student1’         ROW  FORMAT DELIMITED FIELDS TERMINATED BY ‘\t’       </p>
<p>select * from student;  </p>
<p>3）将查询的结果导出到HDFS上(没有local)</p>
<p>  hive (default)&gt; insert  overwrite directory ‘/user/kingge/student2’         ROW  FORMAT DELIMITED FIELDS TERMINATED BY ‘\t’          </p>
<p> select * from student;  </p>
<h3 id="5-2-2-Hadoop命令导出到本地"><a href="#5-2-2-Hadoop命令导出到本地" class="headerlink" title="5.2.2 Hadoop命令导出到本地"></a>5.2.2 Hadoop命令导出到本地</h3><p>  hive  (default)&gt; dfs -get /user/hive/warehouse/student/month=201709/000000_0   /opt/module/datas/export/student3.txt;  </p>
<h3 id="5-2-3-Hive-Shell-命令导出"><a href="#5-2-3-Hive-Shell-命令导出" class="headerlink" title="5.2.3 Hive Shell 命令导出"></a>5.2.3 Hive Shell 命令导出</h3><p>基本语法：（hive -f/-e 执行语句或者脚本 &gt; file）</p>
<p>  [kingge@hadoop102 hive]$ bin/hive -e  ‘select * from default.student;’ &gt; /opt/module/datas/export/student4.txt;  </p>
<h3 id="5-2-4-Export导出到HDFS上"><a href="#5-2-4-Export导出到HDFS上" class="headerlink" title="5.2.4 Export导出到HDFS上"></a>5.2.4 Export导出到HDFS上</h3><p>  hive (default)&gt; export table  default.student to ‘/user/hive/warehouse/export/student’;  </p>
<h3 id="5-2-5-Sqoop导出"><a href="#5-2-5-Sqoop导出" class="headerlink" title="5.2.5 Sqoop导出"></a>5.2.5 Sqoop导出</h3><p>后续课程专门讲。</p>
<h2 id="5-3-清除表中数据（Truncate）"><a href="#5-3-清除表中数据（Truncate）" class="headerlink" title="5.3 清除表中数据（Truncate）"></a>5.3 清除表中数据（Truncate）</h2><p>注意：Truncate只能删除管理表，不能删除外部表中数据</p>
<p>hive (default)&gt; truncate table student;</p>
<h1 id="六-查询"><a href="#六-查询" class="headerlink" title="六 查询"></a>六 查询</h1><p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[WITH CommonTableExpression (, CommonTableExpression)*]    (Note: Only available starting with Hive 0.13.0)</div><div class="line">SELECT [ALL | DISTINCT] select_expr, select_expr, ...</div><div class="line">  FROM table_reference</div><div class="line">  [WHERE where_condition]</div><div class="line">  [GROUP BY col_list]</div><div class="line">  [ORDER BY col_list]</div><div class="line">  [CLUSTER BY col_list</div><div class="line">    | [DISTRIBUTE BY col_list] [SORT BY col_list]</div><div class="line">  ]</div><div class="line"> [LIMIT number]</div></pre></td></tr></table></figure>
<h2 id="6-1-基本查询（Select…From）"><a href="#6-1-基本查询（Select…From）" class="headerlink" title="6.1 基本查询（Select…From）"></a>6.1 基本查询（Select…From）</h2><h3 id="6-1-1-全表和特定列查询"><a href="#6-1-1-全表和特定列查询" class="headerlink" title="6.1.1 全表和特定列查询"></a>6.1.1 全表和特定列查询</h3><p>1）全表查询</p>
<p>hive (default)&gt; select * from emp;</p>
<p>2）选择特定列查询</p>
<p>hive (default)&gt; select empno, ename from emp;</p>
<p>注意：</p>
<p>（1）SQL 语言大小写不敏感。</p>
<p>（2）SQL 可以写在一行或者多行</p>
<p>（3）关键字不能被缩写也不能分行</p>
<p>（4）各子句一般要分行写。</p>
<p>（5）使用缩进提高语句的可读性。</p>
<h3 id="6-1-2-列别名"><a href="#6-1-2-列别名" class="headerlink" title="6.1.2 列别名"></a>6.1.2 列别名</h3><p>1）重命名一个列。</p>
<p>2）便于计算。</p>
<p>3）紧跟列名，也可以在列名和别名之间加入关键字‘AS’ </p>
<p>4）案例实操</p>
<p>​    （1）查询名称和部门</p>
<p>​    hive (default)&gt; select ename AS name, deptno dn from emp;</p>
<h3 id="6-1-3-算术运算符"><a href="#6-1-3-算术运算符" class="headerlink" title="6.1.3 算术运算符"></a>6.1.3 算术运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>A+B</td>
<td>A和B 相加</td>
</tr>
<tr>
<td>A-B</td>
<td>A减去B</td>
</tr>
<tr>
<td>A*B</td>
<td>A和B 相乘</td>
</tr>
<tr>
<td>A/B</td>
<td>A除以B</td>
</tr>
<tr>
<td>A%B</td>
<td>A对B取余</td>
</tr>
<tr>
<td>A&amp;B</td>
<td>A和B按位取与</td>
</tr>
<tr>
<td>A\</td>
<td>B</td>
<td>A和B按位取或</td>
</tr>
<tr>
<td>A^B</td>
<td>A和B按位取异或</td>
</tr>
<tr>
<td>~A</td>
<td>A按位取反</td>
</tr>
</tbody>
</table>
<p>案例实操</p>
<p>​    查询出所有员工的薪水后加1显示。</p>
<p>hive (default)&gt; select sal +1 from emp;</p>
<h3 id="6-1-4-常用函数"><a href="#6-1-4-常用函数" class="headerlink" title="6.1.4 常用函数"></a>6.1.4 常用函数</h3><p>1）求总行数（count）</p>
<p>hive (default)&gt; select count(*) cnt from emp;</p>
<p>2）求工资的最大值（max）</p>
<p>hive (default)&gt; select max(sal) max_sal from emp;</p>
<p>3）求工资的最小值（min）</p>
<p>hive (default)&gt; select min(sal) min_sal from emp;</p>
<p>4）求工资的总和（sum）</p>
<p>hive (default)&gt; select sum(sal) sum_sal from emp; </p>
<p>5）求工资的平均值（avg）</p>
<p>​    hive (default)&gt; select avg(sal) avg_sal from emp;</p>
<h3 id="6-1-5-Limit语句"><a href="#6-1-5-Limit语句" class="headerlink" title="6.1.5 Limit语句"></a>6.1.5 Limit语句</h3><p>典型的查询会返回多行数据。LIMIT子句用于限制返回的行数。</p>
<p>hive (default)&gt; select * from emp limit 5;</p>
<h2 id="6-2-Where语句"><a href="#6-2-Where语句" class="headerlink" title="6.2 Where语句"></a>6.2 Where语句</h2><p>1）使用WHERE子句，将不满足条件的行过滤掉。</p>
<p>2）WHERE子句紧随FROM子句。</p>
<p>3）案例实操</p>
<p>查询出薪水大于1000的所有员工</p>
<p>hive (default)&gt; select * from emp where sal &gt;1000;</p>
<h3 id="6-2-1-比较运算符（Between-In-Is-Null）"><a href="#6-2-1-比较运算符（Between-In-Is-Null）" class="headerlink" title="6.2.1 比较运算符（Between/In/ Is Null）"></a>6.2.1 比较运算符（Between/In/ Is Null）</h3><p>1）下面表中描述了谓词操作符，这些操作符同样可以用于JOIN…ON和HAVING语句中。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>支持的数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>A=B</td>
<td>基本数据类型</td>
<td>如果A等于B则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;=&gt;B</td>
<td>基本数据类型</td>
<td>如果A和B都为NULL，则返回TRUE，其他的和等号（=）操作符的结果一致，如果任一为NULL则结果为NULL</td>
</tr>
<tr>
<td>A&lt;&gt;B, A!=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL则返回NULL；如果A不等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A小于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A小于等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&gt;B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A大于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&gt;=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A大于等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A [NOT] BETWEEN B AND C</td>
<td>基本数据类型</td>
<td>如果A，B或者C任一为NULL，则结果为NULL。如果A的值大于等于B而且小于或等于C，则结果为TRUE，反之为FALSE。如果使用NOT关键字则可达到相反的效果。</td>
</tr>
<tr>
<td>A IS NULL</td>
<td>所有数据类型</td>
<td>如果A等于NULL，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A IS NOT NULL</td>
<td>所有数据类型</td>
<td>如果A不等于NULL，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>IN(数值1, 数值2)</td>
<td>所有数据类型</td>
<td>使用 IN运算显示列表中的值</td>
</tr>
<tr>
<td>A [NOT] LIKE B</td>
<td>STRING 类型</td>
<td>B是一个SQL下的简单正则表达式，如果A与其匹配的话，则返回TRUE；反之返回FALSE。B的表达式说明如下：‘x%’表示A必须以字母‘x’开头，‘%x’表示A必须以字母’x’结尾，而‘%x%’表示A包含有字母’x’,可以位于开头，结尾或者字符串中间。如果使用NOT关键字则可达到相反的效果。</td>
</tr>
<tr>
<td>A RLIKE B, A REGEXP B</td>
<td>STRING 类型</td>
<td>B是一个正则表达式，如果A与其匹配，则返回TRUE；反之返回FALSE。匹配使用的是JDK中的正则表达式接口实现的，因为正则也依据其中的规则。例如，正则表达式必须和整个字符串A相匹配，而不是只需与其字符串匹配。</td>
</tr>
</tbody>
</table>
<p>2）案例实操</p>
<p>（1）查询出薪水等于5000的所有员工</p>
<p>hive (default)&gt; select * from emp where sal =5000;</p>
<p>​    （2）查询工资在500到1000的员工信息</p>
<p>hive (default)&gt; select * from emp where sal between 500 and 1000;</p>
<p>​    （3）查询comm为空的所有员工信息</p>
<p>hive (default)&gt; select * from emp where comm is null;</p>
<p>​    （4）查询工资是1500和5000的员工信息</p>
<p>hive (default)&gt; select * from emp where sal IN (1500, 5000);</p>
<h3 id="6-2-2-Like和RLike"><a href="#6-2-2-Like和RLike" class="headerlink" title="6.2.2 Like和RLike"></a>6.2.2 Like和RLike</h3><p>1）使用LIKE运算选择类似的值</p>
<p>2）选择条件可以包含字符或数字:</p>
<p>% 代表零个或多个字符(任意个字符)。</p>
<p>_ 代表一个字符。</p>
<p>3）RLIKE子句是Hive中这个功能的一个扩展，其可以通过Java的正则表达式这个更强大的语言来指定匹配条件。</p>
<p>4）案例实操</p>
<p>​    （1）查找以2开头薪水的员工信息</p>
<p>​    hive (default)&gt; select * from emp where sal LIKE ‘2%’;</p>
<p>​    （2）查找第二个数值为2的薪水的员工信息</p>
<p>hive (default)&gt; select * from emp where sal LIKE ‘_2%’;</p>
<p>​    （3）查找薪水中含有2的员工信息</p>
<p>hive (default)&gt; select * from emp where sal RLIKE ‘[2]’;</p>
<h3 id="6-2-3-逻辑运算符（And-Or-Not）"><a href="#6-2-3-逻辑运算符（And-Or-Not）" class="headerlink" title="6.2.3 逻辑运算符（And/Or/Not）"></a>6.2.3 逻辑运算符（And/Or/Not）</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND</td>
<td>逻辑并</td>
</tr>
<tr>
<td>OR</td>
<td>逻辑或</td>
</tr>
<tr>
<td>NOT</td>
<td>逻辑否</td>
</tr>
</tbody>
</table>
<p>案例实操</p>
<p>​    （1）查询薪水大于1000，部门是30</p>
<p>hive (default)&gt; select * from emp where sal&gt;1000 and deptno=30;</p>
<p>​    （2）查询薪水大于1000，或者部门是30</p>
<p>hive (default)&gt; select * from emp where sal&gt;1000 or deptno=30;</p>
<p>​    （3）查询除了20部门和30部门以外的员工信息</p>
<p>hive (default)&gt; select * from emp where deptno not IN(30, 20);</p>
<h2 id="6-3-分组"><a href="#6-3-分组" class="headerlink" title="6.3 分组"></a>6.3 分组</h2><h3 id="6-3-1-Group-By语句"><a href="#6-3-1-Group-By语句" class="headerlink" title="6.3.1 Group By语句"></a>6.3.1 Group By语句</h3><p>GROUP BY语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，然后对每个组执行聚合操作。</p>
<p>案例实操：</p>
<p>​    （1）计算emp表每个部门的平均工资</p>
<p>hive (default)&gt; select t.deptno, avg(t.sal) avg_sal from emp t group by t.deptno;</p>
<p>​    （2）计算emp每个部门中每个岗位的最高薪水</p>
<p>hive (default)&gt; select t.deptno, t.job, max(t.sal) max_sal from emp t group by t.deptno, t.job;</p>
<h3 id="6-3-2-Having语句"><a href="#6-3-2-Having语句" class="headerlink" title="6.3.2 Having语句"></a>6.3.2 Having语句</h3><p>1）having与where不同点</p>
<p>（1）where针对表中的列发挥作用，查询数据；having针对查询结果中的列发挥作用，筛选数据。<strong><em>（也就是说在***</em></strong>select*<strong> *</strong>查询结果完后，having*<strong>*</strong>里面的语句才会执行。***</p>
<p><strong><em>Where***</em></strong>是在select*<strong>*</strong>结果时立即生效，参与过滤。）***</p>
<p>（2）where后面不能写分组函数，而having后面可以使用分组函数。</p>
<p>（3）having只用于group by分组统计语句。</p>
<p>2）案例实操：</p>
<p>（1）求每个部门的平均薪水大于2000的部门</p>
<p>​    求每个部门的平均工资</p>
<p>​    hive (default)&gt; select deptno, avg(sal) from emp group by deptno;</p>
<p>​    求每个部门的平均薪水大于2000的部门</p>
<p>hive (default)&gt; select deptno, avg(sal) avg_sal from emp group by deptno having avg_sal &gt; 2000;</p>
<h2 id="6-4-Join语句"><a href="#6-4-Join语句" class="headerlink" title="6.4 Join语句"></a>6.4 Join语句</h2><h3 id="6-4-1-等值Join"><a href="#6-4-1-等值Join" class="headerlink" title="6.4.1 等值Join"></a>6.4.1 等值Join</h3><p>Hive支持通常的SQL JOIN语句，但是只支持等值连接，不支持非等值连接。</p>
<p>何为非等值连接</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173744714.png" alt="image-20200509173744714"></p>
<p>案例实操</p>
<p>（1）根据员工表和部门表中的部门编号相等，查询员工编号、员工名称和部门编号；</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno, d.dname from emp e join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-2-表的别名"><a href="#6-4-2-表的别名" class="headerlink" title="6.4.2 表的别名"></a>6.4.2 表的别名</h3><p>1）好处</p>
<p>（1）使用别名可以简化查询。</p>
<p>（2）使用表名前缀可以提高执行效率。</p>
<p>2）案例实操</p>
<p>合并员工表和部门表</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-3-内连接"><a href="#6-4-3-内连接" class="headerlink" title="6.4.3 内连接"></a>6.4.3 内连接</h3><p>内连接：只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-4-左外连接"><a href="#6-4-4-左外连接" class="headerlink" title="6.4.4 左外连接"></a>6.4.4 左外连接</h3><p>​    左外连接：JOIN操作符左边表中符合WHERE子句的所有记录将会被返回。</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e left join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-5-右外连接"><a href="#6-4-5-右外连接" class="headerlink" title="6.4.5 右外连接"></a>6.4.5 右外连接</h3><p>右外连接：JOIN操作符右边表中符合WHERE子句的所有记录将会被返回。</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e right join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-6-满外连接（oracle支持fulljoin语法，mysql没有该语法）"><a href="#6-4-6-满外连接（oracle支持fulljoin语法，mysql没有该语法）" class="headerlink" title="6.4.6 满外连接（oracle支持fulljoin语法，mysql没有该语法）"></a>6.4.6 满外连接（oracle支持fulljoin语法，mysql没有该语法）</h3><p>​    满外连接：将会返回所有表中符合WHERE语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用NULL值替代。</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e full join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-7-多表连接"><a href="#6-4-7-多表连接" class="headerlink" title="6.4.7 多表连接"></a>6.4.7 多表连接</h3><p>注意：连接 n个表，至少需要n-1个连接条件。例如：连接三个表，至少需要两个连接条件。</p>
<p>0）数据准备</p>
<p> 1700    Beijing<br>1800    London<br>1900    Tokyo</p>
<p>1）创建位置表</p>
<p>  create table if not  exists default.location(  loc int,  loc_name string  )  row format  delimited fields terminated by ‘\t’;  </p>
<p>2）导入数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/location.txt’ into table default.location;</p>
<p>3）多表连接查询</p>
<p>hive (default)&gt;SELECT e.ename, d.deptno, l. loc_name</p>
<p>FROM  emp e </p>
<p>JOIN  dept d</p>
<p>ON   d.deptno = e.deptno</p>
<p>JOIN  location l</p>
<p>ON   d.loc = l.loc;</p>
<p>大多数情况下，Hive会对每对JOIN连接对象启动一个MapReduce任务。本例中会首先启动一个MapReduce job对表e和表d进行连接操作，然后会再启动一个MapReduce job将第一个MapReduce job的输出和表l;进行连接操作。</p>
<p>注意：为什么不是表d和表l先进行连接操作呢？这是因为Hive总是按照从左到右的顺序执行的。</p>
<h3 id="6-4-8-笛卡尔积"><a href="#6-4-8-笛卡尔积" class="headerlink" title="6.4.8 笛卡尔积"></a>6.4.8 笛卡尔积</h3><p>1）笛卡尔集会在下面条件下产生:</p>
<p>（1）省略连接条件</p>
<p>（2）连接条件无效</p>
<p>（3）所有表中的所有行互相连接</p>
<p>2）案例实操</p>
<p>hive (default)&gt; select empno, deptno from emp, dept;</p>
<p>FAILED: SemanticException Column deptno Found in more than One Tables/Subqueries</p>
<h3 id="6-4-9-连接谓词中不支持or"><a href="#6-4-9-连接谓词中不支持or" class="headerlink" title="6.4.9 连接谓词中不支持or"></a>6.4.9 连接谓词中不支持or</h3><p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno = d.deptno or e.ename=d.ename;  错误的</p>
<h2 id="6-5-排序"><a href="#6-5-排序" class="headerlink" title="6.5 排序"></a>6.5 排序</h2><h3 id="6-5-1-全局排序（Order-By）"><a href="#6-5-1-全局排序（Order-By）" class="headerlink" title="6.5.1 全局排序（Order By）"></a>6.5.1 全局排序（Order By）</h3><p>Order By：全局排序，一个MapReduce</p>
<p>1）使用 ORDER BY 子句排序</p>
<p>ASC（ascend）: 升序（默认）</p>
<p>DESC（descend）: 降序</p>
<p>2）ORDER BY 子句在SELECT语句的结尾。</p>
<p>3）案例实操</p>
<p>​    （1）查询员工信息按工资升序排列</p>
<p>hive (default)&gt; select * from emp order by sal;</p>
<p>​    （2）查询员工信息按工资降序排列</p>
<p>hive (default)&gt; select * from emp order by sal desc;</p>
<h3 id="6-5-2-按照别名排序"><a href="#6-5-2-按照别名排序" class="headerlink" title="6.5.2 按照别名排序"></a>6.5.2 按照别名排序</h3><p>按照员工薪水的2倍排序</p>
<p>hive (default)&gt; select ename, sal*2 twosal from emp order by twosal;</p>
<h3 id="6-5-3-多个列排序"><a href="#6-5-3-多个列排序" class="headerlink" title="6.5.3 多个列排序"></a>6.5.3 多个列排序</h3><p>按照部门和工资升序排序</p>
<p>hive (default)&gt; select ename, deptno, sal from emp order by deptno, sal ;</p>
<h3 id="6-5-4-每个MapReduce内部排序（Sort-By）"><a href="#6-5-4-每个MapReduce内部排序（Sort-By）" class="headerlink" title="6.5.4 每个MapReduce内部排序（Sort By）"></a>6.5.4 每个MapReduce内部排序（Sort By）</h3><p>Sort By：每个MapReduce内部进行排序，对全局结果集来说不是排序。</p>
<p>​    1）设置reduce个数</p>
<p>hive (default)&gt; set mapreduce.job.reduces=3;</p>
<p>2）查看设置reduce个数</p>
<p>hive (default)&gt; set mapreduce.job.reduces;</p>
<p>3）根据部门编号降序查看员工信息</p>
<p>hive (default)&gt; select * from emp sort by empno desc;</p>
<p>​    4）将查询结果导入到文件中（按照部门编号降序排序）</p>
<p>hive (default)&gt; insert overwrite local directory ‘/opt/module/datas/sortby-result’ select * from emp sort by deptno desc;</p>
<h3 id="6-5-5-分区排序（Distribute-By）"><a href="#6-5-5-分区排序（Distribute-By）" class="headerlink" title="6.5.5 分区排序（Distribute By）"></a>6.5.5 分区排序（Distribute By）</h3><p>Distribute By：类似MR中partition，进行分区，结合sort by使用。</p>
<p>​    注意，Hive要求DISTRIBUTE BY语句要写在SORT BY语句之前。</p>
<p>对于distribute by进行测试，一定要分配多reduce进行处理，否则无法看到distribute by的效果。</p>
<p>案例实操：</p>
<p>​    （1）先按照部门编号分区，再按照员工编号降序排序。</p>
<p>hive (default)&gt; set mapreduce.job.reduces=3;</p>
<p>​    hive (default)&gt; insert overwrite local directory ‘/opt/module/datas/distribute-result’ select * from emp distribute by deptno sort by empno desc;</p>
<h3 id="6-5-6-Cluster-By"><a href="#6-5-6-Cluster-By" class="headerlink" title="6.5.6 Cluster By"></a>6.5.6 Cluster By</h3><p>当distribute by和sorts by字段相同时，可以使用cluster by方式。</p>
<p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是倒序排序，不能指定排序规则为ASC或者DESC。</p>
<p>1）以下两种写法等价</p>
<p>hive (default)&gt; select * from emp cluster by deptno;</p>
<p>hive (default)&gt; select * from emp distribute by deptno sort by deptno;</p>
<p>注意：按照部门编号分区，不一定就是固定死的数值，可以是20号和30号部门分到一个分区里面去。</p>
<h2 id="6-6-分桶及抽样查询"><a href="#6-6-分桶及抽样查询" class="headerlink" title="6.6 分桶及抽样查询"></a>6.6 分桶及抽样查询</h2><h3 id="6-6-1-分桶表数据存储"><a href="#6-6-1-分桶表数据存储" class="headerlink" title="6.6.1 分桶表数据存储"></a>6.6.1 分桶表数据存储</h3><p>​    分区针对的是数据的存储路径（通过分文件夹的方式存储数据）；分桶针对的是数据文件。（通过把一份数据分为几分去存储）</p>
<p>分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可形成合理的分区，特别是之前所提到过的要确定合适的划分大小这个疑虑。</p>
<p>​    分桶是将数据集分解成更容易管理的若干部分的另一个技术。</p>
<p>1）先创建分桶表，通过直接导入数据文件的方式</p>
<p>（0）数据准备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1001	ss1</div><div class="line">1002	ss2</div><div class="line">1003	ss3</div><div class="line">1004	ss4</div><div class="line">1005	ss5</div><div class="line">1006	ss6</div><div class="line">1007	ss7</div><div class="line">1008	ss8</div><div class="line">1009	ss9</div><div class="line">1010	ss10</div><div class="line">1011	ss11</div><div class="line">1012	ss12</div><div class="line">1013	ss13</div><div class="line">1014	ss14</div><div class="line">1015	ss15</div><div class="line">1016	ss16</div></pre></td></tr></table></figure>
<p>（1）创建分桶表</p>
<p>  create table  stu_buck(id int, name string)  clustered by(id)   into 4 buckets  row format  delimited fields terminated by ‘\t’;  </p>
<p>（2）查看表结构</p>
<p>hive (default)&gt; desc formatted stu_buck;</p>
<p>Num Buckets:      4   </p>
<p>（3）导入数据到分桶表中</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/student.txt’ into table stu_buck;</p>
<p>（4）查看创建的分桶表中是否分成4个桶</p>
<p>发现并没有分成4个桶。是什么原因呢？</p>
<p>2）创建分桶表时，数据通过子查询的方式导入</p>
<p>​    （1）先建一个普通的stu表</p>
<p>  create table stu(id  int, name string)  row format  delimited fields terminated by ‘\t’;  </p>
<p>​    （2）向普通的stu表中导入数据</p>
<p>  load data local inpath ‘/opt/module/datas/student.txt’  into table stu;  </p>
<p>​    （3）清空stu_buck表中数据</p>
<p>  truncate table  stu_buck;  select * from  stu_buck;  </p>
<p>​    （4）导入数据到分桶表，通过子查询的方式</p>
<p>  insert into table  stu_buck  select id, name  from stu;  </p>
<p>（5）发现还是只有一个分桶</p>
<p>（6）需要设置一个属性</p>
<p>  hive (default)&gt; set hive.enforce.bucketing=true;  hive (default)&gt; set mapreduce.job.reduces=-1;  hive (default)&gt; insert into table stu_buck  select id, name from  stu;  </p>
<p>l <strong><em>可以看到，把student***</em></strong>的数据分为了四份存储。***</p>
<p>（7）查询分桶的数据</p>
<p>  hive  (default)&gt; select * from stu_buck;  OK  stu_buck.id   stu_buck.name  1001  ss1  1005  ss5  1009  ss9  1012  ss12  1016  ss16  1002  ss2  1006  ss6  1013  ss13  1003  ss3  1007  ss7  1010  ss10  1014  ss14  1004  ss4  1008  ss8  1011  ss11  1015  ss15  </p>
<h3 id="6-6-2-分桶抽样查询"><a href="#6-6-2-分桶抽样查询" class="headerlink" title="6.6.2 分桶抽样查询"></a>6.6.2 分桶抽样查询</h3><p>对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是全部结果。Hive可以通过对表进行抽样来满足这个需求。</p>
<p>查询表stu_buck中的数据。</p>
<p>  hive (default)&gt; select * from stu_buck tablesample(bucket 1 out of 4 on id);  </p>
<p>注：tablesample是抽样语句，语法：TABLESAMPLE(BUCKET x OUT OF y) 。</p>
<p>y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽样的比例。例如，table总共分了4份，当y=2时，抽取(4/2=)2个bucket的数据，当y=8时，抽取(4/8=)1/2个bucket的数据。</p>
<p>x表示从哪个bucket开始抽取。例如，table总bucket数为4，tablesample(bucket 4 out of 4)，表示总共抽取（4/4=）1个bucket的数据，抽取第4个bucket的数据。</p>
<p>注意：x的值必须小于等于y的值，否则</p>
<p>FAILED: SemanticException [Error 10061]: Numerator should not be bigger than denominator in sample clause for table stu_buck</p>
<h3 id="6-6-3-数据块抽样"><a href="#6-6-3-数据块抽样" class="headerlink" title="6.6.3 数据块抽样"></a>6.6.3 数据块抽样</h3><p>Hive提供了另外一种按照百分比进行抽样的方式，这种是基于行数的，按照输入路径下的数据块百分比进行的抽样。</p>
<p>  hive (default)&gt; select * from stu tablesample(0.1 percent) ;  </p>
<p>提示：这种抽样方式不一定适用于所有的文件格式。另外，这种抽样的最小抽样单元是一个HDFS数据块。因此，如果表的数据大小小于普通的块大小128M的话，那么将会返回所有行。</p>
<h1 id="七-函数"><a href="#七-函数" class="headerlink" title="七 函数"></a>七 函数</h1><h2 id="7-1-系统自带的函数"><a href="#7-1-系统自带的函数" class="headerlink" title="7.1 系统自带的函数"></a>7.1 系统自带的函数</h2><p>1）查看系统自带的函数</p>
<p>hive&gt; show functions;</p>
<p>2）显示自带的函数的用法</p>
<p>hive&gt; desc function upper;</p>
<p>3）详细显示自带的函数的用法</p>
<p>hive&gt; desc function extended upper;</p>
<h2 id="7-2-自定义函数"><a href="#7-2-自定义函数" class="headerlink" title="7.2 自定义函数"></a>7.2 自定义函数</h2><p>1）Hive 自带了一些函数，比如：max/min等，但是数量有限，自己可以通过自定义UDF来方便的扩展。</p>
<p>2）当Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。</p>
<p>3）根据用户自定义函数类别分为以下三种：</p>
<p>​    （1）UDF（User-Defined-Function）</p>
<p>​       一进一出</p>
<p>​    （2）UDAF（User-Defined Aggregation Function）</p>
<p>​       聚集函数，多进一出</p>
<p>​       类似于：count/max/min</p>
<p>​    （3）UDTF（User-Defined Table-Generating Functions）</p>
<p>​       一进多出</p>
<p>​       如lateral view explore()</p>
<p>4）官方文档地址</p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/HivePlugins</a></p>
<p>5）编程步骤：</p>
<p>​    （1）继承org.apache.hadoop.hive.ql.UDF</p>
<p>​    （2）需要实现evaluate函数；evaluate函数支持重载；</p>
<p>​    （3）在hive的命令行窗口创建函数</p>
<p>​       a）添加jar</p>
<p>​           add jar linux_jar_path</p>
<p>​       b）创建function，</p>
<p>​           create [temporary] function [dbname.]function_name AS class_name;</p>
<p>​    （4）在hive的命令行窗口删除函数</p>
<p>​       Drop [temporary] function [if exists] [dbname.]function_name;</p>
<p>6）注意事项</p>
<p>​    （1）UDF必须要有返回类型，可以返回null，但是返回类型不能为void；</p>
<h2 id="7-3-自定义UDF函数开发案例"><a href="#7-3-自定义UDF函数开发案例" class="headerlink" title="7.3 自定义UDF函数开发案例"></a>7.3 自定义UDF函数开发案例</h2><p>1）创建一个java工程，并创建一个lib文件夹</p>
<p>2）将hive的jar包解压后，将apache-hive-1.2.1-bin\lib文件下的jar包都拷贝到java工程中。</p>
<p>3）创建一个类</p>
<p>  package  com.kingge.hive;  import org.apache.hadoop.hive.ql.exec.UDF;     public  class Lower extends UDF {         public String evaluate  (final String s) {                  if (s == null) {             return null;         }                  return  s.toString().toLowerCase();      }  }  </p>
<p>4）打成jar包上传到服务器/opt/module/jars/udf.jar</p>
<p>5）将jar包添加到hive的classpath</p>
<p>hive (default)&gt; add jar /opt/module/datas/udf.jar;</p>
<p>6）创建<strong><em>临时函数\</em></strong>与开发好的java class关联（<strong><em>临时函数***</em></strong>hive*<strong>*</strong>命令窗口一关闭马上销毁，本质是没有注册到元数据中***）</p>
<p>hive (default)&gt; create temporary function udf_lower as “com.kingge.hive.Lower”;</p>
<p>7）即可在hql中使用自定义的函数strip </p>
<p>hive (default)&gt; select ename, udf_lower(ename) lowername from emp;</p>
<h1 id="八-压缩和存储"><a href="#八-压缩和存储" class="headerlink" title="八 压缩和存储"></a>八 压缩和存储</h1><h2 id="8-1-Hadoop源码编译支持Snappy压缩"><a href="#8-1-Hadoop源码编译支持Snappy压缩" class="headerlink" title="8.1 Hadoop源码编译支持Snappy压缩"></a>8.1 Hadoop源码编译支持Snappy压缩</h2><h3 id="8-1-1-资源准备"><a href="#8-1-1-资源准备" class="headerlink" title="8.1.1 资源准备"></a>8.1.1 资源准备</h3><p>1）CentOS联网 </p>
<p>配置CentOS能连接外网。Linux虚拟机ping <a href="http://www.baidu.com" target="_blank" rel="external">www.baidu.com</a> 是畅通的</p>
<p>注意：采用root角色编译，减少文件夹权限出现问题</p>
<p>2）jar包准备(hadoop源码、JDK8 、maven、protobuf)</p>
<p>（1）hadoop-2.7.2-src.tar.gz</p>
<p>（2）jdk-8u144-linux-x64.tar.gz</p>
<p>（3）snappy-1.1.3.tar.gz</p>
<p>（4）apache-maven-3.0.5-bin.tar.gz</p>
<p>（5）protobuf-2.5.0.tar.gz</p>
<h3 id="8-1-2-jar包安装"><a href="#8-1-2-jar包安装" class="headerlink" title="8.1.2 jar包安装"></a>8.1.2 jar包安装</h3><p>0）注意：所有操作必须在root用户下完成</p>
<p>1）JDK解压、配置环境变量JAVA_HOME和PATH，验证<a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">java</a>-version(如下都需要验证是否配置成功)</p>
<p>[root@hadoop101 software] # tar -zxf jdk-8u144-linux-x64.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 software]# vi /etc/profile</p>
<p>  #JAVA_HOME  export JAVA_HOME=/opt/module/jdk1.8.0_144  export PATH=$PATH:$JAVA_HOME/bin  </p>
<p>[root@hadoop101 software]#source /etc/profile</p>
<p>验证命令：java -version</p>
<p>2）Maven解压、配置 MAVEN_HOME和PATH。</p>
<p>[root@hadoop101 software]# tar -zxvf apache-maven-3.0.5-bin.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 apache-maven-3.0.5]# vi /etc/profile</p>
<p>  #MAVEN_HOME  export  MAVEN_HOME=/opt/module/apache-maven-3.0.5  export PATH=$PATH:$MAVEN_HOME/bin  </p>
<p>[root@hadoop101 software]#source /etc/profile</p>
<p>验证命令：mvn -version</p>
<h3 id="8-1-3-编译源码"><a href="#8-1-3-编译源码" class="headerlink" title="8.1.3 编译源码"></a>8.1.3 编译源码</h3><p>1）准备编译环境</p>
<p>[root@hadoop101 software]# yum install svn</p>
<p>[root@hadoop101 software]# yum install autoconf automake libtool cmake</p>
<p>[root@hadoop101 software]# yum install ncurses-devel</p>
<p>[root@hadoop101 software]# yum install openssl-devel</p>
<p>[root@hadoop101 software]# yum install gcc*</p>
<p>2）编译安装snappy</p>
<p>[root@hadoop101 software]# tar -zxvf snappy-1.1.3.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 module]# cd snappy-1.1.3/</p>
<p>[root@hadoop101 snappy-1.1.3]# ./configure</p>
<p>[root@hadoop101 snappy-1.1.3]# make</p>
<p>[root@hadoop101 snappy-1.1.3]# make install</p>
<p># 查看snappy库文件</p>
<p>[root@hadoop101 snappy-1.1.3]# ls -lh /usr/local/lib |grep snappy</p>
<p>3）编译安装protobuf</p>
<p>[root@hadoop101 software]# tar -zxvf protobuf-2.5.0.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 module]# cd protobuf-2.5.0/</p>
<p>[root@hadoop101 protobuf-2.5.0]# ./configure </p>
<p>[root@hadoop101 protobuf-2.5.0]# make </p>
<p>[root@hadoop101 protobuf-2.5.0]# make install</p>
<p># 查看protobuf版本以测试是否安装成功<br> [root@hadoop101 protobuf-2.5.0]# protoc –version</p>
<p>4）编译hadoop native</p>
<p>[root@hadoop101 software]# tar -zxvf hadoop-2.7.2-src.tar.gz</p>
<p>[root@hadoop101 software]# cd hadoop-2.7.2-src/</p>
<p>[root@hadoop101 software]# mvn clean package -DskipTests -Pdist,native -Dtar -Dsnappy.lib=/usr/local/lib -Dbundle.snappy</p>
<p>执行成功后，/opt/software/hadoop-2.7.2-src/hadoop-dist/target/<a href="http://lib.csdn.net/base/hadoop" target="_blank" rel="external">hadoop</a>-2.7.2.tar.gz即为新生成的支持snappy压缩的二进制安装包。</p>
<h2 id="8-2-Hadoop压缩配置"><a href="#8-2-Hadoop压缩配置" class="headerlink" title="8.2 Hadoop压缩配置"></a>8.2 Hadoop压缩配置</h2><h3 id="8-2-1-MR支持的压缩编码"><a href="#8-2-1-MR支持的压缩编码" class="headerlink" title="8.2.1 MR支持的压缩编码"></a>8.2.1 MR支持的压缩编码</h3><table>
<thead>
<tr>
<th>压缩格式</th>
<th>工具</th>
<th>算法</th>
<th>文件扩展名</th>
<th>是否可切分</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFAULT</td>
<td>无</td>
<td>DEFAULT</td>
<td>.deflate</td>
<td>否</td>
</tr>
<tr>
<td>Gzip</td>
<td>gzip</td>
<td>DEFAULT</td>
<td>.gz</td>
<td>否</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2</td>
<td>bzip2</td>
<td>.bz2</td>
<td>是</td>
</tr>
<tr>
<td>LZO</td>
<td>lzop</td>
<td>LZO</td>
<td>.lzo</td>
<td>是</td>
</tr>
<tr>
<td>Snappy</td>
<td>无</td>
<td>Snappy</td>
<td>.snappy</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>为了支持多种压缩/解压缩算法，Hadoop引入了编码/解码器，如下表所示</p>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>对应的编码/解码器</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFLATE</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
</tr>
<tr>
<td>gzip</td>
<td>org.apache.hadoop.io.compress.GzipCodec</td>
</tr>
<tr>
<td>bzip2</td>
<td>org.apache.hadoop.io.compress.BZip2Codec</td>
</tr>
<tr>
<td>LZO</td>
<td>com.hadoop.compression.lzo.LzopCodec</td>
</tr>
<tr>
<td>Snappy</td>
<td>org.apache.hadoop.io.compress.SnappyCodec</td>
</tr>
</tbody>
</table>
<p>压缩性能的比较</p>
<table>
<thead>
<tr>
<th>压缩算法</th>
<th>原始文件大小</th>
<th>压缩文件大小</th>
<th>压缩速度</th>
<th>解压速度</th>
</tr>
</thead>
<tbody>
<tr>
<td>gzip</td>
<td>8.3GB</td>
<td>1.8GB</td>
<td>17.5MB/s</td>
<td>58MB/s</td>
</tr>
<tr>
<td>bzip2</td>
<td>8.3GB</td>
<td>1.1GB</td>
<td>2.4MB/s</td>
<td>9.5MB/s</td>
</tr>
<tr>
<td>LZO</td>
<td>8.3GB</td>
<td>2.9GB</td>
<td>49.3MB/s</td>
<td>74.6MB/s</td>
</tr>
</tbody>
</table>
<p><a href="http://google.github.io/snappy/" target="_blank" rel="external">http://google.github.io/snappy/</a></p>
<p>On a single core of a Core i7 processor in 64-bit mode, Snappy compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more.</p>
<h3 id="8-2-2-压缩参数配置"><a href="#8-2-2-压缩参数配置" class="headerlink" title="8.2.2 压缩参数配置"></a>8.2.2 压缩参数配置</h3><p>要在Hadoop中启用压缩，可以配置如下参数（mapred-site.xml文件中）：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>阶段</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>io.compression.codecs    （在core-site.xml中配置）</td>
<td>org.apache.hadoop.io.compress.DefaultCodec,  org.apache.hadoop.io.compress.GzipCodec,  org.apache.hadoop.io.compress.BZip2Codec,  org.apache.hadoop.io.compress.Lz4Codec</td>
<td>输入压缩</td>
<td>Hadoop使用文件扩展名判断是否支持某种编解码器</td>
</tr>
<tr>
<td>mapreduce.map.output.compress</td>
<td>false</td>
<td>mapper输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.map.output.compress.codec</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
<td>mapper输出</td>
<td>使用LZO、LZ4或snappy编解码器在此阶段压缩数据</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress</td>
<td>false</td>
<td>reducer输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.codec</td>
<td>org.apache.hadoop.io.compress.  DefaultCodec</td>
<td>reducer输出</td>
<td>使用标准工具或者编解码器，如gzip和bzip2</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.type</td>
<td>RECORD</td>
<td>reducer输出</td>
<td>SequenceFile输出使用的压缩类型：NONE和BLOCK</td>
</tr>
</tbody>
</table>
<h2 id="8-3-开启Map输出阶段压缩"><a href="#8-3-开启Map输出阶段压缩" class="headerlink" title="8.3 开启Map输出阶段压缩"></a>8.3 开启Map输出阶段压缩</h2><p>开启map输出阶段压缩可以减少job中map和Reduce task间数据传输量。具体配置如下：</p>
<p><strong>案例实操：</strong></p>
<p>​    1）开启hive中间传输数据压缩功能</p>
<p>hive (default)&gt;set hive.exec.compress.intermediate=true;</p>
<p>2）开启mapreduce中map输出压缩功能</p>
<p>hive (default)&gt;set mapreduce.map.output.compress=true;</p>
<p>3）设置mapreduce中map输出数据的压缩方式</p>
<p>hive (default)&gt;set mapreduce.map.output.compress.codec= org.apache.hadoop.io.compress.SnappyCodec;</p>
<p>4）执行查询语句</p>
<p>​    hive (default)&gt; select count(ename) name from emp;</p>
<h2 id="8-4-开启Reduce输出阶段压缩"><a href="#8-4-开启Reduce输出阶段压缩" class="headerlink" title="8.4 开启Reduce输出阶段压缩"></a>8.4 开启Reduce输出阶段压缩</h2><p>当Hive将输出写入到表中时，输出内容同样可以进行压缩。属性hive.exec.compress.output控制着这个功能。用户可能需要保持默认设置文件中的默认值false，这样默认的输出就是非压缩的纯文本文件了。用户可以通过在查询语句或执行脚本中设置这个值为true，来开启输出结果压缩功能。</p>
<p><strong>案例实操：</strong></p>
<p>1）开启hive最终输出数据压缩功能</p>
<p>hive (default)&gt;set hive.exec.compress.output=true;</p>
<p>2）开启mapreduce最终输出数据压缩</p>
<p>hive (default)&gt;set mapreduce.output.fileoutputformat.compress=true;</p>
<p>3）设置mapreduce最终数据输出压缩方式</p>
<p>hive (default)&gt; set mapreduce.output.fileoutputformat.compress.codec = org.apache.hadoop.io.compress.SnappyCodec;</p>
<p>4）设置mapreduce最终数据输出压缩为块压缩</p>
<p>hive (default)&gt; set mapreduce.output.fileoutputformat.compress.type=BLOCK;</p>
<p>5）测试一下输出结果是否是压缩文件</p>
<p>hive (default)&gt; insert overwrite local directory ‘/opt/module/datas/distribute-result’ select * from emp distribute by deptno sort by empno desc;</p>
<h2 id="8-5-文件存储格式"><a href="#8-5-文件存储格式" class="headerlink" title="8.5 文件存储格式"></a>8.5 文件存储格式</h2><p>Hive支持的存储数的格式主要有：TEXTFILE 、SEQUENCEFILE、ORC、PARQUET。</p>
<h3 id="8-5-1-列式存储和行式存储"><a href="#8-5-1-列式存储和行式存储" class="headerlink" title="8.5.1 列式存储和行式存储"></a>8.5.1 列式存储和行式存储</h3><p>上图左边为逻辑表，右边第一个为行式存储，第二个为列式存储。</p>
<p><strong>行存储的特点：</strong> 查询满足条件的一整行数据的时候，列存储则需要去每个聚集的字段找到对应的每个列的值，行存储只需要找到其中一个值，其余的值都在相邻地方，所以此时行存储查询的速度更快。</p>
<p><strong>列存储的特点：</strong> 因为每个字段的数据聚集存储，在查询只需要少数几个字段的时候，能大大减少读取的数据量；每个字段的数据类型一定是相同的，列式存储可以针对性的设计更好的设计压缩算法。</p>
<p>TEXTFILE和SEQUENCEFILE的存储格式都是基于行存储的；</p>
<p>ORC和PARQUET是基于列式存储的。</p>
<h3 id="8-5-2-TextFile格式"><a href="#8-5-2-TextFile格式" class="headerlink" title="8.5.2 TextFile格式"></a>8.5.2 TextFile格式</h3><p>默认格式，数据不做压缩，磁盘开销大，数据解析开销大。可结合Gzip、Bzip2使用，但使用Gzip这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。</p>
<h3 id="8-5-3-Orc格式"><a href="#8-5-3-Orc格式" class="headerlink" title="8.5.3 Orc格式"></a>8.5.3 Orc格式</h3><p>Orc (Optimized Row Columnar)是Hive 0.11版里引入的新的存储格式。</p>
<p>可以看到每个Orc文件由1个或多个stripe组成，每个stripe250MB大小，这个Stripe实际相当于RowGroup概念，不过大小由4MB-&gt;250MB，这样应该能提升顺序读的吞吐率。每个Stripe里有三部分组成，分别是Index Data，Row Data，Stripe Footer：</p>
<p>  1）Index Data：一个轻量级的index，默认是每隔1W行做一个索引。这里做的索引应该只是记录某行的各字段在Row Data中的offset。</p>
<p>  2）Row Data：存的是具体的数据，先取部分行，然后对这些行按列进行存储。对每个列进行了编码，分成多个Stream来存储。</p>
<p>  3）Stripe Footer：存的是各个Stream的类型，长度等信息。</p>
<p>每个文件有一个File Footer，这里面存的是每个Stripe的行数，每个Column的数据类型信息等；每个文件的尾部是一个PostScript，这里面记录了整个文件的压缩类型以及FileFooter的长度信息等。在读取文件时，会seek到文件尾部读PostScript，从里面解析到File Footer长度，再读FileFooter，从里面解析到各个Stripe信息，再读各个Stripe，即从后往前读。</p>
<h3 id="8-5-4-Parquet格式"><a href="#8-5-4-Parquet格式" class="headerlink" title="8.5.4 Parquet格式"></a>8.5.4 Parquet格式</h3><p>Parquet是面向分析型业务的列式存储格式，由Twitter和Cloudera合作开发，2015年5月从Apache的孵化器里毕业成为Apache顶级项目。</p>
<p>Parquet文件是以二进制方式存储的，所以是不可以直接读取的，文件中包括该文件的数据和元数据，因此Parquet格式文件是自解析的。</p>
<p>通常情况下，在存储Parquet数据的时候会按照Block大小设置行组的大小，由于一般情况下每一个Mapper任务处理数据的最小单位是一个Block，这样可以把每一个行组由一个Mapper任务处理，增大任务执行并行度。Parquet文件的格式如下图所示。</p>
<p>上图展示了一个Parquet文件的内容，一个文件中可以存储多个行组，文件的首位都是该文件的Magic Code，用于校验它是否是一个Parquet文件，Footer length记录了文件元数据的大小，通过该值和文件长度可以计算出元数据的偏移量，文件的元数据中包括每一个行组的元数据信息和该文件存储数据的Schema信息。除了文件中每一个行组的元数据，每一页的开始都会存储该页的元数据，在Parquet中，有三种类型的页：数据页、字典页和索引页。数据页用于存储当前行组中该列的值，字典页存储该列值的编码字典，每一个列块中最多包含一个字典页，索引页用来存储当前行组下该列的索引，目前Parquet中还不支持索引页。</p>
<h3 id="8-5-5-主流文件存储格式对比实验"><a href="#8-5-5-主流文件存储格式对比实验" class="headerlink" title="8.5.5 主流文件存储格式对比实验"></a>8.5.5 主流文件存储格式对比实验</h3><p>从存储文件的压缩比和查询速度两个角度对比。</p>
<p><strong>存储文件的压缩比测试：</strong></p>
<p>0）测试数据</p>
<p>1）TextFile</p>
<p>（1）创建表，存储数据格式为TEXTFILE</p>
<p>  create table log_text (  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as textfile ;  </p>
<p>（2）向表中加载数据</p>
<p>  hive  (default)&gt; load data local inpath ‘/opt/module/datas/log.data’ into table  log_text ;  </p>
<p>（3）查看表中数据大小</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_text;  </p>
<p>18.1 M /user/hive/warehouse/log_text/log.data</p>
<p>2）ORC</p>
<p>​    （1）创建表，存储数据格式为ORC</p>
<p>  create table log_orc(  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as orc ;  </p>
<p>（2）向表中加载数据</p>
<p>  hive  (default)&gt; insert into table log_orc select * from log_text ;  </p>
<p>（3）查看表中数据大小</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_orc/ ;  </p>
<p>2.8 M /user/hive/warehouse/log_orc/000000_0</p>
<p>3）Parquet</p>
<p>​    （1）创建表，存储数据格式为parquet</p>
<p>  create table log_parquet(  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as parquet ;                 </p>
<p>（2）向表中加载数据</p>
<p>  hive  (default)&gt; insert into table log_parquet select * from log_text ;  </p>
<p>（3）查看表中数据大小</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_parquet/ ;  </p>
<p>13.1 M  /user/hive/warehouse/log_parquet/000000_0</p>
<p>存储文件的压缩比总结：</p>
<p>ORC &gt; Parquet &gt; textFile</p>
<p><strong>存储文件的查询速度测试：</strong></p>
<p>1）TextFile</p>
<p>hive (default)&gt; select count(*) from log_text;</p>
<p>_c0</p>
<p>100000</p>
<p>Time taken: 21.54 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 21.08 seconds, Fetched: 1 row(s)</p>
<p>2）ORC</p>
<p>hive (default)&gt; select count(*) from log_orc;</p>
<p>_c0</p>
<p>100000</p>
<p>Time taken: 20.867 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 22.667 seconds, Fetched: 1 row(s)</p>
<p>3）Parquet</p>
<p>hive (default)&gt; select count(*) from log_parquet;</p>
<p>_c0</p>
<p>100000</p>
<p>Time taken: 22.922 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 21.074 seconds, Fetched: 1 row(s)</p>
<p>存储文件的查询速度总结：查询速度相近。</p>
<h2 id="8-6-存储和压缩结合"><a href="#8-6-存储和压缩结合" class="headerlink" title="8.6 存储和压缩结合"></a>8.6 存储和压缩结合</h2><h3 id="8-6-1-修改Hadoop集群具有Snappy压缩方式"><a href="#8-6-1-修改Hadoop集群具有Snappy压缩方式" class="headerlink" title="8.6.1 修改Hadoop集群具有Snappy压缩方式"></a>8.6.1 修改Hadoop集群具有Snappy压缩方式</h3><p>1）查看hadoop checknative命令使用</p>
<p>[kingge@hadoop104 hadoop-2.7.2]$ hadoop</p>
<p>​       checknative [-a|-h] check native hadoop and compression libraries availability</p>
<p>2）查看hadoop支持的压缩方式</p>
<p>​    [kingge@hadoop104 hadoop-2.7.2]$ hadoop checknative</p>
<p>17/12/24 20:32:52 WARN bzip2.Bzip2Factory: Failed to load/initialize native-bzip2 library system-native, will use pure-Java version</p>
<p>17/12/24 20:32:52 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</p>
<p>Native library checking:</p>
<p>hadoop: true /opt/module/hadoop-2.7.2/lib/native/libhadoop.so</p>
<p>zlib:  true /lib64/libz.so.1</p>
<p>snappy: false </p>
<p>lz4:   true revision:99</p>
<p>bzip2:  false</p>
<p>3）将编译好的支持Snappy压缩的hadoop-2.7.2.tar.gz包导入到hadoop102的/opt/software中</p>
<p>4）解压hadoop-2.7.2.tar.gz到当前路径</p>
<p>[kingge@hadoop102 software]$ tar -zxvf hadoop-2.7.2.tar.gz</p>
<p>5）进入到/opt/software/hadoop-2.7.2/lib/native路径可以看到支持Snappy压缩的动态链接库</p>
<p>[kingge@hadoop102 native]$ pwd</p>
<p>/opt/software/hadoop-2.7.2/lib/native</p>
<p>[kingge@hadoop102 native]$ ll</p>
<p>-rw-r–r–. 1 kingge kingge 472950 9月  1 10:19 libsnappy.a</p>
<p>-rwxr-xr-x. 1 kingge kingge   955 9月  1 10:19 libsnappy.la</p>
<p>lrwxrwxrwx. 1 kingge kingge   18 12月 24 20:39 libsnappy.so -&gt; libsnappy.so.1.3.0</p>
<p>lrwxrwxrwx. 1 kingge kingge   18 12月 24 20:39 libsnappy.so.1 -&gt; libsnappy.so.1.3.0</p>
<p>-rwxr-xr-x. 1 kingge kingge 228177 9月  1 10:19 libsnappy.so.1.3.0</p>
<p>6）拷贝/opt/software/hadoop-2.7.2/lib/native里面的所有内容到开发集群的/opt/module/hadoop-2.7.2/lib/native路径上</p>
<p>​    [kingge@hadoop102 native]$ cp ../native/* /opt/module/hadoop-2.7.2/lib/native/</p>
<p>7）分发集群</p>
<p>​    [kingge@hadoop102 lib]$ xsync native/</p>
<p>8）再次查看hadoop支持的压缩类型</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ hadoop checknative</p>
<p>17/12/24 20:45:02 WARN bzip2.Bzip2Factory: Failed to load/initialize native-bzip2 library system-native, will use pure-Java version</p>
<p>17/12/24 20:45:02 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</p>
<p>Native library checking:</p>
<p>hadoop: true /opt/module/hadoop-2.7.2/lib/native/libhadoop.so</p>
<p>zlib:  true /lib64/libz.so.1</p>
<p>snappy: true /opt/module/hadoop-2.7.2/lib/native/libsnappy.so.1</p>
<p>lz4:   true revision:99</p>
<p>bzip2:  false</p>
<p>9）重新启动hadoop集群和hive</p>
<h3 id="8-6-2-测试存储和压缩"><a href="#8-6-2-测试存储和压缩" class="headerlink" title="8.6.2 测试存储和压缩"></a>8.6.2 测试存储和压缩</h3><p>官网：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC</a></p>
<p>ORC存储方式的压缩：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Default</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>orc.compress</td>
<td>ZLIB</td>
<td>high level  compression (one of NONE, ZLIB, SNAPPY)</td>
</tr>
<tr>
<td>orc.compress.size</td>
<td>262,144</td>
<td>number of  bytes in each compression chunk</td>
</tr>
<tr>
<td>orc.stripe.size</td>
<td>67,108,864</td>
<td>number of  bytes in each stripe</td>
</tr>
<tr>
<td>orc.row.index.stride</td>
<td>10,000</td>
<td>number of  rows between index entries (must be &gt;= 1000)</td>
</tr>
<tr>
<td>orc.create.index</td>
<td>true</td>
<td>whether to  create row indexes</td>
</tr>
<tr>
<td>orc.bloom.filter.columns</td>
<td>“”</td>
<td>comma  separated list of column names for which bloom filter should be created</td>
</tr>
<tr>
<td>orc.bloom.filter.fpp</td>
<td>0.05</td>
<td>false  positive probability for bloom filter (must &gt;0.0 and &lt;1.0)</td>
</tr>
</tbody>
</table>
<p>1）创建一个非压缩的的ORC存储方式</p>
<p>​    （1）建表语句</p>
<p>  create table log_orc_none(  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as orc tblproperties  (“orc.compress”=”NONE”);  </p>
<p>​    （2）插入数据</p>
<p>  hive  (default)&gt; insert into table log_orc_none select * from log_text ;  </p>
<p>​    （3）查看插入后数据</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_orc_none/ ;  </p>
<p>7.7 M /user/hive/warehouse/log_orc_none/000000_0</p>
<p>2）创建一个SNAPPY压缩的ORC存储方式</p>
<p>​    （1）建表语句</p>
<p>  create table log_orc_snappy(  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as orc tblproperties (“orc.compress”=”SNAPPY”);  </p>
<p>​    （2）插入数据</p>
<p>  hive  (default)&gt; insert into table log_orc_snappy select * from log_text ;  </p>
<p>​    （3）查看插入后数据</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_orc_snappy/ ;  </p>
<p>3.8 M  /user/hive/warehouse/log_orc_snappy/000000_0</p>
<p>3）上一节中默认创建的ORC存储方式，导入数据后的大小为</p>
<p>2.8 M /user/hive/warehouse/log_orc/000000_0</p>
<p>比Snappy压缩的还小。原因是orc存储文件默认采用ZLIB压缩。比snappy压缩的小。</p>
<p><strong>4**</strong>）存储方式和压缩总结：**</p>
<p>​    在实际的项目开发当中，hive表的数据存储格式一般选择：orc或parquet。压缩方式一般选择snappy，lzo。</p>
<h1 id="九-企业级调优"><a href="#九-企业级调优" class="headerlink" title="九 企业级调优"></a>九 企业级调优</h1><h2 id="9-1-Fetch抓取"><a href="#9-1-Fetch抓取" class="headerlink" title="9.1 Fetch抓取"></a>9.1 Fetch抓取</h2><p>Fetch抓取是指，Hive中对某些情况的查询可以不必使用MapReduce计算。例如：SELECT * FROM employees;在这种情况下，Hive可以简单地读取employee对应的存储目录下的文件，然后输出查询结果到控制台。</p>
<p>在hive-default.xml.template文件中hive.fetch.task.conversion默认是more，老版本hive默认是minimal，该属性修改为more以后，在全局查找、字段查找、limit查找等都不走mapreduce。</p>
  <property>      <name>hive.fetch.task.conversion</name>      <value>more</value>      <description>       Expects one of [none, minimal, more].       Some select queries can be converted to single FETCH task minimizing  latency.       Currently the query should be single sourced not having any subquery  and should not have       any aggregations or distincts (which incurs RS), lateral views and  joins.       0. none : disable hive.fetch.task.conversion       1.  minimal : SELECT STAR, FILTER on partition columns, LIMIT only     2. more   : SELECT, FILTER, LIMIT only (support TABLESAMPLE and virtual columns)      </description>     </property>  

<p>案例实操：</p>
<p>​    1）把hive.fetch.task.conversion设置成none，然后执行查询语句，都会执行mapreduce程序。</p>
<p>hive (default)&gt; set hive.fetch.task.conversion=none;</p>
<p>hive (default)&gt; select * from emp;</p>
<p>hive (default)&gt; select ename from emp;</p>
<p>hive (default)&gt; select ename from emp limit 3;</p>
<p>​    2）把hive.fetch.task.conversion设置成more，然后执行查询语句，如下查询方式都不会执行mapreduce程序。</p>
<p>hive (default)&gt; set hive.fetch.task.conversion=more;</p>
<p>hive (default)&gt; select * from emp;</p>
<p>hive (default)&gt; select ename from emp;</p>
<p>hive (default)&gt; select ename from emp limit 3;</p>
<h2 id="9-2-本地模式"><a href="#9-2-本地模式" class="headerlink" title="9.2 本地模式"></a>9.2 本地模式</h2><p>大多数的Hadoop Job是需要Hadoop提供的完整的可扩展性来处理大数据集的（<strong><em>意思就是需要搭建完整的***</em></strong>hadoop*<strong>*</strong>分布式集群*<strong>）。不过，有时Hive的*</strong>输入数据量是非常小*的**。在这种情况下，为查询触发执行任务消耗的时间可能会比实际job的执行时间要多的多。对于大多数这种情况，Hive可以通过本地模式在单台机器上处理所有的任务。对于小数据集，执行时间可以明显被缩短。</p>
<p>用户可以通过设置hive.exec.mode.local.auto的值为true，来让Hive在适当的时候自动启动这个优化。</p>
<p>  set hive.exec.mode.local.auto=true; //开启本地mr  //设置local mr的最大输入数据量，当输入数据量小于这个值时采用local   mr的方式，默认为134217728，即128M  set hive.exec.mode.local.auto.inputbytes.max=50000000;  //设置local mr的最大输入文件个数，当输入文件个数小于这个值时采用local mr的方式，默认为4  set hive.exec.mode.local.auto.input.files.max=10;  </p>
<p>案例实操：</p>
<p>1）开启本地模式，并执行查询语句</p>
<p>hive (default)&gt; set hive.exec.mode.local.auto=true; </p>
<p>hive (default)&gt; select * from emp cluster by deptno;</p>
<p>Time taken: 1.328 seconds, Fetched: 14 row(s)</p>
<p>2）关闭本地模式，并执行查询语句</p>
<p>hive (default)&gt; set hive.exec.mode.local.auto=false; </p>
<p>hive (default)&gt; select * from emp cluster by deptno;</p>
<p>Time taken: 20.09 seconds, Fetched: 14 row(s)</p>
<h2 id="9-3-表的优化（重要）"><a href="#9-3-表的优化（重要）" class="headerlink" title="9.3 表的优化（重要）"></a>9.3 表的优化（重要）</h2><h3 id="9-3-1-小表、大表Join"><a href="#9-3-1-小表、大表Join" class="headerlink" title="9.3.1 小表、大表Join"></a>9.3.1 小表、大表Join</h3><p>将key相对分散，并且数据量小的表放在join的左边，这样可以有效减少内存溢出错误发生的几率；再进一步，可以使用Group让小的维度表（1000条以下的记录条数）先进内存。在map端完成reduce。</p>
<p>实际测试发现：新版的hive已经对小表JOIN大表和大表JOIN小表进行了优化。小表放在左边和右边已经没有明显区别。</p>
<p><strong>案例实操</strong></p>
<p>（0）需求：测试大表JOIN小表和小表JOIN大表的效率</p>
<p>（1）建大表、小表和JOIN后表的语句</p>
<p>  // 创建大表  create table bigtable(id bigint, time bigint, uid string, keyword  string, url_rank int, click_num int, click_url string) row format delimited  fields terminated by ‘\t’;  // 创建小表  create table smalltable(id bigint, time bigint, uid string, keyword  string, url_rank int, click_num int, click_url string) row format delimited  fields terminated by ‘\t’;  // 创建join后表的语句  create table jointable(id bigint, time bigint, uid string, keyword  string, url_rank int, click_num int, click_url string) row format delimited  fields terminated by ‘\t’;  </p>
<p>（2）分别向大表和小表中导入数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/bigtable’ into table bigtable;</p>
<p>hive (default)&gt;load data local inpath ‘/opt/module/datas/smalltable’ into table smalltable;</p>
<p>（3）关闭mapjoin功能（默认是打开的-这里为了测试先把他关闭）</p>
<p>set hive.auto.convert.join = false;</p>
<p>（4）执行小表JOIN大表语句</p>
<p>  insert overwrite table jointable  select b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,  b.click_url  from smalltable s  left join bigtable b  on b.id = s.id;  </p>
<p>Time taken: 35.921 seconds</p>
<p>（5）执行大表JOIN小表语句</p>
<p>  insert overwrite table jointable  select b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,  b.click_url  from bigtable b  left join smalltable s  on s.id = b.id;  </p>
<p>Time taken: 34.196 seconds</p>
<h3 id="9-3-2-大表Join大表"><a href="#9-3-2-大表Join大表" class="headerlink" title="9.3.2 大表Join大表"></a>9.3.2 大表Join大表</h3><p>1）空KEY过滤</p>
<p>有时join超时是因为某些key对应的数据太多，而相同key对应的数据都会发送到相同的reducer上，从而导致内存不够。此时我们应该仔细分析这些异常的key，很多情况下，这些key对应的数据是异常数据，我们需要在SQL语句中进行过滤。例如key对应的字段为空，操作如下：</p>
<p>案例实操</p>
<p>（1）配置历史服务器</p>
<p>​    配置mapred-site.xml</p>
  <property>  <name>mapreduce.jobhistory.address</name>  <value>hadoop102:10020</value>  </property>  <property>      <name>mapreduce.jobhistory.webapp.address</name>      <value>hadoop102:19888</value>  </property>  

<p>​    启动历史服务器</p>
<p>sbin/mr-jobhistory-daemon.sh start historyserver</p>
<p>​    查看jobhistory</p>
<p><a href="http://192.168.1.102:19888/jobhistory" target="_blank" rel="external">http://192.168.1.102:19888/jobhistory</a></p>
<p>（2）创建原始数据表、空id表、合并后数据表</p>
<p>  // 创建原始表  create table ori(id  bigint, time bigint, uid string, keyword string, url_rank int, click_num int,  click_url string) row format delimited fields terminated by ‘\t’;  // 创建空id表  create table  nullidtable(id bigint, time bigint, uid string, keyword string, url_rank int,  click_num int, click_url string) row format delimited fields terminated by  ‘\t’;  // 创建join后表的语句  create table  jointable(id bigint, time bigint, uid string, keyword string, url_rank int,  click_num int, click_url string) row format delimited fields terminated by  ‘\t’;  </p>
<p>（3）分别加载原始数据和空id数据到对应表中</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/ori’ into table ori;</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/nullid’ into table nullidtable;</p>
<p>（4）测试不过滤空id</p>
<p>hive (default)&gt; insert overwrite table jointable </p>
<p>select n.* from nullidtable n left join ori o on n.id = o.id;</p>
<p>Time taken: 42.038 seconds</p>
<p>（5）测试过滤空id</p>
<p>hive (default)&gt; insert overwrite table jointable </p>
<p>select n.<em> from (select </em> from nullidtable where id is not null ) n left join ori o on n.id = o.id;</p>
<p>Time taken: 31.725 seconds</p>
<p>2）空key转换</p>
<p>有时虽然某个key为空对应的数据很多，但是相应的数据不是异常数据，必须要包含在join的结果中，此时我们可以表a中key为空的字段赋一个随机的值，使得数据随机均匀地分不到不同的reducer上。例如：</p>
<p><strong>案例实操：</strong></p>
<p><strong>不随机分布空**</strong>null<strong>**值：</strong></p>
<p>（1）设置5个reduce个数</p>
<p>set mapreduce.job.reduces = 5;</p>
<p>（2）JOIN两张表</p>
<p>  insert overwrite table jointable  select n.* from nullidtable n left join ori b on n.id = b.id;  </p>
<p><strong>结果：可以看出来，出现了数据倾斜，某些**</strong>reducer<strong><strong>的资源消耗远大于其他</strong></strong>reducer<strong>**。</strong></p>
<p>  <strong>打开历史服务器查看</strong></p>
<p>随机分布空null值</p>
<p>（1）设置5个reduce个数</p>
<p>set mapreduce.job.reduces = 5;</p>
<p>（2）JOIN两张表</p>
<p>  insert overwrite table  jointable  select n.* from  nullidtable n full join ori o on   case when n.id is null  then concat(‘hive’, rand()) else n.id end = o.id;  </p>
<p><strong>结果：可以看出来，消除了数据倾斜，负载均衡**</strong>reducer<strong>**的资源消耗</strong></p>
<h3 id="9-3-3-MapJoin"><a href="#9-3-3-MapJoin" class="headerlink" title="9.3.3 MapJoin"></a>9.3.3 MapJoin</h3><p>如果不指定MapJoin或者不符合MapJoin的条件，那么Hive解析器会将Join操作转换成Common Join，即：在Reduce阶段完成join。容易发生数据倾斜。可以用MapJoin把小表全部加载到内存在map端进行join，避免reducer处理。</p>
<p>1）开启MapJoin参数设置：</p>
<p>（1）设置自动选择Mapjoin</p>
<p>set hive.auto.convert.join = true; 默认为true</p>
<p>（2）大表小表的阈值设置（默认25M一下认为是小表）：</p>
<p>set hive.mapjoin.smalltable.filesize=25000000;</p>
<p>2）MapJoin工作机制</p>
<p><strong>案例实操：</strong></p>
<p>（1）开启Mapjoin功能</p>
<p>set hive.auto.convert.join = true; 默认为true</p>
<p>（2）执行小表JOIN大表语句</p>
<p>  insert overwrite table jointable  select b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,  b.click_url  from smalltable s  join bigtable b  on s.id = b.id;  </p>
<p>Time taken: 24.594 seconds</p>
<p>（3）执行大表JOIN小表语句</p>
<p>  insert overwrite table jointable  select b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,  b.click_url  from bigtable b  join smalltable s  on s.id = b.id;  </p>
<p>Time taken: 24.315 seconds</p>
<h3 id="9-3-4-Group-By"><a href="#9-3-4-Group-By" class="headerlink" title="9.3.4 Group By"></a>9.3.4 Group By</h3><p>默认情况下，Map阶段同一Key数据分发给一个reduce，当一个key数据过大时就倾斜了。</p>
<p>  并不是所有的聚合操作都需要在Reduce端完成，很多聚合操作都可以先在Map端进行部分聚合，最后在Reduce端得出最终结果。</p>
<p>1）开启Map端聚合参数设置</p>
<p>​    （1）是否在Map端进行聚合，默认为True</p>
<p>hive.map.aggr = true</p>
<p>（2）在Map端进行聚合操作的条目数目</p>
<p>  hive.groupby.mapaggr.checkinterval = 100000</p>
<p>（3）有数据倾斜的时候进行负载均衡（默认是false）</p>
<p>  hive.groupby.skewindata = true</p>
<p>  当选项设定为 true，生成的查询计划会有两个MR Job。第一个MR Job中，Map的输出结果会随机分布到Reduce中，每个Reduce做部分聚合操作，并输出结果，这样处理的结果是相同的Group By Key有可能被分发到不同的Reduce中，从而达到负载均衡的目的；第二个MR Job再根据预处理的数据结果按照Group By Key分布到Reduce中（这个过程可以保证相同的Group By Key被分布到同一个Reduce中），最后完成最终的聚合操作。</p>
<h3 id="9-3-5-Count-Distinct-去重统计"><a href="#9-3-5-Count-Distinct-去重统计" class="headerlink" title="9.3.5 Count(Distinct) 去重统计"></a>9.3.5 Count(Distinct) 去重统计</h3><p>数据量小的时候无所谓，数据量大的情况下，由于COUNT DISTINCT操作需要用一个Reduce Task来完成，这一个Reduce需要处理的数据量太大，就会导致整个Job很难完成，一般COUNT DISTINCT使用先GROUP BY再COUNT的方式替换：</p>
<p><strong>案例实操</strong></p>
<p>​    （1）创建一张大表</p>
<p>  hive (default)&gt; create table bigtable(id bigint,  time bigint, uid string, keyword string, url_rank int, click_num int,  click_url string) row format delimited fields terminated by ‘\t’;  </p>
<p>​    （2）加载数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/bigtable’ into table bigtable;</p>
<p>（3）设置5个reduce个数</p>
<p>set mapreduce.job.reduces = 5;</p>
<p>（4）执行去重id查询</p>
<p>hive (default)&gt; select count(distinct id) from bigtable;</p>
<p>Stage-Stage-1: Map: 1 Reduce: 1  Cumulative CPU: 7.12 sec  HDFS Read: 120741990 HDFS Write: 7 SUCCESS</p>
<p>Total MapReduce CPU Time Spent: 7 seconds 120 msec</p>
<p>OK</p>
<p>c0</p>
<p>100001</p>
<p>Time taken: 23.607 seconds, Fetched: 1 row(s)</p>
<p>​    （5）采用GROUP by去重id</p>
<p>hive (default)&gt; select count(id) from (select id from bigtable group by id) a;</p>
<p>Stage-Stage-1: Map: 1 Reduce: 5  Cumulative CPU: 17.53 sec  HDFS Read: 120752703 HDFS Write: 580 SUCCESS</p>
<p>Stage-Stage-2: Map: 1 Reduce: 1  Cumulative CPU: 4.29 sec  HDFS Read: 9409 HDFS Write: 7 SUCCESS</p>
<p>Total MapReduce CPU Time Spent: 21 seconds 820 msec</p>
<p>OK</p>
<p>_c0</p>
<p>100001</p>
<p>Time taken: 50.795 seconds, Fetched: 1 row(s)</p>
<p>虽然会多用一个Job来完成，但在数据量大的情况下，这个绝对是值得的。</p>
<h3 id="9-3-6-笛卡尔积"><a href="#9-3-6-笛卡尔积" class="headerlink" title="9.3.6 笛卡尔积"></a>9.3.6 笛卡尔积</h3><p>尽量避免笛卡尔积，join的时候不加on条件，或者无效的on条件，Hive只能使用1个reducer来完成笛卡尔积。</p>
<h3 id="9-3-7-行列过滤"><a href="#9-3-7-行列过滤" class="headerlink" title="9.3.7 行列过滤"></a>9.3.7 行列过滤</h3><p>列处理：在SELECT中，只拿需要的列，如果有，尽量使用分区过滤，少用SELECT <em>。（**</em>select*<strong> *</strong>具体的列名，非必要时不要使用*<strong>*</strong>select *<strong><em> </em></strong>取全列***）</p>
<p>行处理：在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在Where后面，那么就会先全表关联，之后再过滤。（<strong><em>两个表关联，那么应该先使用***</em></strong>where*<strong>*</strong>过滤自身的数据，然后再*<strong>*</strong>join*<strong>*</strong>两张表，这样数据的操作会更快***）</p>
<p>比如：</p>
<p><strong>案例实操：</strong></p>
<p>​    （1）测试先关联两张表，再用where条件过滤</p>
<p>hive (default)&gt; select o.id from bigtable b</p>
<p>join ori o on o.id = b.id</p>
<p>where o.id &lt;= 10;</p>
<p>Time taken: 34.406 seconds, Fetched: 100 row(s)</p>
<p>（2）通过子查询后，再关联表</p>
<p>hive (default)&gt; select b.id from bigtable b</p>
<p>join (select id from ori where id &lt;= 10 ) o on b.id = o.id;</p>
<p>Time taken: 30.058 seconds, Fetched: 100 row(s)</p>
<h3 id="9-3-8-动态分区调整"><a href="#9-3-8-动态分区调整" class="headerlink" title="9.3.8 动态分区调整"></a>9.3.8 动态分区调整</h3><p>关系型数据库中，对分区表Insert数据时候，数据库自动会根据分区字段的值，将数据插入到相应的分区中，Hive中也提供了类似的机制，即动态分区(Dynamic Partition)，只不过，使用Hive的动态分区，需要进行相应的配置。</p>
<p>1）开启动态分区参数设置</p>
<p>（1）开启动态分区功能（默认true，开启）</p>
<p>hive.exec.dynamic.partition=true</p>
<p>（2）设置为非严格模式（动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。）</p>
<p>hive.exec.dynamic.partition.mode=nonstrict</p>
<p>（3）在所有执行MR的节点上，最大一共可以创建多少个动态分区。</p>
<p>hive.exec.max.dynamic.partitions=1000</p>
<p>​    （4）在每个执行MR的节点上，最大可以创建多少个动态分区。该参数需要根据实际的数据来设定。比如：源数据中包含了一年的数据，即day字段有365个值，那么该参数就需要设置成大于365，如果使用默认值100，则会报错。</p>
<p>hive.exec.max.dynamic.partitions.pernode=100</p>
<p>（5）整个MR Job中，最大可以创建多少个HDFS文件。</p>
<p>hive.exec.max.created.files=100000</p>
<p>（6）当有空分区生成时，是否抛出异常。一般不需要设置。</p>
<p>hive.error.on.empty.partition=false</p>
<p>2）案例实操</p>
<p>需求：将ori中的数据按照时间(如：20111230000008)，插入到目标表ori_partitioned_target的相应分区中。</p>
<p>（1）创建分区表</p>
<p>  create table  ori_partitioned(id bigint, time bigint, uid string, keyword string, url_rank  int, click_num int, click_url string)   partitioned by (p_time  bigint)   row format delimited  fields terminated by ‘\t’;  </p>
<p>（2）加载数据到分区表中</p>
<p>  hive  (default)&gt; load data local inpath ‘/opt/module/datas/ds1’ into table  ori_partitioned partition(p_time=’20111230000010’) ;  hive  (default)&gt; load data local inpath ‘/opt/module/datas/ds2’ into table  ori_partitioned partition(p_time=’20111230000011’) ;  </p>
<p>（3）创建目标分区表</p>
<p>  create  table ori_partitioned_target(id bigint, time bigint, uid string, keyword  string, url_rank int, click_num int, click_url string) PARTITIONED BY (p_time  STRING) row format delimited fields terminated by ‘\t’;  </p>
<p>（4）设置动态分区</p>
<p>  set hive.exec.dynamic.partition = true;  set hive.exec.dynamic.partition.mode = nonstrict;  set hive.exec.max.dynamic.partitions = 1000;  set hive.exec.max.dynamic.partitions.pernode = 100;  set hive.exec.max.created.files = 100000;  set hive.error.on.empty.partition = false;     hive (default)&gt; insert overwrite table  ori_partitioned_target partition (p_time)   select id, time, uid, keyword, url_rank, click_num, click_url, p_time  from ori_partitioned;  </p>
<p>（5）查看目标分区表的分区情况</p>
<p>hive (default)&gt; show partitions ori_partitioned_target;</p>
<h3 id="9-3-9-分桶"><a href="#9-3-9-分桶" class="headerlink" title="9.3.9 分桶"></a>9.3.9 分桶</h3><p>详见6.6章。</p>
<h3 id="9-3-10-分区"><a href="#9-3-10-分区" class="headerlink" title="9.3.10 分区"></a>9.3.10 分区</h3><p>详见4.6章。</p>
<h2 id="9-4-数据倾斜"><a href="#9-4-数据倾斜" class="headerlink" title="9.4 数据倾斜"></a>9.4 数据倾斜</h2><h3 id="9-4-1-合理设置Map数"><a href="#9-4-1-合理设置Map数" class="headerlink" title="9.4.1 合理设置Map数"></a>9.4.1 合理设置Map数</h3><p><strong>1**</strong>）通常情况下，作业会通过input<strong><strong>的目录产生一个或者多个map</strong></strong>任务。**</p>
<p>主要的决定因素有：input的文件总个数，input的文件大小，集群设置的文件块大小。</p>
<p><strong>2**</strong>）是不是map<strong>**数越多越好？</strong></p>
<p>答案是否定的。如果一个任务有很多小文件（远远小于块大小128m），则每个小文件也会被当做一个块，用一个map任务来完成，而一个map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。而且，同时可执行的map数是受限的。</p>
<p><strong>3**</strong>）是不是保证每个map<strong><strong>处理接近128m</strong></strong>的文件块，就高枕无忧了？**</p>
<p>答案也是不一定。比如有一个127m的文件，正常会用一个map去完成，但这个文件只有一个或者两个小字段，却有几千万的记录，如果map处理的逻辑比较复杂，用一个map任务去做，肯定也比较耗时。</p>
<p>针对上面的问题2和3，我们需要采取两种方式来解决：即减少map数和增加map数；</p>
<h3 id="9-4-2-小文件进行合并"><a href="#9-4-2-小文件进行合并" class="headerlink" title="9.4.2 小文件进行合并"></a>9.4.2 小文件进行合并</h3><p>在map执行前合并小文件，减少map数：CombineHiveInputFormat具有对小文件进行合并的功能（系统默认的格式）。HiveInputFormat没有对小文件合并功能。</p>
<p>set hive.input.format= org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;</p>
<h3 id="9-4-3-复杂文件增加Map数"><a href="#9-4-3-复杂文件增加Map数" class="headerlink" title="9.4.3 复杂文件增加Map数"></a>9.4.3 复杂文件增加Map数</h3><p>当input的文件都很大，任务逻辑复杂，map执行非常慢的时候，可以考虑增加Map数，来使得每个map处理的数据量减少，从而提高任务的执行效率。</p>
<p>增加map的方法为：根据computeSliteSize(Math.max(minSize,Math.min(maxSize,blocksize)))=blocksize=128M公式，调整maxSize最大值。让maxSize最大值低于blocksize就可以增加map的个数。</p>
<p><strong>案例实操：</strong></p>
<p>（1）执行查询</p>
<p>hive (default)&gt; select count(*) from emp;</p>
<p>Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 1</p>
<p>​    （2）设置最大切片值为100个字节 默认256M</p>
<p>hive (default)&gt; set mapreduce.input.fileinputformat.split.maxsize=100;</p>
<p>hive (default)&gt; select count(*) from emp;</p>
<p>Hadoop job information for Stage-1: number of mappers: 6; number of reducers: 1</p>
<h3 id="9-4-4-合理设置Reduce数"><a href="#9-4-4-合理设置Reduce数" class="headerlink" title="9.4.4 合理设置Reduce数"></a>9.4.4 合理设置Reduce数</h3><p><strong>1**</strong>）调整reduce<strong>**个数方法一</strong></p>
<p>（1）每个Reduce处理的数据量默认是256MB</p>
<p>hive.exec.reducers.bytes.per.reducer=256000000</p>
<p>​    （2）每个任务最大的reduce数，默认为1009</p>
<p>hive.exec.reducers.max=1009</p>
<p>（3）计算reducer数的公式</p>
<p>N=min(参数2，总输入数据量/参数1)</p>
<p><strong>2**</strong>）调整reduce<strong>**个数方法二</strong></p>
<p>在hadoop的mapred-default.xml文件中修改</p>
<p>设置每个job的Reduce个数</p>
<p>set mapreduce.job.reduces = 15;</p>
<p><strong>3**</strong>）reduce<strong>**个数并不是越多越好</strong></p>
<p>1）过多的启动和初始化reduce也会消耗时间和资源；</p>
<p>2）另外，有多少个reduce，就会有多少个输出文件，如果生成了很多个小文件，那么如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题；</p>
<p>在设置reduce个数的时候也需要考虑这两个原则：处理大数据量利用合适的reduce数；使单个reduce任务处理数据量大小要合适；</p>
<h2 id="9-5-并行执行"><a href="#9-5-并行执行" class="headerlink" title="9.5 并行执行"></a>9.5 并行执行</h2><p>Hive会将一个查询转化成一个或者多个阶段。这样的阶段可以是MapReduce阶段、抽样阶段、合并阶段、limit阶段。或者Hive执行过程中可能需要的其他阶段。默认情况下，Hive一次只会执行一个阶段。不过，某个特定的job可能包含众多的阶段，而这些阶段可能并非完全互相依赖的，也就是说有些阶段是可以并行执行的，这样可能使得整个job的执行时间缩短。不过，如果有更多的阶段可以并行执行，那么job可能就越快完成。</p>
<p>​    通过设置参数hive.exec.parallel值为true（默认是false），就可以开启并发执行。不过，在共享集群中，需要注意下，如果job中并行阶段增多，那么集群利用率就会增加。</p>
<p>  set hive.exec.parallel=true;       //打开任务并行执行  set hive.exec.parallel.thread.number=16; //同一个sql允许最大并行度，默认为8。  </p>
<p>当然，得是在系统资源比较空闲的时候才有优势，否则，没资源，并行也起不来。</p>
<h2 id="9-6-严格模式"><a href="#9-6-严格模式" class="headerlink" title="9.6 严格模式"></a>9.6 严格模式</h2><p>Hive提供了一个严格模式，可以防止用户执行那些可能意向不到的不好的影响的查询。</p>
<p>​    通过设置属性hive.mapred.mode值为默认是非严格模式nonstrict 。开启严格模式需要修改hive.mapred.mode值为strict，开启严格模式可以禁止3种类型的查询。</p>
  <property>      <name>hive.mapred.mode</name>      <value>strict</value>      <description>       The mode in which the Hive operations are being performed.        In strict mode, some risky queries are not allowed to run. They  include:        Cartesian Product.        No partition being picked up for a query.        Comparing bigints and strings.        Comparing bigints and doubles.        Orderby without limit.      </description>     </property>  

<p>1）对于分区表，除非where语句中含有分区字段过滤条件来限制范围，否则不允许执行。换句话说，就是用户不允许扫描所有分区。进行这个限制的原因是，通常分区表都拥有非常大的数据集，而且数据增加迅速。没有进行分区限制的查询可能会消耗令人不可接受的巨大资源来处理这个表。</p>
<p>2）对于使用了order by语句的查询，要求必须使用limit语句。因为order by为了执行排序过程会将所有的结果数据分发到同一个Reducer中进行处理，强制要求用户增加这个LIMIT语句可以防止Reducer额外执行很长一段时间。</p>
<p>3）限制笛卡尔积的查询。对关系型数据库非常了解的用户可能期望在执行JOIN查询的时候不使用ON语句而是使用where语句，这样关系数据库的执行优化器就可以高效地将WHERE语句转化成那个ON语句。不幸的是，Hive并不会执行这种优化，因此，如果表足够大，那么这个查询就会出现不可控的情况。</p>
<h2 id="9-7-JVM重用-重要"><a href="#9-7-JVM重用-重要" class="headerlink" title="9.7 JVM重用(重要)"></a>9.7 JVM重用(重要)</h2><p>JVM重用是Hadoop调优参数的内容，其对Hive的性能具有非常大的影响，特别是对于很难避免小文件的场景或task特别多的场景，这类场景大多数执行时间都很短。</p>
<p>Hadoop的默认配置通常是使用派生JVM来执行map和Reduce任务的。这时JVM的启动过程可能会造成相当大的开销，尤其是执行的job包含有成百上千task任务的情况。JVM重用可以使得JVM实例在同一个job中重新使用N次。N的值可以在Hadoop的mapred-site.xml文件中进行配置。通常在10-20之间，具体多少需要根据具体业务场景测试得出。</p>
  <property>     <name>mapreduce.job.jvm.numtasks</name>     <value>10</value>     <description>How many tasks to run per jvm. If set to -1, there  is     no limit.      </description>  </property>  

<p>这个功能的缺点是，开启JVM重用将一直占用使用到的task插槽，以便进行重用，直到任务完成后才能释放。如果某个“不平衡的”job中有某几个reduce task执行的时间要比其他Reduce task消耗的时间多的多的话，那么保留的插槽就会一直空闲着却无法被其他的job使用，直到所有的task都结束了才会释放。</p>
<h2 id="9-8-推测执行"><a href="#9-8-推测执行" class="headerlink" title="9.8 推测执行"></a>9.8 推测执行</h2><p>在分布式集群环境下，因为程序Bug（包括Hadoop本身的bug），负载不均衡或者资源分布不均等原因，会造成同一个作业的多个任务之间运行速度不一致，有些任务的运行速度可能明显慢于其他任务（比如一个作业的某个任务进度只有50%，而其他所有任务已经运行完毕），则这些任务会拖慢作业的整体执行进度。为了避免这种情况发生，Hadoop采用了推测执行（Speculative Execution）机制，它根据一定的法则推测出“拖后腿”的任务，并为这样的任务启动一个备份任务，让该任务与原始任务同时处理同一份数据，并最终选用最先成功运行完成任务的计算结果作为最终结果。</p>
<p>设置开启推测执行参数：Hadoop的mapred-site.xml文件中进行配置</p>
  <property>     <name>mapreduce.map.speculative</name>     <value>true</value>     <description>If true, then multiple instances of some map tasks           may be executed in  parallel.</description>  </property>     <property>     <name>mapreduce.reduce.speculative</name>     <value>true</value>     <description>If true, then multiple instances of some reduce  tasks           may be executed in  parallel.</description>  </property>  

<p>不过hive本身也提供了配置项来控制reduce-side的推测执行：</p>
<p>​     <property>      <name>hive.mapred.reduce.tasks.speculative.execution</name>      <value>true</value>      <description>Whether speculative execution for reducers should  be turned on. </description>     </property>  </p>
<p>关于调优这些推测执行变量，还很难给一个具体的建议。如果用户对于运行时的偏差非常敏感的话，那么可以将这些功能关闭掉。如果用户因为输入数据量很大而需要执行长时间的map或者Reduce task的话，那么启动推测执行造成的浪费是非常巨大大。</p>
<h2 id="9-9-压缩"><a href="#9-9-压缩" class="headerlink" title="9.9 压缩"></a>9.9 压缩</h2><p>详见第8章。</p>
<h2 id="9-10-执行计划（Explain）"><a href="#9-10-执行计划（Explain）" class="headerlink" title="9.10 执行计划（Explain）"></a>9.10 执行计划（Explain）</h2><p>1）基本语法</p>
<p>EXPLAIN [EXTENDED | DEPENDENCY | AUTHORIZATION] query</p>
<p>2）案例实操</p>
<p>（1）查看下面这条语句的执行计划</p>
<p>hive (default)&gt; explain select * from emp;</p>
<p>hive (default)&gt; explain select deptno, avg(sal) avg_sal from emp group by deptno;</p>
<p>（2）查看详细执行计划</p>
<p>hive (default)&gt; explain extended select * from emp;</p>
<p>hive (default)&gt; explain extended select deptno, avg(sal) avg_sal from emp group by deptno;</p>
<h1 id="十-Hive实战"><a href="#十-Hive实战" class="headerlink" title="十 Hive实战"></a>十 Hive实战</h1><p>敬请期待</p>
<h1 id="十一-数据仓库"><a href="#十一-数据仓库" class="headerlink" title="十一 数据仓库"></a>十一 数据仓库</h1><h2 id="11-1-什么是数据仓库"><a href="#11-1-什么是数据仓库" class="headerlink" title="11.1 什么是数据仓库"></a>11.1 什么是数据仓库</h2><p>数据仓库，英文名称为Data Warehouse，可简写为DW或DWH。数据仓库，是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。它出于分析性报告和决策支持目的而创建。为需要业务智能的企业，提供指导业务流程改进、监视时间、成本、质量以及控制。</p>
<h2 id="11-2-数据仓库能干什么？"><a href="#11-2-数据仓库能干什么？" class="headerlink" title="11.2 数据仓库能干什么？"></a>11.2 数据仓库能干什么？</h2><p>1）年度销售目标的指定，需要根据以往的历史报表进行决策，不能拍脑袋。</p>
<p>2）如何优化业务流程</p>
<p>​    例如：一个电商网站订单的完成包括：浏览、下单、支付、物流，其中物流环节可能和中通、申通、韵达等快递公司合作。快递公司每派送一个订单，都会有订单派送的确认时间，可以根据订单派送时间来分析哪个快递公司比较快捷高效，从而选择与哪些快递公司合作，剔除哪些快递公司，增加用户友好型。</p>
<h2 id="11-3-数据仓库的特点"><a href="#11-3-数据仓库的特点" class="headerlink" title="11.3 数据仓库的特点"></a>11.3 数据仓库的特点</h2><p><strong>1**</strong>）数据仓库的数据是面向主题的**</p>
<p>与传统数据库面向应用进行数据组织的特点相对应，数据仓库中的数据是面向主题进行组织的。什么是主题呢？首先，主题是一个抽象的概念，是较高层次上企业信息系统中的数据综合、归类并进行分析利用的抽象。在逻辑意义上，它是对应企业中某一宏观分析领域所涉及的分析对象。面向主题的数据组织方式，就是在较高层次上对分析对象的数据的一个完整、一致的描述，能完整、统一地刻划各个分析对象所涉及的企业的各项数据，以及数据之间的联系。所谓较高层次是相对面向应用的数据组织方式而言的，是指按照主题进行数据组织的方式具有更高的数据抽象级别。</p>
<p><strong>2**</strong>）数据仓库的数据是集成的**</p>
<p>数据仓库的数据是从原有的分散的数据库数据抽取来的。操作型数据与DSS分析型数据之间差别甚大。第一，数据仓库的每一个主题所对应的源数据在原有的各分散数据库中有许多重复和不一致的地方，且来源于不同的联机系统的数据都和不同的应用逻辑捆绑在一起；第二，数据仓库中的综合数据不能从原有的数据库系统直接得到。因此在数据进入数据仓库之前，必然要经过统一与综合，这一步是数据仓库建设中最关键、最复杂的一步，所要完成的工作有：</p>
<p>（1）要统一源数据中所有矛盾之处，如字段的同名异义、异名同义、单位不统一、字长不一致等。</p>
<p>（2）进行数据综合和计算。数据仓库中的数据综合工作可以在从原有数据库抽取 数据时生成，但许多是在数据仓库内部生成的，即进入数据仓库以后进行综合生成的。</p>
<p><strong>3**</strong>）数据仓库的数据是不可更新的**</p>
<p>数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一般情况下并不进行修改操作。数据仓库的数据反映的是一段相当长的时间内历史数据的内容，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据，而不是联机处理的数据。数据库中进行联机处理的数据经过集成输入到数据仓库中，一旦数据仓库存放的数据已经超过数据仓库的数据存储期限，这些数据将从当前的数据仓库中删去。因为数据仓库只进行数据查询操作，所以数据仓库管理系统相比数据库管理系统而言要简单得多。数据库管理系统中许多技术难点，如完整性保护、并发控制等等，在数据仓库的管理中几乎可以省去。但是由于数据仓库的查询数据量往往很大，所以就对数据查询提出了更高的要求，它要求采用各种复杂的索引技术；同时由于数据仓库面向的是商业企业的高层管理者，他们会对数据查询的界面友好性和数据表示提出更高的要求。</p>
<p><strong>4**</strong>）数据仓库的数据是随时间不断变化的**</p>
<p>数据仓库中的数据不可更新是针对应用来说的，也就是说，数据仓库的用户进行分析处理时是不进行数据更新操作的。但并不是说，在从数据集成输入数据仓库开始到最终被删除的整个数据生存周期中，所有的数据仓库数据都是永远不变的。</p>
<p>数据仓库的数据是随时间的变化而不断变化的，这是数据仓库数据的第四个特征。这一特征表现在以下3方面：</p>
<p>（1）数据仓库随时间变化不断增加新的数据内容。数据仓库系统必须不断捕捉OLTP数据库中变化的数据，追加到数据仓库中去，也就是要不断地生成OLTP数据库的快照，经统一集成后增加到数据仓库中去；但对于确实不再变化的数据库快照，如果捕捉到新的变化数据，则只生成一个新的数据库快照增加进去，而不会对原有的数据库快照进行修改。</p>
<p>（2）数据仓库随时间变化不断删去旧的数据内容。数据仓库的数据也有存储期限，一旦超过了这一期限，过期数据就要被删除。只是数据仓库内的数据时限要远远长于操作型环境中的数据时限。在操作型环境中一般只保存有60~90天的数据，而在数据仓库中则需要保存较长时限的数据（如5~10年），以适应DSS进行趋势分析的要求。</p>
<p>（3）数据仓库中包含有大量的综合数据，这些综合数据中很多跟时间有关，如数据经常按照时间段进行综合，或隔一定的时间片进行抽样等等。这些数据要随着时间的变化不断地进行重新综合。因此，数据仓库的数据特征都包含时间项，以标明数据的历史时期。</p>
<h2 id="11-4-数据仓库发展历程"><a href="#11-4-数据仓库发展历程" class="headerlink" title="11.4 数据仓库发展历程"></a>11.4 数据仓库发展历程</h2><p><strong>数据仓库的发展大致经历了这样的三个过程：</strong></p>
<p><strong>1**</strong>）简单报表阶段：**这个阶段，系统的主要目标是解决一些日常的工作中业务人员需要的报表，以及生成一些简单的能够帮助领导进行决策所需要的汇总数据。这个阶段的大部分表现形式为数据库和前端报表工具。</p>
<p><strong>2**</strong>）数据集市阶段：**这个阶段，主要是根据某个业务部门的需要，进行一定的数据的采集，整理，按照业务人员的需要，进行多维报表的展现，能够提供对特定业务指导的数据，并且能够提供特定的领导决策数据。</p>
<p><strong>3**</strong>）数据仓库阶段：**这个阶段，主要是按照一定的数据模型，对整个企业的数据进行采集，整理，并且能够按照各个业务部门的需要，提供跨部门的，完全一致的业务报表数据，能够通过数据仓库生成对对业务具有指导性的数据，同时，为领导决策提供全面的数据支持。</p>
<p>通过数据仓库建设的发展阶段，我们能够看出，数据仓库的建设和数据集市的建设的重要区别就在于数据模型的支持。因此，数据模型的建设，对于我们数据仓库的建设，有着决定性的意义。</p>
<h2 id="11-5-数据库与数据仓库的区别"><a href="#11-5-数据库与数据仓库的区别" class="headerlink" title="11.5 数据库与数据仓库的区别"></a>11.5 数据库与数据仓库的区别</h2><p>了解数据库与数据仓库的区别之前，首先掌握三个概念。数据库软件、数据库、数据仓库。</p>
<p><strong>数据库软件：</strong>是一种软件，可以看得见，可以操作。用来实现数据库逻辑功能。属于物理层。</p>
<p><strong>数据库：</strong>是一种逻辑概念，用来存放数据的仓库。通过数据库软件来实现。数据库由很多表组成，表是二维的，一张表里可以有很多字段。字段一字排开，对应的数据就一行一行写入表中。数据库的表，在于能够用二维表现多维关系。目前市面上流行的数据库都是二维数据库。如：Oracle、DB2、MySQL、Sybase、MS SQL Server等。</p>
<p><strong>数据仓库：</strong>是数据库概念的升级。从逻辑上理解，数据库和数据仓库没有区别，都是通过数据库软件实现的存放数据的地方，只不过从数据量来说，数据仓库要比数据库更庞大得多。数据仓库主要用于数据挖掘和数据分析，辅助领导做决策。</p>
<p>在IT的架构体系中，数据库是必须存在的。必须要有地方存放数据。比如现在的网购，淘宝，京东等等。物品的存货数量，货品的价格，用户的账户余额之类的。这些数据都是存放在后台数据库中。或者最简单理解，我们现在微博，QQ等账户的用户名和密码。在后台数据库必然有一张user表，字段起码有两个，即用户名和密码，然后我们的数据就一行一行的存在表上面。当我们登录的时候，我们填写了用户名和密码，这些数据就会被传回到后台去，去跟表上面的数据匹配，匹配成功了，你就能登录了。匹配不成功就会报错说密码错误或者没有此用户名等。这个就是数据库，数据库在生产环境就是用来干活的。凡是跟业务应用挂钩的，我们都使用数据库。</p>
<p>数据仓库则是BI下的其中一种技术。由于数据库是跟业务应用挂钩的，所以一个数据库不可能装下一家公司的所有数据。数据库的表设计往往是针对某一个应用进行设计的。比如刚才那个登录的功能，这张user表上就只有这两个字段，没有别的字段了。但是这张表符合应用，没有问题。但是这张表不符合分析。比如我想知道在哪个时间段，用户登录的量最多？哪个用户一年购物最多？诸如此类的指标。那就要重新设计数据库的表结构了。对于数据分析和数据挖掘，我们引入数据仓库概念。数据仓库的表结构是依照分析需求，分析维度，分析指标进行设计的。</p>
<p>数据库与数据仓库的区别实际讲的是OLTP与OLAP的区别。</p>
<p>操作型处理，叫联机事务处理OLTP（On-Line Transaction Processing），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。</p>
<p>分析型处理，叫联机分析处理OLAP（On-Line Analytical Processing）一般针对某些主题的历史数据进行分析，支持管理决策。</p>
<p>表 操作型处理与分析型处理的比较</p>
<table>
<thead>
<tr>
<th>操作型处理</th>
<th>分析型处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>细节的</td>
<td>综合的或提炼的</td>
</tr>
<tr>
<td>实体——关系（E-R）模型</td>
<td>星型模型或雪花模型</td>
</tr>
<tr>
<td>存取瞬间数据</td>
<td>存储历史数据，不包含最近的数据</td>
</tr>
<tr>
<td>可更新的</td>
<td>只读、只追加</td>
</tr>
<tr>
<td>一次操作一个单元</td>
<td>一次操作一个集合</td>
</tr>
<tr>
<td>性能要求高，响应时间短</td>
<td>性能要求宽松</td>
</tr>
<tr>
<td>面向事务</td>
<td>面向分析</td>
</tr>
<tr>
<td>一次操作数据量小</td>
<td>一次操作数据量大</td>
</tr>
<tr>
<td>支持日常操作</td>
<td>支持决策需求</td>
</tr>
<tr>
<td>数据量小</td>
<td>数据量大</td>
</tr>
<tr>
<td>客户订单、库存水平和银行账户查询等</td>
<td>客户收益分析、市场细分等</td>
</tr>
</tbody>
</table>
<h2 id="11-6-数据仓库架构分层"><a href="#11-6-数据仓库架构分层" class="headerlink" title="11.6 数据仓库架构分层"></a>11.6 数据仓库架构分层</h2><h3 id="11-6-1-数据仓库架构"><a href="#11-6-1-数据仓库架构" class="headerlink" title="11.6.1 数据仓库架构"></a>11.6.1 数据仓库架构</h3><p>数据仓库标准上可以分为四层：ODS（临时存储层）、PDW（数据仓库层）、DM（数据集市层）、APP（应用层）。</p>
<p>1）ODS层：</p>
<p>为临时存储层，是接口数据的临时存储区域，为后一步的数据处理做准备。一般来说ODS层的数据和源系统的数据是同构的，主要目的是简化后续数据加工处理的工作。从数据粒度上来说ODS层的数据粒度是最细的。ODS层的表通常包括两类，一个用于存储当前需要加载的数据，一个用于存储处理完后的历史数据。历史数据一般保存3-6个月后需要清除，以节省空间。但不同的项目要区别对待，如果源系统的数据量不大，可以保留更长的时间，甚至全量保存；</p>
<p>2）PDW层：</p>
<p>为数据仓库层，PDW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗（去除了杂质）后的数据。这一层的数据一般是遵循数据库第三范式的，其数据粒度通常和ODS的粒度相同。在PDW层会保存BI系统中所有的历史数据，例如保存10年的数据。</p>
<p>3）DM层：</p>
<p>为数据集市层，这层数据是面向主题来组织数据的，通常是星形或雪花结构的数据。从数据粒度来说，这层的数据是轻度汇总级的数据，已经不存在明细数据了。从数据的时间跨度来说，通常是PDW层的一部分，主要的目的是为了满足用户分析的需求，而从分析的角度来说，用户通常只需要分析近几年（如近三年的数据）的即可。从数据的广度来说，仍然覆盖了所有业务数据。</p>
<p>4）APP层：</p>
<p>为应用层，这层数据是完全为了满足具体的分析需求而构建的数据，也是星形或雪花结构的数据。从数据粒度来说是高度汇总的数据。从数据的广度来说，则并不一定会覆盖所有业务数据，而是DM层数据的一个真子集，从某种意义上来说是DM层数据的一个重复。从极端情况来说，可以为每一张报表在APP层构建一个模型来支持，达到以空间换时间的目的数据仓库的标准分层只是一个建议性质的标准，实际实施时需要根据实际情况确定数据仓库的分层，不同类型的数据也可能采取不同的分层方法。</p>
<h3 id="11-6-2-为什么要对数据仓库分层？"><a href="#11-6-2-为什么要对数据仓库分层？" class="headerlink" title="11.6.2 为什么要对数据仓库分层？"></a>11.6.2 为什么要对数据仓库分层？</h3><p>1）用空间换时间，通过大量的预处理来提升应用系统的用户体验（效率），因此数据仓库会存在大量冗余的数据。</p>
<p>2）如果不分层的话，如果源业务系统的业务规则发生变化将会影响整个数据清洗过程，工作量巨大。</p>
<p>3）通过数据分层管理可以简化数据清洗的过程，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。</p>
<h2 id="11-7-元数据介绍"><a href="#11-7-元数据介绍" class="headerlink" title="11.7 元数据介绍"></a>11.7 元数据介绍</h2><p>当需要了解某地企业及其提供的服务时，电话黄页的重要性就体现出来了。元数据（Metadata）类似于这样的电话黄页。</p>
<p>1）元数据的定义</p>
<p>  数据仓库的元数据是关于数据仓库中数据的数据。它的作用类似于数据库管理系统的数据字典，保存了逻辑数据结构、文件、地址和索引等信息。广义上讲，在数据仓库中，元数据描述了数据仓库内数据的结构和建立方法的数据。</p>
<p>   元数据是数据仓库管理系统的重要组成部分，元数据管理器是企业级数据仓库中的关键组件，贯穿数据仓库构建的整个过程，直接影响着数据仓库的构建、使用和维护。</p>
<p>（1）构建数据仓库的主要步骤之一是ETL。这时元数据将发挥重要的作用，它定义了源数据系统到数据仓库的映射、数据转换的规则、数据仓库的逻辑结构、数据更新的规则、数据导入历史记录以及装载周期等相关内容。数据抽取和转换的专家以及数据仓库管理员正是通过元数据高效地构建数据仓库。</p>
<p>（2）用户在使用数据仓库时，通过元数据访问数据，明确数据项的含义以及定制报表。</p>
<p>（3）数据仓库的规模及其复杂性离不开正确的元数据管理，包括增加或移除外部数据源，改变数据清洗方法，控制出错的查询以及安排备份等。</p>
<p>元数据可分为技术元数据和业务元数据。技术元数据为开发和管理数据仓库的IT人员使用，它描述了与数据仓库开发、管理和维护相关的数据，包括数据源信息、数据转换描述、数据仓库模型、数据清洗与更新规则、数据映射和访问权限等。而业务元数据为管理层和业务分析人员服务，从业务角度描述数据，包括商务术语、数据仓库中有什么数据、数据的位置和数据的可用性等，帮助业务人员更好地理解数据仓库中哪些数据是可用的以及如何使用。</p>
<p>由上可见，元数据不仅定义了数据仓库中数据的模式、来源、抽取和转换规则等，而且是整个数据仓库系统运行的基础，元数据把数据仓库系统中各个松散的组件联系起来，组成了一个有机的整体，如图所示</p>
<p>2）元数据的存储方式</p>
<p>   元数据有两种常见存储方式：一种是以数据集为基础，每一个数据集有对应的元数据文件，每一个元数据文件包含对应数据集的元数据内容；另一种存储方式是以数据库为基础，即元数据库。其中元数据文件由若干项组成，每一项表示元数据的一个要素，每条记录为数据集的元数据内容。上述存储方式各有优缺点，第一种存储方式的优点是调用数据时相应的元数据也作为一个独立的文件被传输，相对数据库有较强的独立性，在对元数据进行检索时可以利用数据库的功能实现，也可以把元数据文件调到其他数据库系统中操作；不足是如果每一数据集都对应一个元数据文档，在规模巨大的数据库中则会有大量的元数据文件，管理不方便。第二种存储方式下，元数据库中只有一个元数据文件，管理比较方便，添加或删除数据集，只要在该文件中添加或删除相应的记录项即可。在获取某数据集的元数据时，因为实际得到的只是关系表格数据的一条记录，所以要求用户系统可以接受这种特定形式的数据。因此推荐使用元数据库的方式。</p>
<p>   元数据库用于存储元数据，因此元数据库最好选用主流的关系数据库管理系统。元数据库还包含用于操作和查询元数据的机制。建立元数据库的主要好处是提供统一的数据结构和业务规则，易于把企业内部的多个数据集市有机地集成起来。目前，一些企业倾向建立多个数据集市，而不是一个集中的数据仓库，这时可以考虑在建立数据仓库（或数据集市）之前，先建立一个用于描述数据、服务应用集成的元数据库，做好数据仓库实施的初期支持工作，对后续开发和维护有很大的帮助。元数据库保证了数据仓库数据的一致性和准确性，为企业进行数据质量管理提供基础。</p>
<p>3）元数据的作用</p>
<p>   在数据仓库中，元数据的主要作用如下。</p>
<p>（1）描述哪些数据在数据仓库中，帮助决策分析者对数据仓库的内容定位。</p>
<p>（2）定义数据进入数据仓库的方式，作为数据汇总、映射和清洗的指南。</p>
<p>（3）记录业务事件发生而随之进行的数据抽取工作时间安排。</p>
<p>（4）记录并检测系统数据一致性的要求和执行情况。</p>
<p>（5）评估数据质量。</p>
<h2 id="11-8-星型模型和雪花模型"><a href="#11-8-星型模型和雪花模型" class="headerlink" title="11.8 星型模型和雪花模型"></a>11.8 星型模型和雪花模型</h2><p>在多维分析的商业智能解决方案中，根据事实表和维度表的关系，又可将常见的模型分为星型模型和雪花型模型。在设计逻辑型数据的模型的时候，就应考虑数据是按照星型模型还是雪花型模型进行组织。</p>
<h3 id="11-8-1-星型模型"><a href="#11-8-1-星型模型" class="headerlink" title="11.8.1 星型模型"></a>11.8.1 星型模型</h3><p>当所有维表都直接连接到“ 事实表”上时，整个图解就像星星一样，故将该模型称为星型模型。</p>
<p>  <strong>星型架构是一种非正规化的结构，多维数据集的每一个维度都直接与事实表相连接，不存在渐变维度，所以数据有一定的冗余</strong>，如在地域维度表中，存在国家A 省B的城市C以及国家A省B的城市D两条记录，那么国家A和省B的信息分别存储了两次，即存在冗余。</p>
<h3 id="11-8-2-雪花模型"><a href="#11-8-2-雪花模型" class="headerlink" title="11.8.2 雪花模型"></a>11.8.2 雪花模型</h3><p>当有一个或多个维表没有直接连接到事实表上，而是通过其他维表连接到事实表上时，其图解就像多个雪花连接在一起，故称雪花模型。雪花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的” 层次” 区域，这些被分解的表都连接到主维度表而不是事实表。如图所示，将地域维表又分解为国家，省份，城市等维表。它的优点是：<strong>通过最大限度地减少数据存储量以及联合较小的维表来改善查询性能。</strong>雪花型结构去除了数据冗余。</p>
<p><strong>星型模型因为数据的冗余所以很多统计查询不需要做外部的连接，因此一般情况下效率比雪花型模型要高。</strong>星型结构不用考虑很多正规化的因素，设计与实现都比较简单。雪花型模型由于去除了冗余，有些统计就需要通过表的联接才能产生，所以效率不一定有星型模型高。正规化也是一种比较复杂的过程，相应的数据库结构设计、数据的 ETL、以及后期的维护都要复杂一些。<strong>因此在冗余可以接受的前提下，实际运用中星型模型使用更多，也更有效率。</strong></p>
<h3 id="11-8-3-星型模型和雪花模型对比"><a href="#11-8-3-星型模型和雪花模型对比" class="headerlink" title="11.8.3 星型模型和雪花模型对比"></a>11.8.3 星型模型和雪花模型对比</h3><p>星形模型和雪花模型是数据仓库中常用到的两种方式，而它们之间的对比要从四个角度来进行讨论。</p>
<p>　　<strong>1**</strong>）数据优化**</p>
<p><strong>雪花模型使用的是规范化数据，也就是说数据在数据库内部是组织好的，以便消除冗余，因此它能够有效地减少数据量。</strong>通过引用完整性，其业务层级和维度都将存储在数据模型之中。</p>
<p>雪花模型</p>
<p><strong>相比较而言，星形模型使用的是反规范化数据。</strong>在星形模型中，维度直接指的是事实表，业务层级不会通过维度之间的参照完整性来部署。</p>
<p>星形模型</p>
<p>　　<strong>2**</strong>）业务模型**</p>
<p>主键是一个单独的唯一键(数据属性)，为特殊数据所选择。在上面的例子中，Advertiser_ID就将是一个主键。外键(参考属性)仅仅是一个表中的字段，用来匹配其他维度表中的主键。在我们所引用的例子中，Advertiser_ID将是Account_dimension的一个外键。</p>
<p>在雪花模型中，数据模型的业务层级是由一个不同维度表主键-外键的关系来代表的。而在星形模型中，所有必要的维度表在事实表中都只拥有外键。</p>
<p>　　<strong>3**</strong>）性能**</p>
<p>第三个区别在于性能的不同。<strong>雪花模型在维度表、事实表之间的连接很多，因此性能方面会比较低。</strong>举个例子，如果你想要知道Advertiser 的详细信息，雪花模型就会请求许多信息，比如Advertiser Name、ID以及那些广告主和客户表的地址需要连接起来，然后再与事实表连接。</p>
<p>而星形模型的连接就少的多，在这个模型中，如果你需要上述信息，你只要将Advertiser的维度表和事实表连接即可。</p>
<p>　　<strong>4**</strong>）<strong>**ETL</strong></p>
<p>雪花模型加载数据集市，因此ETL操作在设计上更加复杂，而且由于附属模型的限制，不能并行化。</p>
<p>星形模型加载维度表，不需要再维度之间添加附属模型，因此ETL就相对简单，而且可以实现高度的并行化。</p>
<p>　　<strong>总结</strong></p>
<p>雪花模型使得维度分析更加容易，比如“针对特定的广告主，有哪些客户或者公司是在线的?”星形模型用来做指标分析更适合，比如“给定的一个客户他们的收入是多少?”</p>
<h1 id="十二-常见错误解析"><a href="#十二-常见错误解析" class="headerlink" title="十二 常见错误解析"></a>十二 常见错误解析</h1><p>1）SecureCRT 7.3出现乱码或者删除不掉数据，免安装版的SecureCRT 卸载或者用虚拟机直接操作或者换安装版的SecureCRT </p>
<p>2）连接不上mysql数据库</p>
<p>​    （1）导错驱动包，应该把mysql-connector-java-5.1.27-bin.jar导入/opt/module/hive/lib的不是这个包。错把mysql-connector-java-5.1.27.tar.gz导入hive/lib包下。</p>
<p>​    （2）修改user表中的主机名称没有都修改为%，而是修改为localhost</p>
<p>3）hive默认的输入格式处理是CombineHiveInputFormat，会对小文件进行合并。</p>
<p>hive (default)&gt; set hive.input.format;</p>
<p>hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat</p>
<p>可以采用HiveInputFormat就会根据分区数输出相应的文件。</p>
<p>hive (default)&gt; set hive.input.format=org.apache.hadoop.hive.ql.io.HiveInputFormat;</p>
<p>4）不能执行mapreduce程序</p>
<p>​    可能是hadoop的yarn没开启。</p>
<p>5）启动mysql服务时，报MySQL server PID file could not be found! 异常。</p>
<p>​    在/var/lock/subsys/mysql路径下创建hadoop102.pid，并在文件中添加内容：4396</p>
<p>6）报service mysql status MySQL is not running, but lock file (/var/lock/subsys/mysql[失败])异常。</p>
<p>​    解决方案：在/var/lib/mysql 目录下创建： -rw-rw—-. 1 mysql mysql    5 12月 22 16:41 hadoop102.pid 文件，并修改权限为 777。</p>
<p>6）hive中文乱码 <a href="https://www.cnblogs.com/qingyunzong/p/8724155.html" target="_blank" rel="external">https://www.cnblogs.com/qingyunzong/p/8724155.html</a></p>
<h1 id="十三-好的网站"><a href="#十三-好的网站" class="headerlink" title="十三 好的网站"></a>十三 好的网站</h1><p><a href="https://www.cnblogs.com/qingyunzong/p/8710356.html#_labelTop" target="_blank" rel="external">https://www.cnblogs.com/qingyunzong/p/8710356.html#_labelTop</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-Hive基本概念&quot;&gt;&lt;a href=&quot;#一-Hive基本概念&quot; class=&quot;headerlink&quot; title=&quot;一 Hive基本概念&quot;&gt;&lt;/a&gt;一 Hive基本概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是Hive&quot;&gt;&lt;a href=&quot;#1-1-什么是Hiv
    
    </summary>
    
      <category term="hadoop" scheme="http://kingge.top/categories/hadoop/"/>
    
    
      <category term="hive" scheme="http://kingge.top/tags/hive/"/>
    
      <category term="数据仓库工具" scheme="http://kingge.top/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>hadoop在使用中的常用优化手段</title>
    <link href="http://kingge.top/2018/05/14/hadoop%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/"/>
    <id>http://kingge.top/2018/05/14/hadoop在使用中的常用优化手段/</id>
    <published>2018-05-14T13:59:59.000Z</published>
    <updated>2019-08-25T02:20:55.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>我们知道影响MapReduce运算的因素很多，主要是机器性能、网络、磁盘读写速度、I/O 操作等等有关。</p>
<p>机器的问题属于外部因素，那么下面主要是介绍关于IO操作引发的性能问题：</p>
<p>主要是有几个以下方面</p>
<blockquote>
<p>（1）数据倾斜 - <strong>重点</strong></p>
<p>（2）map和reduce数设置不合理</p>
<p>（3）map运行时间太长，导致reduce等待过久</p>
<p>（4）小文件过多 - <strong>重点</strong></p>
<p>（5）大量的不可分块的超大文件</p>
<p>（6）spill次数过多</p>
<p>（7）merge次数过多。</p>
</blockquote>
<p>​    MapReduce优化方法主要从六个方面考虑：数据输入、Map阶段、Reduce阶段、IO传输、数据倾斜问题和常用的调优参数。</p>
<p>  下面想讲解小文件的处理方式：</p>
<h2 id="1-1-HDFS小文件优化"><a href="#1-1-HDFS小文件优化" class="headerlink" title="1.1 HDFS小文件优化"></a>1.1 HDFS小文件优化</h2><p>​    <strong>HDFS上每个文件都要在namenode上建立一个索引</strong>，这个索引的大小约为<strong>150byte</strong>，这样当小文件比较多的时候，就会产生很多的索引文件，一方面会大量占用namenode的内存空间，另一方面就是索引文件过大是的索引速度变慢。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>1）Hadoop Archive:</strong></p>
<p> 是一个高效地将小文件放入HDFS块中的文件存档工具，它能够将多个小文件打包成一个HAR文件，这样就减少了namenode的内存使用。</p>
<p><img src="/2018/05/14/hadoop在使用中的常用优化手段/1564667225107.png" alt="1564667225107"></p>
<p><strong>2）Sequence file：</strong></p>
<p> sequence file由一系列的二进制key/value组成，如果key为文件名，value为文件内容，则可以将大批小文件合并成一个大文件。</p>
<p><strong>3）CombineFileInputFormat：</strong></p>
<p>  CombineFileInputFormat是一种新的inputformat，用于将多个文件合并成一个单独的split，另外，它会考虑数据的存储位置。（之前hadoop相关的章节讲解道，可以翻翻看看）</p>
<p><strong>4）开启JVM重用</strong></p>
<p>对于大量小文件Job，可以开启JVM重用会减少45%运行时间。</p>
<p>JVM重用理解：一个map运行一个jvm，重用的话，在一个map在jvm上运行完毕后，jvm继续运行其他map。</p>
<p>具体设置：mapreduce.job.jvm.numtasks值在10-20之间。</p>
<h2 id="1-2-分阶段优化"><a href="#1-2-分阶段优化" class="headerlink" title="1.2 分阶段优化"></a>1.2 分阶段优化</h2><h3 id="数据输入阶段"><a href="#数据输入阶段" class="headerlink" title="数据输入阶段"></a>数据输入阶段</h3><blockquote>
<p>（1）合并小文件：在执行mr任务前将小文件进行合并，大量的小文件会产生大量的map任务，增大map任务装载次数，而任务的装载比较耗时，从而导致mr运行较慢。</p>
<p>（2）采用CombineTextInputFormat来作为输入，解决输入端大量小文件场景。</p>
</blockquote>
<h3 id="数据传输阶段"><a href="#数据传输阶段" class="headerlink" title="数据传输阶段"></a>数据传输阶段</h3><p><strong>1）采用数据压缩的方式</strong>，减少网络IO的的时间。安装Snappy和LZO压缩编码器。</p>
<p><strong>2）使用SequenceFile二进制文件。</strong></p>
<h3 id="进入Map阶段"><a href="#进入Map阶段" class="headerlink" title="进入Map阶段"></a>进入Map阶段</h3><blockquote>
<p><strong>1）减少溢写（spill）次数：</strong>通过调整io.sort.mb及sort.spill.percent参数值，增大触发spill的内存上限，减少spill次数，从而减少磁盘IO。</p>
<p><strong>2）减少合并（merge）次数：</strong>通过调整io.sort.factor参数，增大merge的文件数目，减少merge的次数，从而缩短mr处理时间。</p>
<p>3）在map之后，<strong>不影响业务逻辑前提下，先进行combine处理</strong>，减少 I/O。</p>
</blockquote>
<h3 id="进入Reduce阶段"><a href="#进入Reduce阶段" class="headerlink" title="进入Reduce阶段"></a>进入Reduce阶段</h3><blockquote>
<p>暂无</p>
</blockquote>
<h3 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h3><blockquote>
<p>暂无总结</p>
</blockquote>
<h3 id="常用参数哟花"><a href="#常用参数哟花" class="headerlink" title="常用参数哟花"></a>常用参数哟花</h3><blockquote>
<p>暂无</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;我们知道影响MapReduce运算的因素很多，主要是机器性能、网络、磁盘读写速度、I/O 操作等等有关。&lt;/p&gt;
&lt;p&gt;机器
    
    </summary>
    
      <category term="hadoop" scheme="http://kingge.top/categories/hadoop/"/>
    
    
      <category term="大数据" scheme="http://kingge.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hadoop优化" scheme="http://kingge.top/tags/hadoop%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
