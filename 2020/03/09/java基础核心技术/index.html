<!DOCTYPE html>



  




<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('OOPS, 主人请输入文章密码才能够观看哟') !== ''){
                alert('哎呀，密码错误哟！');
                history.back();
            }
        }
    })();
</script>


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|40:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="动态代理,juc,对象头,chm,cas," />





  <link rel="alternate" href="/atom.xml" title="King哥" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="String​    通过日常编码，发现，我们在编程的过程中，使用频率最高的变量或者对象，往往是字符串（可以通过分析jvm内存，可得，string类型的数据一般占用的内存排行在最前列），那么怎么优化string类型的字符串成为了一个重点。 ​    而且优化的目的就是，复用已经存在的字符串，让他的存取类比于java基本类型的存取。  string并不是基本类型。 通过看源码，发现String是一个">
<meta name="keywords" content="动态代理,juc,对象头,chm,cas">
<meta property="og:type" content="article">
<meta property="og:title" content="java核心技术杂记">
<meta property="og:url" content="http://kingge.top/2020/03/09/java基础核心技术/index.html">
<meta property="og:site_name" content="King哥">
<meta property="og:description" content="String​    通过日常编码，发现，我们在编程的过程中，使用频率最高的变量或者对象，往往是字符串（可以通过分析jvm内存，可得，string类型的数据一般占用的内存排行在最前列），那么怎么优化string类型的字符串成为了一个重点。 ​    而且优化的目的就是，复用已经存在的字符串，让他的存取类比于java基本类型的存取。  string并不是基本类型。 通过看源码，发现String是一个">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200111235950327.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200112095817759.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200112113301062.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200113095241291.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200120163400968.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200117091622074.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200121094835443.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20191218151354613.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/writethrouth.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/writeback.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200318155625412.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200318155816975.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200318160922524.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200318162036721.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200318162058308.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200318162644664.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/820029-20190807082621811-2089453748.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200402164715040.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200402173402270.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200403105339055.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200120093410478.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/4840092-f85e70e2262b72312878.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200120153246954.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20200120150958113.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200119173919024.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200121154028153.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200121163129464.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200121170115696.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200122100331106.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200324211514948.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200325002730647.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/1582083684068.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/1582084167742.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/1582093357161.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/1582093389451.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/1582100947354.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/1582102255142.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200302141610073.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312085301969.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312085233353.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312085320578.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200311231236281.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312100605462.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312100651905.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312113121360.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312113143163.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312113152044.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312114117435.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200312115119402.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/学习总结/java基础核心技术/java基础核心技术/image-20200312115529333.png">
<meta property="og:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200318145712228.png">
<meta property="og:updated_time" content="2020-05-09T08:56:11.451Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java核心技术杂记">
<meta name="twitter:description" content="String​    通过日常编码，发现，我们在编程的过程中，使用频率最高的变量或者对象，往往是字符串（可以通过分析jvm内存，可得，string类型的数据一般占用的内存排行在最前列），那么怎么优化string类型的字符串成为了一个重点。 ​    而且优化的目的就是，复用已经存在的字符串，让他的存取类比于java基本类型的存取。  string并不是基本类型。 通过看源码，发现String是一个">
<meta name="twitter:image" content="http://kingge.top/2020/03/09/java基础核心技术/image-20200111235950327.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://kingge.top/2020/03/09/java基础核心技术/"/>





  <title>java核心技术杂记 | King哥</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">King哥</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">To know everything, no words don't talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-picture">
          <a href="/picture/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            照片
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kingge.top/2020/03/09/java基础核心技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeremy Kinge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java核心技术杂记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-09T12:57:58+08:00">
                2020-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java核心技术杂记/" itemprop="url" rel="index">
                    <span itemprop="name">java核心技术杂记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  49,773
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  198
                </span>
              
            </div>
          

          

		  
		  
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>​    通过日常编码，发现，我们在编程的过程中，使用频率最高的变量或者对象，往往是字符串（可以通过分析jvm内存，可得，string类型的数据一般占用的内存排行在最前列），那么怎么优化string类型的字符串成为了一个重点。</p>
<p>​    而且优化的目的就是，复用已经存在的字符串，让他的存取类比于java基本类型的存取。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200111235950327.png" alt="image-20200111235950327"></p>
<p><strong>string并不是基本类型。</strong></p>
<p>通过看源码，发现String是一个final不可变的，换言说，如果你给一个String变量重新赋值，那么最终是会重新建立一个string类型数据复制给他，而不会覆盖之前的值。<code>final</code>修饰的成员变量，因此任何看似对String内容进行操作的方法，实际上都是返回了一个新的String对象，这就造就了一个String对象的被创建后，就一直会保持不变（所以要警惕，string的多次修改，因为会创建很多string值，那么常量池可能会占尽）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public final class String</div><div class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</div></pre></td></tr></table></figure>
<p>同时我们知道，string的值，是存放在jvm方法区中，具体位置是，方法区的常量池。这样做的好处就是，能够共享已经存在的string数据，避免重复创建。</p>
<p>举个简单例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">string a = &quot;123&quot;;</div><div class="line"></div><div class="line">string b = &quot;123&quot;;</div><div class="line"></div><div class="line">a == b?</div></pre></td></tr></table></figure>
<p>答案是true，为什么，因为创建a 变量时，就会在常量池中创建 123字符串，然后把该字符串在常量池的地址，复制给a变量。当发现b的值也是123的时候，那么他会现在常量池中寻找是否存在123字符串，如果存在，那么就直接把123的地址复制给b变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">string a = &quot;123&quot;;</div><div class="line">string b = &quot;12&quot;;</div><div class="line">b+=&quot;3&quot;</div><div class="line">a == b?</div><div class="line">答案，肯定也是true，因为b+=&quot;3&quot;会发生字符串堆叠，编译器会优化，生成123。但是我们知道a已经在常量池中创建了123，那么就会把地址直接返回给b。</div><div class="line">那么上面这段代码，创建了多少个对象？四个，a，“123”，b,&quot;12&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">string b = &quot;12&quot;;</div><div class="line">String a = &quot;1212&quot;</div><div class="line">String c = b+&quot;12&quot;</div><div class="line">a == c?</div><div class="line">答案是 false，因为c指向的是堆内存的地址。为什么呢？b+&quot;12&quot;因为是变量加上常量，那么只有在运行时才能够确定c的值。</div><div class="line">通过反编译这段代码（javap -verbose），发现实际上最终实现是：new Stringbuilder(&quot;12&quot;).append(&quot;12&quot;).toString(); 所以String c = b+&quot;12&quot;,一共创建了两个对象，一个是stringbuilder，一个是string，两个对象都在堆中。</div></pre></td></tr></table></figure>
<p>反编译代码：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200112095817759.png" alt="image-20200112095817759"></p>
<p>再来看一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String s = &quot;1&quot;+&quot;2&quot;+&quot;3&quot;;//这一行一共生成对少个对象？ 答案是1个，涉及到字符串堆叠的问题。</div><div class="line">        //他会直接在常量池生成&quot;123&quot;一个对象，s只是一个局部变量</div><div class="line">        String s1 = new String(&quot;hello&quot;);//这里的意思是，在堆内存创建一个String对象，然后他指向常量池的“hello”，这里一共创建了两个对象，一个是常量池的hello，一个是在堆中的对象</div><div class="line">        String s2 = &quot;hello&quot;;//s2指向常量池的“hello”，这里的hello是s1创建的。</div><div class="line">        String s3 = &quot;h&quot;+&quot;e&quot;+&quot;l&quot;+&quot;l&quot;+&quot;o&quot;;</div><div class="line">        System.out.println(s);//输出123</div><div class="line">        System.out.println(s1 == s2);//输出false，我们知道，s1指向的是堆内存分配的String的地址。s2指向的是常量池的“hello”</div><div class="line">        System.out.println(s1.equals(s2));//true，equal比较的是内容，string</div><div class="line">        重写了object的equals方法，object比较的是地址。</div><div class="line">        System.out.println(s2 == s3);//返回时true // 因为jvm会自动优化，在执行s3的时候，产生字符串堆叠，生成</div><div class="line">        //hello,然后发现常量池中已经存在一个hello（s1创建的），所以s3和s2都指向同一个常量池地址</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>String类型的常量池比较特殊。它的主要使用方法有两种：</p>
<p>1.直接使用双引号声明出来的String对象会直接存储在常量池中。</p>
<p>2.如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</p>
<p>查看string重写的equals方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public boolean equals(Object anObject) &#123;</div><div class="line">    if (this == anObject) &#123;//1.如果地址相同，那么说明内容肯定一样</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    if (anObject instanceof String) &#123;//2.紧接着获取两个要比较对象的char数组，然后逐个比较</div><div class="line">        String anotherString = (String)anObject;</div><div class="line">        int n = value.length;</div><div class="line">        if (n == anotherString.value.length) &#123;</div><div class="line">            char v1[] = value;</div><div class="line">            char v2[] = anotherString.value;</div><div class="line">            int i = 0;</div><div class="line">            while (n-- != 0) &#123;</div><div class="line">                if (v1[i] != v2[i])</div><div class="line">                    return false;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="什么是字面值？"><a href="#什么是字面值？" class="headerlink" title="什么是字面值？"></a>什么是字面值？</h2><p>字面值就是可以直接看到是多少的数据，在程序运行中其值不能发生改变。</p>
<p>以下这些就是字面值，字面值，都是存放在常量池中</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* 字符串，用双引号括起来的内容，例如：monkey</span></div><div class="line"><span class="comment">* 整数，所有整数，例如：1024</span></div><div class="line"><span class="comment">* 小数，所有小数，例如：3.14</span></div><div class="line"><span class="comment">* 字符，用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号</span></div><div class="line"><span class="comment">* 布尔，只有true和false</span></div><div class="line"><span class="comment">* 空，null</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConstantDemo01</span> &#123;                        </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line"></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"monkey"</span>);    <span class="comment">//字符串</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"monkey1024"</span>);    <span class="comment">//字符串</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="number">1024</span>);        <span class="comment">//整数</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="number">3.14</span>);        <span class="comment">//小数</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">'a'</span>);        <span class="comment">//''中必须放的是单个字符</span></div><div class="line">    <span class="comment">//error</span></div><div class="line">    <span class="comment">//System.out.println('ab');        //这个ab不是单个字符，而是字符串</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">' '</span>);        <span class="comment">//带表空格字符</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="literal">true</span>);        <span class="comment">//boolean类只有两个值,true和false</span></div><div class="line">    System.<span class="keyword">out</span>.println(<span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Stringbuffer和Stringbuilder"><a href="#Stringbuffer和Stringbuilder" class="headerlink" title="Stringbuffer和Stringbuilder"></a>Stringbuffer和Stringbuilder</h2><p>这两者其实是一模一样的，区别在于，stringbuffer是线程安全的，而stringbuilder是线程不安全的。二者都继承了 AbstractStringBuilder，里面包含了基本操作。区别仅在于Stringbuffer的方法都加了 synchronized。</p>
<p><strong>我们在使用stringbuilder或者stringbuffer的时候，需要考虑到是否存在锁优化的问题（详情参见java并发总结文章）</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.string是一个不可变的变量，<strong>常量池中一定不存在两个相同的字符串</strong>。不可变的意思是，假设创建了这个值就不会再改变，针对于这个字符串的改变，都会重新创建一个新的字符串对象。（例如调用string的，substring，concat等方法，都是返回一个新的string对象）</p>
<p>2.两个字面值字符串相加，在编译期间就可以确定他们的值，他们的加值就存放在字符串常量池中。但是一个字面量加上一个字符串变量，只有在运行期间才会确定值，他们最终是通过stringbuilder的append方法实现相加，最终通过调用toString方法返回一个新的string对象。</p>
<p>关于string.iten的源码：<a href="http://cmsblogs.com/?p=5248" target="_blank" rel="external">http://cmsblogs.com/?p=5248</a></p>
<p>好的博客地址：<a href="https://www.cnblogs.com/dengchengchao/p/9713859.html" target="_blank" rel="external">https://www.cnblogs.com/dengchengchao/p/9713859.html</a> 重要</p>
<p><a href="https://blog.csdn.net/JohnDeng520/article/details/94914717" target="_blank" rel="external">https://blog.csdn.net/JohnDeng520/article/details/94914717</a></p>
<p>深入理解Java中的String（大坑）<a href="https://blog.csdn.net/qq_34490018/article/details/82110578" target="_blank" rel="external">https://blog.csdn.net/qq_34490018/article/details/82110578</a></p>
<p><a href="https://blog.csdn.net/ifwinds/article/details/80849184" target="_blank" rel="external">https://blog.csdn.net/ifwinds/article/details/80849184</a> 重要，iten方法的存在就是为了避免，创建过多的对象。</p>
<p><a href="https://www.cnblogs.com/airnew/p/11628017.html" target="_blank" rel="external">https://www.cnblogs.com/airnew/p/11628017.html</a> 重要 </p>
<h1 id="Exception和Error有什么区别？"><a href="#Exception和Error有什么区别？" class="headerlink" title="Exception和Error有什么区别？"></a><strong>Exception和Error有什么区别？</strong></h1><p>异常的出现，是为了解决在编码过程中，某个逻辑可能出现的意料之外的情况，我们通过捕获这种情况，然后做相应的修正逻辑或者后继处理，使得我们的程序更加健壮。</p>
<p>我们知道出现的意料之外的情况，可以能分为两种，出现问题后我们获取问题然后做拯救措施，程序紧着可以运行，另一种就是出现问题，就算我们再拯救也没用，那么就直接让程序挂掉，然后我们事后做分析。那就是，可以恢复和不可恢复，进而言之分为，exception和error。</p>
<p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p><strong>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类</strong>。Exception 是程序正常运行中，可以<strong>预料的意外情况，可能并且应该被捕获，进行相应处理。</strong></p>
<p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p>
<p>Exception 又分为<strong>可检查</strong>（checked）异常和<strong>不检查</strong>（unchecked）异常，可检查异常在源代码里<strong>必须显式地进行捕获处理</strong>，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。</p>
<p>不检查异常就是所谓的<strong>运行时异常</strong>，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p>
<h2 id="你了解哪些-Error、Exception-或者-RuntimeException？"><a href="#你了解哪些-Error、Exception-或者-RuntimeException？" class="headerlink" title="你了解哪些 Error、Exception 或者 RuntimeException？"></a>你了解哪些 Error、Exception 或者 RuntimeException？</h2><p><img src="/2020/03/09/java基础核心技术/image-20200112113301062.png" alt="image-20200112113301062"></p>
<p>NullPointerException，在写if判断逻辑的时候，没有考虑充分，导致某种情况的入参，没有做到对象的初始化，然后用对象去调用某个方法时，出现问题。</p>
<p>ClassCastException 类转化异常。报表导入时，做映射的时候。</p>
<p>继承于RuntimeException的异常都是可检查异常，继承Exception是非检查异常</p>
<h2 id="try-with-resources-自动关闭资源"><a href="#try-with-resources-自动关闭资源" class="headerlink" title="try-with-resources 自动关闭资源"></a>try-with-resources 自动关闭资源</h2><p>Try-with-resources是java7中一个新的异常处理机制，它能够很容易地关闭在try-catch语句块中使用的资源。</p>
<p>在以前的代码中，我们一般是通过finally做最后的资源回收工作，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static void printFile() throws IOException &#123;</div><div class="line"></div><div class="line">​    InputStream input = null;</div><div class="line"></div><div class="line">​    try &#123;</div><div class="line">​        input = &lt;strong&gt;new FileInputStream(&quot;file.txt&quot;);</div><div class="line">​        int data = &lt;strong&gt;input.read()</div><div class="line">​        while(data != -1)&#123;</div><div class="line">​            System.out.print((char) data);</div><div class="line">​            data = &lt;strong&gt;input.read()</div><div class="line">​        &#125;</div><div class="line">​    &#125; finally &#123;</div><div class="line">​        if(input != null)&#123;</div><div class="line">​            input.close();</div><div class="line">​        &#125;</div><div class="line">​    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在java7中，对于上面的例子可以用try-with-resource 结构这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static void printFileJava7() throws IOException &#123;</div><div class="line">    try(FileInputStream input = new FileInputStream(&quot;file.txt&quot;)) &#123;</div><div class="line">        int data = input.read();</div><div class="line">        while(data != -1)&#123;</div><div class="line">            System.out.print((char) data);</div><div class="line">            data = input.read();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是try-with-resource 结构的用法。FileInputStream 类型变量就在try关键字后面的括号中声明。而且一个FileInputStream 类型被实例化并被赋给了这个变量。</p>
<p>当try语句块运行结束时，FileInputStream 会被自动关闭。这是因为FileInputStream 实现了java中的java.lang.AutoCloseable接口。所有实现了这个接口的类都可以在try-with-resources结构中使用。</p>
<p>当try-with-resources结构中抛出一个异常，同时FileInputStreami被关闭时（调用了其close方法）也抛出一个异常，try-with-resources结构中抛出的异常会向外传播，而FileInputStreami被关闭时抛出的异常被抑制了。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a><strong>知识扩展</strong></h2><p>先开看第一个吧，下面的代码反映了异常处理中哪些不当之处？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try &#123;</div><div class="line">  // 业务代码</div><div class="line">  // …</div><div class="line">  Thread.sleep(1000L);</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">  // Ignore it</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码虽然很短，但是已经违反了异常处理的两个基本原则。</p>
<p>第一，<strong>尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常</strong>，在这里是 Thread.sleep() 抛出的 InterruptedException。</p>
<p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务让自己的代码能够直观地体现出尽量多的信息，而泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获。</p>
<p><strong>进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。</strong></p>
<p>第二，<strong>不要生吞（swallow）异常</strong>。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。</p>
<p>生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设！</p>
<p>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束。没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p>
<blockquote>
<p><strong>体会一下Throw early, catch late 原则</strong></p>
</blockquote>
<p>我们接下来看下面的代码段，体会一下<strong>Throw early, catch late 原则</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void readPreferences(String fileName)&#123;</div><div class="line">	 //...perform operations... </div><div class="line">	InputStream in = new FileInputStream(fileName);</div><div class="line">	 //...read the preferences file...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 fileName 是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。这个 NPE 只是作为例子，实际产品代码中，可能是各种情况，比如获取配置失败之类的。在发现问题的时候，第一时间抛出，能够更加清晰地反映问题。</p>
<p>我们可以修改一下，让问题“throw early”，对应的异常信息就非常直观了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void readPreferences(String filename) &#123;</div><div class="line">	Objects. requireNonNull(filename);</div><div class="line">	//...perform other operations... </div><div class="line">	InputStream in = new FileInputStream(filename);</div><div class="line">	 //...read the preferences file...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处理，可以选择保留原有异常的 cause 信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</p>
<p>有的时候，我们会根据需要自定义异常，这个时候除了保证提供足够的信息，还有两点需要考虑：</p>
<ul>
<li>是否需要定义成 Checked Exception，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。</li>
<li>在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。如果我们看 Java 的标准类库，你可能注意到类似 java.net.ConnectException，出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数据一般是不可以输出到日志里面的。</li>
</ul>
<p>业界有一种争论（甚至可以算是某种程度的共识），Java 语言的 Checked Exception 也许是个设计错误，反对者列举了几点：</p>
<ul>
<li>Checked Exception 的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception 的使用，已经大大偏离了最初的设计目的。</li>
<li>Checked Exception 不兼容 functional 编程，如果你写过 Lambda/Stream 代码，相信深有体会。</li>
</ul>
<p>我们从性能角度来审视一下 Java 的异常处理机制，这里有两个可能会相对昂贵的地方：</p>
<ul>
<li>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li>
<li>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</li>
</ul>
<p>所以，对于部分追求极致性能的底层类库，有种方式是尝试创建不进行栈快照的 Exception。这本身也存在争议，因为这样做的假设在于，我创建异常时知道未来是否需要堆栈。问题是，实际上可能吗？小范围或许可能，但是在大规模项目中，这么做可能不是个理智的选择。如果需要堆栈，但又没有收集这些信息，在复杂情况下，尤其是类似微服务这种分布式系统，这会大大增加诊断的难度。</p>
<p>当我们的服务出现反应变慢、吞吐量下降的时候，检查发生最频繁的 Exception 也是一种思路。关于诊断后台变慢的问题，我会在后面的 Java 性能基础模块中系统探讨。</p>
<h1 id="强引用、软引用、弱引用、幻象引用有什么区别？"><a href="#强引用、软引用、弱引用、幻象引用有什么区别？" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别？"></a><strong>强引用、软引用、弱引用、幻象引用有什么区别？</strong></h1><p>不同的引用类型，主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响</strong>。也就是说，他是跟</p>
<p>所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象（<strong>我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new 创建的对象所关联的引用就是强引用</strong>）。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>软引用（通过这个类实现SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。<strong>虽说难以下咽，但是弃之可惜，所以他是强引用的一种折中方案，当jvm堆内存充足不会回收，但是当堆内存不足的时候，就会被回收。换句话说，就是尽量留下来</strong></p>
<p>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p>
<p>对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。</p>
<h1 id="动态代理和反射是基于什么原理？"><a href="#动态代理和反射是基于什么原理？" class="headerlink" title="动态代理和反射是基于什么原理？"></a>动态代理和反射是基于什么原理？</h1><p>​     </p>
<p>​    什么叫代理，就是我代替你去做某件事情，例如代购，通过代理功能，我们可以在调用<strong>被代理对象（委托类）</strong>的某个方法的<strong>前后做一些逻辑补充操作</strong>，例如我们要做饭，那么我们在做饭之前先洗米，插上电源—&gt;&gt; 做饭 —&gt;拔下电源。</p>
<p>这个就是我们常说的切面，就是在<strong>原来的基础上（不改变委托类）</strong>，切入我们想要的逻辑。</p>
<p><strong>代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</strong></p>
<p>​    代理模式是一种常用的设计模式。代理模式为其对象提供了一种代理以控制对这个对象的访问。代理模式可以将主要业务与次要业务进行松耦合的组装。根据代理类的创建时机和创建方式的不同，可以将其分为静态代理和动态代理两种形式：<br>在程序运行前就已经存在的<strong>编译好的代理类</strong>是为静态代理。<br>在程序运行期间根据需要动态创建代理类及其实例来完成具体的功能是为动态代理。（<strong>动态代理的实现方式有两种，JDK动态代理和cglib动态代理</strong>）</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>就是通过继承委托类，生成代理类，然后重写委托类的方法，重新实现逻辑，完成代理的逻辑。</p>
<p>代理类是委托类的子类（有点cglib动态代理的味道）</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><strong>代理类和委托类，都实现同一个接口，代理类依赖委托类（代理类注入委托类）</strong></p>
<p>接下来看一下静态代理的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 委托接口</div><div class="line">public interface IHelloService &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 定义接口方法</div><div class="line">     * @param userName</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    String sayHello(String userName);</div><div class="line"></div><div class="line">&#125;</div><div class="line">// 委托类实现</div><div class="line">public class HelloService implements IHelloService &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String sayHello(String userName) &#123;</div><div class="line">        System.out.println(&quot;helloService&quot; + userName);</div><div class="line">        return &quot;HelloService&quot; + userName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 代理类</div><div class="line">public class StaticProxyHello implements IHelloService &#123;</div><div class="line"></div><div class="line">    private IHelloService helloService = new HelloService();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String sayHello(String userName) &#123;</div><div class="line">        /** 代理对象可以在此处包装一下*/</div><div class="line">        System.out.println(&quot;代理对象包装礼盒...&quot;);</div><div class="line">        return helloService.sayHello(userName);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 测试静态代理类</div><div class="line">public class MainStatic &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        StaticProxyHello staticProxyHello = new StaticProxyHello();</div><div class="line">        staticProxyHello.sayHello(&quot;isole&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    可以看到，代理类和委托类，<strong>都实现共同的接口IHelloService</strong>。静态代理，实际上就是在代理类中，注入委托类，然后代理类可以实现一些额外的方法，然后真正的调用时。通过代理类去调用委托类。我们可以看待，代码的结构是固定的，在编译前就可以确定代理类有哪些方法。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200113095241291.png" alt="image-20200113095241291"></p>
<p>​    使用静态代理的缺点是：只适用委托方法少的情况下, 试想一下如果委托类有几百上千个方法, 岂不是很难受, 要在代理类中写一堆的代理方法。换句话说，我们有三个开发，每个人在调用委托类的方法之前，都会有自己的迁入逻辑补充，那么也就意味着，需要在StaticProxyHello代理类中，实现各自的方法，那么代理类中的代理方法就会疯狂增多，那么就会导致代理类很难管理。也就是说，<strong>我们想要按需在代理类中添加我们想要切入的逻辑，那么这个就是要动态的添加代理方法了。</strong></p>
<p>   ①代理类和被代理类实现了相同的接口，导致代码的重复，如果接口增加一个方法，那么除了被代理类需要实现这个方法外，代理类也要实现这个方法，增加了代码维护的难度。<br>   ②代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。比如上面的例子，只是对用户的业务功能（IUserService）进行代理，如果是商品（IItemService）的业务功能那就无法代理，需要去编写商品服务的代理类。</p>
<blockquote>
<p><strong>实现静态代理有四个步骤：</strong></p>
</blockquote>
<ul>
<li>定义业务接口</li>
<li>定义委托类并实现业务接口</li>
<li>定义代理类并实现业务接口，同时依赖委托类（委托类是代理类的一个成员变量）</li>
</ul>
<p>这个需求，就需要动态代理。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理类在程序运行时创建的代理方式被成为 <code>动态代理</code>。在了解动态代理之前, 我们先简回顾一下 JVM 的类加载机制中的加载阶段要做的三件事情 ( 附 Java 中的类加载器 )</p>
<ol>
<li>通过一个类的全名或其它途径来获取这个类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 Class 对象, 作为方法区中对这个类访问的入口。</li>
</ol>
<p>​    而我们要说的动态代理，主要就发生在第一个阶段, 这个阶段类的二进制字节流的来源可以有很多, 比如 zip 包、网络、<code>运行时计算生成</code>、其它文件生成 (JSP)、数据库获取。其中运行时计算生成就是我们所说的动态代理技术，在 Proxy 类中, 就是运用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流。所谓的动态代理就是想办法根据接口或者目标对象计算出<code>代理类</code>的字节码然后加载进 JVM 中。实际计算的情况会很复杂，我们借助一些诸如 <strong>JDK 动态代理实现、CGLIB 第三方库来完成</strong>。</p>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>在 Java 的动态代理中, 主要涉及 2 个类,<code>java.lang.reflect.Proxy</code>和<code>java.lang.reflect.InvocationHandler</code> 我们需要一个实现 InvocationHandler 接口的<strong>中间类</strong>, 这个接口只有一个方法 invoke 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">public interface InvocationHandler &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 调用处理</span></div><div class="line"><span class="comment">     * @param proxy 代理类对象</span></div><div class="line"><span class="comment">     * @param methon 标识具体调用的是代理类的哪个方法</span></div><div class="line"><span class="comment">     * @param args 代理类方法的参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args)</div><div class="line">        throws Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>实际上最关键的就是这个中间类，通过中间类，我们可以拦截委托类所有方法的调用，然后做一些额外的工作。</strong></p>
<p>​    <strong>我们对处理类（中间类生成的代理对象）中的所有方法的调用都会变成对 invoke 方法的调用，这样我们可以在 invoke 方法中添加统一的处理逻辑（也可以根据 method 参数判断是哪个方法）</strong>。<strong>中间类 (实现了 InvocationHandler 的类)</strong> 有一个<strong>委托类对象引用</strong>, 在 Invoke 方法中调用了委托类对象的相应方法，通过这种<strong>聚合的方式</strong>持有委托类对象引用，把外部对 invoke 的调用最终都转为对委托类对象的调用。</p>
<p>​    实际上，中间类与委托类构成了静态代理关系（他们的关系就是在中间类总注入委托类，然后调用，编译时即可确定关系），在这个关系中，中间类是代理类，委托类是委托类。然后代理类与中间类也构成一个静态代理关系，在这个关系中，中间类是委托类，代理类是代理类。也就是说，<strong>动态代理关系由两组静态代理关系组成，这就是动态代理的原理</strong>。</p>
<p>jdk的reflect实现动态代理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 委托类接口</span></div><div class="line">public interface IHelloService &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法1</span></div><div class="line"><span class="comment">     * @param userName</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="built_in">String</span> sayHello(<span class="built_in">String</span> userName);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法2</span></div><div class="line"><span class="comment">     * @param userName</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="built_in">String</span> sayByeBye(<span class="built_in">String</span> userName);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 委托类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> <span class="title">implements</span> <span class="title">IHelloService</span> </span>&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public <span class="built_in">String</span> sayHello(<span class="built_in">String</span> userName) &#123;</div><div class="line">        System.out.println(userName + <span class="string">" hello"</span>);</div><div class="line">        <span class="keyword">return</span> userName + <span class="string">" hello"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public <span class="built_in">String</span> sayByeBye(<span class="built_in">String</span> userName) &#123;</div><div class="line">        System.out.println(userName + <span class="string">" ByeBye"</span>);</div><div class="line">        <span class="keyword">return</span> userName + <span class="string">" ByeBye"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 中间类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">JavaProxyInvocationHandler</span> <span class="title">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 中间类持有委托类对象的引用,这里会构成一种静态代理关系</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    private <span class="built_in">Object</span> obj ;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 有参构造器,传入委托类的对象</span></div><div class="line"><span class="comment">     * @param obj 委托类的对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public JavaProxyInvocationHandler(<span class="built_in">Object</span> obj)&#123;</div><div class="line">        <span class="keyword">this</span>.obj = obj;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 动态生成代理类对象,Proxy.newProxyInstance</span></div><div class="line"><span class="comment">     * @return 返回代理类的实例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public <span class="built_in">Object</span> newProxyInstance() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Proxy</span>.newProxyInstance(</div><div class="line">                <span class="comment">//指定代理对象的类加载器，然后委托类跟代理类由同一个类加载器加载</span></div><div class="line">                obj.getClass().getClassLoader(),</div><div class="line">                <span class="comment">//代理对象需要实现的接口，可以同时指定多个接口</span></div><div class="line">                obj.getClass().getInterfaces(),</div><div class="line">                <span class="comment">//方法调用的实际处理者，代理对象的方法调用都会转发到这里</span></div><div class="line">                <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param proxy 代理对象</span></div><div class="line"><span class="comment">     * @param method 代理方法</span></div><div class="line"><span class="comment">     * @param args 方法的参数</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     * @throws Throwable</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    @Override</div><div class="line">    public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args) throws Throwable &#123;</div><div class="line">        System.out.println(<span class="string">"invoke before"</span>);</div><div class="line">        <span class="built_in">Object</span> result = method.invoke(obj, args);</div><div class="line">        System.out.println(<span class="string">"invoke after"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 测试动态代理类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainJavaProxy</span> </span>&#123;</div><div class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</div><div class="line">        JavaProxyInvocationHandler proxyInvocationHandler = <span class="keyword">new</span> JavaProxyInvocationHandler(<span class="keyword">new</span> HelloService());</div><div class="line">        IHelloService helloService = (IHelloService) proxyInvocationHandler.newProxyInstance();</div><div class="line">        helloService.sayByeBye(<span class="string">"paopao"</span>);</div><div class="line">        helloService.sayHello(<span class="string">"yupao"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    在上面的测试动态代理类中, 我们调用 Proxy 类的 <strong>newProxyInstance 方法来获取一个代理类实例</strong>。这个代理类<strong>实现了我们指定的接口</strong>并且会把方法调用分发到<strong>指定的调用处理器*</strong>（也就是invocationhandler的invoke方法）。</p>
<p>​    首先通过 newProxyInstance 方法获取<strong>代理类的实例</strong>, 之后就可以通过这个代理类的实例调用<strong>代理类的方法</strong>，对代理类的方法调用<strong>都会调用中间类 (实现了 invocationHandle 的类) 的 invoke 方法</strong>，在 invoke 方法中我们调用委托类的对应方法，然后加上自己的处理逻辑。</p>
<p>​    java 动态代理最大的特点就是<strong>动态生成的代理类和委托类实现同一个接口</strong>。java 动态代理其实内部是<strong>通过反射机制实现的，也就是已知的一个对象，在运行的时候动态调用它的方法，并且调用的时候还可以加一些自己的逻辑在里面。</strong></p>
<blockquote>
<p><strong>Proxy.newProxyInstance 源码阅读。</strong></p>
</blockquote>
<p>上面说过, Proxy.newProxyInstance 通过反射机制用来动态生成代理类对象, 为接口创建一个代理类，这个代理类实现这个接口。具体源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">public <span class="keyword">static</span> <span class="built_in">Object</span> newProxyInstance(ClassLoader loader,</div><div class="line">                                          Class&lt;?&gt;[] interfaces,</div><div class="line">                                          InvocationHandler h)</div><div class="line">        throws IllegalArgumentException</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 检查空指针</span></div><div class="line">        Objects.requireNonNull(h);</div><div class="line">        <span class="comment">// 用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象</span></div><div class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</div><div class="line">        <span class="comment">// 获取系统的安全接口,不为空的话需要验证是否允许访问这种关系的代理访问</span></div><div class="line">        final SecurityManager sm = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</div><div class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * 查找或生成代理类 Class,通过类加载器和接口，如果已经存在代理类，则直接返回</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * 通过构造器来创建实例</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</div><div class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//获取所有的构造器</span></div><div class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class="line">            final InvocationHandler ih = h;</div><div class="line">            <span class="comment">// 构造器不是public的话需要设置可以访问</span></div><div class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</div><div class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">                    public Void run() &#123;</div><div class="line">                        cons.setAccessible(<span class="literal">true</span>);</div><div class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 返回创建的代理类Class的实例对象</span></div><div class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;h&#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">InternalError</span>(e.toString(), e);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            Throwable t = e.getCause();</div><div class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">                <span class="keyword">throw</span> (RuntimeException) t;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">InternalError</span>(t.toString(), t);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">InternalError</span>(e.toString(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>接着分析一下 getProxyClass0（）方法</p>
<p>我们发现他会先从<strong>缓存中查找</strong>是否存在相应的<strong>代理类的class对象</strong>，有则直接返回，没有则新增。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Generate a proxy class.  Must call the checkProxyAccess method</div><div class="line"> * to perform permission checks before calling this.</div><div class="line"> */</div><div class="line">private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</div><div class="line">                                       Class&lt;?&gt;... interfaces) &#123;</div><div class="line">    if (interfaces.length &gt; 65535) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // If the proxy class defined by the given loader implementing</div><div class="line">    // the given interfaces exists, this will simply return the cached copy;</div><div class="line">    // otherwise, it will create the proxy class via the ProxyClassFactory</div><div class="line">    //意思是：如果代理类被指定的类加载器loader定义了，并实现了给定的接口interfaces，</div><div class="line">    //那么就返回缓存的代理类对象，否则使用ProxyClassFactory创建代理类。</div><div class="line">    return proxyClassCache.get(loader, interfaces);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>超详细源码分析：<a href="https://www.jianshu.com/p/269afd0a52e6" target="_blank" rel="external">https://www.jianshu.com/p/269afd0a52e6</a></p>
<h4 id="为什么实现同一个接口是实现jdk动态代理的基础"><a href="#为什么实现同一个接口是实现jdk动态代理的基础" class="headerlink" title="为什么实现同一个接口是实现jdk动态代理的基础"></a>为什么实现同一个接口是实现jdk动态代理的基础</h4><p>为什么jdk动态代理就不能通过继承某个类的方式实现呢？</p>
<p>我们可以通过查看jdk动态动态代理方式生成的代理类，我们发现，代理类他最终的结构是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public final class ProxyClass extend Proxy implements  IHelloService</div><div class="line"></div><div class="line">可以看到生成的代理类已经继承了 Proxy类，那么java只支持单继承，那么所以就不能通过继承的方式生成代理类。</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p>​    我们发现，实际上，委托类和代理类本质上都是实现了同一个接口，<strong>实现同一个接口是实现动态代理的基础</strong>。jdk的动态代理，实际上是两组静态代理实现。代理类和中间类是静态代理关系，中间类和委托类是静态代理关系。</p>
<p>​    而且动态代理跟静态代理的区别，在于<strong>，我们不用实现一个静态的代理类（例如静态代理的StaticProxyHello），我们通过一个中间类（invocationhandler是实现类）生成代理类。然后我们可以定制自己在调用委托类方法之前，切入自己的逻辑。</strong> 也就是说，<strong>代理类是运行的时候才生成的。故叫动态代理</strong></p>
<p>​    同时我们注意源码的<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</code> 你会发现，它是会先查找缓存中是否存在代理类Class对象，如果存在则不新增。<strong>这样的好处就是，不会在jvm的metaspace区占满内存。</strong></p>
<p><strong>itss项目和固定资产项目，使用到了，动态反射，实现了资产的导入。</strong></p>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>​    JDK 动态代理依赖接口实现，而当我们只有类没有接口的时候就需要使用另一种动态代理技术 CGLIB 动态代理。首先 CGLIB 动态代理是第三方框架实现的，在 maven 工程中我们需要引入 cglib 的包, 如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;cglib&lt;<span class="regexp">/groupId&gt;</span></div><div class="line"><span class="regexp">    &lt;artifactId&gt;cglib&lt;/</span>artifactId&gt;</div><div class="line">    &lt;version&gt;<span class="number">2.2</span>&lt;<span class="regexp">/version&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>dependency&gt;</div></pre></td></tr></table></figure>
<p>​    CGLIB 代理是针对类来实现代理的，原理是对指定的委托类生成一个子类并重写其中业务方法来实现代理。代理类对象是由 Enhancer 类创建的。CGLIB 创建动态代理类的模式是:</p>
<ol>
<li>查找目标类上的所有非 final 的 public 类型的方法 (final 的不能被重写)</li>
<li>将这些方法的定义转成字节码</li>
<li>将组成的字节码转换成相应的代理的 Class 对象然后通过反射获得代理类的实例对象</li>
<li>实现 MethodInterceptor 接口, 用来处理对代理类上所有方法的请求</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 委托类,是一个简单类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CglibHelloClass</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法1</span></div><div class="line"><span class="comment">     * @param userName</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public <span class="built_in">String</span> sayHello(<span class="built_in">String</span> userName)&#123;</div><div class="line">        System.out.println(<span class="string">"目标对象的方法执行了"</span>);</div><div class="line">        <span class="keyword">return</span> userName + <span class="string">" sayHello"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public <span class="built_in">String</span> sayByeBye(<span class="built_in">String</span> userName)&#123;</div><div class="line">        System.out.println(<span class="string">"目标对象的方法执行了"</span>);</div><div class="line">        <span class="keyword">return</span> userName + <span class="string">" sayByeBye"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * CglibInterceptor 用于对方法调用拦截以及回调</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CglibInterceptor</span> <span class="title">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * CGLIB 增强类对象，代理类对象是由 Enhancer 类创建的，</span></div><div class="line"><span class="comment">     * Enhancer 是 CGLIB 的字节码增强器，可以很方便的对类进行拓展</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    private Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * @param obj  被代理的对象</span></div><div class="line"><span class="comment">     * @param method 代理的方法</span></div><div class="line"><span class="comment">     * @param args 方法的参数</span></div><div class="line"><span class="comment">     * @param proxy CGLIB方法代理对象</span></div><div class="line"><span class="comment">     * @return  cglib生成用来代替Method对象的一个对象，使用MethodProxy比调用JDK自身的Method直接执行方法效率会有提升</span></div><div class="line"><span class="comment">     * @throws Throwable</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    @Override</div><div class="line">    public <span class="built_in">Object</span> intercept(<span class="built_in">Object</span> obj, Method method, <span class="built_in">Object</span>[] args, MethodProxy proxy) throws Throwable &#123;</div><div class="line">        System.out.println(<span class="string">"方法调用之前"</span>);</div><div class="line">        <span class="built_in">Object</span> o = proxy.invokeSuper(obj, args);</div><div class="line">        System.out.println(<span class="string">"方法调用之后"</span>);</div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用动态代理创建一个代理对象</span></div><div class="line"><span class="comment">     * @param c</span></div><div class="line"><span class="comment">     * @return</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    public  <span class="built_in">Object</span> newProxyInstance(Class&lt;?&gt; c) &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 设置产生的代理对象的父类,增强类型</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        enhancer.setSuperclass(c);</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 定义代理逻辑对象为当前对象，要求当前对象实现 MethodInterceptor 接口</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        enhancer.setCallback(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 使用默认无参数的构造函数创建目标对象,这是一个前提,被代理的类要提供无参构造方法</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">return</span> enhancer.create();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainCglibProxy</span> </span>&#123;</div><div class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</div><div class="line">        CglibInterceptor cglibProxy = <span class="keyword">new</span> CglibInterceptor();</div><div class="line">        CglibHelloClass cglibHelloClass = (CglibHelloClass) cglibProxy.newProxyInstance(CglibHelloClass.class);</div><div class="line">        cglibHelloClass.sayHello(<span class="string">"isole"</span>);</div><div class="line">        cglibHelloClass.sayByeBye(<span class="string">"sss"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    对于需要被代理的类，它只是动态生成一个子类以覆盖非 final 的方法，同时绑定钩子回调自定义的拦截器。值得说的是，它比 JDK 动态代理还要快。值得注意的是，<strong>我们传入目标类作为代理的父类</strong>。</p>
<p>​    <strong>不同于 JDK 动态代理，我们不能使用目标对象来创建代理（我们是通过接口来实现代理类）。目标对象只能被 CGLIB 创建。</strong></p>
<p>​    在例子中，默认的无参构造方法被使用来创建目标对象。</p>
<p>​    <strong>可以看到使用CGLIB实现动态代理，少实现了一个类，那就是IHelloService。因为CGLIB实现的代理类的父类就是委托类。</strong></p>
<p>​    </p>
<p><strong>使用cglib要注意，开启使用缓存标志，否则，就会导致，因为动态生成过多的Class对象，从而挤爆永久代（metaspace）</strong></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>​    静态代理比较容易理解, 需要被代理的类和代理类实现自同一个接口, 然后在代理类中调用真正实现类, 并且静态代理的关系在编译期间就已经确定了。</p>
<p>​    而动态代理的关系是在运行期间确定的。静态代理实现简单，适合于代理类较少且确定的情况，而动态代理则给我们提供了更大的灵活性。</p>
<p>​    JDK 动态代理所用到的代理类在程序调用到代理类对象时才由 JVM 真正创建，JVM 根据传进来的 业务实现类对象 以及 方法名 ，动态地创建了一个代理类的 class 文件并被字节码引擎执行，然后通过该代理类对象进行方法调用。我们需要做的，只需指定代理类的预处理、调用后操作即可。</p>
<p>​    <strong>静态代理和动态代理都是基于接口实现的</strong>, 而对于那些<strong>没有提供接口只是提供了实现类</strong>的而言, 就<strong>只能选择 CGLIB 动态代理</strong>了</p>
<p><strong>JDK 动态代理和 CGLIB 动态代理的区别</strong></p>
<ul>
<li><p>JDK 动态代理基于 Java 反射机制实现, 必须要实现了接口的业务类才能用这种方法生成代理对象。</p>
</li>
<li><p>CGLIB 动态代理基于 ASM 框架通过生成业务类的子类来实现。</p>
</li>
<li><p><strong>JDK 动态代理的优势是最小化依赖关系，但是需要定义一个公有的接口（IHelloService）</strong>，减少依赖意味着简化开发和维护并且有 JDK 自身支持。还可以平滑进行 JDK 版本升级，代码实现简单。</p>
<p>基于 CGLIB 框架的优势是<strong>无须实现接口</strong>，达到代理类无侵入，我们只需操作我们关系的类，不必为其它相关类增加工作量，性能比较高。</p>
</li>
</ul>
<p><strong>描述代理的几种实现方式? 分别说出优缺点?</strong></p>
<p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK 动态代理” 和 “CGLIB 动态代理” 实现。</p>
<p><strong>静态代理</strong>：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object.</p>
<ul>
<li>优点：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li>
<li>缺点：不同的接口要有不同的代理类实现，会很冗余</li>
</ul>
<p><strong>JDK 动态代理</strong>： 为了解决静态代理中，生成大量的代理类造成的冗余； JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，</p>
<p>jdk 的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象 jdk 动态代理之所以只能代理接口是因为代理类本身已经 extends 了 Proxy，而 java 是不允许多重继承的，但是允许实现多个接口</p>
<ul>
<li>优点：解决了静态代理中冗余的代理实现类问题。</li>
<li>缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</li>
</ul>
<p><strong>CGLIB 代理：</strong> 由于 <strong>JDK 动态代理限制</strong>了<strong>只能基于接口设计</strong>，而对于没有接口的情况，JDK 方式解决不了； CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。 实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。</p>
<p>但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以<strong>对于单例的对象</strong>，因为无需频繁创建对象，<strong>用 CGLib 合适</strong>，反之，如果<strong>需要创建大量对象</strong>，<strong>使用 JDK 方式要更为合适</strong>一些。 同时，<strong>由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</strong></p>
<p>优点：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</p>
<p> 缺点：技术实现相对难理解些。</p>
<p>总而言之，<strong>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用CGLIB实现。</strong>  但是使用CGLIB要非常注意，因为</p>
<h2 id="为什么面试会问？"><a href="#为什么面试会问？" class="headerlink" title="为什么面试会问？"></a>为什么面试会问？</h2><p>从考察知识点的角度，这道题涉及的知识点比较庞杂，所以面试官能够扩展或者深挖的内容非常多，比如：</p>
<ul>
<li>考察你对反射机制的了解和掌握程度。</li>
<li>动态代理解决了什么问题，在你业务系统中的应用场景是什么？</li>
<li>JDK 动态代理在设计和实现上与 cglib 等方式有什么不同，进而如何取舍？</li>
</ul>
<h2 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h2><p>我们知道JDK生成代理类的方式，最终实现是是通过，反射的机制实现的，那么什么是反射呢？</p>
<p><strong>反射目的就是为了程序在运行过程中动态创建某个类。</strong></p>
<blockquote>
<p><strong>首先要知道Class类</strong></p>
</blockquote>
<p>​    对象照镜子后可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。</p>
<p>Class 对象只能由系统建立对象（不能自己new），<strong>在jvm加载字节码文件到元空间（永久代），就会自动创建Class对象。</strong></p>
<p>一个类在 JVM 中只会有一个Class实例 （<strong>类加载机制，双亲委任机制保证了字节码文件的唯一性</strong>）</p>
<p>每个类的实例都会记得自己是由哪个 Class 实例所生成 。</p>
<p>​    <strong>所以我们都是通过Class类获取某个对象的，已经定义方法，成员变量，构造函数等等，然后在运行过程中动态执行某个方法。</strong></p>
<p>获取一个对象的Class对象的方式有三种。</p>
<pre><code>1.通过对象的getClass方法获取
  Student stu1 = new Student();/
  Class class = stu1.getClass（）；
2. 通过类的class属性获取，该方法最为安全可靠，程序性能更高
  Class class = Student.class（）

3，通过Class对象的forName静态方法获取
   但是可能会抛出ClassNotFoundException异常
  Class class = Class.forName（&quot;www.kingge.top.Student&quot;）
</code></pre><p>​    </p>
<p>​    三种方式常用第三种，第一种对象都有了还要反射干什么(<strong>使用反射的目的是为了创建对象</strong>)。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p>
<blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p>反射的出现，目的就是让程序在运行过程中，动态生成我们所需要的类。</p>
<p>反射的实现，就是通过Class类，Class类是唯一的，因为通过双亲委任机制可以得知。</p>
<h1 id="Java-hashCode-和-equals-的若干问题解答"><a href="#Java-hashCode-和-equals-的若干问题解答" class="headerlink" title="Java hashCode() 和 equals()的若干问题解答"></a>Java hashCode() 和 equals()的若干问题解答</h1><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="external"></a></p>
<h1 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h1><p><a href="http://cmsblogs.com/?p=15717" target="_blank" rel="external">http://cmsblogs.com/?p=15717</a></p>
<p>这两个接口，都可以用来实现对象的排序。也就是说他们两个的功能实际上就是一样的。所以不要混着使用。也就是说，一个类最后不要同时实现这两个接口。</p>
<p>那么，他们的使用规则一般是：一个类，一般是通过实现Comparable接口实现排序（作为内部排序），但是当我们在不想修改类的代码结构的同时又想改变内部排序，这个时候可以使用Comparator接口实现重写排序逻辑（作为外部排序）。这样在排序的时候，默认的内部排序，就会被外部排序逻辑覆盖。</p>
<h1 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h1><p>​    JMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念 ，并不真实存在，它描述的是一组规则或规范通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式。</p>
<p>JMM关于同步规定:</p>
<p>1.线程解锁前,必须把共享变量的值刷新回主内存<br>2.线程加锁前,必须读取主内存的最新值到自己的工作内存<br>3.加锁解锁是同一把锁</p>
<p>​    由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间，实际上就是java虚拟机栈)，工作内存是每个线程的私有数据区域（<strong>java虚拟机栈</strong>），而Java内存模型中规定<strong>所有变量都存储在主内存</strong>，<strong>主内存是共享内存区域，所有线程都可访问</strong>，<strong>但线程对变量的操作(读取赋值等)必须在工作内存中进行，所以线程要将操作的变量从主内存拷贝到自己的工作空间，然后对变量进行操作，操作完成再将变量写回主内存，不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝</strong>，因此不同的线程无法访问对方的工作内存,此案成间的通讯(传值) 必须通过主内存来完成,其简要访问过程如下图:</p>
<p> <img src="/2020/03/09/java基础核心技术/image-20200120163400968.png" alt="image-20200120163400968"></p>
<p>这个就是并发问题出现的根源之一，数据可见性。</p>
<p><strong>也就是说：JMM的存在就是为了保证，原子性，可见性，有序性。也即是，保证多线程访问资源的安全性</strong></p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a><strong>Volatile</strong></h1><p> <strong>首先声明，他不是一种锁。</strong>  <strong>它会确保我们对于某个变量的读取和写入，都一定会同步到主内存里，而不是从 Cache 里面读取（也就是我们通俗的说禁用缓存）</strong>。</p>
<p>volatile是java虚拟机提供的的<strong>轻量级的同步机制</strong>，它能够<strong>保证可见性和禁止指令重排序</strong>。但是<strong>不能够保证原子性（那就意味着，会产生线程不安全问题）</strong></p>
<blockquote>
<p><strong>什么叫可见性</strong></p>
</blockquote>
<p>一个线程对于共享资源的修改，对于另一个线程是可见的。也就是说，我修改后的值，你是可以看到的。<strong>也就意味着，假设另一个线程改完了，那么会通知到另一个线程。</strong></p>
<blockquote>
<p><strong>什么叫原子性</strong></p>
</blockquote>
<p>也就是一个线程操作某个逻辑的时候，它能够保证在执行的过程中，不会发生线程切换，<strong>要么都完成，要么都失败</strong>，而且我们能够所说的原子性是针对于CPU指令而言的（高级语言里一条语句往往需要多条 CPU 指令完成）。例如我们在执行，自增操作的时候，count+=1；<strong>你以为这是一个原子操作，就是执行一条指令而已，其实不是</strong>，因为他至少会分成三个cpu指令去执行。</p>
<ul>
<li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li>
<li>指令 2：之后，在寄存器中执行 +1 操作；</li>
<li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>
</ul>
<p>​    <strong>操作系统做任务切换</strong>，可以发生在任何一条<strong>CPU 指令</strong>执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200117091622074.png" alt="image-20200117091622074"></p>
<blockquote>
<p><strong>指令重排序</strong></p>
</blockquote>
<p>参见《java并发章节》</p>
<h2 id="那么volatile是怎么保证可见性（数据一致性）呢？"><a href="#那么volatile是怎么保证可见性（数据一致性）呢？" class="headerlink" title="那么volatile是怎么保证可见性（数据一致性）呢？"></a>那么volatile是怎么保证可见性（数据一致性）呢？</h2><p>首先查看下面例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class VolatileTets &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ShareData shareData = new ShareData();//主内存中，初始化了ShareData对象，并初始化了number值为0</div><div class="line">		</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				System.out.println( Thread.currentThread().getName() +&quot;  开始执行&quot; );</div><div class="line">				try &#123;</div><div class="line">					TimeUnit.SECONDS.sleep(3);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				shareData.addNumber();</div><div class="line">				System.out.println( Thread.currentThread().getName() +&quot;  更新完毕 number的值是：&quot;+ shareData.number );</div><div class="line">			&#125;</div><div class="line">		&#125;, &quot;a&quot;).start();</div><div class="line">		</div><div class="line">		</div><div class="line">		while(shareData.number == 0) &#123;</div><div class="line">		&#125;</div><div class="line">		System.out.println( Thread.currentThread().getName() + &quot; main线程执行结束  &quot;  );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ShareData&#123;</div><div class="line">	public int number = 0;</div><div class="line">	public void addNumber() &#123;</div><div class="line">		this.number = 60;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道上诉代码，一共创建了两个线程，一个是main线程，一个是a线程。</p>
<p>那么为什么在a线程内部停了三秒呢？目的就是，让a线程跟main线程，获取的共享资源的number都是一样的（也就是0），拷贝到自己的java虚拟机栈的number都是0。这样就能够保证，main线程，执行成功while循环，然后main线程不会结束。这样才能够验证volatile的可见性。</p>
<p>上诉代码，的执行结果，我们其实也能够看的出来，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a线程  开始执行</div><div class="line">a线程  更新完毕 number的值是：60</div></pre></td></tr></table></figure>
<p><strong>main线程，永久挂在那里，a线程执行完毕。</strong> 也就意味着，a线程虽然修改了number 的值，<strong>同时把主内存的number修改为60</strong>，但是对于main线程而言是不可见的，没有通知main线程，main线程认为还是0。否则，main线程应该结束while循环。</p>
<p><strong>那么我们说volatile可以解决可见性，那么是真是假呢？</strong></p>
<p>我们把 <code>public int number = 0;</code> 修改为<code>public volatile int number = 0;</code>，再次运行代码。</p>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a线程  开始执行</div><div class="line">a线程  更新完毕 number的值是：60</div><div class="line">main main线程执行结束</div></pre></td></tr></table></figure>
<p>我们惊喜的发现，main线程竟然退出了！！！，那也就意味着，a线程修改完number后，写入到主内存，然后成功通知了挂起来的main线程。</p>
<p><strong>所以，到这里，我们就成功的验证了volatile的可见性机制。</strong></p>
<h2 id="验证volatile不支持原子性"><a href="#验证volatile不支持原子性" class="headerlink" title="验证volatile不支持原子性"></a>验证volatile不支持原子性</h2><p>验证例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class VolatileTets &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ShareData shareData = new ShareData();</div><div class="line">		for (int i = 0; i &lt; 20000; i++) &#123;</div><div class="line">			new Thread(new Runnable() &#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					shareData.add();</div><div class="line">				&#125;</div><div class="line">			&#125;, String.valueOf(i)).start();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		Thread.yield();</div><div class="line">		System.out.println( shareData.number );</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ShareData&#123;</div><div class="line">	</div><div class="line">	public volatile int number = 0;</div><div class="line"></div><div class="line">	public void add() &#123;</div><div class="line">		this.number++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会发现，输出的值，都是随机的，并不是我们预期的20000，<strong>所以volatile并不能保证原子性。</strong></p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p><strong>解决方案：使用synchronized内部锁或者Lock显示锁</strong>，但是加锁又太重，杀鸡用牛刀，我们可以考虑使用AtomicInteger来实现number++的问题。</p>
<h2 id="volatile怎么禁止指令重排序？"><a href="#volatile怎么禁止指令重排序？" class="headerlink" title="volatile怎么禁止指令重排序？"></a>volatile怎么禁止指令重排序？</h2><blockquote>
<p><strong>什么叫指令重排序</strong></p>
</blockquote>
<p>计算机在执行程序时,为了提高性能,编译器和处理器常常会做指令重排,一把分为以下3种：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200121094835443.png" alt="image-20200121094835443"></p>
<p>单线程环境里面能确保程序最终执行结果和代码顺序执行的结果一致。</p>
<p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程使用的变量能否保持一致性是无法确定的,结果无法预测。</p>
<p>但是处理器在进行重新排序是必须要<strong>考虑指令之间的数据依赖性</strong>。</p>
<blockquote>
<p><strong>指令重排例子1</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void mySort()&#123;</div><div class="line">    int x=11;//语句1</div><div class="line">    int y=12;//语句2</div><div class="line">    x=x+5;//语句3</div><div class="line">    y=x*x;//语句4</div><div class="line">&#125;</div><div class="line">例如我们从编程角度看上面代码，以为执行顺序是1234。</div><div class="line">但是，可能不是，可能会发生指令重排。例如，重拍后是按照 2134、1324这样的执行顺序。</div><div class="line"></div><div class="line">问题:</div><div class="line">请问语句4 可以重排后变成第一条码?</div><div class="line">存在数据的依赖性，没办法排到第一个，因为要执行语句4，需要依赖 y或者x，放到第一条，这个时候，y或者x还没有初始化。那么很明显语句四肯定执行失败，所以语句四不可能被重排到第一个</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>指令重排序例子2</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CP &#123;</div><div class="line">	</div><div class="line">	int a = 0;</div><div class="line">	boolean flag = false;</div><div class="line">	public void initValue() &#123;</div><div class="line">		a = 1;//1</div><div class="line">		flag = true;//2</div><div class="line">	&#125;</div><div class="line">	public void updateValue() &#123;</div><div class="line">		if(flag) &#123;//3</div><div class="line">			a = a + 5;//4</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有两个线程，分别调用initValue、updateValue这两个方法。</p>
<p>按照代码的顺序读，我们知道，当线程1调用完成initValue后，接着调用updateValue，那么代码3判断是成功的，然后a的最终值是6。</p>
<p>我们知道initValue方法的flag和a变量是<strong>没有依赖关系</strong>的，<strong>所以可能发生了指令重排</strong>，代码1和代码2的位置调换</p>
<pre><code>public void initValue() {
    flag = true;//1
    a = 1;//2
}
</code></pre><p>那么假设线程1执行完成代码1后，<strong>进行了线程切换</strong>，线程2获得了执行机会，线程2去执行updateValue，那么if判断通过，这个时候，a的值是0，那么执行a+5，那么a最终结果是5</p>
<p>很明显跟上面的结果是6不相等。所以就会产生线程不安全问题。</p>
<p><strong>解决方案，就是给flag，添加volatile修饰符，这样就能够通过给flag变量添加内存屏障的方式，禁止，指令重排。</strong></p>
<h2 id="你在哪些地方用到过volatile"><a href="#你在哪些地方用到过volatile" class="headerlink" title="你在哪些地方用到过volatile"></a>你在哪些地方用到过volatile</h2><p>1.首先我们知道 Atomic包下的类，大量使用到了volatile，例如AtomicInteger，AtomicReference等等。</p>
<p>2.单例模式DCL代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class SingletonDemo &#123;</div><div class="line"></div><div class="line">    private static volatile SingletonDemo instance=null;</div><div class="line">    private SingletonDemo()&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot;\t 构造方法&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 双重检测机制</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static SingletonDemo getInstance()&#123;</div><div class="line">        if(instance==null)&#123;</div><div class="line">            synchronized (SingletonDemo.class)&#123;</div><div class="line">                if(instance==null)&#123;</div><div class="line">                    instance=new SingletonDemo();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        for (int i = 1; i &lt;=10; i++) &#123;</div><div class="line">            new Thread(() -&gt;&#123;</div><div class="line">                SingletonDemo.getInstance();</div><div class="line">            &#125;,String.valueOf(i)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是最终的实现代码，可以解决多线程下单例请求问题。</p>
<p>但是你可能有个问题，为什么需要双重判断机制？<strong>问题一</strong></p>
<p>假设getInstance方法修改为：</p>
<pre><code>public static SingletonDemo getInstance(){
        synchronized (SingletonDemo.class){
            if(instance==null){
                instance=new SingletonDemo();
            }
        }
    return instance;
}
</code></pre><p>​    你觉得，有什么问题？那就是可能会引发多余的请求加锁操作，假设instance实例已经初始化了，但是每一次线程访问getInstance方法的时候，都会请求锁，这样就会耗费时间。所以我们需要在最外一层再包裹一个if判断。如果已经初始化，那么就直接返回。</p>
<p>那为什么最里层也要判断一下呢？<strong>问题二</strong></p>
<p>假设剔除最里层的if判断，最终代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static SingletonDemo getInstance()&#123;</div><div class="line">      if(instance==null)&#123;//代码1</div><div class="line">               //代码2</div><div class="line">          synchronized (SingletonDemo.class)&#123;//代码3</div><div class="line">                  instance=new SingletonDemo();//代码4</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      return instance;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>那么这样会有什么问题呢？</p>
<p>假设有 三个线程同时执行到了，代码二这个位置，那么开始执行代码3，只有一个线程能获取锁，然后实例化instance，然后返回instance，当前线程执行结束。这个时候，其他两个线程获得执行机会，也会执行到代码3，获取锁，然后又<strong>再次实例化instance</strong>。这个问题就出来，instance就不再是单例了。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>DCL(双端检锁) 机制不一定线程安全,原因是有指令重排的存在,加入volatile可以禁止指令重排。</p>
<p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 <code>instance == null</code> ，于是同时对 SingletonDemo.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 SingletonDemo实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 <code>instance == null</code> 时会发现，已经创建过 SingletonDemo实例了，所以线程 B 不会再创建一个 SingletonDemo实例。</p>
<p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p>
<ol>
<li>分配一块内存 M；</li>
<li>在内存 M 上初始化 SingletonDemo 对象；</li>
<li>然后 M 的地址赋值给 instance 变量。</li>
</ol>
<p>因为第2、第3步骤没有什么关系（<strong>没有相互依赖</strong>），那么是可以调换顺序的</p>
<p>但是实际上优化后的执行路径却是这样的：</p>
<ol>
<li>分配一块内存 M；</li>
<li>将 M 的地址赋值给 instance 变量；</li>
<li>最后在内存 M 上初始化 SingletonDemo对象。</li>
</ol>
<p>​    优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 <code>instance != null</code> ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就<strong>可能触发空指针异常。</strong></p>
<p><img src="/2020/03/09/java基础核心技术/image-20191218151354613.png" alt="image-20191218151354613"></p>
<ul>
<li><p>线程A进入第二个判空条件，进行初始化时，发生了时间片切换，即使没有释放锁，线程B刚要进入第一个判空条件时，发现条件不成立，直接返回instance引用，不用去获取锁。<strong>如果对instance进行volatile语义声明，就可以禁止指令重排序，避免该情况发生</strong>。</p>
<p>对于CPU缓存和内存的疑问，CPU缓存不存在于内存中的，它是一块比内存更小、读写速度更快的芯片，至于什么时候把数据从缓存写到内存，没有固定的时间，同样地，对于有volatile语义声明的变量，线程A执行完后会<strong>强制</strong>将值刷新到内存中，线程B进行相关操作时会强制重新把内存中的内容写入到自己的缓存，这就涉及到了volatile的写入屏障问题，当然也就是所谓<strong>happen-before问题</strong>。</p>
</li>
</ul>
<p>好的总结文档：<a href="https://dzone.com/articles/java-volatile-keyword-0" target="_blank" rel="external">https://dzone.com/articles/java-volatile-keyword-0</a></p>
<h2 id="MESI-cpu缓存一致性协议！！！重要！！！！保证了可见性"><a href="#MESI-cpu缓存一致性协议！！！重要！！！！保证了可见性" class="headerlink" title="MESI  cpu缓存一致性协议！！！重要！！！！保证了可见性"></a>MESI  cpu缓存一致性协议！！！重要！！！！保证了可见性</h2><p>MESI协议是一种基于无效的缓存一致性协议，他是基于硬件级别的优化</p>
<p>什么是基于无效呢？<br>    首先讲一下CPU和缓存的关系。计算机在数据处理或信号控制的时候，常与内存进行数据访问，但是内存和CPU的速度差别很大，所以会造成CPU资源浪费问题，为了解决两者的速度不匹配，所以在两者之间加了L1、L2、L3等缓存。在多核计算机中有多个CPU，每个CPU都有自己的缓存，所以就会造成缓存的数据不一致问题。<br>在早期解决缓存不一致是对<strong>总线使用LOCK（I/O总线）#锁</strong>，使得CPU访问某个变量的时候，其他CPU无法访问。但是这种<strong>效率很低</strong>。</p>
<p>MESI的主要思想：<strong>当CPU写数据时，如果该变量是共享数据，给其他CPU发送信号，使得其他的CPU中的该变量的缓存行无效。</strong></p>
<p>执行写操作的时候有两种策略，一种是write-back caches，另一种是write-through caches。<br>MESI支持write-back。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Write-through: write is done synchronously both to the cache and to the backing store.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Write-back (also called write-behind): initially, writing is done only to the cache. The write to the backing store is postponed until the modified content is about to be replaced by another cache block.</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>Write through就是直接写回主存</strong></p>
</blockquote>
<p><img src="/2020/03/09/java基础核心技术/writethrouth.png" style="zoom:30%;"></p>
<p>​    最简单的一种写入策略，叫作写直达（Write-Through）。在这个策略里，每一次数据都要写入到主内存里面。在写直达的策略里面，写入前，我们会先去判断数据是否已经在 Cache 里面了。如果数据已经在 Cache 里面了，我们先把数据写入更新到 Cache 里面，再写入到主内存里面；如果数据不在 Cache 里，我们就只更新主内存。</p>
<p>​    写直达的这个策略很直观，但是问题也很明显，那就是这个策略很慢。无论数据是不是在 Cache 里面，我们都需要把数据写到主内存里面。这个方式就有点儿像我们上面用 volatile 关键字，始终都要把数据同步到主内存里面。</p>
<blockquote>
<p><strong>Write back就是先标记不写回，等到使用的时候再写回主存。</strong></p>
</blockquote>
<p><img src="/2020/03/09/java基础核心技术/writeback.png" style="zoom:33%;"></p>
<p>这个时候，我们就想了，既然我们去读数据也是默认从 Cache 里面加载，能否不用把所有的写入都同步到主内存里呢？只写入 CPU Cache 里面是不是可以？</p>
<p>当然是可以的。在 CPU Cache 的写入策略里，还有一种策略就叫作写回（Write-Back）。这个策略里，我们不再是每次都把数据写入到主内存，而是只写到 CPU Cache 里。只有当 CPU Cache 里面的数据要被“替换”的时候，我们才把数据写入到主内存里面去。</p>
<p>写回策略的过程是这样的：如果发现我们要写入的数据，就在 CPU Cache 里面，那么我们就只是更新 CPU Cache 里面的数据。同时，我们会标记 CPU Cache 里的这个 Block 是脏（Dirty）的。所谓脏的，就是指这个时候，我们的 CPU Cache 里面的这个 Block 的数据，和主内存是不一致的。</p>
<p>如果我们发现，我们要写入的数据所对应的 Cache Block 里，放的是别的内存地址的数据，那么我们就要看一看，那个 Cache Block 里面的数据有没有被标记成脏的。如果是脏的话，我们要先把这个 Cache Block 里面的数据，写入到主内存里面。然后，再把当前要写入的数据，写入到 Cache 里，同时把 Cache Block 标记成脏的。如果 Block 里面的数据没有被标记成脏的，那么我们直接把数据写入到 Cache 里面，然后再把 Cache Block 标记成脏的就好了。</p>
<p>在用了写回这个策略之后，我们在加载内存数据到 Cache 里面的时候，也要多出一步同步脏 Cache 的动作。如果加载内存里面的数据到 Cache 的时候，发现 Cache Block 里面有脏标记，我们也要先把 Cache Block 里的数据写回到主内存，才能加载数据覆盖掉 Cache。</p>
<p>可以看到，在写回这个策略里，如果我们大量的操作，都能够命中缓存。那么大部分时间里，我们都不需要读写主内存，自然性能会比写直达的效果好很多。</p>
<p>​    然而，无论是写回还是写直达，其实都还没有解决我们在上面 volatile 程序示例中遇到的问题，也就是<strong>多个线程，或者是多个 CPU 核的缓存一致性的问题（就是如果两个线程都想写回内存，那么怎么解决这个问题）。这也就是我们在写入修改缓存后，需要解决的第二个问题。</strong></p>
<p>要解决这个问题，我们需要引入一个新的方法，叫作 MESI 协议。这是一个维护缓存一致性协议。这个协议不仅可以用在 CPU Cache 之间，也可以广泛用于各种需要使用缓存，同时缓存之间需要同步的场景下。</p>
<blockquote>
<p><strong>什么 叫缓存一致性问题</strong></p>
</blockquote>
<p>以下是多核cpu的cache缓存结构，一般而言多核 CPU 里的每一个 CPU 核，都有独立的属于自己的 L1 Cache 和 L2 Cache。多个 CPU 之间，只是共用 L3 Cache 和主内存。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318155625412.png" alt="image-20200318155625412"></p>
<p>那什么是缓存一致性呢？我们拿一个有两个核心的 CPU，来看一下。你可以看这里这张图，我们结合图来说。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318155816975.png" alt="image-20200318155816975"></p>
<p>​    比方说，iPhone 降价了，我们要把 iPhone 最新的价格更新到内存里。为了性能问题，它采用了上一讲我们说的写回策略，先把数据写入到 L2 Cache 里面，然后把 Cache Block 标记成脏的。这个时候，数据其实并没有被同步到 L3 Cache 或者主内存里。1 号核心希望在这个 Cache Block 要被交换出去的时候，数据才写入到主内存里。</p>
<p>​    如果我们的 CPU 只有 1 号核心这一个 CPU 核，那这其实是没有问题的。不过，我们旁边还有一个 2 号核心呢！这个时候，2 号核心尝试从内存里面去读取 iPhone 的价格，结果读到的是一个错误的价格。这是因为，iPhone 的价格刚刚被 1 号核心更新过。但是这个更新的信息，只出现在 1 号核心的 L2 Cache 里，而没有出现在 2 号核心的 L2 Cache 或者主内存里面。<strong>这个问题，就是所谓的缓存一致性问题，1 号核心和 2 号核心的缓存，在这个时候是不一致的。</strong></p>
<p>为了解决这个缓存不一致的问题，我们就需要有一种机制，来同步两个不同核心里面的缓存数据。那这样的机制需要满足什么条件呢？我觉得能够做到下面两点就是合理的。</p>
<p>第一点叫<strong>写传播</strong>（Write Propagation）。写传播是说，在一个 CPU 核心里，我们的 Cache 数据更新，必须能够传播到其他的对应节点的 Cache Line 里。</p>
<p>第二点叫<strong>事务的串行化</strong>（Transaction Serialization），事务串行化是说，我们在一个 CPU 核心里面的读取和写入，在其他的节点看起来，顺序是一样的。</p>
<p>第一点写传播很容易理解。既然我们数据写完了，自然要同步到其他 CPU 核的 Cache 里。但是第二点事务的串行化，可能没那么好理解，我这里仔细解释一下。</p>
<p>​    我们还拿刚才修改 iPhone 的价格来解释。这一次，我们找一个有 4 个核心的 CPU。1 号核心呢，先把 iPhone 的价格改成了 5000 块。差不多在同一个时间，2 号核心把 iPhone 的价格改成了 6000 块。这里两个修改，都会传播到 3 号核心和 4 号核心。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318160922524.png" alt="image-20200318160922524"></p>
<p><strong>我们发现，这样还是会导致，数据的不一致性。</strong></p>
<p>​    事实上，我们需要的是，<strong>从 1 号到 4 号核心</strong>，都能<strong>看到相同顺序的数据变化</strong>。比如说，都是先变成了 5000 块，再变成了 6000 块。这样，我们才能称之为实现了<strong>事务的串行化</strong>。</p>
<p>​    而在 CPU Cache 里做到事务串行化，需要做到两点，第一点是一个 CPU 核心对于数据的操作，需要同步通信给到其他 CPU 核心。第二点是，如果两个 CPU 核心里有同一个数据的 Cache，那么对于这个 Cache 数据的更新，需要有一个“锁”的概念。只有拿到了对应 Cache Block 的“锁”之后，才能进行对应的数据更新。接下来，我们就看看实现了这两个机制的 MESI 协议。</p>
<h3 id="总线嗅探机制和-MESI-协议"><a href="#总线嗅探机制和-MESI-协议" class="headerlink" title="总线嗅探机制和 MESI 协议"></a>总线嗅探机制和 MESI 协议</h3><p>​    要解决缓存一致性问题，首先要解决的是多个 CPU 核心之间的数据传播问题。最常见的一种解决方案呢，叫作<strong>总线嗅探</strong>（Bus Snooping）。这个名字听起来，你多半会很陌生，但是其实特很好理解。</p>
<p>​    这个策略，本质上就是把所有的读写请求都通过总线（Bus）广播给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。</p>
<p>​    总线本身就是一个特别适合广播进行数据传输的机制，所以总线嗅探这个办法也是我们日常使用的 Intel CPU 进行缓存一致性处理的解决方案。</p>
<p>​    <strong>基于总线嗅探机制，其实还可以分成很多种不同的缓存一致性协议</strong>。不过其中最常用的，就是今天我们要讲的 MESI 协议。和很多现代的 CPU 技术一样，MESI 协议也是在 Pentium 时代，被引入到 Intel CPU 中的。</p>
<p>​    <strong>MESI 协议</strong>，是一种叫作<strong>写失效</strong>（Write Invalidate）的协议。在写失效协议里，只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个 CPU 核心写入 Cache 之后，它会去广播一个“失效”请求告诉所有其他的 CPU 核心。其他的 CPU 核心，只是去判断自己是否也有一个“失效”版本的 Cache Block，然后把这个也标记成失效的就好了。</p>
<p>​    相对于写失效协议，还有一种叫作<strong>写广播</strong>（Write Broadcast）的协议。在那个协议里，一个写入请求广播到所有的 CPU 核心，同时更新各个核心里的 Cache。</p>
<p>​    写广播在实现上自然很简单，但是写广播需要占用更多的总线带宽。写失效只需要告诉其他的 CPU 核心，哪一个内存地址的缓存失效了，但是写广播还需要把对应的数据传输给其他 CPU 核心。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318162036721.png" alt="image-20200318162036721"></p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318162058308.png" alt="image-20200318162058308"></p>
<p>MESI 协议的由来呢，来自于我们对 Cache Line 的四个不同的标记，分别是：</p>
<ul>
<li>M：代表已修改（Modified）</li>
<li>E：代表独占（Exclusive）</li>
<li>S：代表共享（Shared）</li>
<li>I：代表已失效（Invalidated）</li>
</ul>
<p>我们先来看看“已修改”和“已失效”，这两个状态比较容易理解。所谓的“已修改”，就是我们上一讲所说的“脏”的 Cache Block。Cache Block 里面的内容我们已经更新过了，但是还没有写回到主内存里面。而所谓的“已失效“，自然是这个 Cache Block 里面的数据已经失效了，我们不可以相信这个 Cache Block 里面的数据。</p>
<p>然后，我们再来看“独占”和“共享”这两个状态。这就是 MESI 协议的精华所在了。无论是独占状态还是共享状态，缓存里面的数据都是“干净”的。这个“干净”，自然对应的是前面所说的“脏”的，也就是说，这个时候，<strong>Cache Block 里面的数据和主内存里面的数据是一致的。</strong></p>
<p>那么“独占”和“共享”这两个状态的差别在哪里呢？这个差别就在于，在独占状态下，对应的 Cache Line 只加载到了当前 CPU 核所拥有的 Cache 里。其他的 CPU 核，并没有加载对应的数据到自己的 Cache 里。这个时候，如果要向独占的 Cache Block 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。</p>
<p>在独占状态下的数据，如果收到了一个来自于总线的读取对应缓存的请求，它就会变成共享状态。这个共享状态是因为，这个时候，另外一个 CPU 核心，也把对应的 Cache Block，从内存里面加载到了自己的 Cache 里来。</p>
<p>而在共享状态下，因为同样的数据在多个 CPU 核心的 Cache 里都有。所以，当我们想要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的 Cache，都变成无效的状态，然后再更新当前 Cache 里面的数据。这个广播操作，一般叫作 RFO（Request For Ownership），<strong>也就是获取当前对应 Cache Block 数据的所有权</strong>。</p>
<p>​    有没有觉得这个操作有点儿像我们在多线程里面用到的读写锁。在共享状态下，大家都可以并行去读对应的数据。但是如果要写，我们就需要通过一个锁，获取当前写入位置的所有权。</p>
<p>​    整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把对应的状态机流转图放在了下面，你可以对照着<a href="https://zh.wikipedia.org/wiki/MESI协议" target="_blank" rel="external">Wikipedia 里面 MESI 的内容</a>，仔细研读一下。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318162644664.png" alt="image-20200318162644664"></p>
<p>好的文档：<a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="external">https://www.cnblogs.com/yanlong300/p/8986041.html</a></p>
<p>​                    <a href="https://www.jianshu.com/p/0e036fa7af2a" target="_blank" rel="external">https://www.jianshu.com/p/0e036fa7af2a</a></p>
<p>​                    <a href="https://www.cnblogs.com/ynyhl/p/12119690.html" target="_blank" rel="external">https://www.cnblogs.com/ynyhl/p/12119690.html</a> 不错</p>
<h2 id="面试中如果问到你对volatile的理解？"><a href="#面试中如果问到你对volatile的理解？" class="headerlink" title="面试中如果问到你对volatile的理解？"></a>面试中如果问到你对volatile的理解？</h2><p>那么首先你应该从内存模型，原子性，有序性，可见性的理解，然后才是volatile关键字的理解和他解决的问题。</p>
<p>，</p>
<h1 id="synchronized的对象头核心知识"><a href="#synchronized的对象头核心知识" class="headerlink" title="synchronized的对象头核心知识"></a>synchronized的对象头核心知识</h1><h2 id="synchronized-obj-到底锁的是什么-？-对象头"><a href="#synchronized-obj-到底锁的是什么-？-对象头" class="headerlink" title="synchronized(obj)到底锁的是什么 ？ - 对象头"></a>synchronized(obj)到底锁的是什么 ？ - 对象头</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (obj) &#123;</div><div class="line">	<span class="comment">///业务代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    synchronized到底锁的是整个业务代码块还是obj？</p>
<p>​    我们知道synchronized<strong>锁住的是obj对象</strong>，达到互斥的效果，<strong>那么在那里记录是那个线程锁住的呢？</strong>。而且synchronized是会锁升级的，<strong>那么在哪里记录这些锁的信息？哪里记录线程对obj对象上锁成功呢？</strong></p>
<p>​    <strong>举个例子，我们知道ReentrantLock的lock方法，是通过对state的cas操作标识是否上锁成功，state如果能从0设置成1，那么说明上锁成功，如果多次重入，那么state标识重入次数。</strong></p>
<p>​    <strong>我们发现单从这段代码<code>synchronized (obj)</code>，他并没有像lock 对象那样，有个成员属性state来做一些锁的标志和判断。而且synchronized 只是一个关键字，那么只有一种解释，那就是，加锁的信息，肯定是在obj对象里面保存着！！</strong></p>
<p>​    换句话说，我们的问题是：<strong>如果某个线程对obj对象加锁成功，那么他是怎么标记加锁成功的，到底修改了obj对象什么信息，来表示加锁成功？</strong></p>
<p>这里先说结论：<strong>加锁实际上是改变了对象的对象头！！</strong></p>
<h2 id="java对象的布局-计算对象大小"><a href="#java对象的布局-计算对象大小" class="headerlink" title="java对象的布局 - 计算对象大小"></a>java对象的布局 - 计算对象大小</h2><p>我们要了解对象头，那么首先首当其冲就要先了解一下对象的构成。首先我们可以确定，<strong>对象的属性</strong>肯定是构成对象的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span>  <span class="keyword">int</span> value;<span class="comment">//对象属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了对象属性之外，还有<strong>对象头</strong>和<strong>数据对齐</strong>两个模块。</p>
<p>也就是说对象是由：<strong>对象属性、对象头、数据对齐</strong>三个组件构成。</p>
<p>其中<strong>对象头是肯定存在的</strong>，但是<strong>对象属性和数据对齐却不一定存在</strong>。一个对象可以没有成员属性，这个我们是知道的，那么数据对齐是什么意思呢？我们首先要明确，java定义对象的大小时，规定，<strong>对象的字节大小必须是8的倍数</strong>。</p>
<p>​    <strong>那么数据对齐就是为了凑够8的倍数而来的。</strong>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span>  <span class="keyword">boolean</span> flag;<span class="comment">//1byte </span></div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;<span class="comment">//4个byte </span></div><div class="line">&#125;</div><div class="line"><span class="comment">//首先至于boolean到底占几个字节，java并没有明确规定，他说这个取决于jvm的实现，我这里假设是占1byte。</span></div></pre></td></tr></table></figure>
<p>​    那么上面student对象单从成员属性而言，一共是占了5个字节（<strong>这里先暂时不考虑对象头</strong>），那么很明显5不是8的倍数。所以需要<strong>补上3个字节</strong>，一共是8个字节，那么就是8的倍数。<strong>那么这里所说的补上3个字节，就是数据对齐模块的大小和作用。</strong></p>
<p>​    <strong>换言之，假设对象成员属性的大小本身就是8的倍数，那么数据对齐也就不存在了。</strong></p>
<p><strong>所以说，对象的布局中，至于对象头是固定存在的，其他两个是不一定存在。</strong></p>
<p><strong>也就是说，一个对象的大小，等于这三个组成的大小之和。</strong></p>
<blockquote>
<p><strong>怎么证明对象是由这三个部分组成？</strong></p>
</blockquote>
<p>接下来我们通过一个工具类来输出对象的信息，从而证明。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;0.10&lt;/version&gt;</div><div class="line">  &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>//计算对象大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span>  <span class="keyword">boolean</span> flag;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Obj obj  = <span class="keyword">new</span> Obj();</div><div class="line">        System.out.println( VM.current().details() );</div><div class="line">		System.out.println( ClassLayout.parseInstance(obj).toPrintable() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>Running 64-bit HotSpot VM.//<strong>此时表示是64位虚拟机上，因为32位虚拟机下面的输出会有不同</strong></p>
<p>Using compressed oop with 0-bit shift.、、</p>
<p>Using compressed klass with 3-bit shift.//<strong>开启指针压缩</strong></p>
<p>Objects are 8 bytes aligned.</p>
<p>Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</p>
<p>Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</p>
<p>com.kingge.obj.Obj object internals:<br> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE<br>      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      8     4           (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)<br>     12     4       int Obj.value                                 0<br>     16     1   boolean Obj.flag                                  false<br>     17     7           (loss due to the next object alignment)<br><strong>Instance size: 24 bytes</strong><br>Space losses: 0 bytes internal + 7 bytes external = 7 bytes total</p>
<p>​    <strong>可以看到一共是24个字节，其中对象头是12个字节，两个成员变量一共是5个字节，那么因为加起来17个字节，并不是8的倍数，那么需要数据对齐，于是加上7个字节的数据对齐。</strong></p>
<p>​    <strong>从而证明了，我们那上面所说的结论是正确的。</strong></p>
<p>假设对象修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Obj obj  = <span class="keyword">new</span> Obj();</div><div class="line">		System.out.println( ClassLayout.parseInstance(obj).toPrintable() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>com.kingge.obj.Obj object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      8     4        (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)<br>     12     4    int Obj.value                                 0<br><strong>Instance size: 16 bytes</strong><br>Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</p>
<p>​    你会发现，<strong>数据对齐，没有了</strong>？那是因为，刚好<strong>属性+对象头一共是16个字节，是8的倍数</strong>。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>对象是由：对象头（大小固定，64位虚拟机下一共占12字节），成员属性（大小根据数据类型决定），数据对齐（不一定存在）。</p>
<p>那么对象的大小就是由着三个部分组成。</p>
<h2 id="对象头的构成"><a href="#对象头的构成" class="headerlink" title="对象头的构成"></a>对象头的构成</h2><p><strong>在上面的分析中，我们得到64位虚拟机下，对象头的大小是12字节，一共是96位。</strong></p>
<p>我们通过查看一下官方文档，获得对象头构成：</p>
<p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="external">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">object header</div><div class="line">Common structure at the beginning of every GC-managed heap object. (Every oop points to an object header.) Includes fundamental information about the heap object&apos;s layout, type, GC state, synchronization state, and identity hash code. Consists of two words. In arrays it is immediately followed by a length field. Note that both Java objects and VM-internal objects have a common object header format.</div><div class="line"></div><div class="line"> ----- 翻译来自有道，可能不准确，但是可以知道大概意思----</div><div class="line"> </div><div class="line">每个gc管理的堆对象开头的公共结构。(每个oop都指向一个对象标头。)包括堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。由两个词组成。在数组中，它后面紧跟着一个长度字段。注意，Java对象和vm内部对象都有一个通用的对象头格式。</div></pre></td></tr></table></figure>
<p>​    也就是说：对象头包含了这些信息，<strong>堆对象的布局</strong>、<strong>类型</strong>、<strong>GC状态</strong>、<strong>同步状态</strong>和<strong>标识哈希码</strong>的基本信息。我么终于发现了，在文章最开始提出的问题的答案，那就是在那里记录了加锁的信息？就是这里的同步状态，而且我们发现，对象头还保存了对象hashcode的值。</p>
<p>   我们知道了对象头包含的信息，但是并没有说明对象头由哪些部分组成？</p>
<p>​    上面的翻译已经说了 Consists of two words。也就是<strong>对象头由两个部分组成</strong>：<strong>klass pointer和mark word</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">klass pointer - 保存了类的指针，也就是当前对象是基于那个Class创建的。</div><div class="line">The second word of every object header. Points to another object (a metaobject) which describes the layout and behavior of the original object. For Java objects, the &quot;klass&quot; contains a C++ style &quot;vtable&quot;.</div><div class="line"></div><div class="line">mark word</div><div class="line">The first word of every object header. Usually a set of bitfields including synchronization state and identity hash code. May also be a pointer (with characteristic low bit encoding) to synchronization related information. During GC, may contain GC state bits.</div></pre></td></tr></table></figure>
<p>那么markword他的结构是怎么样的呢？我们通过看源码的形式查看的他的结构</p>
<p><strong>openjdk\hotspot\src\share\vm\oops\markOop.hpp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// The markOop describes the header of an object.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Note that the mark is not a real oop but just a word.</span></div><div class="line"><span class="comment">// It is placed in the oop hierarchy for historical reasons.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">////////////////////这个位置就说明了，在32位和64位环境下，markword的结构、、、、、、</span></div><div class="line"><span class="comment">//  32 bits:</span></div><div class="line"><span class="comment">//  --------</span></div><div class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></div><div class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></div><div class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></div><div class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  64 bits:</span></div><div class="line"><span class="comment">//  --------</span></div><div class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></div><div class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></div><div class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></div><div class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></div><div class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></div><div class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></div><div class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  - hash contains the identity hash value: largest value is</span></div><div class="line"><span class="comment">//    31 bits, see os::random().  Also, 64-bit vm's require</span></div><div class="line"><span class="comment">//    a hash value no bigger than 32 bits because they will not</span></div><div class="line"><span class="comment">//    properly generate a mask larger than that: see library_call.cpp</span></div><div class="line"><span class="comment">//    and c1_CodePatterns_sparc.cpp.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  - the biased lock pattern is used to bias a lock toward a given</span></div><div class="line"><span class="comment">//    thread. When this pattern is set in the low three bits, the lock</span></div><div class="line"><span class="comment">//    is either biased toward a given thread or "anonymously" biased,</span></div><div class="line"><span class="comment">//    indicating that it is possible for it to be biased. When the</span></div><div class="line"><span class="comment">//    lock is biased toward a given thread, locking and unlocking can</span></div><div class="line"><span class="comment">//    be performed by that thread without using atomic operations.</span></div><div class="line"><span class="comment">//    When a lock's bias is revoked, it reverts back to the normal</span></div><div class="line"><span class="comment">//    locking scheme described below.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    Note that we are overloading the meaning of the "unlocked" state</span></div><div class="line"><span class="comment">//    of the header. Because we steal a bit from the age we can</span></div><div class="line"><span class="comment">//    guarantee that the bias pattern will never be seen for a truly</span></div><div class="line"><span class="comment">//    unlocked object.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    Note also that the biased state contains the age bits normally</span></div><div class="line"><span class="comment">//    contained in the object header. Large increases in scavenge</span></div><div class="line"><span class="comment">//    times were seen when these bits were absent and an arbitrary age</span></div><div class="line"><span class="comment">//    assigned to all biased objects, because they tended to consume a</span></div><div class="line"><span class="comment">//    significant fraction of the eden semispaces and were not</span></div><div class="line"><span class="comment">//    promoted promptly, causing an increase in the amount of copying</span></div><div class="line"><span class="comment">//    performed. The runtime system aligns all JavaThread* pointers to</span></div><div class="line"><span class="comment">//    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))</span></div><div class="line"><span class="comment">//    to make room for the age bits &amp; the epoch bits (used in support of</span></div><div class="line"><span class="comment">//    biased locking), and for the CMS "freeness" bit in the 64bVM (+COOPs).</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread</span></div><div class="line"><span class="comment">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  - the two lock bits are used to describe three states: locked/unlocked and monitor.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    [ptr             | 00]  locked             ptr points to real header on stack</span></div><div class="line"><span class="comment">//    [header      | 0 | 01]  unlocked           regular object header</span></div><div class="line"><span class="comment">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span></div><div class="line"><span class="comment">//    [ptr             | 11]  marked             used by markSweep to mark an object</span></div><div class="line"><span class="comment">//                                               not valid at any other time</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//    We assume that stack/thread pointers have the lowest two bits cleared.</span></div></pre></td></tr></table></figure>
<p><strong>可以得到，markword的构成是：unused:25 hash:31 –&gt;| unused:1   age:4    biased_lock:1 lock:2</strong></p>
<blockquote>
<p>   <strong>特殊提醒，我们在JVM中讲到，为什么当对象年龄达到15的时候，才会进入老年代。那么15这个数字是怎么得来的，就是这里的age：4，他占四位，四位能够表达的最大数是15，这就是-XX:MaxTenuringThreshold选项最大值为15的原因</strong></p>
</blockquote>
<p>​    <strong>也就是25+31+1+4+1+2 == 64bit，也就是说在64位对象头中，markword占64位，那么也就意味着，对象类型指针kclass pointer占32bit（96-64）</strong></p>
<p><strong>特殊提醒！！！！</strong>，有些时候我们发现kclass pointer的大小是：64位，也就是需要8个字节，并不是上面所说的需要32位。这两种说法都是对的，因为jvm默认开启了指针压缩，会把kclass pointer压缩成4个字节。如果没有卡其指针压缩，那么就是8个字节。</p>
<p>那么怎么知道jvm 是否开启了指针压缩呢？<code>System.out.println( VM.current().details() );</code> 通过这个命令就可以输出，jvm当前信息。</p>
<h3 id="检验kclass-pointer未压缩前大小是否是8个字节"><a href="#检验kclass-pointer未压缩前大小是否是8个字节" class="headerlink" title="检验kclass pointer未压缩前大小是否是8个字节"></a>检验kclass pointer未压缩前大小是否是8个字节</h3><p>测试例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Obj obj  = <span class="keyword">new</span> Obj();</div><div class="line">		System.out.println( VM.current().details() );</div><div class="line">		System.out.println( ClassLayout.parseInstance(obj).toPrintable() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Running 64-bit HotSpot VM.</div><div class="line"># Using compressed oop with 0-bit shift.</div><div class="line"># Using compressed klass with 3-bit shift.//默认开启指针压缩</div><div class="line"># Objects are 8 bytes aligned.</div><div class="line"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</div><div class="line"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</div><div class="line"></div><div class="line">com.kingge.obj.Obj object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)</div><div class="line">     12     4    int Obj.value                                 0</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</div></pre></td></tr></table></figure>
<p>可以看到输出：# Using compressed klass with 3-bit shift.<strong>//表示默认开启指针压缩</strong></p>
<p><strong>此时，对象头大小是12字节，其中markword占8个字节，对象指针kclass pointer 占4个字节。</strong></p>
<blockquote>
<p><strong>下面我们去掉指针压缩，再次运行。</strong></p>
</blockquote>
<p>使用jvm参数去掉指针压缩： <code>-XX:-UseCompressedOops</code> 。</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Running 64-bit HotSpot VM.</div><div class="line"># Objects are 8 bytes aligned.</div><div class="line"># Field sizes by type: 8, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</div><div class="line"># Array element sizes: 8, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</div><div class="line"></div><div class="line">com.kingge.obj.Obj object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           20 04 b1 17 (00100000 00000100 10110001 00010111) (397476896)</div><div class="line">     12     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">     16     4    int Obj.value                                 0</div><div class="line">     20     4        (loss due to the next object alignment)</div><div class="line">Instance size: 24 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div></pre></td></tr></table></figure>
<p>我们发现，此时，<strong>对象头大小是16字节，其中markword固定占8个字节，那么很明显剩下的8个字节就是对象指针kclass pointer 的大小。</strong></p>
<p><strong>得证！！！</strong>未开启压缩的情况下，对象指针在64位虚拟机下，占8个字节。</p>
<h2 id="markword构成"><a href="#markword构成" class="headerlink" title="markword构成"></a>markword构成</h2><p><strong>我们知道markword在64位虚拟机下，是占8个字节。</strong></p>
<p>首先我们要知道，对象一共有几个状态？</p>
<ul>
<li>初始状态 - 刚new出来</li>
<li>成为偏向锁</li>
<li>成为轻量级锁</li>
<li>成为重量级锁</li>
<li>GC标记-表示可垃圾回收</li>
</ul>
<p>再来看一下 markword结构：</p>
<blockquote>
<p> <strong>unused:25 hash:31 –&gt;| unused:1   age:4    biased_lock:1 lock:2</strong> </p>
<p>​                                           </p>
</blockquote>
<p>​    从上面可以看到，锁标记(lock)占了2位，那么两位的二级制，只有四种可能，00，01,10,11.那么他怎么表示上面这五种状态呢？</p>
<p>​    通过biased_lock偏向锁的1个标志位，来表示，对象的五种状态，右下图可见。</p>
<p>​    <strong>偏向锁和无锁状态表示为同一个状态（lock都是01），然后根据图中偏向锁的标识再去标识是无锁还是偏向锁状态；</strong></p>
<p><img src="/2020/03/09/java基础核心技术/820029-20190807082621811-2089453748.png" alt="img"></p>
<p>下面我们拉分析一下在初始状态下，对象的对象头的markword信息。</p>
<p>com.kingge.obj.Obj object internals:<br> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)<br>      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)<br>      8     4        (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)<br>     12     4    int Obj.value                                 0<br>Instance size: 16 bytes<br>Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</p>
<p><strong>从上面的图再根据下面输出的对象结构信息，我们可以得出，markword 一共是64位，八个字节。剩下的4个字节就是kclass pointer（也就是Obj.class的指针）</strong></p>
<p>markword也就是这64位：</p>
<p> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE<br>      0     4        (object header)                           01 00 00 00 (<strong>00000001 00000000 00000000 00000000</strong>) (1)<br>      4     4        (object header)                           00 00 00 00 (<strong>00000000 00000000 00000000 00000000</strong>) (0)<br>      8     4        (object header)                           05 c0 00 20 (00000101 11000000 00000000 00100000) </p>
<p><strong>那么其中这8个字节，就是存储的markword的信息。</strong></p>
<p>  0     4        (object header)                           01 00 00 00 (00000001 <strong>00000000 00000000 00000000</strong>) (1)<br>  4     4        (object header)                           00 00 00 00 (<strong>00000000 00000000 00000000 00000000</strong>) (0)</p>
<p>剩下的未标黑色的8位保存的就是：<strong>unused:1   age:4    biased_lock:1 lock:2</strong> </p>
<p>​    这八位等于00000001，那么正好跟，初始化状态的对象的状态是一样的。前六位都是0，lock等于01表示正常（因为上面的代码中obj对象是刚new出来的。unuseed等于0，那么gc年龄肯定是0，也就是age的四位都是0，biaed_lock也是0，lock等于01）</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200402164715040.png" alt="image-20200402164715040"></p>
<blockquote>
<p><strong>那为什么在上面输出的31位的hashcode都是0？ </strong></p>
</blockquote>
<p>原因是没有调用对象的hashcode方法生成hashcode。</p>
<p>测试代码修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Obj &#123;</div><div class="line"></div><div class="line">    public  int value;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">		Obj obj  = new Obj();</div><div class="line">		System.out.println( VM.current().details() );</div><div class="line">		System.out.println( Integer.toHexString(obj.hashCode()));//多加了这一行，获取对象hashcode，以16进制输出。</div><div class="line">		System.out.println( ClassLayout.parseInstance(obj).toPrintable() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">obj对象hashcode：37bba400</div><div class="line">com.kingge.obj.Obj object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION          VALUE</div><div class="line">   0     4       (object header)         01 00 a4 bb (00000001 00000000 10100100 10111011) (-1146879999)</div><div class="line">      4     4        (object header)     37 00 00 00 (00110111 00000000 00000000 00000000) (55)</div><div class="line">      8     4        (object header)     05 c0 00 20 (00000101 11000000 00000000 00100000) (536920069)</div><div class="line">     12     4    int Obj.value                                 0</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</div></pre></td></tr></table></figure>
<p>你会发现，输出的对象结构信息中，<strong>hashcode的值，已经存在</strong>。且为：37bba400。</p>
<p>跟上面的value字段输出一致。</p>
<h3 id="模拟偏向锁和轻量级锁对象头"><a href="#模拟偏向锁和轻量级锁对象头" class="headerlink" title="模拟偏向锁和轻量级锁对象头"></a>模拟偏向锁和轻量级锁对象头</h3><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> value;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">// Thread.sleep(5000); 放开这一行，那么输出的就是偏向锁，或者设置-XX:BiasedLockingStartupDelay=0</span></div><div class="line">		 Obj obj  = <span class="keyword">new</span> Obj();</div><div class="line">		System.out.println(<span class="string">"befor lock"</span>);</div><div class="line">		System.out.println(ClassLayout.parseInstance(obj).toPrintable());</div><div class="line"></div><div class="line">	        <span class="keyword">synchronized</span> (obj)&#123;</div><div class="line">	        		 System.out.println(<span class="string">"lock ing"</span>);</div><div class="line">	        		 System.out.println(ClassLayout.parseInstance(obj).toPrintable());</div><div class="line">	        &#125;</div><div class="line">	        System.out.println(<span class="string">"after lock"</span>);</div><div class="line">	        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200402173402270.png" alt="image-20200402173402270"></p>
<p>如果把上面的 // Thread.sleep(5000); 注释放开或者设置-XX:BiasedLockingStartupDelay=0，那么此刻输出的是偏向锁的信息，前八位是：0 0000 1 01</p>
<h4 id="为什么不是偏向锁"><a href="#为什么不是偏向锁" class="headerlink" title="为什么不是偏向锁"></a>为什么不是偏向锁</h4><p><strong>为什么呢？从上面代码看，只有一个main线程在获取锁啊，应该是偏向锁才对啊？</strong></p>
<p>经过翻hotspot源码发现：</p>
<p>路径： <a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/globals.hpp" target="_blank" rel="external">http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/globals.hpp</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">product(bool, UseBiasedLocking, <span class="keyword">true</span>,                   </div><div class="line"></div><div class="line">    <span class="string">"Enable biased locking in JVM"</span>)                 </div><div class="line"></div><div class="line">                          </div><div class="line"></div><div class="line">product(intx, BiasedLockingStartupDelay, <span class="number">4000</span>,              </div><div class="line"></div><div class="line">    <span class="string">"Number of milliseconds to wait before enabling biased locking"</span>) </div><div class="line"></div><div class="line">    range(<span class="number">0</span>, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) </div><div class="line"></div><div class="line">    constraint(BiasedLockingStartupDelayFunc,AfterErgo)       </div><div class="line"></div><div class="line">BiasedLockingStartupDelay, <span class="number">4000</span>  <span class="comment">//偏向锁延迟4000ms启动</span></div><div class="line"></div><div class="line"><span class="comment">//所以我们需要让main线程jvm把偏向锁的初始化工作准备好，后再去争抢锁。</span></div></pre></td></tr></table></figure>
<p><strong>想想为什么偏向锁会延迟？</strong></p>
<p>我们来看官方解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> BiasedLocking::init() &#123;</div><div class="line">  <span class="comment">// If biased locking is enabled, schedule a task to fire a few</span></div><div class="line">  <span class="comment">// seconds into the run which turns on biased locking for all</span></div><div class="line">  <span class="comment">// currently loaded classes as well as future ones. This is a</span></div><div class="line">  <span class="comment">// workaround for startup time regressions due to a large number of</span></div><div class="line">  <span class="comment">// safepoints being taken during VM startup for bias revocation.</span></div><div class="line">  <span class="comment">// Ideally we would have a lower cost for individual bias revocation</span></div><div class="line">  <span class="comment">// and not need a mechanism like this.</span></div><div class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</div><div class="line">    <span class="keyword">if</span> (BiasedLockingStartupDelay &gt; <span class="number">0</span>) &#123;</div><div class="line">      EnableBiasedLockingTask* task = <span class="keyword">new</span> EnableBiasedLockingTask(BiasedLockingStartupDelay);</div><div class="line">      task-&gt;enroll();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="function">VM_EnableBiasedLocking <span class="title">op</span><span class="params">(<span class="keyword">false</span>)</span></span>;</div><div class="line">      VMThread::execute(&amp;op);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">注意看上面的注释和代码</div></pre></td></tr></table></figure>
<p>英文大概翻译为： <strong>当jvm启动记载资源的时候，初始化的对象加偏向锁会耗费资源，减少大量偏向锁撤销的成本（jvm的偏向锁的优化）</strong></p>
<p>这就解释了加上睡眠5000ms，偏向锁就会出现的原因；</p>
<p>​    为了方便我们测试我们可以直接通过修改jvm的参数来禁止偏向锁延迟（不用在代码睡眠了）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</div></pre></td></tr></table></figure>
<p>​    <strong>注意：这块严谨来说，在jdk 1.6之后，关于使用偏向锁和轻量级锁，jvm是有优化的，在没有禁止偏向锁延迟的情况下，使用的是轻量级锁；禁止偏向锁延迟的话，使用的是偏向锁；</strong></p>
<p>​    <strong>总而言之：因为jvm 在启动的时候需要加载资源，这些对象加上偏向锁没有任何意义啊，减少了大量偏向锁撤销的成本；所以默认就把偏向锁延迟了4000ms；</strong></p>
<p>如果还不能确定是否延迟，那么我们可以通过查看jvm默认启动参数来查看：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200403105339055.png" alt="image-20200403105339055"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ jinfo -flag BiasedLockingStartupDelay 16212</div><div class="line">-XX:BiasedLockingStartupDelay=4000</div><div class="line"></div><div class="line">可以发现启动的jvm。BiasedLockingStartupDelay默认是4000</div></pre></td></tr></table></figure>
<h3 id="比较偏向锁和轻量级锁性能"><a href="#比较偏向锁和轻量级锁性能" class="headerlink" title="比较偏向锁和轻量级锁性能"></a>比较偏向锁和轻量级锁性能</h3><p>测试轻量级锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj1</span> </span>&#123;</div><div class="line"></div><div class="line">	 	<span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span></span>&#123;</div><div class="line">	        i++;</div><div class="line">	    &#125;</div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">	        </div><div class="line">	    	Obj1 obj1 = <span class="keyword">new</span> Obj1();</div><div class="line">	        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">	        <span class="comment">//调用同步方法1000000000L 来计算1000000000L的++，对比偏向锁和轻量级锁的性能</span></div><div class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">1000000000L</span>;i++)&#123;</div><div class="line">	        	obj1.parse();</div><div class="line">	        &#125;</div><div class="line">	        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">	        System.out.println(String.format(<span class="string">"%sms"</span>, end - start));<span class="comment">//轻量级锁：21743ms</span></div><div class="line">	         																						   <span class="comment">//偏向锁：1801ms</span></div><div class="line">	        <span class="comment">//可以发现，偏向锁比轻量级锁快了12倍左右</span></div><div class="line">	    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试偏向锁，只需要运行的时候指定：-XX:BiasedLockingStartupDelay=0，表示不需要延迟设置偏向锁。</p>
<p>​    为什么呢？我们知道偏向锁是支持重入的，意思就是，假设下次获取锁的线程还是之前的线程，那么不需要在申请锁，只需要增加重入次数即可。这个假设是只有一个线程 需要获取锁的情况下。</p>
<p>​    但是如果存在多个线程获取锁，那么锁会升级，升级为轻量级锁，<strong>因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可</strong>。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> com.kingge.obj;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHeavyLock</span> </span>&#123;</div><div class="line"></div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		 ObjLock objLock = <span class="keyword">new</span> ObjLock();</div><div class="line">		 System.out.println(<span class="string">"befor lock"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());<span class="comment">//无锁</span></div><div class="line">		 </div><div class="line">		 Thread thread = <span class="keyword">new</span> Thread( () -&gt; &#123;</div><div class="line">			 <span class="keyword">synchronized</span> (objLock) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					TimeUnit.SECONDS.sleep(<span class="number">5</span>);<span class="comment">//休息五秒的目的是，让sysn也同时去获取锁，让锁升级</span></div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		 &#125; );</div><div class="line">		 thread.start();</div><div class="line">		 System.out.println(<span class="string">"thread locking"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());<span class="comment">//轻量级锁</span></div><div class="line">		 </div><div class="line">		 sysn(objLock);<span class="comment">//main线程请求锁，这个时候轻量级锁已经存在，那么锁升级</span></div><div class="line">		 </div><div class="line">		 System.out.println(<span class="string">"after  main  lock"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());<span class="comment">//重量级锁</span></div><div class="line">		 </div><div class="line">		 System.gc();</div><div class="line">		 System.out.println(<span class="string">"after  gc"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());<span class="comment">//无锁</span></div><div class="line">		 </div><div class="line">	&#125;</div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysn</span><span class="params">(ObjLock objLock)</span> </span>&#123;</div><div class="line">		 <span class="keyword">synchronized</span> (objLock) &#123;</div><div class="line">		System.out.println(<span class="string">"main lock ing"</span>);</div><div class="line">		 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	 </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjLock</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">befor lock</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div><div class="line"></div><div class="line">thread locking</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           60 f2 c9 1a (01100000 11110010 11001001 00011010) (449442400)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div><div class="line"></div><div class="line">main lock ing</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           4a 3c 4a 03 (01001010 00111100 01001010 00000011) (55196746)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div><div class="line"></div><div class="line">after  main  lock</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           4a 3c 4a 03 (01001010 00111100 01001010 00000011) (55196746)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div><div class="line"></div><div class="line">after  gc</div><div class="line">com.kingge.obj.ObjLock object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           09 00 00 00 (00001001 00000000 00000000 00000000) (9)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           43 c0 00 20 (01000011 11000000 00000000 00100000) (536920131)</div><div class="line">     12     4        (loss due to the next object alignment)</div><div class="line">Instance size: 16 bytes</div><div class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</div></pre></td></tr></table></figure>
<p>分析锁的前八位：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">befor lock</div><div class="line">0 0000 0 01  //无锁，gc年龄是0</div><div class="line"> </div><div class="line">thread locking</div><div class="line">0 1100 0 00  //轻量级锁，gc年龄是12，说明ObjLock对象在survivor倒腾了12次</div><div class="line"> </div><div class="line">main lock ing</div><div class="line">0 1001 0 10  //重量级锁</div><div class="line"> </div><div class="line">after  main  lock</div><div class="line">0 1001 0 10 //重量级锁？？？？</div><div class="line"> </div><div class="line">after gc</div><div class="line">0 0001 0 01 //gc回收变无锁（就会发现gc回收过一次之后对象由最初刚开始的 0000 变成了 0001 年龄+1了）</div></pre></td></tr></table></figure>
<p>​    上面的分析应该很容易看得懂，那么我们注意，<strong>打问号的地方</strong>。按道理main线程执行完sync，也就意味着thread线程在这之前也已经释放了锁（不然sync方法也无法得到锁执行），objLock此刻是没有线程去锁住才对，那么应该是是无锁状态，那为什么还是输出的是重量级锁的信息呢？</p>
<p>​    <strong>是因为重量级锁释放会有延迟，可以在sync()方法中加入睡眠。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> public static void sysn(ObjLock objLock) throws InterruptedException &#123;</div><div class="line">	 synchronized (objLock) &#123;</div><div class="line">	System.out.println(&quot;main lock ing&quot;);</div><div class="line">	 System.out.println(ClassLayout.parseInstance(objLock).toPrintable());</div><div class="line">	&#125;</div><div class="line">	 Thread.sleep(5000);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//此时再看输出，你会发现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">after  main  lock</div><div class="line">0 0000 0 01  //已经是无锁状态</div></pre></td></tr></table></figure>
<h3 id="偏向锁的epoch作用"><a href="#偏向锁的epoch作用" class="headerlink" title="偏向锁的epoch作用"></a>偏向锁的epoch作用</h3><p><strong>这里的</strong> <strong>epoch 值是一个什么概念呢？</strong></p>
<ul>
<li>我们先从偏向锁的撤销讲起。当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时（而且 epoch 值相等，如若不等，那么当前线程可以将该锁重偏向至自己），Java 虚拟机需要撤销该偏向锁。这个撤销过程非常麻烦，它要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁；</li>
<li>如果某一类锁对象的总撤销数超过了一个阈值（对应 jvm参数 <strong>-XX:BiasedLockingBulkRebiasThreshold，默认为 20</strong>），那么 Java 虚拟机会宣布这个类的偏向锁失效；（这里说的就是<strong>批量重偏向</strong>）</li>
</ul>
<p>​    JVM源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \</div><div class="line">        &quot;Threshold of number of revocations per type to try to &quot;          \</div><div class="line">        &quot;rebias all objects in the heap of that type&quot;)                    \</div><div class="line">        range(0, max_intx)                                                \</div><div class="line">        constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \</div></pre></td></tr></table></figure>
<ul>
<li>具体的做法便是在每个类中维护一个 epoch 值，你可以理解为第几代偏向锁。当设置偏向锁时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中；</li>
<li>在宣布某个类的偏向锁失效时，Java 虚拟机实则将该类的 epoch 值加 1，表示之前那一代的偏向锁已经失效。而新设置的偏向锁则需要复制新的 epoch 值；</li>
<li>为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态；</li>
<li>如果总撤销数超过另一个阈值（对应 jvm 参数 <strong>-XX:BiasedLockingBulkRevokeThreshold，默认值为 40</strong>），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁(这里说的就是<strong>偏向批量撤销</strong>)</li>
</ul>
<p>​    </p>
<p>JVM源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \</div><div class="line">        &quot;Threshold of number of revocations per type to permanently &quot;     \</div><div class="line">        &quot;revoke biases of all objects in the heap of that type&quot;)          \</div><div class="line">        range(0, max_intx)                                                \</div><div class="line">        constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)</div></pre></td></tr></table></figure>
<p>　　</p>
<h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><p>​    所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级：</p>
<ul>
<li>当没有竞争出现时，默认会使用偏向锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏向锁可以降低无竞争开销。</li>
<li>如果有另外的线程试图锁定某个已经被偏向过的对象，JVM 就需要撤销（revoke）偏向锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用轻量级锁；否则，进一步升级为重量级锁</li>
</ul>
<p><strong>膨胀过程的实现比较复杂，大概实现过程如下：</strong></p>
<p>1、整个膨胀过程在自旋下完成；</p>
<p>2、mark-&gt;has_monitor()方法判断当前是否为重量级锁，即Mark Word的锁标识位为 10，如果当前状态为重量级锁，执行步骤（3），否则执行步骤（4）；</p>
<p>3、mark-&gt;monitor()方法获取指向ObjectMonitor的指针，并返回，说明膨胀过程已经完成；</p>
<p>4、如果当前锁处于膨胀中，说明该锁正在被其它线程执行膨胀操作，则当前线程就进行自旋等待锁膨胀完成，这里需要注意一点，虽然是自旋操作，但不会一直占用cpu资源，每隔一段时间会通过os::NakedYield方法放弃cpu资源，或通过park方法挂起；如果其他线程完成锁的膨胀操作，则退出自旋并返回；</p>
<p>5、如果当前是轻量级锁状态，即锁标识位为 00，膨胀过程如下：</p>
<ul>
<li>通过omAlloc方法，获取一个可用的ObjectMonitor monitor，并重置monitor数据；</li>
<li>通过CAS尝试将Mark Word设置为markOopDesc:INFLATING，标识当前锁正在膨胀中，如果CAS失败，说明同一时刻其它线程已经将Mark Word设置为markOopDesc:INFLATING，当前线程进行自旋等待膨胀完成；</li>
<li>如果CAS成功，设置monitor的各个字段：_header、_owner和_object等，并返回；</li>
</ul>
<p>6、如果是无锁，重置监视器值；</p>
<h2 id="好的相关文档"><a href="#好的相关文档" class="headerlink" title="好的相关文档"></a>好的相关文档</h2><p><a href="https://www.cnblogs.com/JonaLin/p/11571482.html#autoid-2-0-0" target="_blank" rel="external">https://www.cnblogs.com/JonaLin/p/11571482.html#autoid-2-0-0</a> 非常推荐！！！！！</p>
<p><a href="https://www.cnblogs.com/yrjns/p/12152975.html" target="_blank" rel="external">https://www.cnblogs.com/yrjns/p/12152975.html</a></p>
<h2 id="题外话：Java中boolean类型占几个字节，你知道吗？"><a href="#题外话：Java中boolean类型占几个字节，你知道吗？" class="headerlink" title="题外话：Java中boolean类型占几个字节，你知道吗？"></a>题外话：Java中boolean类型占几个字节，你知道吗？</h2><p><a href="https://blog.csdn.net/amoscn/article/details/97377833" target="_blank" rel="external">https://blog.csdn.net/amoscn/article/details/97377833</a></p>
<h1 id="cas是什么-无锁并发安全实现-轻量级锁"><a href="#cas是什么-无锁并发安全实现-轻量级锁" class="headerlink" title="cas是什么 - 无锁并发安全实现 - 轻量级锁"></a>cas是什么 - 无锁并发安全实现 - 轻量级锁</h1><blockquote>
<p><strong>概念</strong></p>
</blockquote>
<p>他就是比较并交换的缩写 - compareAndSet。他的作用就是通过比较期望值，来判断本次操作能否成功。</p>
<p><strong>也就是说比较当前工作内存的值和主内存中的值，如果相等，那么执行相应的逻辑操作（临界区操作），如果不相等，那么一直比较到相同为止。</strong></p>
<p>那么他究竟是什么呢？</p>
<p>我们来回忆一下AtomicInteger的compareAndSet方法。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200120093410478.png" alt="image-20200120093410478"></p>
<p>第一个参数和第二个参数是相辅相成的，只有在第一个参数比较成功后，才能够成功赋值第二个参数的值。</p>
<p>那么第一个参数是跟谁比较呢？<strong>答案是，跟主内存中目前的值比较。</strong></p>
<p>​    重要提示：<strong>首先我们要明确一点，那就是，线程对数据的操作，都是先把数据从主内存（电脑内存），读取出来，然后load自己的线程栈中，再进行自己的运算逻辑，然后线程结束后，再把新值写回主内存。（那么可想而知，多线程的情况下，必然会发生线程不安全问题，因为每个线程把自己的处理结果写回主内存的时机不同，导致结果出现各种变化）</strong></p>
<blockquote>
<p><strong>接下来演示使用cas的例子：</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        AtomicInteger atomicInteger = new AtomicInteger(5);//在主内存中，设置共享变量的值为5</div><div class="line">        System.out.println(atomicInteger.compareAndSet(5, 2019)+&quot;\t current&quot;+atomicInteger.get());</div><div class="line">        System.out.println(atomicInteger.compareAndSet(5, 2014)+&quot;\t current&quot;+atomicInteger.get());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">true	 current 2019</div><div class="line">false	 current 2019</div></pre></td></tr></table></figure>
<p>​    为什么第一次compareAndSet能成功，第二次就不行了呢？这是因为，初始的AtomicInteger的值是5，那么在主内存中就是5。第一次执行cas操作，所要表达的逻辑是，我要把atomicInteger修改为2019，但是我是要从5修改为2019。也就是说，主内存中的atomicInteger的值必须是5，我才能<strong>紧接着</strong>把atomicInteger修改为2019。</p>
<p><strong>很明显在第一次cas操作之前，主内存中的atomicInteger一直是5，</strong> 所以<strong>比较成功</strong>。<strong>交换值</strong>，5修改为2019，成功写入主内存中的atomicInteger。</p>
<p>​    但是第二次cas操作，表达的是我要从5修改为2014，但是<strong>通过比较主内存</strong>中的atomicInteger，发现atomicInteger的值是2019，那么<strong>比较失败</strong>，<strong>值交换也相继失败</strong>。所以主内存中atomicInteger的值保持不变，还是2019。</p>
<p><strong>也就是说，CAS的本质就是，先比较后交换。</strong></p>
<blockquote>
<p><strong>我们接着查看一下compareAndSet的源码：</strong></p>
</blockquote>
<pre><code>/**
 * Atomically sets the value to the given updated value
 * if the current value {@code ==} the expected value.
 *
 * @param expect the expected value
 * @param update the new value
 * @return {@code true} if successful. False return indicates that
 * the actual value was not equal to the expected value.
 */
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
</code></pre><ul>
<li><p>this：就是当前的atomicInteger对象- AtomicInteger atomicInteger = new AtomicInteger(5);</p>
</li>
<li><p>valueOffset：我们知道atomicInteger的值是保存在value成员变量中，而且他是通过volatile修饰。而且这个值是在创建AtomicInteger之前（在调用构造器之前）通过静态代码块，进行赋值。目的就是求得，value成员变量在内存中的地址。</p>
<ul>
<li>static {<pre><code>try {
    valueOffset = unsafe.objectFieldOffset
        (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
} catch (Exception ex) { throw new Error(ex); }
</code></pre>}</li>
</ul>
</li>
<li><p>expect：我们的预期值，也即是5，也即是要更新为2019的<strong>条件值</strong>。<strong>那么value在主内存中现在的值是多少呢</strong>？怎么获取呢？</p>
<ul>
<li>通过前两个参数获取，通过this和valueOffset，就可以定位到，value属性在内存中的地址，从而获取它的值。</li>
</ul>
</li>
<li><p>update：要把内存中的值，更新update的值。</p>
</li>
</ul>
<blockquote>
<p><strong>抽象出来的CAS的逻辑</strong></p>
</blockquote>
<p>CAS(V, E, N)</p>
<ul>
<li>V：要更新的变量，目前内存中的变量的值。</li>
<li>E：预期值，条件值。要把v更新为n的条件值</li>
<li>N：新值<br>如果V值等于E值，则将V值设为N值；如果V值不等于E值，说明其他线程做了更新，那么当前线程什么也不做。（放弃操作或重新读取数据）</li>
</ul>
<blockquote>
<p><strong>疑问</strong></p>
</blockquote>
<p>​    compareAndSet方法，咋一看，是没有添加任何线程同步的处理，例如没有synchronized或者Lock，那么他是线程安全的么？</p>
<p><strong>答案：是线程安全的，因为使用cas原理（一种硬件原语），cas就能够保证线程安全。</strong></p>
<h2 id="AtomicInteger的CAS底层原理"><a href="#AtomicInteger的CAS底层原理" class="headerlink" title="AtomicInteger的CAS底层原理"></a>AtomicInteger的CAS底层原理</h2><p><strong>为什么cas能够保证线程安全？</strong></p>
<p>​    首先回顾一下我们做过的一个实例：实现两个线程对一个数自增，例如各自对number（共享数据）增加一百万。我们知道如果不对自增方法添加synchronized（或者使用Lock），那么就会导致，最终得数是变化不断的，是不会出现预期的两百万的得值，而是一个游离变化不断得值，<strong>因为这个就是线程安全的问题</strong>。</p>
<blockquote>
<p><strong>通过学习我们知道有多种方案，解决线程安全问题：</strong></p>
</blockquote>
<ul>
<li><p>通过给方法添加synchronized关键字</p>
</li>
<li><p>可以使用Lock来实现多线程同步问题。</p>
</li>
<li><p>也可以使用AtomicInteger来解决多线程同步问题。</p>
</li>
</ul>
<p><strong>前面两种，我们都已经测试过，但是AtomicInteger为什么能够保证线程安全？同时他是通过什么机制来保证线程安全？通过上面的学习我们知道 AtomicInteger 是通过CAS来保证线程安全，但是是怎么保证的？</strong></p>
<p>那么我们可以通过AtomicInteger来推导出CAS的底层原理。</p>
<blockquote>
<p><strong>看实现代码：通过添加synchronized</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CASDemo &#123;</div><div class="line">	</div><div class="line"> static class Share&#123;</div><div class="line">	 private  int number = 0;//</div><div class="line">	 </div><div class="line">	 public synchronized  void add() &#123;</div><div class="line">		 number++;</div><div class="line">	 &#125;</div><div class="line">	 public int get() &#123;</div><div class="line">		 return number;</div><div class="line">	 &#125;</div><div class="line"> &#125;</div><div class="line">	</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    	Share share = new Share();</div><div class="line">    	Thread pp = new Thread(new Runnable() &#123;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			 for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">   			  share.add1();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;,&quot;线程1&quot;);</div><div class="line">    	Thread ppp =  new Thread(new Runnable() &#123;</div><div class="line">    	  @Override</div><div class="line">    	  public void run() &#123;</div><div class="line">    		  for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">    			  share.add1();</div><div class="line">			&#125;</div><div class="line">    	  &#125;</div><div class="line">      &#125;,&quot;线程2&quot;);</div><div class="line">    	</div><div class="line">      pp.start();</div><div class="line">      ppp.start();</div><div class="line">      </div><div class="line">      pp.join();</div><div class="line">      ppp.join();</div><div class="line">      System.err.println( share.get() );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案，肯定是正确的，因为使用了synchronized内部锁，进行了线程安全的控制。</p>
<blockquote>
<p><strong>我们知道可以使用，AtomicInteger来实现相同的功能</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CASDemo &#123;</div><div class="line">	</div><div class="line"> static class Share&#123;</div><div class="line">	  AtomicInteger atomicInteger = new AtomicInteger(0);//在主内存中，设置共享变量的值为0</div><div class="line">	 public   void add1() &#123;</div><div class="line">		 atomicInteger.incrementAndGet();</div><div class="line">	 &#125;</div><div class="line">	 public int get1() &#123;</div><div class="line">		 return atomicInteger.get();</div><div class="line">	 &#125;</div><div class="line">	 </div><div class="line"> &#125;</div><div class="line">	</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    	Share share = new Share();</div><div class="line">    	Thread pp = new Thread(new Runnable() &#123;</div><div class="line">		@Override</div><div class="line">		public void run() &#123;</div><div class="line">			 for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">   			  share.add1();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;,&quot;线程1&quot;);</div><div class="line">    	Thread ppp =  new Thread(new Runnable() &#123;</div><div class="line">    	  @Override</div><div class="line">    	  public void run() &#123;</div><div class="line">    		  for (int i = 0; i &lt; 1000000; i++) &#123;</div><div class="line">    			  share.add1();</div><div class="line">			&#125;</div><div class="line">    	  &#125;</div><div class="line">      &#125;,&quot;线程2&quot;);</div><div class="line">    	</div><div class="line">      pp.start();</div><div class="line">      ppp.start();</div><div class="line">      </div><div class="line">      pp.join();</div><div class="line">      ppp.join();</div><div class="line">      System.err.println( share.get1() );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现add1方法，根本就没有添加synchronized关键字修饰，但是他为什么能够保证数值就是2000000呢？</p>
<p><strong>通过查看上面的代码，我们发现是通过<code>atomicInteger.incrementAndGet()</code>解决了，number++在多线程访问下竟态线程安全问题。那么具体是怎么实现呢，往下看</strong></p>
<blockquote>
<p><strong>通过查看incrementAndGet方法</strong></p>
</blockquote>
<pre><code>/**
 * Atomically increments by one the current value.
 *
 * @return the updated value
 */
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
</code></pre><p>​    <strong>发现它内部实现是通过调用UnSafe类的方法。那么很明显UnSafe就是多线程同步的关键</strong></p>
<p>​    通过上面的分析我们知道，<code>unsafe.getAndAddInt(this, valueOffset, 1)</code>，this参数就是atomicInteger实例，valueOffset就是atomicInteger实例的成员变量value在内存中的偏移量（也就是内存地址 ），<strong>通过前两个参数，就可以获取当前value在主内存的值。</strong>，第三个参数就是自增1。</p>
<blockquote>
<p><strong>我们接着查看unsafe.getAndAddInt源码</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> /**</div><div class="line">  * Atomically adds the given value to the current value of a field</div><div class="line">  * or array element within the given object &lt;code&gt;o&lt;/code&gt;</div><div class="line">  * at the given &lt;code&gt;offset&lt;/code&gt;.</div><div class="line">  *</div><div class="line">  * @param o object/array to update the field/element in</div><div class="line">  * @param offset field/element offset</div><div class="line">  * @param delta the value to add</div><div class="line">  * @return the previous value</div><div class="line">  * @since 1.8</div><div class="line">  */</div><div class="line"> public final int getAndAddInt(Object o, long offset, int delta) &#123;</div><div class="line">     int v;</div><div class="line">     do &#123;</div><div class="line">         v = getIntVolatile(o, offset);</div><div class="line">     &#125; while (!compareAndSwapInt(o, offset, v, v + delta));</div><div class="line">     return v;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"></div><div class="line">/** Volatile version of &#123;@link #getInt(Object, long)&#125;  */</div><div class="line"> public native int     getIntVolatile(Object o, long offset);//调用操作系统的方法获取当前atomicInteger实例在主内存中value的值。</div><div class="line"> </div><div class="line"> </div><div class="line">     /**</div><div class="line">  * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</div><div class="line">  * holding &lt;tt&gt;expected&lt;/tt&gt;.</div><div class="line">  * @return &lt;tt&gt;true&lt;/tt&gt; if successful</div><div class="line">  */</div><div class="line"> public final native boolean compareAndSwapInt(Object o, long offset,</div><div class="line">                                               int expected,</div><div class="line">                                               int x);</div></pre></td></tr></table></figure>
<p>1.首先看这个方法getAndAddInt，刚开始执行一次do操作，调用getIntVolatile方法</p>
<ul>
<li>目的是获取当前的atomicInteger共享资源，对应的value值，<strong>在主内存中现在的值</strong>（因为可能有其他线程已经修改了它的值，所以要获取最新的值）。然后赋值给v变量。</li>
</ul>
<p>2.然后进行while判断，这个就是核心的cas的原理关键，比较和交换。</p>
<ul>
<li><p>​    compareAndSwapInt方法，一共有四个参数。第一个参数，就是atomicInteger共享资源（<strong>就是我们 AtomicInteger atomicInteger = new AtomicInteger(0)这里new出来的实例本身</strong>），保存自己首次从主内存中，捞取的value数据（因为我们知道，任何线程对数据的操作，都是先从主内存加载到自己的栈内存中，进行操作，也就是cas的expect值）</p>
</li>
<li><p>第二个参数：就是atomicInteger共享资源的value属性在内存的地址。</p>
<ul>
<li>这样通过第一和第二参数，我们就可以获取cas的expect值。</li>
</ul>
</li>
</ul>
<p>第三个参数：就是目前value在主内存中的值。</p>
<p>第四个参数：就是update值，更新最新的值，v + delta。线程操作成功。</p>
<p>通过前面三个参数，我们就可以<strong>实现cas中的compare阶段</strong>，比较期望值跟主内存中value值，是否一致，如果一致，那么就直接更新值，<strong>实现cas的set阶段</strong>，<strong>更新成功</strong>，然后返回v变量的值（没有进行v + delta前的值）</p>
<p>如果比对失败，那么compareAndSwapInt返回false，那么<code>while (!compareAndSwapInt(o, offset, v, v + delta));</code>判断成功，然后接着进行do操作，<strong>无线循环，直到while判断成功</strong>。</p>
<blockquote>
<p><strong>我们在捋一下思路</strong></p>
</blockquote>
<p>  假设线程A和线程B两个线程同时执行getAndAddInt操作(分别在不同的CPU上):</p>
<p>1.AtomicInteger里面的value原始值为3,即主内存中AtomicInteger的value为3,根据JMM模型,线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存.</p>
<p>2.线程A通过getIntVolatile(var1,var2) 拿到value值3,这时线程A被挂起.</p>
<p>3.线程B也通过getIntVolatile(var1,var2) 拿到value值3,此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存中的值也是3 成功修改主内存的值为4 线程B打完收工 一切OK.</p>
<p> 4.这是线程A恢复,执行compareAndSwapInt方法比较,发现自己手里的数值（3）和内存中的数字4不一致,说明该值已经被其他线程抢先一步修改了,那A线程修改失败,只能重新来一遍了.（while循环判断失败，重新进入do逻辑获取主内存的value值）</p>
<p> 5.线程A重新获取value值,因为变量value是volatile修饰,所以其他线程对他的修改,线程A总是能够看到,线程A继续执行compareAndSwapInt方法进行比较替换,直到成功.</p>
<blockquote>
<p><strong>我们知道上述方法都是通过Unsafe类进行调用的，那么UnSafe是是什么？</strong></p>
</blockquote>
<p>​     是CAS的核心类 由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法.<br>​    注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务<br>  变量ValueOffset,便是该变量在内存中的偏移地址,因为UnSafe就是根据内存偏移地址获取数据的。</p>
<h3 id="那么cas到底是怎么保证了并发问题？"><a href="#那么cas到底是怎么保证了并发问题？" class="headerlink" title="那么cas到底是怎么保证了并发问题？"></a><strong>那么cas到底是怎么保证了并发问题？</strong></h3><p>​    CAS的全称为Compare-And-Swap ,它是一条CPU并发原语。</p>
<p>​    它的功能是判断内存某个位置的值是否为预期值,如果是则更新为新的值,<strong>这个过程是原子的.</strong></p>
<p>​    CAS并发原语提现在Java语言中就是sun.misc.UnSaffe类中的各个方法.调用UnSafe类中的CAS方法,<strong>JVM会帮我实现CAS汇编指令</strong>.这是一种完全依赖于硬件 功能,通过它<strong>实现了原子操作</strong>。</p>
<p>​    再次强调,由于CAS是一种系统原语。原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程,并且原语的执行必须是连续的,在执行过程中<strong>不允许中断</strong>，<strong>也即是说CAS是一条原子指令,不会造成所谓的数据不一致的问题.</strong></p>
<p><img src="/2020/03/09/java基础核心技术/4840092-f85e70e2262b72312878.png" alt="image-20200120144908032"></p>
<p>也就是说，cas为什么能够保证并发安全，靠的就是底层的汇编命令，指令的原子性。</p>
<h3 id="为什么使用cas不使用synchronized？"><a href="#为什么使用cas不使用synchronized？" class="headerlink" title="为什么使用cas不使用synchronized？"></a>为什么使用cas不使用synchronized？</h3><p>我们通过上面的源码知道，cas是不会加锁的，他是通过一个无线循环，来进行比对值，然后设置值的思路。这样就可以让<strong>多个线程在同一个时刻同时进入逻辑</strong>。</p>
<p>然而synchronized或者lock，只能在<strong>同一个时刻，只有一个线程</strong>获取锁后，才能进入逻辑。</p>
<p>所以并发上，cas更佳。但是synchronized至少能够保证，我做完一然后接着下一个，很稳定。cas虽然是可以大家一起做，但是不一定能成功。</p>
<p>但是cas只能够保证一个资源的并发安全，多个资源他无法保证。synchronized是可以保证多个资源的并发安全。</p>
<h2 id="AtomicReference-实现对象的资源保护"><a href="#AtomicReference-实现对象的资源保护" class="headerlink" title="AtomicReference 实现对象的资源保护"></a>AtomicReference 实现对象的资源保护</h2><p>我们知道java.util.concurrent.atomic包下提供了，多种通过cas实现并发安全的各种类。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200120153246954.png" alt="image-20200120153246954"></p>
<p>那么我们之前已经使用了AtomicInteger，通过它可以保证某个int类型数据的并发安全。</p>
<p>但是如果共享资源是多个属性，或者说是一个对象的话，那么怎么办？那么就可以使用 AtomicReference<t>。</t></p>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class AtomicReferenceDemo &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		User user = new User(&quot;kingge&quot;, 12);</div><div class="line">		User userCopy = new User(&quot;kingge&quot;, 12);</div><div class="line">		User user1 = new User(&quot;kingger&quot;, 12);</div><div class="line">		AtomicReference&lt;User&gt; reference = new AtomicReference&lt;&gt;();</div><div class="line">		reference.set(user);</div><div class="line">	        System.out.println(reference.compareAndSet(user, user1)+&quot;\t&quot;+reference.get().toString());</div><div class="line">	        System.out.println(reference.compareAndSet(user, user1)+&quot;\t&quot;+reference.get().toString());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class User&#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">	public User(String name, int age) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">//省略get/set方法</div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">true	User [name=kingger, age=12]</div><div class="line">false	User [name=kingger, age=12]</div></pre></td></tr></table></figure>
<p>需要注意的是：这里需要注意下，这里的比对两个对象，比对的方式不是<code>equals</code>而是<code>==</code>,意味着比对的是内存的中地址，这个我们可以通过<code>unsafe.compareAndSwapObject()</code>方法查看，他是一个native方法。</p>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><blockquote>
<p><strong>1.循环时间长开销很大，可能某个线程一直操作不成功，那么一直循环，对cpu造成压力大。</strong></p>
</blockquote>
<pre><code>public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
</code></pre><blockquote>
<p><strong>2.只能保证一个共享变量的原子性。</strong></p>
</blockquote>
<p>​    你看代码，你会发现，他是无法保证多个共享资源的并发安全。但是synchronized是可以的，可以对一段代码进行并发安全控制。</p>
<blockquote>
<p><strong>3.引出来ABA问题</strong></p>
</blockquote>
<p><img src="/2020/03/09/java基础核心技术/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200120150958113.png" alt="image-20200120150958113"></p>
<p><strong>什么是ABA问题</strong></p>
<p>cas算法实现的一个重要前提就是需要取出内存中某个时刻的数据并在当下时刻比较替换，那么在这个时间差内，会导致数据的变化。</p>
<p>比如说，一个线程从a从内存位置o中取出A，这个时候另一个线程b，也从内存中取出A，并且线程b进行了一些操作将主内存的A变成了B，然后线程b又将主内存中位置o的数据从B修改为了A。这个时候，线程a进行cas操作，发现主内存中仍然是A，然后线程a操作成功。</p>
<p>尽管线程a的cas操作成功，但是并不代表这个过程是没有问题的，也就是说cas值关注头尾，只要对应的上就操作成功。所以说ABA问题，是存在的，但是这个也不算是问题，因为有可能你的业务就是只关注头尾是否相同，中间不论发生什么，我都不在意。</p>
<p><strong>怎么解决ABA问题</strong></p>
<p>很明显，解决的思路就是，通过时间戳或者记录版本号的方式，只要修改一次版本号就记录一次，自增1。</p>
<p>实现方式就是通过，AtomicStampedReference，类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Description: ABA问题的解决</div><div class="line"> **/</div><div class="line">public class ABADemo &#123;</div><div class="line">    private static AtomicReference&lt;Integer&gt; atomicReference=new AtomicReference&lt;&gt;(100);//通过atomicReference演示ABA问题的产生</div><div class="line">    </div><div class="line">    private static AtomicStampedReference&lt;Integer&gt; stampedReference=new AtomicStampedReference&lt;&gt;(100,1);//通过stampedReference演示ABA的解决方案</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;===以下是ABA问题的产生===&quot;);</div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            atomicReference.compareAndSet(100,101);</div><div class="line">            atomicReference.compareAndSet(101,100);</div><div class="line">        &#125;,&quot;t1&quot;).start();</div><div class="line"></div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            //先暂停1秒 也即是保证t1线程先执行 保证完成ABA。</div><div class="line">            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line">            System.out.println(atomicReference.compareAndSet(100, 2019)+&quot;\t&quot;+atomicReference.get());</div><div class="line">        &#125;,&quot;t2&quot;).start();</div><div class="line">        try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line">        //很明显t2是可以修改成功的，因为这里他并不关注ABA的出现，只关注头尾，因为最开始</div><div class="line">        </div><div class="line">        </div><div class="line">        System.out.println(&quot;===以下是ABA问题的解决===&quot;);</div><div class="line"></div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            int stamp = stampedReference.getStamp();</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 第1次版本号&quot;+stamp+&quot;\t值是&quot;+stampedReference.getReference());</div><div class="line">            //暂停1秒钟t3线程</div><div class="line">            try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line"></div><div class="line">            stampedReference.compareAndSet(100,101,stampedReference.getStamp(),stampedReference.getStamp()+1);</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 第2次版本号&quot;+stampedReference.getStamp()+&quot;\t值是&quot;+stampedReference.getReference());</div><div class="line">            stampedReference.compareAndSet(101,100,stampedReference.getStamp(),stampedReference.getStamp()+1);</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 第3次版本号&quot;+stampedReference.getStamp()+&quot;\t值是&quot;+stampedReference.getReference());</div><div class="line">        &#125;,&quot;t3&quot;).start();</div><div class="line"></div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            int stamp = stampedReference.getStamp();</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 第1次版本号&quot;+stamp+&quot;\t值是&quot;+stampedReference.getReference());</div><div class="line">            //保证线程3完成1次ABA</div><div class="line">            try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line">            boolean result = stampedReference.compareAndSet(100, 2019, stamp, stamp + 1);</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t 修改成功否&quot;+result+&quot;\t最新版本号&quot;+stampedReference.getStamp());</div><div class="line">            System.out.println(&quot;最新的值\t&quot;+stampedReference.getReference());</div><div class="line">        &#125;,&quot;t4&quot;).start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">===以下是ABA问题的产生===</div><div class="line">true	2019</div><div class="line">===以下是ABA问题的解决===</div><div class="line">t3	 第1次版本号1	值是100</div><div class="line">t4	 第1次版本号1	值是100</div><div class="line">t3	 第2次版本号2	值是101</div><div class="line">t3	 第3次版本号3	值是100</div><div class="line">t4	 修改成功否false	最新版本号3</div><div class="line">最新的值	100</div></pre></td></tr></table></figure>
<h2 id="atomic包下的工具类，都是基于CAS实现线程安全"><a href="#atomic包下的工具类，都是基于CAS实现线程安全" class="headerlink" title="atomic包下的工具类，都是基于CAS实现线程安全"></a>atomic包下的工具类，都是基于CAS实现线程安全</h2><h1 id="ArrayList线程不安全解决"><a href="#ArrayList线程不安全解决" class="headerlink" title="ArrayList线程不安全解决"></a>ArrayList线程不安全解决</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class ArrayListTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">		for (int i = 0; i &lt; 30; i++) &#123;</div><div class="line">			new Thread(new Runnable() &#123;</div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					list.add(UUID.randomUUID().toString().substring(0, 8));</div><div class="line">					System.out.println(list);</div><div class="line">				&#125;</div><div class="line">			&#125;, String.valueOf(i)).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>30个线程，共同操作list，那么就会出现下面的问题：<code>Exception in thread &quot;10&quot; Exception in thread &quot;26&quot; java.util.ConcurrentModificationException</code></p>
<p>多个线程，进行add数据的时候，可能会报这个错误</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200119173919024.png" alt="image-20200119173919024"></p>
<p>这种情况就是因为add方法，可以让多个线程同时执行，那么某个线程正在写入list数组的某个下标时，其他写成也可能在下入同一个下标，那么这个时候就会触发并发修改异常。</p>
<p><strong>那么怎么解决呢？</strong></p>
<p>备选方案，使用Vector，vector提供了synchronized修饰的方法，需要加锁，并发能力下降。</p>
<p>我们可以使用    Collections.synchronizedList(list)，通过传递一个list，然后他会返回一个线程安全的list给你，实际上返回的线程安全list内部实现，就是通过在方法内部加上synchronized的方式实现线程安全，他跟vector是一样的。</p>
<p>以上两个方案，如果公司都不建议使用，那么可以使用下面的类。</p>
<p>我们推荐使用 CopyOnWriteArrayList 类。查看他的add方法</p>
<pre><code>/**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return {@code true} (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>发现他实际上就是通过ReentrantLock进行加锁和解锁，很简单，所以他能够解决并发问题。</p>
<p>我们在深入的看一下CopyOnWriteArrayList的源码：</p>
<pre><code>/** The lock protecting all mutators */
final transient ReentrantLock lock = new ReentrantLock();

/** The array, accessed only via getArray/setArray. */
private transient volatile Object[] array;
</code></pre><p>可以看到他的成员属性有这两个，一个加锁的实例对象，一个保存list数据的 volatile类型的数组。</p>
<h2 id="同理hashset和hashmap也是线程不安全的"><a href="#同理hashset和hashmap也是线程不安全的" class="headerlink" title="同理hashset和hashmap也是线程不安全的"></a>同理hashset和hashmap也是线程不安全的</h2><p>那么他们的解决方案，其实跟ArrayList是一样的。</p>
<p>hashset线程不安全解决的方案是，可以使用Collections生成线程安全的set，那么也是可以使用CopyOnWriteArraySet（你会发现，他底层依赖的就是CopyOnWriteArrayList实现）。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200121154028153.png" alt="image-20200121154028153"></p>
<p>hashmap的解决方案是：可以使用hashtable，或者Collections集合类生成 线程安全的map，那么也是可以使用ConcurrentHashMap</p>
<p><strong>特别提示：hashset的底层实现是hashmap，但是hashset的add方法参数只有一个，hashmap的入参是一个k-v键值对，怎么回事？</strong></p>
<p><strong>原来hashset的k就是add方法的入参，但是我们只关注k，所以value的值，是一个恒定使用final修饰的new Object()对象。</strong></p>
<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><p>请查看&lt;面试突击第三季.md&gt;里面有完整分析</p>
<h1 id="公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解-请手写一个自旋锁"><a href="#公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解-请手写一个自旋锁" class="headerlink" title="公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解?请手写一个自旋锁"></a>公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解?请手写一个自旋锁</h1><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁<br>    是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到。<br>非公平锁<br>    是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象。</p>
<p>  <strong>并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Creates an instance of &#123;@code ReentrantLock&#125;.</div><div class="line"> * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</div><div class="line"> */</div><div class="line">public ReentrantLock() &#123;</div><div class="line">    sync = new NonfairSync();//Nonfair 默认是非公平锁 。</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Creates an instance of &#123;@code ReentrantLock&#125; with the</div><div class="line"> * given fairness policy.</div><div class="line"> *</div><div class="line"> * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</div><div class="line"> */</div><div class="line">public ReentrantLock(boolean fair) &#123;</div><div class="line">    sync = fair ? new FairSync() : new NonfairSync();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>synchronized和默认创建的lock都是非公平锁。</strong></p>
<h2 id="可重入锁-又名递归锁"><a href="#可重入锁-又名递归锁" class="headerlink" title="可重入锁(又名递归锁)"></a>可重入锁(又名递归锁)</h2><p><img src="/2020/03/09/java基础核心技术/image-20200121163129464.png" alt="image-20200121163129464"></p>
<p><strong>也就是说，同步方法内部，再去访问另一个同步方法，可以不用再请求锁，只需要记录重入次数即可，释放锁后减少重入次数即可 。（好处是这样就不会死锁）</strong></p>
<p><strong>ReentrantLock/synchronized就是一个典型的可重入锁</strong>。</p>
<p><strong>可重入锁最大的作用就是避免死锁</strong></p>
<p>例子一：使用synchronized实现可重入锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.cas;</div><div class="line"></div><div class="line">class Phone&#123;</div><div class="line">    public synchronized void sendSms() throws Exception&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot;\tsendSms&quot;);</div><div class="line">        sendEmail();</div><div class="line">    &#125;</div><div class="line">    public synchronized void sendEmail() throws Exception&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot;\tsendEmail&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">/**</div><div class="line"></div><div class="line"> *  也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块</div><div class="line"> **/</div><div class="line"></div><div class="line">public class ReenterLockDemo &#123;</div><div class="line">	 public static void main(String[] args) &#123;</div><div class="line">	        Phone phone = new Phone();</div><div class="line">	        new Thread(()-&gt;&#123;</div><div class="line">	            try &#123;</div><div class="line">	                phone.sendSms();</div><div class="line">	            &#125; catch (Exception e) &#123;</div><div class="line">	                e.printStackTrace();</div><div class="line">	            &#125;</div><div class="line">	        &#125;,&quot;t1&quot;).start();</div><div class="line">	        new Thread(()-&gt;&#123;</div><div class="line">	            try &#123;</div><div class="line">	                phone.sendSms();</div><div class="line">	            &#125; catch (Exception e) &#123;</div><div class="line">	                e.printStackTrace();</div><div class="line">	            &#125;</div><div class="line">	        &#125;,&quot;t2&quot;).start();</div><div class="line">	    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">t1	sendSms</div><div class="line">t1	sendEmail</div><div class="line">t2	sendSms</div><div class="line">t2	sendEmail</div></pre></td></tr></table></figure>
<p>​    很明显sendSms是一个同步方法，在sendSms（外层函数）内部调用的sendEmail（内层函数）也是一个同步方法。那么假设线程获取锁后能够进入sendSms方法，那么在调用sendSms方法的时候，就不需要再申请锁了，所以锁时可以重复使用的，即是，可重入锁。</p>
<p><strong>sendSms和sendEmail都是请求同一个锁资源（this），那么假设没有重入锁。程序运行，t1线程获取锁资源成功，那么执行 phone.sendSms()，接着调用sendEmail()方法，那么因为sendSms()还占据着this锁，很明显在调用sendEmail时会阻塞，sendEmail方法会等待sendSms方法释放资源，但是sendSms方法要等sendEmail方法执行完才释放资源，相互等待，产生死锁。</strong></p>
<p><strong>举个例子，你能用锁进入你家，那么进入你家的厕所，肯定是可以的，也就不要再开锁了。</strong></p>
<p><strong>需要注意的是：sendSms和sendSms本质上请求的都是同一把锁（Phone.class），所以是可以重入的。</strong></p>
<p>例子二：使用Lock演示可重入锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Phone implements Runnable &#123;</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void get() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\tget&quot;);</div><div class="line">            set();</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void set() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\tset&quot;);</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class ReenterLockDemo &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Phone phone = new Phone();</div><div class="line">        Thread t3 = new Thread(phone);</div><div class="line">        Thread t4 = new Thread(phone);</div><div class="line">        t3.start();</div><div class="line">        t4.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Thread-0	get</div><div class="line">Thread-0	set</div><div class="line">Thread-1	get</div><div class="line">Thread-1	set</div></pre></td></tr></table></figure>
<h2 id="自旋锁-似锁非锁"><a href="#自旋锁-似锁非锁" class="headerlink" title="自旋锁 似锁非锁"></a>自旋锁 似锁非锁</h2><p>我们之前，学过Unsafe和cas，就已经接触过自旋锁。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200121170115696.png" alt="image-20200121170115696"></p>
<p>也就是说：<strong>自旋锁实现的本质，就是通过while循环加上cas方法实现。</strong></p>
<p>其实自旋锁，也可以说，不是锁，这样说的很绕。我们先回顾一下，我们之前学习的，内部锁（synchronized）和显示锁（lock），当多个线程访问共享资源时，只有一个线程能够获取锁，然后进入临界区，操作逻辑。那么这个时候其他锁，是在锁池等待，<strong>是阻塞的</strong>。也就是说，其他线程，根本没有进入临界区的机会。</p>
<p>但是自旋锁，不一样，他是<strong>允许所有</strong>，线程都进入临界区，<strong>操作共享资源数据</strong>，<strong>没有线程是阻塞的</strong>。他实际上就是乐观锁的意思，就是先尝试修改数据，如果不行再请求锁。</p>
<p>他是通过cas硬件原语的，机制，来实现，原子性。通过比较预期值和实际值是否一致，来决定是否做更新操作。如果一致，那么更新值，while循环结束，返回true，线程结束。</p>
<p>如果不一致，那么while循环，持续判断，直到判断成功。</p>
<h3 id="实现一个自旋锁"><a href="#实现一个自旋锁" class="headerlink" title="实现一个自旋锁"></a>实现一个自旋锁</h3><p>那么我们知道，自旋锁的本质就是，<strong>while加上cas</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.zixuan;</div><div class="line"></div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line">import java.util.concurrent.atomic.AtomicReference;</div><div class="line"></div><div class="line">public class SpinLockDemo &#123;</div><div class="line">	//原子引用线程</div><div class="line">	AtomicReference&lt;Thread&gt; reference = new AtomicReference&lt;&gt;();//我们知道，他的底层是private volatile V value; 存储共享资源，也就是说，这段代码执行完成后，value的值是null。因为没有赋值</div><div class="line"></div><div class="line">	public void myLock() &#123;</div><div class="line">		Thread currentThread = Thread.currentThread();</div><div class="line">		System.out.println( currentThread.getName() + &quot; 开始加锁 。。。 &quot; );</div><div class="line">		//自旋锁核心逻辑</div><div class="line">		//通过cas比较，获取锁</div><div class="line">		//他的核心逻辑是：只要当前reference的值跟预期值一样都是null，那么我就把reference的值设置为当前线程，也就意味着，当前线程成功取到了锁，成功进行了资源操作。</div><div class="line">		//那么如果返回true，那么就不需要进行while循环，所以这里是用!取反，只要不满足，就一直死循环，直到满足未知。</div><div class="line">		while( !reference.compareAndSet(null, currentThread) ) &#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void myUnLock() &#123;</div><div class="line">		Thread currentThread = Thread.currentThread();</div><div class="line">		System.out.println( currentThread.getName() + &quot; 开始解锁 。。。 &quot; );</div><div class="line">		//这个意思就是，当前线程操作完了逻辑，那么解锁操作，也要比对一下。</div><div class="line">		//如果reference的值是当前线程，那么就解锁，加锁完成后把reference更新为null，这样才能够让下一个线程继续加锁。</div><div class="line">		reference.compareAndSet(currentThread, null);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpinLockDemo spinLockDemo = new SpinLockDemo();</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				//开始占用锁</div><div class="line">				spinLockDemo.myLock();</div><div class="line">				//处理业务逻辑，这里假设处理业务逻辑需要5s，这样也能在A线程处理业务的同时，B线程</div><div class="line">				//也进入加锁逻辑，这样才能判断自旋锁是否成功</div><div class="line">				try &#123;</div><div class="line">					TimeUnit.SECONDS.sleep(5);</div><div class="line">					System.out.println( Thread.currentThread().getName() +&quot;  执行完毕。。&quot; );</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				//解锁</div><div class="line">				spinLockDemo.myUnLock();</div><div class="line">			&#125;</div><div class="line">		&#125;, &quot;A&quot;).start();</div><div class="line">		</div><div class="line">		//这里暂停1s的目的就是，让main线程暂停1s，保证A线程先启动运行。接着启动B线程</div><div class="line">		try &#123;</div><div class="line">			TimeUnit.SECONDS.sleep(1);</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		new Thread(new Runnable() &#123;</div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				//开始占用锁</div><div class="line">				spinLockDemo.myLock();</div><div class="line">				//解锁</div><div class="line">				spinLockDemo.myUnLock();</div><div class="line">			&#125;</div><div class="line">		&#125;, &quot;B&quot;).start();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A 开始加锁 。。。 </div><div class="line">B 开始加锁 。。。 </div><div class="line">A  执行完毕。。</div><div class="line">A 开始解锁 。。。 </div><div class="line">B 开始解锁 。。。</div></pre></td></tr></table></figure>
<p>可以看到，虽然A、B同时加锁，但是最终只有A线程获取了锁，那么也就意味着，线程B在while循环里面自旋。直到线程A执行完，业务逻辑后，解锁。线程Bwhile循环结束，获取锁，然后执行业务逻辑，最后解锁。</p>
<h2 id="独占锁-写锁-共享锁-读锁-互斥锁"><a href="#独占锁-写锁-共享锁-读锁-互斥锁" class="headerlink" title="独占锁(写锁)/共享锁(读锁)/互斥锁"></a>独占锁(写锁)/共享锁(读锁)/互斥锁</h2><p><img src="/2020/03/09/java基础核心技术/image-20200122100331106.png" alt="image-20200122100331106"></p>
<p>那么既然有了ReentrantLock，为什么还需要读写锁（ReentrantReadWriteLock）呢？为了更细致化的使用锁，实现读写分离。</p>
<p>我们知道ReentrantLock是不管什么操作逻辑，只要进入临界区访问共享资源，那么就会加锁，也就意味着，假设，我只是想读共享资源而已，那么还要去申请锁？这个就有点不符合道理了。<strong>这样会造成什么问题呢？多线程情况下读取资源，还需要等锁，那这个并发量就下降了，而且也没有必要加锁。</strong></p>
<p><strong>也就是说</strong></p>
<p><strong>为了并发量，可以允许多个线程同时进行读取共享资源，但是，如果有一个线程想去写共享资源， 那么就不应该有其他线程对资源进行读或写。</strong></p>
<p>代码例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.cas;</div><div class="line"></div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 资源类</div><div class="line"> */</div><div class="line">class MyCaChe &#123;</div><div class="line">    /**</div><div class="line">     * 保证可见性</div><div class="line">     */</div><div class="line">    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</div><div class="line">    private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 写</div><div class="line">     *</div><div class="line">     * @param key</div><div class="line">     * @param value</div><div class="line">     */</div><div class="line">    public void put(String key, Object value) &#123;</div><div class="line">        reentrantReadWriteLock.writeLock().lock();</div><div class="line">        try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t正在写入的key是：&quot; + key);</div><div class="line">            //模拟网络延时</div><div class="line">            try &#123;</div><div class="line">                TimeUnit.MICROSECONDS.sleep(300);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            map.put(key, value);</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 写入完成&quot;);</div><div class="line">        &#125; finally &#123;</div><div class="line">            reentrantReadWriteLock.writeLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 读</div><div class="line">     *</div><div class="line">     * @param key</div><div class="line">     */</div><div class="line">    public void get(String key) &#123;</div><div class="line">        reentrantReadWriteLock.readLock().lock();</div><div class="line">        try &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t正在读取&quot;);</div><div class="line">            //模拟网络延时</div><div class="line">            try &#123;</div><div class="line">                TimeUnit.MICROSECONDS.sleep(300);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            Object result = map.get(key);</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t读取完成 &quot; + result);</div><div class="line">        &#125; finally &#123;</div><div class="line">            reentrantReadWriteLock.readLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void clearCaChe() &#123;</div><div class="line">        map.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Description:</div><div class="line"> * 多个线程同时操作 一个资源类没有任何问题 所以为了满足并发量</div><div class="line"> * 读取共享资源应该可以同时进行</div><div class="line"> * 但是</div><div class="line"> * 如果有一个线程想去写共享资源来  就不应该有其他线程可以对资源进行读或写</div><div class="line"> * &lt;p&gt;</div><div class="line"> * 小总结:</div><div class="line"> * 读 读能共存</div><div class="line"> * 读 写不能共存</div><div class="line"> * 写 写不能共存</div><div class="line"> * 写操作 原子+独占 整个过程必须是一个完成的统一整体 中间不允许被分割 被打断</div><div class="line"> *</div><div class="line"> **/</div><div class="line">public class ReadWriteLockDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyCaChe myCaChe = new MyCaChe();</div><div class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</div><div class="line">            final int temp = i;</div><div class="line">            new Thread(() -&gt; &#123;</div><div class="line">                myCaChe.put(temp + &quot;&quot;, temp);</div><div class="line">            &#125;, String.valueOf(i)).start();</div><div class="line">        &#125;</div><div class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</div><div class="line">            int finalI = i;</div><div class="line">            new Thread(() -&gt; &#123;</div><div class="line">                myCaChe.get(finalI + &quot;&quot;);</div><div class="line">            &#125;, String.valueOf(i)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1	正在写入的key是：1</div><div class="line">1	 写入完成</div><div class="line">2	正在写入的key是：2</div><div class="line">2	 写入完成</div><div class="line">3	正在写入的key是：3</div><div class="line">3	 写入完成</div><div class="line">5	正在写入的key是：5</div><div class="line">5	 写入完成</div><div class="line">4	正在写入的key是：4</div><div class="line">4	 写入完成</div><div class="line">1	正在读取</div><div class="line">2	正在读取</div><div class="line">3	正在读取</div><div class="line">4	正在读取</div><div class="line">5	正在读取</div><div class="line">1	读取完成 1</div><div class="line">2	读取完成 2</div><div class="line">5	读取完成 5</div><div class="line">3	读取完成 3</div><div class="line">4	读取完成 4</div></pre></td></tr></table></figure>
<p>你会发现，写操作，都是原子性，没有中断（正在写入和写入完成是一对出现）。中间不会存在其他线程的读取或者写入。</p>
<p>读取的时候，是可以多个线程进行读取，你会发现，读取完成和读取结束并不是一对出现，这个是允许的，因为不需要原子性。</p>
<p><strong>所以满足读写锁的要求。</strong></p>
<h1 id="CountDownLatch-CyclicBarrier-Semaphore"><a href="#CountDownLatch-CyclicBarrier-Semaphore" class="headerlink" title="CountDownLatch/CyclicBarrier/Semaphore"></a>CountDownLatch/CyclicBarrier/Semaphore</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是基于AQS的阻塞工具，阻塞一个或者多个线程，直到所有的线程都执行完成。</p>
<blockquote>
<p><strong>CountDownLatch解决了什么问题</strong></p>
</blockquote>
<p>当一个任务运算量比较大的时候，需要拆分为各种子任务，必须要所有子任务完成后才能汇总为总任务。<br>使用并发模拟的时候可以使用CountDownLatch.也可以设置超时等待时间。同时CountDownLatch也提供了可以设置超时等待的await方法。</p>
<p>让一些线程阻塞直到另外一些完成后才被唤醒。类似于wait和notify。</p>
<p>CountDownLatch主要有两个方法,当一个或多个线程调用await方法时,调用线程会被阻塞.其他线程调用countDown方法计数器减1(调用countDown方法时线程不会阻塞),当计数器的值变为0,因调用await方法被阻塞的线程会被唤醒,继续执行</p>
<blockquote>
<p><strong>举个例子：</strong></p>
</blockquote>
<p>​    假设，教室中有七个人，其中六个人是同学，一个是班长，班长要等这六个人都出教室了，然后再关门，那么这种等待其他子线程完成后主线程才操作的就很适合使用CountDownLatch。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CountDownLatchDemo &#123;</div><div class="line">	static CountDownLatch countDownLatch = new   CountDownLatch(6);</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		 for (int i = 1; i &lt;= 6; i++) &#123;</div><div class="line">	            new Thread(() -&gt; &#123;</div><div class="line">	                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + &quot;上完自习&quot;);</div><div class="line">	                countDownLatch.countDown();</div><div class="line">	            &#125;, String.valueOf(i)).start();</div><div class="line">	        &#125;</div><div class="line">	        countDownLatch.await();//挂起main线程，等到countDownLatch减到0时，main线程被唤醒</div><div class="line">	        //也就意味着，要等前面六个线程执行完毕后才会唤醒main线程</div><div class="line">	        System.out.println(Thread.currentThread().getName() + &quot;\t班长锁门离开教室&quot;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><blockquote>
<p><strong>例子</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">public class CDL extends Thread &#123;</div><div class="line">	</div><div class="line"></div><div class="line">	public CDL(String name) &#123;</div><div class="line">		super(name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static CountDownLatch countDownLatch = new   CountDownLatch(1); </div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		try &#123;</div><div class="line">			countDownLatch.await();</div><div class="line">		&#125; catch (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println( Thread.currentThread().getName() + &quot; 执行 &quot; );</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		for (int i = 0; i &lt;3; i++) &#123;</div><div class="line">			new CDL(String.valueOf(i)).start();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println( &quot;123 &quot; );</div><div class="line">		countDownLatch.countDown();</div><div class="line">		System.out.println( &quot;345 &quot; );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道CountDownLatch是 基于共享锁的形式，建立阻塞队列。也就是 Node.SHARE，意味着，多个线程可以同时阻塞在countDownLatch.await()，等到计数器减到0时，多个线程会同时进行执行await后面的代码。</p>
<p><strong>他跟 ReentrantLock不同，lock采用的是独占锁的方式，Node.EXCLUSIVE，在某个时刻，只能够允许一个线程在执行。</strong></p>
<p>​    <strong>所以共享锁的方式，更加的验证了，CountDownLatch的应用场景，在计数器未减少到0时，线程可以同时进行自己各自的业务代码，等计数器减少到0后，那么被await的线程唤醒，然后执行。</strong></p>
<p><strong>以下使用CDL简称CountDownLatch</strong></p>
<blockquote>
<p><strong>查看CDL构造函数</strong></p>
</blockquote>
<pre><code>public CountDownLatch(int count) {
    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);
    this.sync = new Sync(count);
}

        Sync(int count) {//Sync是CDL内部类，Sync继承了AQS
            setState(count);
        }
  这里可以看到，aqs的state属性，在CDL这里的含义是，计数器的数量。而不再是之前我们所说的是否获取锁的标志位/重入次数。被赋予了新的含义
</code></pre><blockquote>
<p><strong>1.查看await（）方法</strong></p>
</blockquote>
<p>java.util.concurrent.CountDownLatch.await()</p>
<pre><code>public void await() throws InterruptedException {//顾名思义，他是请求共享锁，并且可以响应中断

    sync.acquireSharedInterruptibly(1);
}
</code></pre><p>​<br>​        public final void AbstractQueuedSynchronizer.acquireSharedInterruptibly(int arg)<br>​                throws InterruptedException {<br>​            if (Thread.interrupted())<br>​                throw new InterruptedException();<br>​            if (tryAcquireShared(arg) &lt; 0)//首次进来，state一般是不等于0的，因为计数器还为减少到0，所以tryAcquireShared返回-1<br>​                doAcquireSharedInterruptibly(arg);<br>​        }</p>
<p>​<br>​<br>​            protected int tryAcquireShared(int acquires) {//如果计数器减少到0，那么返回1，否则返回-1<br>​                return (getState() == 0) ? 1 : -1;<br>​            }</p>
<p><strong>接着执行 doAcquireSharedInterruptibly 方法</strong></p>
<p>java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(int)</p>
<pre><code>/**
 * Acquires in shared interruptible mode.
 * @param arg the acquire argument
 */
private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);//这个就是将当前线程节点，放到aqs阻塞队列中。返回当前线程节点
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);//判断计数器state是否==0，如果是返回1，表示阻塞的线程可以开始唤醒执行
                if (r &gt;= 0) {
                    setHeadAndPropagate(node, r);//注意这里，这里会遍历整个aqs阻塞队列，然后逐个释放
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())//我们知道线程最终都会阻塞在这里
                throw new InterruptedException();//这里可以直接响应中断，直接抛出异常
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre><p>​    <strong>也就是说，实际上，await（）方法的最终目的就是：将所有调用await方法的线程，都放到aqs阻塞队列中，开始在阻塞。什么时候唤醒呢？等到计数器state==0，也就是countdown到0。</strong></p>
<p>​    <strong>我们发现他跟ReentrantLock整个加锁的流程是类似的，主要的区别在于，lock是独占锁，state表示的是锁标记。CDL在计数器到零后，会unpark所有在aqs阻塞队列的线程，而lock只会唤醒aqs阻塞队列首节点（所以说是独占锁）</strong></p>
<blockquote>
<p><strong>2.查看CDL的countDown（）</strong></p>
</blockquote>
<p>java.util.concurrent.CountDownLatch.countDown()</p>
<pre><code>public void countDown() {
    sync.releaseShared(1);
}
</code></pre><p>​<br>​        public final boolean AbstractQueuedSynchronizer.releaseShared(int arg) {<br>​            if (tryReleaseShared(arg)) {<br>​                doReleaseShared();<br>​                return true;<br>​            }<br>​            return false;<br>​        }</p>
<p><strong>首先调用tryReleaseShared（）方法，state减-1 </strong></p>
<p>java.util.concurrent.CountDownLatch.Sync.tryReleaseShared(int)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> c = getState();</div><div class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</div><div class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果返回true，说明state已经变为了0。那么需要唤醒阻塞的线程。</p>
<p><strong>接着调用doReleaseShared方法，释放共享锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;<span class="comment">//一个for循环。持续一个一个的唤醒aqs阻塞队列中节点</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</div><div class="line">            <span class="keyword">int</span> ws = h.waitStatus;</div><div class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</div><div class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></div><div class="line">                unparkSuccessor(h);<span class="comment">//释放锁，然后唤醒线程</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</div><div class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</div><div class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (h == head) <span class="comment">//循环唤醒aqs阻塞队列的线程，直到队列没有元素，那么跳出循环                  // loop if head changed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>3.唤醒线程后</strong></p>
</blockquote>
<p>接着调用doAcquireSharedInterruptibly的parkAndCheckInterrupt，然后，继续执行for循环，然后执行 setHeadAndPropagate(node, r)方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">              parkAndCheckInterrupt())//我们知道线程最终都会阻塞在这里</div><div class="line">              throw new InterruptedException();//这里可以直接响应中断，直接抛出异常</div></pre></td></tr></table></figure>
<pre><code>private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);//将当前线程设置为头结点，这样的好处是，释放一个就将当前线程设置为头结点，然后再doReleaseShared方法中，总会触发 if (h == head)，这样才能够跳出doReleaseShared（）的for循环。唤醒所有阻塞队列线程结束。

    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
        (h = head) == null || h.waitStatus &lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();//接着唤醒，当前节点的下一个节点，以此类推。直到唤醒完所有的阻塞队列的节点。
    }
}
</code></pre><blockquote>
<p><strong>总结</strong></p>
</blockquote>
<p>​    CDL使用共享锁（不需要竞争）的方式阻塞所有的线程，所有线程阻塞到阻塞队列中，直到countdown到0。就会去唤醒阻塞队列中<strong>所有线程</strong>（共享锁，不需要竞争）。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>例如zookeeper的server的启动挂起，唤醒关闭server就是利用CountDownLatch实现的。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>这个跟CountDownLatch是相反的，他是做加法，当增加到某一个值后，那么就会唤醒阻塞的线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CyclicBarrierDemo &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		</div><div class="line">		CyclicBarrier barrier = new CyclicBarrier(7, () -&gt; &#123;System.out.println( &quot;增加到7了，被唤醒当前线程&quot; );&#125;);</div><div class="line">		</div><div class="line">		for (int i = 1; i &lt;  8; i++) &#123;</div><div class="line">			final int index = i;</div><div class="line">			 new Thread(() -&gt; &#123;</div><div class="line">				  System.out.println( &quot;开始执行业务 &quot; + Thread.currentThread().getName()  );</div><div class="line">				  </div><div class="line">				  try &#123;</div><div class="line">					barrier.await();</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">					// TODO Auto-generated catch block</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				  </div><div class="line">			 &#125;,String.valueOf(i)).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Semaphore-可以用作限流"><a href="#Semaphore-可以用作限流" class="headerlink" title="Semaphore - 可以用作限流"></a>Semaphore - 可以用作限流</h2><p><strong>它的本质实际上就是基于信号量（PV操作）的机制实现。</strong></p>
<p>信号量的主要用户两个目的，一个是用于多个共享资源的相互排斥使用，另一个用于并发资源数的控制。</p>
<p>​    也就是说，我们可以限制资源的数量（令牌），那么多个请求进来后，去争抢固定数量的令牌，如果令牌争抢完，后面还没有得到令牌的线程就会阻塞，直到后令牌释放，然后才会去争抢（争抢的过程中，也可以插队，也就是说Semaphore也是有公平锁和非公平锁的区分）</p>
<p>以下案例，模拟六辆车抢占三个车位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class SemaphoreDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //模拟3个停车位</div><div class="line">        Semaphore semaphore = new Semaphore(3);</div><div class="line">        //模拟6部汽车</div><div class="line">        for (int i = 1; i &lt;= 6; i++) &#123;</div><div class="line">            new Thread(() -&gt; &#123;</div><div class="line">                try &#123;</div><div class="line">                    //抢到资源，拿不到，那么就会阻塞在这里</div><div class="line">                    semaphore.acquire();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + &quot;\t抢到车位&quot;);</div><div class="line">                    try &#123;</div><div class="line">                        TimeUnit.SECONDS.sleep(3);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + &quot;\t 停3秒离开车位&quot;);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    //释放资源</div><div class="line">                    semaphore.release();</div><div class="line">                &#125;</div><div class="line">            &#125;, String.valueOf(i)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>很明显，Semaphore是可以替代，synchronized和lock的，只需要把信号量修改为1即可。因为内部锁和显示锁的本质就是抢占一个资源。</strong></p>
<p>而且我们发现，Semapore实际上是CountDownLatch和CyclicBarrier的结合体。CountDownLatch是减少到某个数然后唤醒某个线程，CyclicBarrier是新增到某个数，然后唤醒某个线程。</p>
<p>但是Semapore是有增有减，可以提供给多个线程功能抢占资源，线程使用完资源后，马上释放，然后另一个线程可以马上的抢占资源。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>​    你会发现，Semaphore获取资源的源代码跟COuntDownlatch基本上是一样的，也是通过共享锁的形式，进行资源的争抢（只不过他有公平和非公平两种实现方式，共享公平锁和共享非公平锁的区别跟ReentrantLock一样，公平锁多了hasQueuedPredecessors方法的判断）</p>
<h1 id="ConcurrentHashMap源码分析"><a href="#ConcurrentHashMap源码分析" class="headerlink" title="ConcurrentHashMap源码分析"></a>ConcurrentHashMap源码分析</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ConcurrentHashMap&lt;String, String&gt; chm = new ConcurrentHashMap&lt;&gt;();</div><div class="line">chm.put(&quot;kingge&quot;, &quot;123&quot;);</div></pre></td></tr></table></figure>
<p><strong>以下ConcurrentHashMap简称chm。</strong></p>
<p>​    <strong>我们阅读源码的原则是，第一时刻考虑如果是多线程访问时，这段代码会不会有问题。第二，不要通读所有代码，而是根据if条件或者其他条件，选择性的读取某段代码。</strong></p>
<h2 id="查看put操作"><a href="#查看put操作" class="headerlink" title="查看put操作"></a><strong>查看put操作</strong></h2><p>我们知道，map是通过数组+链表/红黑树的数据结构保存数据，其中数组是保存key经过hash后得到下标。</p>
<p><strong>在chm中，数组使用 transient volatile Node<k,v>[] table 实现。 </k,v></strong>  <strong>下面简称chm数组（如果不特别指定，那么数组，也代表chm数组）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//阅读时，要注意每个步骤的方法，他是如何保证线程安全的</span></div><div class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="comment">//chm的key和value不能为null，跟hashtable一样。hashmap是允许key和value为null</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());<span class="comment">//获取key对应 hash值，通过右移16位，再通过异或，保证高低16位的特征，这样在进行hash计算数组下标时，更加离散</span></div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<span class="comment">//一个死循环，进行put操作 </span></div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//首先判断数组是否为空，为空则进行初始化数组</span></div><div class="line">            tab = initTable();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;<span class="comment">//b1</span></div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">        &#125;<span class="comment">//end b1</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">// b12 区域</span></div><div class="line">            tab = helpTransfer(tab, f);<span class="comment">//当前节点是转移状态，说明，正在数组扩容，那么当前线程就需要帮助扩容 - 我们知道chm是支持多个线程同时进行扩容操作的</span></div><div class="line">        <span class="keyword">else</span> &#123;<span class="comment">// b2 区域</span></div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;<span class="comment">//直接锁住某个node数组下标，锁粒度细化，保证了其他下标能够被其他线程操作</span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        binCount = <span class="number">1</span>;<span class="comment">//当前数组下标节点，链表元素的个数。方便转化为红黑树进行判断，bincount &gt;= 7,进行单链表转化为红黑树</span></div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<span class="comment">//遍历插入链表中</span></div><div class="line">                            K ek;</div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;<span class="comment">//key和hash值相等，那么更新value值即可</span></div><div class="line">                                oldVal = e.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="comment">// end synchronized</span></div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="comment">//end b2</span></div><div class="line">    &#125;<span class="comment">//end for</span></div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="initTable数组初始化工作-sizeCtl属性"><a href="#initTable数组初始化工作-sizeCtl属性" class="headerlink" title="initTable数组初始化工作 - sizeCtl属性"></a>initTable数组初始化工作 - sizeCtl属性</h3><p>首先我们要明确一点，多线程情况下，initTable()方法的调用是存在线程安全的，所以我们需要注意chm对于initTable()是如何保证线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)<span class="comment">//如果sizeCtl小于，表示数组已经初始化，那么就没有必要再次初始化数组，当前线程让出cpu，给其他线程执行，当前线程回到就绪状态</span></div><div class="line">，            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;<span class="comment">//可以看到这里是通过了cas保证了初始化数组的原子性，sizeCtl设置为-1</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;<span class="comment">//初始化数组,长度默认是16</span></div><div class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//关键点 ， 假设数组长度是16，那么sc=12，相当于n*0.75，</span></div><div class="line">                    <span class="comment">//那为什么这里要用n - (n &gt;&gt;&gt; 2) 呢？因为位运算比算术运算要快</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                sizeCtl = sc;<span class="comment">//sizeCtl = 12，这里sizeCtl被赋予了另外一种含义，表示下次数组扩容的数量</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了一个chm的一个非常重要的成员变量     <strong>private transient volatile int sizeCtl</strong></p>
<p>​    通过<code>U.compareAndSwapInt(this, SIZECTL, sc, -1)</code> cas操作，保证了高并发下只有一个线程能够进行初始化数组，比较sizeCtl是否跟预期值一致（等于0），如果是，那么把sizeCtl设置为-1，进入初始化数组逻辑。</p>
<p>​    否则cas失败，表示数组已经初始化，那么退出whil循环（此时table已经不为null），返回数组。</p>
<blockquote>
<p><strong>sizeCtl的三个作用</strong></p>
</blockquote>
<p><strong>通过上面的源码我们发现，是否已经初始化的数组是通过sizeCtl和cas来进行判断和操作的。而且sizeCtl一共有两个作用：sizeCtl  == -1 ，表示当前已经有线程抢到了初始化chm数组的权限、sizeCtl &gt; 0，sizeCtl=sc=n*0.75，表示下一次数组扩容大小。</strong></p>
<p>​    <strong>sizectl的第三个作用，当sizeCtl是负数，但不是-1，就表示当前有几个线程在进行扩容操作，例如sizeCtl=-2，表示有两个线程在执行扩容操作（ 关于第三个作用，在下面的addCount()方法的第二段if，里面会有用到 ）</strong></p>
<h3 id="tabat和casTabAt，获取key对应的数组下标"><a href="#tabat和casTabAt，获取key对应的数组下标" class="headerlink" title="tabat和casTabAt，获取key对应的数组下标"></a>tabat和casTabAt，获取key对应的数组下标</h3><p>同时这两个方法也是需要保证线程安全的。我们来看源代码。他们是怎么保证线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//////////初始化为数组后，for死循环，会执行到这段代码，获取key对应的数组下标</span></div><div class="line"><span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">            &#125;</div><div class="line">            </div><div class="line">  <span class="comment">////////////////为了避免高并发下，key被覆盖问题，那么需要保证tabAt的线程安全</span></div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">//通过底层保证tabAt线程安全</span></div><div class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//通过cas保证了 put操作的线程安全</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></div><div class="line"><span class="function"><span class="params">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="addCount-1L-binCount-最终执行"><a href="#addCount-1L-binCount-最终执行" class="headerlink" title="addCount(1L, binCount) 最终执行"></a>addCount(1L, binCount) 最终执行</h3><p>我们知道不管，put最终都会执行到addCount(1L, binCount)，顾名思义 ，就是计数的意思，新增put一条数据，那么size就会增1。</p>
<p>​    那么怎么保证高并发下，addCount方法线程安全呢？通过cas、加锁？虽然这两种方法都可以保证线程安全，但是会有性能影响。那么我们来看一下他是怎么进行线程安全控制的</p>
<p>​    他是怎么维护chm的size呢？</p>
<p>那么我们来看一下他的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;<span class="comment">//第一个传的就是1，表示增加chm元素个数，因为put一次元素个数肯定是自增1，所以 这里固定传1.那么第二个参数是是检查是否需要扩容的依据，一般是表示当前chm数组某个下标，构建的单链表的元素个数，根据该值判断是否需要扩容</span></div><div class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</div><div class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</div><div class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<span class="comment">//尝试对于basecount进行一次cas操作，如果失败，那么说明当前访问addCount方法的线程过多，为了避免无效的cas操作，浪费加剧cpu操作，那么往下执行，引入CounterCell数组，进行线程分流操作。</span></div><div class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</div><div class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</div><div class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</div><div class="line">            !(uncontended =</div><div class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</div><div class="line">            fullAddCount(x, uncontended);<span class="comment">//初始化CounterCell数组</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        s = sumCount();</div><div class="line">    &#125;<span class="comment">//size增加1</span></div><div class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;<span class="comment">//检查是否需要扩容</span></div><div class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</div><div class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<span class="comment">//判断s当前chm元素个数，是否大于sizectl（这里等于12，因为此时sizectl得知是在initTable()方法中进行初始化的），且chm数组不为空，且chm数组长度不大于最大值。</span></div><div class="line">            <span class="keyword">int</span> rs = resizeStamp(n);<span class="comment">//</span></div><div class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                    transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</div><div class="line">                transfer(tab, <span class="keyword">null</span>);</div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// </span></div><div class="line"></div><div class="line">ThreadLocalRandom.getProbe() &amp; m <span class="comment">//ThreadLocalRandom.getProbe() ，获得一个随机数，然后跟counterCells数组长度进行与运算，最终获得某个线程需要操作counterCells数组哪个下标的位置。起到分流作用，降低无效cas操作</span></div><div class="line">    <span class="comment">//这样那么多个线程会被分配到不同的数组下标，然后取到数组下标已经存在的value值，再进行cas自增1。完成本次的chm元素数量增加1操作</span></div></pre></td></tr></table></figure>
<p>结论：</p>
<p>   <strong>chm的size，数据个数，是通过chm的baseCount和counterCells这两个成员属性来进行控制的或者说得到的。</strong></p>
<p>​    首先我们回顾一下，hashmap或者arrayList，都是通过一个成员属性size来进行元素个数的维护，那么为什么chm不通过这样的方式来维护元素个数呢？</p>
<p>​    实际上，chm是通过这样的策略进行元素个数的维护：</p>
<p>​         <strong>如果在线程数不是很多的情况下，那么对baseCount进行cas操作，自增1，实现元素数量的增加维护。</strong></p>
<p>​        <strong>但是假设是高并发情况下或者说对于baseCount的cas操作失败，那么就会增加一个counterCells数组来进行高并发下分流操作，避免无效的cas操作。</strong></p>
<p>​        <strong>总而言之，在对chm元素数量自增1的时候，会尝试进行一次对baseCount进行cas的自增操作，假设失败，马上使用counterCells数组进行数组元素的维护。</strong></p>
<blockquote>
<p><strong>下面详细分析</strong></p>
</blockquote>
<p>​    首先我们假设chm只通过baseCount，来进行元素个数的维护，那么在put一条数据的时候，我们知道baseCount需要自增1，那么为了线程安全，baseCount的自增需要通过加锁或者cas的方式进行，一般使用cas。</p>
<p>​    那么如果使用只使用baseCount来维护chm元素个数，那么进行cas自增1的时候就会面临一个问题，假设高并发情况下，多个线程同时执行put操作，cas只能够运行一个线程修改成功，那么其他线程就会做没有意义的cas操作，线程多的情况下，cpu压力会上升。</p>
<p>​    那么怎么改变这种情况呢？<strong>那就是引入分段的概念，就是可以让多个线程执行同时执行cas自增操作，类似于部署多个节点，支持高并发。那么就引出了counterCells数组，每个数组位置，都保存一个value值，表示chm元素个数，这样求得整个chm元素个数的时候，只需要遍历counterCells数组然后累加再加上baseCount就等于chm元素个数（详情查看chm的size()方法）</strong></p>
<p>​    <strong>那么引入后上面的高并发cas的问题，怎么解决了呢？</strong></p>
<p>​    假设counterCells数组初始化为2，那么假设有三个线程，put操作完，三个线程需要调用addCount增加元素个数。那么就会给这三个线程，随机分配一个关于counterCells数组的下标，让他们各自去数组下标的位置，进行自增1操作。那么这样就起到了分流的作用，这样就减少了无效cas的个数。</p>
<p>​    <strong>也就是说，CounterCell数组，保存了chm的元素个数。</strong></p>
<p>为了加深上面的理论，我们查看一下chm的size() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> n = sumCount();</div><div class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</div><div class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</div><div class="line">            (<span class="keyword">int</span>)n);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        CounterCell[] as = counterCells; CounterCell a;</div><div class="line">        <span class="keyword">long</span> sum = baseCount;</div><div class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;<span class="comment">//遍历CounterCell数组，累加里面的个数，再加上baseCount，就是整个chm元素个数</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</div><div class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</div><div class="line">                    sum += a.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="fullAddCount（）初始化counterCells数组"><a href="#fullAddCount（）初始化counterCells数组" class="headerlink" title="fullAddCount（）初始化counterCells数组"></a>fullAddCount（）初始化counterCells数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// See LongAdder version for explanation</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</div><div class="line">         ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></div><div class="line">         h = ThreadLocalRandom.getProbe();</div><div class="line">         wasUncontended = <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></div><div class="line">     <span class="keyword">for</span> (;;) &#123;</div><div class="line">         CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</div><div class="line">          <span class="keyword">if</span>()&#123;<span class="comment">//先忽略这部分代码，判断counterCells数组是否为空</span></div><div class="line">            ......<span class="comment">//不为空则执行这部分代码</span></div><div class="line">          &#125;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</div><div class="line">                  U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//cellsBusy==0,那么当前线程获取锁，得到执行当前counterCells数组的机会，并将cellsBusy设置为1</span></div><div class="line">             <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</div><div class="line">             <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></div><div class="line">                 <span class="keyword">if</span> (counterCells == as) &#123;</div><div class="line">                     CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];<span class="comment">//初始化一个两个数量的CounterCell数组</span></div><div class="line">                     rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);<span class="comment">//因为CounterCell数组长度为 2，所以我们为了获取当前线程分配到所需要操作的CounterCell数组下标，那么要进行，（h &amp; 1，随机数&amp;1），因为长度为2的数组，最终有两个结果，那就是0或者1。</span></div><div class="line">                     counterCells = rs;</div><div class="line">                     init = <span class="keyword">true</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                 cellsBusy = <span class="number">0</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (init)</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</div><div class="line">             <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>首先我们要知道，counterCells数组某个下标也会存在线程安全问题，因为，可能有多个线程通过随机数&amp;m的计算得到了，相同的数组下标。为了避免自增的线程安全，所需要也是需要进行加锁控制。</p>
<p>​    这里是通过chm的成员属性cellsBusy，进行数组下标锁的控制，默认是0，通过cas判断，当前数组下标是否存在操作的线程，如果不存在则把cellsBusy设置为1（<code>U.compareAndSwapInt(this, CELLSBUSY, 0, 1)</code>），然后执行里面的业务操作 .</p>
<h4 id="resizeStamp-扩容操作"><a href="#resizeStamp-扩容操作" class="headerlink" title="resizeStamp() 扩容操作"></a>resizeStamp() 扩容操作</h4><p>扩容操作的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;<span class="comment">//检查是否需要扩容</span></div><div class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</div><div class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<span class="comment">//判断s当前chm元素个数，是否大于sizectl（这里等于12，因为此时sizectl得知是在initTable()方法中进行初始化的），且chm数组不为空，且chm数组长度不大于最大值。</span></div><div class="line">            <span class="keyword">int</span> rs = resizeStamp(n);<span class="comment">//获得一个值，此时n是16，那么返回的是32795，得到一个唯一的扩容戳</span></div><div class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;<span class="comment">//这里的sc==sizeCtl==12，所以首次进来时，那么if判断不满足。但是当第二个线程进来后，发现sc已经是一个负数（因为此前已经被(U.compareAndSwapInt(this, SIZECTL, sc,(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) 设置为负数），满足条件，进入逻辑</span></div><div class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                    transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                    transfer(tab, nt);<span class="comment">//扩容操作</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))<span class="comment">//sc &gt;= 0 执行cas操作。将sc设置为一个负数。</span></div><div class="line">                transfer(tab, <span class="keyword">null</span>);<span class="comment">//扩容操作</span></div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//返回无符号整型i的最高非零位前面的0的个数，包括符号位在内；如果i为负数，这个方法将会返回0，符号位为1.比如说，10的二进制表示为 0000 0000 0000 0000 0000 0000 0000 1010，java的整型长度为32位。那么这个方法返回的就是28（32-4，因为10的最高非零是第四位的1，他前面还有28个0 - 即是：0000 0000 0000 0000 0000 0000 0000）</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此时通过resizeStamp(16)得到的值是32795，二进制是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">else if (U.compareAndSwapInt(this, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))//sc &gt;= 0 执行cas操作。</div><div class="line">                                         </div><div class="line"></div><div class="line">0000 ‭0000 ‭0000 ‭0000 ‭1000 0000 0001 1011‬ 然后rs &lt;&lt; RESIZE_STAMP_SHIFT，表示左移16位</div><div class="line">1000 0000 0001 1011‬ 0000 ‭0000 ‭0000 ‭0000 也就是相当于低十六位移动到高十六位，接着+2</div><div class="line">1000 0000 0001 1011‬ 0000 ‭0000 ‭0000 ‭0010 </div><div class="line"></div><div class="line">高十六位代表扩容的标记，低十六位代表参加扩容的线程数（需要注意的是chm的扩容是可以多个线程并行扩容的，所以这里要记录参与扩容操作的线程数），也就是说，这里的+2，就表示当前有1个线程在扩容。</div><div class="line"></div><div class="line">最终通过cas把扩容戳转化为如上的数值，他是一个负数，执行cas成功，那么接着在执行扩容操作：  transfer(tab, null);</div></pre></td></tr></table></figure>
<p><strong>需要注意的是chm的扩容是可以多个线程并行扩容的，所以才需要通过sc的低十六位来记录参与扩容操作的线程个数！！！！！！！！！！！！！！</strong></p>
<h4 id="transfer-扩容操作"><a href="#transfer-扩容操作" class="headerlink" title="transfer() 扩容操作"></a>transfer() 扩容操作</h4><p>我们知道扩容操作，要做的事情就两件：</p>
<ul>
<li>增加chm数组的长度</li>
<li>转移原数组的节点到新数组 - 数据转移（这一步支持多个线程同时操作，提升效率）</li>
</ul>
<p>因为方法比较长，所以在这里我们需要进行分段分析。为了方便分析，<strong>我们这里假设chm原数组长度是32</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> n = tab.length, stride;<span class="comment">// n == 32</span></div><div class="line">      <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">          stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></div><div class="line">    <span class="comment">//NCPU是等于电脑cpu核数，我这里是4，所有NCPU=4，这里n还是32，那么stride = (4 &gt; 1) ? (32&gt;&gt;&gt; 3) / 4 : 32 就等于1. 又因为 1 &lt; MIN_TRANSFER_STRIDE,所以if成立，最终stride == 16。表示一个线程可以处理16个数组下标的位置。那么刚好此时数组长度是32，所以这里只需要2个线程进行扩容操作即可。</span></div><div class="line">    </div><div class="line">    </div><div class="line">   <span class="comment">// 也就是表示需要2个线程同时进行扩容操作（最多支持CPU核心数的数量的线程，这里是4，但是因为数组长度是32，每个线程处理16个下标，所以这里只需要2个线程）。那么他们具体是怎么进行协调工作呢？还是分而治之的思路，</span></div><div class="line">   <span class="comment">//我们知道目前chm数组长度是n==32,那么我们这里一共需要2个线程同时进行扩容操作，那么每个线程刚好负责一个数组的16个下标，负责处理转移自己负责的数组下标的node节点数据到新数组。</span></div><div class="line">    </div><div class="line">    <span class="comment">//按道理通过上面的分析，我们可以得到这两个线程负责的数组下标区间，那么线程1负责下标为0-15的数据，线程2负责16-31的数据，转移到新数组。</span></div><div class="line">    </div><div class="line">    <span class="comment">//说了这么多，那么新数组的长度是多少呢？</span></div><div class="line">    </div><div class="line">    </div><div class="line">      <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating初始化新数组，</span></div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">              <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">              Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];<span class="comment">//长度是n&lt;&lt; 1 也即是 32&lt;&lt; 1 等于64，那么也就是说，新数组长度为64位</span></div><div class="line">              nextTab = nt;</div><div class="line">          &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></div><div class="line">              sizeCtl = Integer.MAX_VALUE;</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">          &#125;</div><div class="line">          nextTable = nextTab;</div><div class="line">          transferIndex = n;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">int</span> nextn = nextTab.length;</div><div class="line">      ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">      <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></div></pre></td></tr></table></figure>
<p>​    <strong>通过上面的代码，我们知道可以设置多个线程进行并发的参与扩容操作，那么这么确定每个线程自己负责哪一段的数组下标呢？</strong></p>
<p>接着往下看代码</p>
<p>可以看到这里是通过一个无限循环进行分割，每个线程负责的下标区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</div><div class="line">    Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</div><div class="line">    <span class="keyword">while</span> (advance) &#123;</div><div class="line">        <span class="keyword">int</span> nextIndex, nextBound;</div><div class="line">        <span class="keyword">if</span> (--i &gt;= bound || finishing)</div><div class="line">            advance = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</div><div class="line">            i = -<span class="number">1</span>;</div><div class="line">            advance = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//关键代码在这里，通过cas来确定每个线程负责的数组下标区间</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</div><div class="line">                 (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</div><div class="line">                  nextBound = (nextIndex &gt; stride ?</div><div class="line">                               nextIndex - stride : <span class="number">0</span>))) &#123;<span class="comment">//首先nextIndex== 32，那么32 &gt; 16，所以nextBound = 32-16 == 16，然后cas操作，将TRANSFERINDEX设置为16</span></div><div class="line">            <span class="comment">//首先</span></div><div class="line">            bound = nextBound;<span class="comment">//所以bound = nextBound == 16</span></div><div class="line">            i = nextIndex - <span class="number">1</span>;<span class="comment">//  i == 32-1== 31</span></div><div class="line">            advance = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//那么通过上面的操作，就得到了当前线程所需要的操作的线程区间，那就是（i，bound）=== (31,16)</span></div><div class="line">            <span class="comment">//那么第二个线程进来后，他负责的就是（15,0），跟我们上面的推测一致</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​    </p>
<p><strong>我们知道上面的代码只是确定了线程负责数组区间，但是真正进行数据迁移到新数组的代码还在下面。</strong></p>
<p>​    <strong>首先我们需要明确一点，迁移数据是从数组的后面往前迁移的，`</strong> if (–i &gt;= bound || finishing)<strong>`  由这段代码可以看出，i–的方式从后往前一个一个的迁移</strong></p>
<blockquote>
<p><strong>迁移数据代码</strong></p>
</blockquote>
<p>​    迁移数据的代码块就是在for循环里面的，synchronize代码段。线程在他负责的数组下标区间进行，从后往前的数组下标数据的逐个迁移。最终每个数组的下标的数据，都会拆分成两个链表，高位链表和低位链表（  Node<k,v> ln, hn）。低位链表，可以直接迁移到跟旧数组下标一样的新数组对应的下标的位置（例如链表本来在旧数组i==2的位置，那么迁移到新数组，也还是迁移到下标为2的位置），高位链表，需要迁移到i+n位置（例如旧数组下表是i==2，上面的代码数组长度n就是32，那么迁移到新数组的下标就是32+2 == 34）</k,v></p>
<p>​    形成高低位链表迁移的好处就是，可以批量迁移节点到新数组。如果不怎么做，那么就需要把旧数组下标的链表逐个rehash，然后再逐个放到新数组，这样的效率太慢。</p>
<p>那么为什么低位链表可以直接平移，高位链表移到新数组对应的下标，要用原来的下标+原来数组长度呢？</p>
<p>我们来证明一下：</p>
<p>假设原来数组长度是 n == 16，通过put（“k”,”k”），那么key要通过 <code>hash&amp;(n-1)</code> 算法得到他所属的数组下标，那么key==k的hash值假设等于9.</p>
<p>那么<code>hash&amp;(n-1)</code> 等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hash     0000 1001</div><div class="line">&amp;</div><div class="line">n-1== 15 0000 1111</div><div class="line">==       0000 1001 等于9，也就是key等于k的节点应该归属于数组的9下标位置</div></pre></td></tr></table></figure>
<p>假设n 扩容到 32，那么需要rehash原先在旧数组的值，然后通过<code>hash&amp;(n-1)</code> 算法得到他所属的新数组的下标</p>
<p>那么<code>hash&amp;(n-1)</code> 等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hash     0000 1001</div><div class="line">&amp;</div><div class="line">32-1== 31 0001 1111</div><div class="line">==       0000 1001 等于9，也就是该节点在新数组还是对应下标9.</div></pre></td></tr></table></figure>
<p>所以我们发现低位链表可以直接平移到新数组（因为key的hash的高位都是0，所以计算获取数组下标时，取决于低位）</p>
<p>同理证明高位链表，为什么需要n+i。假设key的hash是20，他的二进制是：0001 0100</p>
<p>那么<code>hash&amp;(n-1)</code> 等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hash     0001 0100</div><div class="line">&amp;</div><div class="line">n-1== 15 0000 1111</div><div class="line">==       0000 0100 等于9</div></pre></td></tr></table></figure>
<p>假设数组扩容到32</p>
<p>那么<code>hash&amp;(n-1)</code> 等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hash      0001 0100</div><div class="line">&amp;</div><div class="line">32-1== 31 0001 1111</div><div class="line">==        0001 0100 等于16+4 == 20，也就是 n+i</div></pre></td></tr></table></figure>
<p><strong>证明完毕</strong></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>​     换句话说，addCount方法的<strong>第一个if代码块</strong>核心就是，进行chm元素个数的自增1。如果在单线程情况下，直接通过对baseCount的cas操作，进行数量的自增1.</p>
<p>​    但是如果存在多个线程进行增加元素个数的操作时，不再使用对baseCount进行cas的方式进行数量增加，进而转化为使用一个counterCells数组的方式，进行分而治之的方式，通过对数组每个下标的cas操作，达到高效率高性能的元素数量自增。</p>
<h3 id="执行到b2-区域-代码块"><a href="#执行到b2-区域-代码块" class="headerlink" title="执行到b2 区域 代码块"></a>执行到b2 区域 代码块</h3><p>如果执行到这部分代码那就表示，当前put操作的key对应的数组下标的位置，已经存在节点。（也就是冲突）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    V oldVal = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">synchronized</span> (f) &#123;<span class="comment">// f就是当前数组下标的节点信息 node，然后锁着这个数组这个位置的节点</span></div><div class="line">        <span class="comment">//可以看到加锁的粒度很细，这样能够拥有更高的性能，这样其他线程仍然能够操作node数组的其他下标节点。保证了当前节点的线程安全</span></div><div class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">            <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                binCount = <span class="number">1</span>;<span class="comment">//当前数组下标，链表的元素个数，这个值，我们知道 在addCount(1L, binCount)，方法会使用，通过他来判断你是否需要扩容</span></div><div class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                    K ek;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((ek = e.key) == key ||</div><div class="line">                         (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                        oldVal = e.val;</div><div class="line">                        <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                            e.val = value;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;<span class="comment">//这个if的作用就是，判断当前插入的节点，的hash，key信息是否相等，如果相等，那么覆盖value值。然后退出当前循环，否则往下执行</span></div><div class="line">                    Node&lt;K,V&gt; pred = e;</div><div class="line">                    <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;<span class="comment">//因为hash和key不同，那么，在当前数组节点，构建一个链表，把新加入的节点，使用单链表连接保存</span></div><div class="line">                        pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                  value, <span class="keyword">null</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                Node&lt;K,V&gt; p;</div><div class="line">                binCount = <span class="number">2</span>;</div><div class="line">                <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                               value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                    oldVal = p.val;</div><div class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                        p.val = value;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">            treeifyBin(tab, i);</div><div class="line">        <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> oldVal;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先来看一下Node节点的数据结构</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200324211514948.png" alt="image-20200324211514948"></p>
<p>​    hash就是当前节点的key的hash值，key和val就是put操作是传入的key和value，原样保存，next就是冲突时，需要构建的单链表指向下一个占据相同数组下标的节点。</p>
<h3 id="什么时候转化为红黑树"><a href="#什么时候转化为红黑树" class="headerlink" title="什么时候转化为红黑树"></a>什么时候转化为红黑树</h3><p>如果链表长度大于8和node数组长度大于64的时候，如果再往当前链表添加数据，那么就会将当前链表转化为红黑树。</p>
<p>如果扩容后，当前数组节点的链表树小于8，他又会把红黑树转化为单链表</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>一下就是chm的核心要点</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200325002730647.png" alt="image-20200325002730647"></p>
<p><a href="https://blog.csdn.net/yyzzhc999/article/details/96724885" target="_blank" rel="external">https://blog.csdn.net/yyzzhc999/article/details/96724885</a></p>
<h1 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 - BlockingQueue"></a>阻塞队列 - BlockingQueue</h1><p>阻塞队列，顾名思义，首先它是一个队列,而一个阻塞队列在数据结构中所起的作用大致如图所示:<br><img src="/2020/03/09/java基础核心技术/1582083684068.png" alt="1582083684068"><br>                                                <strong>线程1往阻塞队列中添加元素二线程2从队列中移除元素</strong></p>
<p><strong>当阻塞队列是空时,从队列中获取元素的操作将会被阻塞.</strong><br><strong>当阻塞队列是满时,往队列中添加元素的操作将会被阻塞.</strong></p>
<p>同样</p>
<p>​    试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他线程从队列中移除一个或者多个元素或者全清空队列后使队列重新变得空闲起来并后续新增。</p>
<h2 id="为什么用-有什么好处"><a href="#为什么用-有什么好处" class="headerlink" title="为什么用?有什么好处?"></a><strong>为什么用?有什么好处?</strong></h2><p>​    在多线程领域：所谓阻塞，在某些情况下会挂起线程(即线程阻塞)，一旦条件满足,被挂起的线程优惠被自动唤醒。</p>
<p>​    <strong>为什么需要使用BlockingQueue，好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为BlockingQueue都一手给你包办好了。</strong></p>
<p>​    <strong>在concurrent包 发布以前,在多线程环境下，我们每个程序员都必须自己去控制这些细节（通过wait和notify），尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</strong></p>
<p>BlockingQueue的结构</p>
<p><img src="/2020/03/09/java基础核心技术/1582084167742.png" alt="1582084167742"></p>
<ul>
<li><p><strong>ArrayBlockingQueue</strong>: 由数组结构组成的有界阻塞队列.</p>
</li>
<li><p><strong>LinkedBlockingDeque</strong>: 由链表结构组成的有界(但大小默认值Integer&gt;MAX_VALUE)阻塞队列.</p>
</li>
<li><p>PriorityBlockingQueue:支持优先级排序的无界阻塞队列.</p>
</li>
</ul>
<ul>
<li>DelayQueue: 使用优先级队列实现的延迟无界阻塞队列.</li>
</ul>
<ul>
<li><p><strong>SynchronousQueue</strong>:不存储元素的阻塞队列,也即是单个元素的队列.</p>
<ul>
<li><p>SynchronousQueue没有容量</p>
<p>与其他BlcokingQueue不同,SynchronousQueue是一个不存储元素的BlcokingQueue</p>
<p>每个put操作必须要等待一个take操作,否则不能继续添加元素,反之亦然.</p>
<p><strong>生产就马上用</strong></p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 阻塞队列SynchronousQueue演示</div><div class="line"> **/</div><div class="line">public class SynchronousQueueDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;();</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t put 1&quot;);</div><div class="line">                blockingQueue.put(&quot;1&quot;);//阻塞，等待take</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t put 2&quot;);</div><div class="line">                blockingQueue.put(&quot;2&quot;);//阻塞，等待take</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t put 3&quot;);</div><div class="line">                blockingQueue.put(&quot;3&quot;);//阻塞，等待take</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;, &quot;AAA&quot;).start();</div><div class="line"></div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            try &#123;</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(5);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + blockingQueue.take());//取出阻塞队列中队列头元素 1。 然后这个时候才能够put（2）</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(5);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + blockingQueue.take());//取出阻塞队列中队列头元素 2。 然后这个时候才能够put（3）</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(5);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + blockingQueue.take());</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;, &quot;BBB&quot;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>输出：</p>
</li>
<li><p>AAA     put 1<br>BBB    1<br>AAA     put 2<br>BBB    2<br>AAA     put 3<br>BBB    3</p>
</li>
<li><p>可以看到，他是生产一个，然后生产线程阻塞，等待消费者，take消费。然后再接着生产。。。。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>LinkedTransferQueue:由链表结构组成的无界阻塞队列.</li>
</ul>
<ul>
<li>LinkedBlockingDeque:由了解结构组成的双向阻塞队列.</li>
</ul>
<h2 id="BlockingQueue的核心方法"><a href="#BlockingQueue的核心方法" class="headerlink" title="BlockingQueue的核心方法"></a>BlockingQueue的核心方法</h2><p><img src="/2020/03/09/java基础核心技术/1582093357161.png" alt="1582093357161"></p>
<p><img src="/2020/03/09/java基础核心技术/1582093389451.png" alt="1582093389451"></p>
<p>实际上，这四组api是适用于不同的应用场景的。</p>
<blockquote>
<p><strong>校验第一组api，使用的时候，会抛出异常。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class BlockingQueueDemo &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);//因为ArrayBlockingQueue是有界的，所有必须传入有界值</div><div class="line">		System.out.println(blockingQueue.add(&quot;a&quot;));</div><div class="line">		System.out.println(blockingQueue.add(&quot;b&quot;));</div><div class="line">		System.out.println(blockingQueue.add(&quot;c&quot;));</div><div class="line">//		System.out.println(blockingQueue.add(&quot;d&quot;));//插入失败，提示java.lang.IllegalStateException: Queue full。因为我们设置的数组长度最大是3.</div><div class="line">		</div><div class="line">/*		System.out.println(blockingQueue.remove());//不指定删除的元素，那么就会默认删除队列头元素</div><div class="line">		System.out.println(blockingQueue.remove());</div><div class="line">		System.out.println(blockingQueue.remove());*/</div><div class="line">//		System.out.println(blockingQueue.remove());//删除失败，因为数组最大长度只允许有三个元素。抛出异常 java.util.NoSuchElementException</div><div class="line">		</div><div class="line">		System.out.println( blockingQueue.element() );//获取队列头元素，不存在则抛出异常-NoSuchElementException</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>校验第二组api</strong></p>
</blockquote>
<p>offer，插入元素，假设插入元素后，数组长度超过了设定的有界值，那么返回false（相比第一组api的add，offer不会抛出异常）</p>
<p>poll，移除元素，同理，要移除的元素不存在则返回null</p>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>生产一个消费一个</p>
<h4 id="wait和notify版本"><a href="#wait和notify版本" class="headerlink" title="wait和notify版本"></a>wait和notify版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.test;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.Condition;</div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 共享资源类</div><div class="line"> */</div><div class="line">class ShareData &#123;</div><div class="line">    private int num = 0;</div><div class="line">    private Lock lock = new ReentrantLock();</div><div class="line">    private Condition condition = lock.newCondition();</div><div class="line"></div><div class="line">    public void increment() throws Exception &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            //判断</div><div class="line">            while (num != 0) &#123;</div><div class="line">                //等待 不生产</div><div class="line">                condition.await();</div><div class="line">            &#125;</div><div class="line">            //干活</div><div class="line">            num++;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);</div><div class="line">            //通知唤醒</div><div class="line">            condition.signalAll();</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void deIncrement() throws Exception &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            //判断</div><div class="line">            while (num == 0) &#123;</div><div class="line">                //等待 不消费</div><div class="line">                condition.await();</div><div class="line">            &#125;</div><div class="line">            //干活</div><div class="line">            num--;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + num);</div><div class="line">            //通知唤醒</div><div class="line">            condition.signalAll();</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * 一个初始值为0的变量 两个线程交替操作 一个加1 一个减1来5轮</div><div class="line"> **/</div><div class="line">public class ProdConsumerTraditionDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ShareData shareData = new ShareData();</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            for (int i = 1; i &lt;= 5; i++) &#123;</div><div class="line">                try &#123;</div><div class="line">                    shareData.increment();</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, &quot;AA&quot;).start();</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            for (int i = 1; i &lt;= 5; i++) &#123;</div><div class="line">                try &#123;</div><div class="line">                    shareData.deIncrement();</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, &quot;BB&quot;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">AA	1</div><div class="line">BB	0</div><div class="line">AA	1</div><div class="line">BB	0</div><div class="line">AA	1</div><div class="line">BB	0</div><div class="line">AA	1</div><div class="line">BB	0</div><div class="line">AA	1</div><div class="line">BB	0</div></pre></td></tr></table></figure>
<h4 id="阻塞队列版"><a href="#阻塞队列版" class="headerlink" title="阻塞队列版"></a>阻塞队列版</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.kingge.test;</div><div class="line"></div><div class="line">import java.util.concurrent.ArrayBlockingQueue;</div><div class="line">import java.util.concurrent.BlockingQueue;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line">import java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line">class MyResource &#123;</div><div class="line">    /**</div><div class="line">     * 默认开启 进行生产消费的交互</div><div class="line">     */</div><div class="line">    private volatile boolean flag = true;</div><div class="line">    /**</div><div class="line">     * 默认值是0</div><div class="line">     */</div><div class="line">    private AtomicInteger atomicInteger = new AtomicInteger();</div><div class="line"></div><div class="line">    private BlockingQueue&lt;String&gt; blockingQueue = null;</div><div class="line"></div><div class="line">    public MyResource(BlockingQueue&lt;String&gt; blockingQueue) &#123;</div><div class="line">        this.blockingQueue = blockingQueue;</div><div class="line">        System.out.println(blockingQueue.getClass().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void myProd() throws Exception &#123;</div><div class="line">        String data = null;</div><div class="line">        boolean returnValue;</div><div class="line">        while (flag) &#123;</div><div class="line">            data = atomicInteger.incrementAndGet() + &quot;&quot;;</div><div class="line">            returnValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);</div><div class="line">            if (returnValue) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t 插入队列数据&quot; + data + &quot;成功&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t 插入队列数据&quot; + data + &quot;失败&quot;);</div><div class="line">            &#125;</div><div class="line">            TimeUnit.SECONDS.sleep(1);//1s生产一个</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 停止 表示 flag&quot; + flag);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void myConsumer() throws Exception &#123;</div><div class="line">        String result = null;</div><div class="line">        while (flag) &#123;</div><div class="line">            result = blockingQueue.poll(2L, TimeUnit.SECONDS);</div><div class="line">            if(null==result||&quot;&quot;.equalsIgnoreCase(result))&#123;</div><div class="line">                flag=false;</div><div class="line">                System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+&quot;超过2m没有取到 消费退出&quot;);</div><div class="line">                System.out.println();</div><div class="line">                System.out.println();</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;消费队列&quot; + result + &quot;成功&quot;);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void stop() throws Exception&#123;</div><div class="line">        flag=false;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * volatile/CAS/atomicInteger/BlockQueue/线程交互/原子引用</div><div class="line"> **/</div><div class="line">public class ProdConsumerBlockQueueDemo &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        MyResource myResource = new MyResource(new ArrayBlockingQueue&lt;&gt;(10));</div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t生产线程启动&quot;);</div><div class="line">            try &#123;</div><div class="line">                myResource.myProd();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;,&quot;Prod&quot;).start();</div><div class="line"></div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;\t消费线程启动&quot;);</div><div class="line">            try &#123;</div><div class="line">                myResource.myConsumer();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;,&quot;consumer&quot;).start();</div><div class="line">        try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</div><div class="line">        System.out.println();</div><div class="line">        System.out.println();</div><div class="line">        System.out.println();</div><div class="line">        System.out.println(&quot;时间到,停止活动&quot;);</div><div class="line">        myResource.stop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java.util.concurrent.ArrayBlockingQueue</div><div class="line">Prod	生产线程启动</div><div class="line">consumer	消费线程启动</div><div class="line">Prod	 插入队列数据1成功</div><div class="line">consumer消费队列1成功</div><div class="line">Prod	 插入队列数据2成功</div><div class="line">consumer消费队列2成功</div><div class="line">Prod	 插入队列数据3成功</div><div class="line">consumer消费队列3成功</div><div class="line">consumer消费队列4成功</div><div class="line">Prod	 插入队列数据4成功</div><div class="line">consumer消费队列5成功</div><div class="line">Prod	 插入队列数据5成功</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">时间到,停止活动</div><div class="line">Prod	 停止 表示 flagfalse</div><div class="line">consumer	超过2m没有取到 消费退出</div></pre></td></tr></table></figure>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>​    通过查看take源码，我们就可以知道，为什么take能够实现阻塞。实际上就是利用了ReentrantLock的condition的await机制，进行阻塞，然后把当前执行take 操作的线程加入到notEmpty的condition等待队列中，然后等待其他线程加入元素后，那么就会执行notEmpty.signal（）方法唤醒在等待队列的take线程，加入到aqs阻塞队列，然后等待获取锁，然后接着执行take操作。</p>
<p><strong>也就是说，阻塞队列，是基于ReentrantLock来实现的。</strong></p>
<h1 id="获取线程的第三种方式-Callable"><a href="#获取线程的第三种方式-Callable" class="headerlink" title="获取线程的第三种方式 - Callable"></a>获取线程的第三种方式 - Callable</h1><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。 </p>
<p>这2种方式都有一个缺陷就是：<strong>在执行完任务之后无法获取执行结果</strong>。 </p>
<p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p>
<blockquote>
<p><strong>Callable和Future介绍</strong></p>
</blockquote>
<p>​    Callable接口代表一段<strong>可以调用并返回结果的代码</strong>。Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p>
<p>​    Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法在线程池中执行Callable内的任务。由于Callable任务是并行的（并行就是整体看上去是并行的，其实在某个时间点只有一个线程在执行），我们必须等待它返回的结果。 </p>
<p>​    java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以<strong>等待Callable结束并获取它的执行结果</strong>。</p>
<p>这里说的是通过实现Callable接口，来创建线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@FunctionalInterface</div><div class="line">public interface Callable&lt;V&gt; &#123;</div><div class="line">    /**</div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * @return computed result</div><div class="line">     * @throws Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    V call() throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>相比实现Runnable的run方法，Callable的call方法，是具备返回值的，而且能够抛出异常。</strong></p>
<p>那么怎么使用呢？跟Runnable一样，传入Thread构造函数中，然后创建实例？</p>
<p>我们查看Thread的构造函数，发现并没有入参是Callable的构造器。</p>
<p><img src="/2020/03/09/java基础核心技术/1582100947354.png" alt="1582100947354"></p>
<p>那么我们这个时候就想，有没有什么接口实现了Runnable接口.</p>
<p><img src="/2020/03/09/java基础核心技术/1582102255142.png" alt="1582102255142"></p>
<p>很明显这里找到了，这个接口或者实现类。通过查看，我们可以得知FutureTask类，既提供了Callable为入参的构造器。</p>
<p><strong>最终示例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CallableDemo implements Callable&lt;Integer&gt;&#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Integer call() throws Exception &#123;</div><div class="line">		System.out.println(&quot;开始执行call 方法&quot;);</div><div class="line">		return 1024;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</div><div class="line">		FutureTask&lt;Integer&gt; futureTask = new  FutureTask&lt;&gt;(new CallableDemo());</div><div class="line">		Thread thread = new Thread(futureTask);</div><div class="line">		thread.start();</div><div class="line">		</div><div class="line">		System.out.println( &quot;获取call方法返回的回执： &quot; + futureTask.get() );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>测试futureTask.get()方法的阻塞性</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class CallableResource implements Callable&lt;Integer&gt;&#123;</div><div class="line"></div><div class="line">	private Long awaitTime;</div><div class="line">	public CallableResource(  Long awaitTime ) &#123;</div><div class="line">		this.awaitTime = awaitTime;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public Integer call() throws Exception &#123;</div><div class="line">		System.out.println( Thread.currentThread().getName() + &quot; 开始执行call 方法&quot;);</div><div class="line">		TimeUnit.SECONDS.sleep(this.awaitTime);</div><div class="line">		return 1024;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class CallableDemo  &#123;</div><div class="line"> public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</div><div class="line">	 FutureTask&lt;Integer&gt; target = new FutureTask&lt;&gt;(new CallableResource(10l));</div><div class="line">       Thread thread = new Thread(target,&quot;AA&quot;);	 </div><div class="line">       thread.start();</div><div class="line">       System.out.println( target.get() );//执行到这里会阻塞，等待十秒后拿到call的返回结果，才往下执行。</div><div class="line">       System.out.println( &quot;执行main线程&quot; );</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>所以说，建议把futuretask.get方法放到最后，不然，一直阻塞，影响其他线程执行。</strong></p>
<h1 id="获取线程的第四种方式：线程池-底层由ThreadPoolExecutor实现"><a href="#获取线程的第四种方式：线程池-底层由ThreadPoolExecutor实现" class="headerlink" title="获取线程的第四种方式：线程池- 底层由ThreadPoolExecutor实现"></a>获取线程的第四种方式：线程池- 底层由ThreadPoolExecutor实现</h1><p>  线程池做的工作主要是控制运行的线程的数量，处理过程中将任务加入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出的数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>他的主要特点为：线程复用，控制最大并发数，管理线程。</p>
<p>第一：降低资源消耗，通过重复利用自己创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>第三：提高线程的可管理性，线程是稀缺资源，如果无限的创建，不仅会消耗资源（JVM的内存管理），还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。</p>
<h2 id="线程池架构实现"><a href="#线程池架构实现" class="headerlink" title="线程池架构实现"></a>线程池架构实现</h2><p>Java中的线程池是通过Executor框架实现的。该框架中用到了Executor,Executors,ExecutorService,ThreadPoolExecutor这几个类.</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200302141610073.png" alt="image-20200302141610073"></p>
<p>其中Executors是工具类，类似于。Arrays、Collections。</p>
<h2 id="编码实现-五种方式创建线程池"><a href="#编码实现-五种方式创建线程池" class="headerlink" title="编码实现 - 五种方式创建线程池"></a>编码实现 - 五种方式创建线程池</h2><h3 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool()"></a><strong>Executors.newScheduledThreadPool()</strong></h3><h3 id="Executors-newWorkStealingPool-int"><a href="#Executors-newWorkStealingPool-int" class="headerlink" title="Executors.newWorkStealingPool(int)"></a><strong>Executors.newWorkStealingPool(int)</strong></h3><p>java8新增,使用目前机器上可以的处理器作为他的并行级别，不常用。</p>
<h3 id="Executors-newFixedThreadPool-int"><a href="#Executors-newFixedThreadPool-int" class="headerlink" title="Executors.newFixedThreadPool(int)"></a><strong>Executors.newFixedThreadPool(int)</strong></h3><p>主要特点如下:<br>1.创建一个<strong>定长线程池</strong>，可控制线程的最大并发数，超出的线程会在队列中等待。<br>2.newFixedThreadPool创建的线程池corePoolSize和MaxmumPoolSize是 相等的,它使用的的LinkedBlockingQueue。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312085301969.png" alt="image-20200312085301969"></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);//设置一个线程个数为5的线程池</div><div class="line">		</div><div class="line">		try &#123;</div><div class="line">			for (int i = 0; i &lt; 10; i++) &#123;//模拟十个用户进行请求</div><div class="line">				fixedThreadPool.submit( () -&gt; &#123;</div><div class="line">					 System.out.println( &quot;使用线程 &quot; +Thread.currentThread().getName() + &quot; 处理业务&quot; );</div><div class="line">				&#125; );</div><div class="line">			&#125;</div><div class="line">		&#125; catch (Exception e) &#123;</div><div class="line">		&#125;finally &#123;</div><div class="line">			fixedThreadPool.shutdown();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div></pre></td></tr></table></figure>
<p>可以看到，不管有多少个请求，最多有五个线程进行交替处理这十个请求。</p>
<h3 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor()"></a>Executors.newSingleThreadExecutor()</h3><p>一个任务一个线程执行的任务场景，线程池中只有一个线程来处理业务。</p>
<p>他就类似于，<strong>Executors.newFixedThreadPool(1)</strong>，不管有多少个请求，线程池内只有一个线程在执行这些请求 。</p>
<p>主要特点如下:<br>1.创建一个单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务都按照指定顺序执行.<br>2.newSingleThreadExecutor将corePoolSize和MaxmumPoolSize都设置为1,它使用的的LinkedBlockingQueue</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312085233353.png" alt="image-20200312085233353"></p>
<h3 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h3><p>这个是一池N线程，也就是，不知道线程池中有多少个线程，当请求过来时，他会自动的创建相应的线程，线程池中的线程不是固定数量，有时候可能创建5个，也有可能创建1个，就看每个线程的执行能力，自动创建。</p>
<p>适用:执行很多短期异步的小程序或者负载较轻的服务器。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312085320578.png" alt="image-20200312085320578"></p>
<p> 主要特点如下:<br>1.创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则创建新线程.<br>2.newCachedThreadPool将corePoolSize设置为0，MaxmumPoolSize设置为Integer.MAX_VALUE,它使用的是SynchronousQUeue,也就是说来了任务就创建线程运行,如果线程空闲超过60秒,就销毁线程</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>可以看到，后面三个线程池的创建，底层代码，都是通过ThreadPoolExecutor进行创建的。</p>
<h2 id="线程池几个重要参数介绍-重要"><a href="#线程池几个重要参数介绍-重要" class="headerlink" title="线程池几个重要参数介绍 - 重要"></a>线程池几个重要参数介绍 - 重要</h2><p>刚才我们看了fixedThreadPool、singleThreadPool、cachedThreadPool发现他们最终的实现都是ThreadPoolExecutor，只有五个参数啊？哪来的七个参数呢？</p>
<p>我们再接着查看ThreadPoolExecutor构造器，发下他内部调用的this就是传递了七个参数。</p>
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
</code></pre><p>再接着看this</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</div><div class="line"> * parameters.</div><div class="line"> *</div><div class="line"> * @param corePoolSize the number of threads to keep in the pool, even</div><div class="line"> *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</div><div class="line"> * @param maximumPoolSize the maximum number of threads to allow in the</div><div class="line"> *        pool</div><div class="line"> * @param keepAliveTime when the number of threads is greater than</div><div class="line"> *        the core, this is the maximum time that excess idle threads</div><div class="line"> *        will wait for new tasks before terminating.</div><div class="line"> * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</div><div class="line"> * @param workQueue the queue to use for holding tasks before they are</div><div class="line"> *        executed.  This queue will hold only the &#123;@code Runnable&#125;</div><div class="line"> *        tasks submitted by the &#123;@code execute&#125; method.</div><div class="line"> * @param threadFactory the factory to use when the executor</div><div class="line"> *        creates a new thread</div><div class="line"> * @param handler the handler to use when execution is blocked</div><div class="line"> *        because the thread bounds and queue capacities are reached</div><div class="line"> * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</div><div class="line"> *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</div><div class="line"> *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</div><div class="line"> *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;</div><div class="line"> *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</div><div class="line"> * @throws NullPointerException if &#123;@code workQueue&#125;</div><div class="line"> *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</div><div class="line"> */</div><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    if (corePoolSize &lt; 0 ||</div><div class="line">        maximumPoolSize &lt;= 0 ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    if (workQueue == null || threadFactory == null || handler == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    this.corePoolSize = corePoolSize;</div><div class="line">    this.maximumPoolSize = maximumPoolSize;</div><div class="line">    this.workQueue = workQueue;</div><div class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    this.threadFactory = threadFactory;</div><div class="line">    this.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p> <strong>corePoolSize:线程池中的常驻核心线程数</strong></p>
</blockquote>
<p>1.在创建了线程池后,当有请求任务来之后,就会安排池中的线程去执行请求任务,近视理解为今日当值线程</p>
<p>2.当线程池中的线程数目达到corePoolSize后,就会把到达的任务放入到缓存队列当中。</p>
<p><strong>通俗来讲，就是，不管你用不用得到，线程池创建后，里面就有corePoolSize个线程在等着你使用。</strong>类似于银行的办事窗口，不管有没有办业务，窗口还是这么多个等着你。</p>
<blockquote>
<p><strong>maximumPoolSize:线程池能够容纳同时执行的最大线程数,此值大于等于1</strong></p>
</blockquote>
<p>也就是说，线程池中，最多最多有maximumPoolSize个线程，已经是峰值了，不能再增加了。<strong>也就是说当corePoolSize不够用了，那么可能增加到maximumPoolSize个线程。</strong>这里说的是，<strong>可能会增加</strong>，但是什么时候增加呢？</p>
<p><strong>答案是：当corePoolSize个线程已经被使用，而且，任务队列（workQueue）中等待执行的任务也已经占满了队列，那么这个时候，如果还有任务请求进来，那么这个时候就会扩展线程到maximumPoolSize个，然后先执行之前在任务队列中阻塞的任务，把后来的任务放到任务队列中继续等待。</strong></p>
<p><strong>但是可能会有个问题，这个时候，又有新的任务进来了，此刻线程已经扩展到maximumPoolSize个，任务队列也已经占满。那么为了避免其他情况的发生，这个时候就需要拒绝后来的任务。这个时候，第七个参数的重要性就来了。handler拒绝策略</strong></p>
<blockquote>
<p><strong>keepAliveTime:多余的空闲线程存活时间。</strong></p>
</blockquote>
<p>当空间时间达到keepAliveTime值时，发现没有任务执行了，那么多余的线程会被销毁直到只剩下corePoolSize个线程为止。</p>
<p>默认情况下:</p>
<p>只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用,直到线程中的线程数不大于corepoolSIze,</p>
<p>​    <strong>这个很好理解，因为创建线程太多（最多maximumPoolSize个）会消耗内存资源，所以我们肯定要有个销毁机制，但是我们又不能全部销毁线程池中的所有线程（创建线程也需要开销），所以我们一般是销毁到corePoolSize个就停止。</strong></p>
<blockquote>
<p><strong>unit</strong>: </p>
</blockquote>
<p>keepAliveTime的单位</p>
<blockquote>
<p><strong>workQueue:任务队列,被提交但尚未被执行的任务.</strong></p>
</blockquote>
<p>这个也很好理解，就是线程不够用了（达到corePoolSize个），那么后面进来的请求，就等待阻塞。这里一般是通过阻塞队列进行实现。</p>
<blockquote>
<p><strong>threadFactory:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般用默认即可</strong></p>
<p><strong>handler:拒绝策略,表示当线程队列满了并且工作线程大于等于线程池的最大 数(maxnumPoolSize)时如何来拒绝.</strong></p>
</blockquote>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>换句话说，corePoolSize是线程池的初始值，如果任务上涨，那么maximumPoolSize和workQueue就是保底策略，当任务还是持续上涨，那么handler拒绝策略是最终解决方案。</p>
<p>反之如果任务从高峰开始下降，那么keepAliveTime和unit就是收尾工作的保证。</p>
<h2 id="线程池的底层工作原理-重要！！！！！！！！！"><a href="#线程池的底层工作原理-重要！！！！！！！！！" class="headerlink" title="线程池的底层工作原理 - 重要！！！！！！！！！"></a>线程池的底层工作原理 - 重要！！！！！！！！！</h2><p><img src="/2020/03/09/java基础核心技术/image-20200311231236281.png" alt="image-20200312095632702"></p>
<p>这张图就是对应了整个线程池七个参数的的使用和执行流程。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312100605462.png" alt="image-20200312100605462"></p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312100651905.png" alt="image-20200312100651905"></p>
<h2 id="线程池用过吗-生产上你是如何设置合理参数"><a href="#线程池用过吗-生产上你是如何设置合理参数" class="headerlink" title="线程池用过吗?生产上你是如何设置合理参数"></a>线程池用过吗?生产上你是如何设置合理参数</h2><h3 id="线程池的拒绝策略请你谈谈"><a href="#线程池的拒绝策略请你谈谈" class="headerlink" title="线程池的拒绝策略请你谈谈"></a>线程池的拒绝策略请你谈谈</h3><blockquote>
<p><strong>拒绝策略什么时候生效？</strong></p>
</blockquote>
<p>等待队列也已经排满了,再也塞不下新的任务了，同时，线程池的max也到达了,无法继续为新任务服务，这时我们需要拒绝策略机制合理的处理这个问题。</p>
<blockquote>
<p><strong>JDK内置的拒绝策略</strong></p>
</blockquote>
<ul>
<li>AbortPolicy(默认):直接抛出RejectedException异常阻止系统正常运行</li>
</ul>
<ul>
<li>CallerRunPolicy:”调用者运行”一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是将某些任务回退到调用者</li>
</ul>
<ul>
<li>DiscardOldestPolicy:抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交。</li>
</ul>
<ul>
<li>DiscardPolicy:直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的一种方案。</li>
</ul>
<p><strong>以上内置策略均实现了RejectExecutionHandler接口。</strong></p>
<h3 id="你在工作中单一的-固定数的-可变你的三种创建线程池的方法-你用哪个多-超级大坑"><a href="#你在工作中单一的-固定数的-可变你的三种创建线程池的方法-你用哪个多-超级大坑" class="headerlink" title="你在工作中单一的/固定数的/可变你的三种创建线程池的方法,你用哪个多?超级大坑"></a>你在工作中单一的/固定数的/可变你的三种创建线程池的方法,你用哪个多?超级大坑</h3><p><strong>正确答案是：一个都不用，我们生产上只能使用自定义的。</strong></p>
<p>参考阿里巴巴java开发手册</p>
<p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 </p>
<p>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明：Executors返回的线程池对象的弊端如下：<br>1）FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。<br>2）CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p>
<h3 id="自定义过线程池使用-并使用拒绝策略"><a href="#自定义过线程池使用-并使用拒绝策略" class="headerlink" title="自定义过线程池使用 - 并使用拒绝策略"></a>自定义过线程池使用 - 并使用拒绝策略</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	</div><div class="line">	ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">			<span class="number">2</span>, <span class="number">5</span>, </div><div class="line">			<span class="number">1</span>, TimeUnit.SECONDS, </div><div class="line">			<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</div><div class="line">	</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</div><div class="line">			poolExecutor.execute( () -&gt; &#123;</div><div class="line">				 System.out.println( <span class="string">"使用线程 "</span> +Thread.currentThread().getName() + <span class="string">" 处理业务"</span> );</div><div class="line">			&#125; );</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;<span class="keyword">finally</span> &#123;</div><div class="line">		poolExecutor.shutdown();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上面代码，我们知道，<strong>线程池最多容纳8个任务（最大值5+阻塞队列3 = 8，5个任务在执行，3个任务在阻塞队列等待）</strong>，那么执行的任务达到9个时候，很明显就会触发拒绝策略。</p>
<p>运行上面代码输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">java.util.concurrent.RejectedExecutionException: Task kingge.CustomThreadPool$$Lambda$1/681842940@2a84aee7 rejected from java.util.concurrent.ThreadPoolExecutor@a09ee92[Running, pool size = 5, active threads = 5, queued tasks = 0, completed tasks = 3]</div><div class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)</div><div class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)</div><div class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)</div><div class="line">	at kingge.CustomThreadPool.main(CustomThreadPool.java:19)</div><div class="line">使用线程 pool-1-thread-5 处理业务</div></pre></td></tr></table></figure>
<p>很明显报了异常RejectedExecutionException。这个就是默认的AbortPolicy策略发出的。</p>
<h4 id="使用CallerRunPolicy策略"><a href="#使用CallerRunPolicy策略" class="headerlink" title="使用CallerRunPolicy策略"></a>使用CallerRunPolicy策略</h4><pre><code>ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(
        2, 5, 
        1, TimeUnit.SECONDS, 
        new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunPolicy());
</code></pre><p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 main 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div></pre></td></tr></table></figure>
<p>你会发现他成功执行了8个任务（这个是符合我们对于线程池的设置），但是我们发现，他并没有报异常，但是输出了这么一行日志<code>使用线程 main 处理业务</code>。</p>
<p>我们再回过头来看一下CallerRunPolicy拒绝策略的定义：</p>
<p><strong>该策略既不会抛弃任务,也不会抛出异常,而是将某些任务回退到调用者</strong>。那么谁是线程调用者？很明显上诉代码中，main线程就是任务的调用者。所以这里让main新成进行了处理</p>
<h4 id="DiscardOldestPolicy拒绝策略"><a href="#DiscardOldestPolicy拒绝策略" class="headerlink" title="DiscardOldestPolicy拒绝策略"></a>DiscardOldestPolicy拒绝策略</h4><p>抛弃队列中等待最久的任务,然后把当前任务加入队列中尝试再次提交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(</div><div class="line">				2, 5, </div><div class="line">				1, TimeUnit.SECONDS, </div><div class="line">				new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy());</div></pre></td></tr></table></figure>
<p>我们发现，他每次只执行8个任务（服务设置），其余两个任务被抛弃，不会抛出异常。</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div></pre></td></tr></table></figure>
<h4 id="DiscardPolicy拒绝策略"><a href="#DiscardPolicy拒绝策略" class="headerlink" title="DiscardPolicy拒绝策略"></a>DiscardPolicy拒绝策略</h4><p>直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的一种方案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(</div><div class="line">		2, 5, </div><div class="line">		1, TimeUnit.SECONDS, </div><div class="line">		new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardPolicy());</div></pre></td></tr></table></figure>
<p>他的运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-2 处理业务</div><div class="line">使用线程 pool-1-thread-3 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-4 处理业务</div><div class="line">使用线程 pool-1-thread-1 处理业务</div><div class="line">使用线程 pool-1-thread-5 处理业务</div></pre></td></tr></table></figure>
<p>他跟DiscardOldestPolicy策略类似，只不过DiscardOldestPolicy是从阻塞队列中抛弃长时间的任务，而，DiscardPolicy是从一开始就抛弃多余任务，压根就没进阻塞队列。</p>
<h3 id="合理配置线程池你是如何考虑的"><a href="#合理配置线程池你是如何考虑的" class="headerlink" title="合理配置线程池你是如何考虑的?"></a>合理配置线程池你是如何考虑的?</h3><p>首先查看CPU核数</p>
<blockquote>
<p><strong>CPU密集型</strong></p>
</blockquote>
<p>System.out.println(Runtime.getRuntime().availableProcessors());查看CPU核数</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312113121360.png" alt="image-20200312113121360"></p>
<blockquote>
<p><strong>IO密集型</strong></p>
</blockquote>
<p><img src="/2020/03/09/java基础核心技术/image-20200312113143163.png" alt="image-20200312113143163"></p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312113152044.png" alt="image-20200312113152044"></p>
<h2 id="如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？"><a href="#如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？" class="headerlink" title="如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？"></a>如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？</h2><p>阻塞队列中的请求，都是存放在内存中的，那么如果机器宕机，那么队列中的请求必然会丢失。那么怎么解决呢？</p>
<p>第一反应，应该就是，本地化，保存到本地硬盘（例如数据库等等）</p>
<p><strong>解决方案：</strong></p>
<p>  如果你要提交一个任务到线程池之前，先把任务的信息，保存到数据库中，并更新他的状态（未提交，已提交，已完成），提交成功后，他的状态修改为已提交。</p>
<p>假设机器宕机，那么当机器重启后，系统启动，后台线程可以去扫描数据库中的数据，然后把未提交和已提交的任务拿出来，再次重新提交到线程池中，继续执行</p>
<h1 id="死锁编码及定位分析"><a href="#死锁编码及定位分析" class="headerlink" title="死锁编码及定位分析"></a>死锁编码及定位分析</h1><p><img src="/2020/03/09/java基础核心技术/image-20200312114117435.png" alt="image-20200312114117435"></p>
<p>产生死锁的主要原因：系统资源不足、进程运行推进的顺序不合适、资源分配不当。</p>
<p>代码实现死锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package kingge;</div><div class="line"></div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line">class HoldThread implements Runnable &#123;</div><div class="line"></div><div class="line">    private String lockA;</div><div class="line">    private String lockB;</div><div class="line"></div><div class="line">    public HoldThread(String lockA, String lockB) &#123;</div><div class="line">        this.lockA = lockA;</div><div class="line">        this.lockB = lockB;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        synchronized (lockA) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 自己持有锁&quot; + lockA + &quot;尝试获得&quot; + lockB);</div><div class="line">            try &#123;</div><div class="line">                TimeUnit.SECONDS.sleep(1);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            synchronized (lockB) &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t 自己持有锁&quot; + lockB + &quot;尝试获得&quot; + lockA);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Description:</div><div class="line"> * 死锁是指两个或者以上的进程在执行过程中,</div><div class="line"> * 因争夺资源而造成的一种相互等待的现象,</div><div class="line"> * 若无外力干涉那他们都将无法推进下去</div><div class="line"> **/</div><div class="line">public class DeadLockDemo &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String lockA = &quot;lockA&quot;;</div><div class="line">        String lockB = &quot;lockB&quot;;</div><div class="line">        new Thread(new HoldThread(lockA, lockB), &quot;threadAAA&quot;).start();</div><div class="line">        new Thread(new HoldThread(lockB, lockA), &quot;threadBBB&quot;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序：</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200312115119402.png" alt="image-20200312115119402"></p>
<p>你会发现程序卡死在这里</p>
<h2 id="解决死锁-重要！！！！"><a href="#解决死锁-重要！！！！" class="headerlink" title="解决死锁 - 重要！！！！"></a>解决死锁 - 重要！！！！</h2><blockquote>
<p><strong>1.jps命令定位进程编号</strong></p>
</blockquote>
<p>获取死锁程序的进程编号- 使用 jps -l </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">King哥@JeremyKing MINGW64 ~/Desktop</div><div class="line">$ jps -l</div><div class="line">9268 kingge.DeadLockDemo</div><div class="line">7736</div><div class="line">10908 sun.tools.jps.Jps</div></pre></td></tr></table></figure>
<p>可以知道是9268</p>
<blockquote>
<p><strong>2.jstack找到死锁查看</strong></p>
</blockquote>
<p>使用命令 ： jstack 9268</p>
<p>查看输出日志可以得到：</p>
<p><img src="/2020/03/09/java基础核心技术/学习总结\java基础核心技术\java基础核心技术\image-20200312115529333.png" alt="image-20200312115529333"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Java stack information for the threads listed above:</div><div class="line">===================================================</div><div class="line">&quot;threadBBB&quot;:</div><div class="line">        at kingge.HoldThread.run(DeadLockDemo.java:25)</div><div class="line">        - waiting to lock &lt;0x00000000d5c9b7e0&gt; (a java.lang.String)</div><div class="line">        - locked &lt;0x00000000d5c9b818&gt; (a java.lang.String)</div><div class="line">        at java.lang.Thread.run(Thread.java:745)</div><div class="line">&quot;threadAAA&quot;:</div><div class="line">        at kingge.HoldThread.run(DeadLockDemo.java:25)</div><div class="line">        - waiting to lock &lt;0x00000000d5c9b818&gt; (a java.lang.String)</div><div class="line">        - locked &lt;0x00000000d5c9b7e0&gt; (a java.lang.String)</div><div class="line">        at java.lang.Thread.run(Thread.java:745)</div><div class="line"></div><div class="line">Found 1 deadlock.</div></pre></td></tr></table></figure>
<p>可以看到 threadBBB 锁着0x00000000d5c9b818，等待0x00000000d5c9b7e0。然而threadAAA锁着0x00000000d5c9b7e0，等待0x00000000d5c9b818。就是死锁。</p>
<h1 id="缓存的重要性"><a href="#缓存的重要性" class="headerlink" title="缓存的重要性"></a>缓存的重要性</h1><p>缓存就是利用了<strong>局部性原理</strong>实现了数据的高效读取。局部性原理包括<strong>时间局部性</strong>（temporal locality）和<strong>空间局部性</strong>（spatial locality）这两种策略。</p>
<p>​    在实际的计算机日常的开发和应用中，我们对于<strong>数据的访问总是会存在一定的局部性</strong>。有时候，这个局部性是<strong>时间局部性</strong>，就是我们最近访问过的数据还会被反复访问。有时候，这个局部性是<strong>空间局部性</strong>，就是我们最近访问过数据附近的数据很快会被访问到。</p>
<p>​    而局部性的存在，使得我们可以在应用开发中<strong>使用缓存</strong>这个有利的武器。比如，通过将热点数据加载并保留在速度更快的存储设备里面，我们可以用更低的成本来支撑服务器。</p>
<p><img src="/2020/03/09/java基础核心技术/image-20200318145712228.png" alt="image-20200318145712228"></p>
<h1 id="序列化和反序列化原理分析"><a href="#序列化和反序列化原理分析" class="headerlink" title="序列化和反序列化原理分析"></a>序列化和反序列化原理分析</h1><p>设么叫序列化：把存储在内存中的数据，保存到本地硬盘或者传输</p>
<p>trensiant：修饰某个属性，目的就是阻止这个属性进行序列化</p>
<p>那么为什么会存在writeObject和readObject？这两个方法就是序列化和反序列化调用的方法。</p>
<p>可以通过这个方法制订序列化和反序列化规则，例如某个字段虽然被trensiant修饰，但是我们可以在writeObejct方法中对这个字段打破trensiant的作用，也就是，可以序列化。让trensiant失效</p>
<p>java原生序列化，需要实现接口，Serializable。同时建议制订一个serialVersionUID，目的就是给序列化的对象加个版本号，也就是说我当前序列化这个对象的版本是serialVersionUID，那么你反序列化的时候，也要是这个serialVersionUID，一模一样，如果你修改了这个值serialVersionUID，再去反序列化那么就会报异常。，这样保证了数据的安全性。</p>
<p>​    <strong>如果不指定serialVersionUID，默认会生成一个，但是建议制订。避免后面来的开发人员，发现，咦，你这个要序列化的类竟然没有制订serialVersionUID，那么他随手给你加上了，导致，下次反序列化的时候，发现版本号不一致（默认生成的serialVersionUID跟后来人加上的serialVersionUID，不相等），反序列化失败，对象数据就拿不到了。</strong></p>
<p>现在常用的序列化格式有，json，xml，hessian等等</p>
<p>xml的好处是：阅读性强，可以保存更多的东西，例如类名，等等。缺点是，序列化后很大，占据的空间多</p>
<p>json，就是比较轻量级，类似{name:”King哥”,age:12} 这样的格式，好处就是轻量级，传输所需要的带宽少，缺点就是不能够携带更多的信息。</p>
<p>所以具体选择哪种序列化手段，得看你具体业务场景，和你对带宽的要求</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>如果你感觉文章对你又些许感悟，你可以支持我！！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/wechatpay.png" alt="Jeremy Kinge WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/uploads/alipay.png" alt="Jeremy Kinge Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
	
	<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/动态代理/" rel="tag"><i class="fa fa-tag"></i> 动态代理</a>
          
            <a href="/tags/juc/" rel="tag"><i class="fa fa-tag"></i> juc</a>
          
            <a href="/tags/对象头/" rel="tag"><i class="fa fa-tag"></i> 对象头</a>
          
            <a href="/tags/chm/" rel="tag"><i class="fa fa-tag"></i> chm</a>
          
            <a href="/tags/cas/" rel="tag"><i class="fa fa-tag"></i> cas</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/05/jmeter使用总结/" rel="next" title="jmeter压测工具使用总结">
                <i class="fa fa-chevron-left"></i> jmeter压测工具使用总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/19/教你摸清线上系统的JVM运行情况/" rel="prev" title="教你摸清线上系统的JVM运行情况">
                教你摸清线上系统的JVM运行情况 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微薄</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDUxMS83MDY1"></div>
    
  </div>


      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDUxMS83MDY1"></div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Jeremy Kinge" />
          <p class="site-author-name" itemprop="name">Jeremy Kinge</p>
           
              <p class="site-description motion-element" itemprop="description">To know everything, no words don't talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">71</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">116</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JeremyKinge" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/LJBANANABLUE?s=09" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://m.weibo.cn/u/3991058874?from=1078095010&wm=20005_0002&sourceType=qq&uid=3991058874" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/profile.php?id=100010100689349" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="StackOverflow">
                  
                    <i class="fa fa-fw fa-stack-overflow"></i>
                  
                    
                      StackOverflow
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://xiezejingzhazha.blog.163.com/" target="_blank" title="网易博客">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                    
                      网易博客
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

		<div id="music163player">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=451768026&auto=0&height=66"></iframe>
</div>
		
        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#String"><span class="nav-number">1.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是字面值？"><span class="nav-number">1.1.</span> <span class="nav-text">什么是字面值？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stringbuffer和Stringbuilder"><span class="nav-number">1.2.</span> <span class="nav-text">Stringbuffer和Stringbuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Exception和Error有什么区别？"><span class="nav-number">2.</span> <span class="nav-text">Exception和Error有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#你了解哪些-Error、Exception-或者-RuntimeException？"><span class="nav-number">2.1.</span> <span class="nav-text">你了解哪些 Error、Exception 或者 RuntimeException？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-with-resources-自动关闭资源"><span class="nav-number">2.2.</span> <span class="nav-text">try-with-resources 自动关闭资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#知识扩展"><span class="nav-number">2.3.</span> <span class="nav-text">知识扩展</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#强引用、软引用、弱引用、幻象引用有什么区别？"><span class="nav-number">3.</span> <span class="nav-text">强引用、软引用、弱引用、幻象引用有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态代理和反射是基于什么原理？"><span class="nav-number">4.</span> <span class="nav-text">动态代理和反射是基于什么原理？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#静态代理"><span class="nav-number">4.1.</span> <span class="nav-text">静态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">4.1.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚合"><span class="nav-number">4.1.2.</span> <span class="nav-text">聚合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态代理"><span class="nav-number">4.2.</span> <span class="nav-text">动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-动态代理"><span class="nav-number">4.2.1.</span> <span class="nav-text">JDK 动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么实现同一个接口是实现jdk动态代理的基础"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">为什么实现同一个接口是实现jdk动态代理的基础</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGLIB动态代理"><span class="nav-number">4.2.2.</span> <span class="nav-text">CGLIB动态代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">4.2.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么面试会问？"><span class="nav-number">4.3.</span> <span class="nav-text">为什么面试会问？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java反射"><span class="nav-number">4.4.</span> <span class="nav-text">java反射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-hashCode-和-equals-的若干问题解答"><span class="nav-number">5.</span> <span class="nav-text">Java hashCode() 和 equals()的若干问题解答</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Comparable和Comparator"><span class="nav-number">6.</span> <span class="nav-text">Comparable和Comparator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMM内存模型"><span class="nav-number">7.</span> <span class="nav-text">JMM内存模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Volatile"><span class="nav-number">8.</span> <span class="nav-text">Volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#那么volatile是怎么保证可见性（数据一致性）呢？"><span class="nav-number">8.1.</span> <span class="nav-text">那么volatile是怎么保证可见性（数据一致性）呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#验证volatile不支持原子性"><span class="nav-number">8.2.</span> <span class="nav-text">验证volatile不支持原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决方式"><span class="nav-number">8.2.1.</span> <span class="nav-text">解决方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile怎么禁止指令重排序？"><span class="nav-number">8.3.</span> <span class="nav-text">volatile怎么禁止指令重排序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#你在哪些地方用到过volatile"><span class="nav-number">8.4.</span> <span class="nav-text">你在哪些地方用到过volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">8.4.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MESI-cpu缓存一致性协议！！！重要！！！！保证了可见性"><span class="nav-number">8.5.</span> <span class="nav-text">MESI  cpu缓存一致性协议！！！重要！！！！保证了可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总线嗅探机制和-MESI-协议"><span class="nav-number">8.5.1.</span> <span class="nav-text">总线嗅探机制和 MESI 协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试中如果问到你对volatile的理解？"><span class="nav-number">8.6.</span> <span class="nav-text">面试中如果问到你对volatile的理解？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized的对象头核心知识"><span class="nav-number">9.</span> <span class="nav-text">synchronized的对象头核心知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-obj-到底锁的是什么-？-对象头"><span class="nav-number">9.1.</span> <span class="nav-text">synchronized(obj)到底锁的是什么 ？ - 对象头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java对象的布局-计算对象大小"><span class="nav-number">9.2.</span> <span class="nav-text">java对象的布局 - 计算对象大小</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总结一下"><span class="nav-number">9.2.1.</span> <span class="nav-text">总结一下</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象头的构成"><span class="nav-number">9.3.</span> <span class="nav-text">对象头的构成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检验kclass-pointer未压缩前大小是否是8个字节"><span class="nav-number">9.3.1.</span> <span class="nav-text">检验kclass pointer未压缩前大小是否是8个字节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#markword构成"><span class="nav-number">9.4.</span> <span class="nav-text">markword构成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟偏向锁和轻量级锁对象头"><span class="nav-number">9.4.1.</span> <span class="nav-text">模拟偏向锁和轻量级锁对象头</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么不是偏向锁"><span class="nav-number">9.4.1.1.</span> <span class="nav-text">为什么不是偏向锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较偏向锁和轻量级锁性能"><span class="nav-number">9.4.2.</span> <span class="nav-text">比较偏向锁和轻量级锁性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重量级锁"><span class="nav-number">9.4.3.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁的epoch作用"><span class="nav-number">9.4.4.</span> <span class="nav-text">偏向锁的epoch作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁升级过程"><span class="nav-number">9.5.</span> <span class="nav-text">锁升级过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#好的相关文档"><span class="nav-number">9.6.</span> <span class="nav-text">好的相关文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题外话：Java中boolean类型占几个字节，你知道吗？"><span class="nav-number">9.7.</span> <span class="nav-text">题外话：Java中boolean类型占几个字节，你知道吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cas是什么-无锁并发安全实现-轻量级锁"><span class="nav-number">10.</span> <span class="nav-text">cas是什么 - 无锁并发安全实现 - 轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AtomicInteger的CAS底层原理"><span class="nav-number">10.1.</span> <span class="nav-text">AtomicInteger的CAS底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#那么cas到底是怎么保证了并发问题？"><span class="nav-number">10.1.1.</span> <span class="nav-text">那么cas到底是怎么保证了并发问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么使用cas不使用synchronized？"><span class="nav-number">10.1.2.</span> <span class="nav-text">为什么使用cas不使用synchronized？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AtomicReference-实现对象的资源保护"><span class="nav-number">10.2.</span> <span class="nav-text">AtomicReference 实现对象的资源保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS缺点"><span class="nav-number">10.3.</span> <span class="nav-text">CAS缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#atomic包下的工具类，都是基于CAS实现线程安全"><span class="nav-number">10.4.</span> <span class="nav-text">atomic包下的工具类，都是基于CAS实现线程安全</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ArrayList线程不安全解决"><span class="nav-number">11.</span> <span class="nav-text">ArrayList线程不安全解决</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#同理hashset和hashmap也是线程不安全的"><span class="nav-number">11.1.</span> <span class="nav-text">同理hashset和hashmap也是线程不安全的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap源码解析"><span class="nav-number">12.</span> <span class="nav-text">HashMap源码解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#公平锁-非公平锁-可重入锁-递归锁-自旋锁谈谈你的理解-请手写一个自旋锁"><span class="nav-number">13.</span> <span class="nav-text">公平锁/非公平锁/可重入锁/递归锁/自旋锁谈谈你的理解?请手写一个自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#公平锁和非公平锁"><span class="nav-number">13.1.</span> <span class="nav-text">公平锁和非公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可重入锁-又名递归锁"><span class="nav-number">13.2.</span> <span class="nav-text">可重入锁(又名递归锁)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自旋锁-似锁非锁"><span class="nav-number">13.3.</span> <span class="nav-text">自旋锁 似锁非锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现一个自旋锁"><span class="nav-number">13.3.1.</span> <span class="nav-text">实现一个自旋锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#独占锁-写锁-共享锁-读锁-互斥锁"><span class="nav-number">13.4.</span> <span class="nav-text">独占锁(写锁)/共享锁(读锁)/互斥锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CountDownLatch-CyclicBarrier-Semaphore"><span class="nav-number">14.</span> <span class="nav-text">CountDownLatch/CyclicBarrier/Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">14.1.</span> <span class="nav-text">CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">14.1.1.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">14.1.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">14.2.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore-可以用作限流"><span class="nav-number">14.3.</span> <span class="nav-text">Semaphore - 可以用作限流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析-1"><span class="nav-number">14.3.1.</span> <span class="nav-text">源码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ConcurrentHashMap源码分析"><span class="nav-number">15.</span> <span class="nav-text">ConcurrentHashMap源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查看put操作"><span class="nav-number">15.1.</span> <span class="nav-text">查看put操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initTable数组初始化工作-sizeCtl属性"><span class="nav-number">15.1.1.</span> <span class="nav-text">initTable数组初始化工作 - sizeCtl属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tabat和casTabAt，获取key对应的数组下标"><span class="nav-number">15.1.2.</span> <span class="nav-text">tabat和casTabAt，获取key对应的数组下标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addCount-1L-binCount-最终执行"><span class="nav-number">15.1.3.</span> <span class="nav-text">addCount(1L, binCount) 最终执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fullAddCount（）初始化counterCells数组"><span class="nav-number">15.1.3.1.</span> <span class="nav-text">fullAddCount（）初始化counterCells数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#resizeStamp-扩容操作"><span class="nav-number">15.1.3.2.</span> <span class="nav-text">resizeStamp() 扩容操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transfer-扩容操作"><span class="nav-number">15.1.3.3.</span> <span class="nav-text">transfer() 扩容操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-3"><span class="nav-number">15.1.3.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行到b2-区域-代码块"><span class="nav-number">15.1.4.</span> <span class="nav-text">执行到b2 区域 代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候转化为红黑树"><span class="nav-number">15.1.5.</span> <span class="nav-text">什么时候转化为红黑树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-4"><span class="nav-number">15.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#阻塞队列-BlockingQueue"><span class="nav-number">16.</span> <span class="nav-text">阻塞队列 - BlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么用-有什么好处"><span class="nav-number">16.1.</span> <span class="nav-text">为什么用?有什么好处?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue的核心方法"><span class="nav-number">16.2.</span> <span class="nav-text">BlockingQueue的核心方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用案例"><span class="nav-number">16.3.</span> <span class="nav-text">使用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者模式"><span class="nav-number">16.3.1.</span> <span class="nav-text">生产者消费者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait和notify版本"><span class="nav-number">16.3.1.1.</span> <span class="nav-text">wait和notify版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞队列版"><span class="nav-number">16.3.1.2.</span> <span class="nav-text">阻塞队列版</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-5"><span class="nav-number">16.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#获取线程的第三种方式-Callable"><span class="nav-number">17.</span> <span class="nav-text">获取线程的第三种方式 - Callable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#获取线程的第四种方式：线程池-底层由ThreadPoolExecutor实现"><span class="nav-number">18.</span> <span class="nav-text">获取线程的第四种方式：线程池- 底层由ThreadPoolExecutor实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池架构实现"><span class="nav-number">18.1.</span> <span class="nav-text">线程池架构实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码实现-五种方式创建线程池"><span class="nav-number">18.2.</span> <span class="nav-text">编码实现 - 五种方式创建线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors-newScheduledThreadPool"><span class="nav-number">18.2.1.</span> <span class="nav-text">Executors.newScheduledThreadPool()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors-newWorkStealingPool-int"><span class="nav-number">18.2.2.</span> <span class="nav-text">Executors.newWorkStealingPool(int)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors-newFixedThreadPool-int"><span class="nav-number">18.2.3.</span> <span class="nav-text">Executors.newFixedThreadPool(int)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors-newSingleThreadExecutor"><span class="nav-number">18.2.4.</span> <span class="nav-text">Executors.newSingleThreadExecutor()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors-newCachedThreadPool"><span class="nav-number">18.2.5.</span> <span class="nav-text">Executors.newCachedThreadPool()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-6"><span class="nav-number">18.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池几个重要参数介绍-重要"><span class="nav-number">18.3.</span> <span class="nav-text">线程池几个重要参数介绍 - 重要</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-7"><span class="nav-number">18.3.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的底层工作原理-重要！！！！！！！！！"><span class="nav-number">18.4.</span> <span class="nav-text">线程池的底层工作原理 - 重要！！！！！！！！！</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池用过吗-生产上你是如何设置合理参数"><span class="nav-number">18.5.</span> <span class="nav-text">线程池用过吗?生产上你是如何设置合理参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的拒绝策略请你谈谈"><span class="nav-number">18.5.1.</span> <span class="nav-text">线程池的拒绝策略请你谈谈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你在工作中单一的-固定数的-可变你的三种创建线程池的方法-你用哪个多-超级大坑"><span class="nav-number">18.5.2.</span> <span class="nav-text">你在工作中单一的/固定数的/可变你的三种创建线程池的方法,你用哪个多?超级大坑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义过线程池使用-并使用拒绝策略"><span class="nav-number">18.5.3.</span> <span class="nav-text">自定义过线程池使用 - 并使用拒绝策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用CallerRunPolicy策略"><span class="nav-number">18.5.3.1.</span> <span class="nav-text">使用CallerRunPolicy策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DiscardOldestPolicy拒绝策略"><span class="nav-number">18.5.3.2.</span> <span class="nav-text">DiscardOldestPolicy拒绝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DiscardPolicy拒绝策略"><span class="nav-number">18.5.3.3.</span> <span class="nav-text">DiscardPolicy拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合理配置线程池你是如何考虑的"><span class="nav-number">18.5.4.</span> <span class="nav-text">合理配置线程池你是如何考虑的?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？"><span class="nav-number">18.6.</span> <span class="nav-text">如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#死锁编码及定位分析"><span class="nav-number">19.</span> <span class="nav-text">死锁编码及定位分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解决死锁-重要！！！！"><span class="nav-number">19.1.</span> <span class="nav-text">解决死锁 - 重要！！！！</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缓存的重要性"><span class="nav-number">20.</span> <span class="nav-text">缓存的重要性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列化和反序列化原理分析"><span class="nav-number">21.</span> <span class="nav-text">序列化和反序列化原理分析</span></a></li></ol></div>
            

          </div>
		  

		  
        </section>
      <!--/noindex-->
      

      

    </div>
	

	
  </aside>
  

  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2022 &mdash; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeremy Kinge</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">
      458.0k
    </span>
  
</div>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">
  
</div>



  <span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span class="post-meta-divider">|</span>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共458.0k字</span>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  




  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
