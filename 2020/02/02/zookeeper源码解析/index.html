<!DOCTYPE html>



  




<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('OOPS, 主人请输入文章密码才能够观看哟') !== ''){
                alert('哎呀，密码错误哟！');
                history.back();
            }
        }
    })();
</script>


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|40:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="zookeeper,zk源码，顺序一致性," />





  <link rel="alternate" href="/atom.xml" title="King哥" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="zk集群角色leader：负责进行投票的发起和决议，最终更新状态。 follower：用于接收客户请求，并返回结果。参与竞争leader的投票。 observer：可以接收客户的请求，将写请求转发给leader节点，但是observer不参与投票，只是同步leader的状态（同步leader的数据）。observer是作为系统扩展节点。 learner：和leader进行状态同步的server统称">
<meta name="keywords" content="zookeeper,zk源码，顺序一致性">
<meta property="og:type" content="article">
<meta property="og:title" content="zookeeper源码解析">
<meta property="og:url" content="http://kingge.top/2020/02/02/zookeeper源码解析/index.html">
<meta property="og:site_name" content="King哥">
<meta property="og:description" content="zk集群角色leader：负责进行投票的发起和决议，最终更新状态。 follower：用于接收客户请求，并返回结果。参与竞争leader的投票。 observer：可以接收客户的请求，将写请求转发给leader节点，但是observer不参与投票，只是同步leader的状态（同步leader的数据）。observer是作为系统扩展节点。 learner：和leader进行状态同步的server统称">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200408144623344.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200408161037598.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200409083750078.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200409085351851.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200409113142773.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200409153236451.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200409113142773.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-2020041210123330920.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200413205835549.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200413110859408.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200413115911137.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200413143508887.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200408115045686.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200408115408050.png">
<meta property="og:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200408141112408.png">
<meta property="og:updated_time" content="2020-05-09T09:16:41.556Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zookeeper源码解析">
<meta name="twitter:description" content="zk集群角色leader：负责进行投票的发起和决议，最终更新状态。 follower：用于接收客户请求，并返回结果。参与竞争leader的投票。 observer：可以接收客户的请求，将写请求转发给leader节点，但是observer不参与投票，只是同步leader的状态（同步leader的数据）。observer是作为系统扩展节点。 learner：和leader进行状态同步的server统称">
<meta name="twitter:image" content="http://kingge.top/2020/02/02/zookeeper源码解析/image-20200408144623344.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://kingge.top/2020/02/02/zookeeper源码解析/"/>





  <title>zookeeper源码解析 | King哥</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">King哥</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">To know everything, no words don't talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-picture">
          <a href="/picture/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            照片
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kingge.top/2020/02/02/zookeeper源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeremy Kinge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">zookeeper源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-02T19:12:44+08:00">
                2020-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/zookeeper/" itemprop="url" rel="index">
                    <span itemprop="name">zookeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  32,790
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  139
                </span>
              
            </div>
          

          

		  
		  
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="zk集群角色"><a href="#zk集群角色" class="headerlink" title="zk集群角色"></a>zk集群角色</h1><p>leader：负责进行投票的发起和决议，最终更新状态。</p>
<p>follower：用于接收客户请求，并返回结果。参与竞争leader的投票。</p>
<p>observer：可以接收客户的请求，将写请求转发给leader节点，但是<strong>observer不参与投票</strong>，只是同步leader的状态（同步leader的数据）。observer是作为系统扩展节点。</p>
<p>learner：和leader进行状态同步的server统称为学习者。例如上面的跟随者和观察者都是learner。</p>
<h2 id="为什么需要observer"><a href="#为什么需要observer" class="headerlink" title="为什么需要observer"></a>为什么需要observer</h2><p>​    如果我们想增加follower来进行应对多客户的请求，那么会有个问题，那么就是follower是会参与leader的投票的，增加了服务器的数量，意味着，增加了zab协议中投票过程的压力，从而使得zk集群的不可用时间增加。</p>
<p>​    因为leader节点必须等待集群中过半server响应投票，于是节点的增加使得部分计算机运行缓慢，从而拖慢整个投票过程的可能性也随着提高。写操作效率也会下降。zk集群的不断增大，但是写操作的吞吐量反而下降，这就违背了我们的意愿。</p>
<p>​    <strong>那么我们就需要增加一种跟follower不同的server，他是不参与投票的。那么这个就是observer。</strong></p>
<p>也就是说observer除了不参与投票外，他跟follower是一样的。</p>
<blockquote>
<p><strong>zk集群配置observer</strong></p>
</blockquote>
<p>zoo.cfg文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">peerType=observer</div><div class="line">server.4=0.0.0.0:2888:3888:observer</div></pre></td></tr></table></figure>
<p>然后启动就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ./zkServer.sh status</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: J:\JavaSoftwareRuntime\apache-zookeeper-3.5.7-bin\conf\zoo.cfg</div><div class="line">Client port found: 2181. Client address: localhost.</div><div class="line">Mode: observer</div></pre></td></tr></table></figure>
<h2 id="怎么保证一致性"><a href="#怎么保证一致性" class="headerlink" title="怎么保证一致性"></a>怎么保证一致性</h2><p>​    zk集群中的所有server都可以接受客户的请求，如果是读请求，那么当前server直接处理并返回结果，但是如果是写请求，那么当前server节点需要转发请求给leader进行处理。这个协议就是我们所说的<strong>zab协议。</strong></p>
<p>​    简答来说，zab协议规定，来自客户端的所有写请求，都要转发给zk集群中的唯一一台leader处理，有leader根据该请求发起一个proposal，收到proposal的server进行投票，之后返回结果给leader，leader收集结果。当投票结果过半时leader会向所有的server发送一个通知请求。</p>
<p>​    最后server收到请求后，会把该操作更新到内存中，完成写请求。然后返回结果给客户端。</p>
<p>​    zk满足了CAP原则中的CP。比如现在集群中有Leader和Follower两种角色，那么当其中任意一台服务器挂掉了，都要重新进行选举，在选举过程中，集群是不可用的，这就是牺牲了可用性。</p>
<p>​     但是，如果集群中有Leader、Follower、Observer三种角色，那么如果挂掉的是Observer，那么对于集群来说 并没有影响，集群还是可以用的，只是Observer节点的数据不同了，从这个角度考虑，Zookeeper又牺牲了 一致性，满足了AP。</p>
<p>需要注意的是：<strong>zk并不能够保证强一致性（在某个时刻，任意客户端读取到的数据都是一样的），它能够保证在一定时间范围内数据是一致的。他保证了顺序一致性。（至于为为什么，请看下面的源码分析）</strong></p>
<h1 id="zk的ACL节点权限"><a href="#zk的ACL节点权限" class="headerlink" title="zk的ACL节点权限"></a>zk的ACL节点权限</h1><p>在实际开发中，某些zk 的节点，我们不允许其他人任意的修改和删除，所以需要个特定的节点添加权限，保证节点的安全。</p>
<p>其特性如下：</p>
<ol>
<li>ZooKeeper的权限控制是基于<strong>每个znode节点的，需要对每个节点设置权限</strong>。</li>
<li>每个znode支持设置多种权限控制方案和多个权限</li>
<li><strong>子节点不会继承父节点的权限</strong>，客户端无权访问某节点，但可能可以访问它的子节点。</li>
</ol>
<p><strong>zk支持准确的控制某个节点的权限，权限的设置也仅仅只是对当前节点生效。</strong></p>
<blockquote>
<p><strong>zk的权限:</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">权限</th>
<th style="text-align:left">ACL简写</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CREATE</td>
<td style="text-align:left">c</td>
<td style="text-align:left">可以创建子节点</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">d</td>
<td style="text-align:left">可以删除子节点（仅下一级节点）</td>
</tr>
<tr>
<td style="text-align:left">READ</td>
<td style="text-align:left">r</td>
<td style="text-align:left">可以读取节点数据及显示子节点列表</td>
</tr>
<tr>
<td style="text-align:left">WRITE</td>
<td style="text-align:left">w</td>
<td style="text-align:left">可以设置节点数据</td>
</tr>
<tr>
<td style="text-align:left">ADMIN</td>
<td style="text-align:left">a</td>
<td style="text-align:left">可以设置节点访问控制列表权限</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>zk权限认证方式</strong></p>
</blockquote>
<p><strong>ACL 权限控制，使用：schema​ : id:permission 来标识，主要涵盖 3 个方面：</strong></p>
<ol>
<li><strong>权限模式（Schema）：鉴权的策略</strong></li>
<li><strong>授权对象（ID）</strong></li>
<li><strong>权限（Permission）</strong></li>
</ol>
<p><strong>1、schema：</strong></p>
<p><strong>ZooKeeper内置了一些权限控制方案，可以用以下方案为每个节点设置权限：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>方案</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>world</strong></td>
<td style="text-align:center"><strong>只有一个用户：anyone，代表所有人都能够操作（创建的节点，默认就是这个策略）</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>ip</strong></td>
<td style="text-align:center"><strong>使用IP地址认证</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>auth</strong></td>
<td style="text-align:center"><strong>使用已添加认证的用户认证。代表已经认证通过的用户(cli中可以通过addauth digest user:pwd 来添加当前上下文中的授权用户)</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>digest</strong></td>
<td style="text-align:center"><strong>使用“用户名:密码”方式认证</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>Super</strong></td>
<td style="text-align:center"><strong>超级用户</strong></td>
</tr>
</tbody>
</table>
<p><strong>2、id</strong></p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200408144623344.png" alt="image-20200408144623344"></p>
<blockquote>
<p><strong>权限相关命令：</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">使用方式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getAcl</td>
<td style="text-align:left">getAcl <path></path></td>
<td style="text-align:left">读取ACL权限</td>
</tr>
<tr>
<td style="text-align:left">setAcl</td>
<td style="text-align:left">setAcl <path></path> <acl></acl></td>
<td style="text-align:left">设置ACL权限</td>
</tr>
<tr>
<td style="text-align:left">addauth</td>
<td style="text-align:left">addauth <scheme> <auth></auth></scheme></td>
<td style="text-align:left">添加认证用户</td>
</tr>
</tbody>
</table>
<h2 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h2><blockquote>
<p><strong>默认权限</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">11</span>] create /kingge</div><div class="line">Created /kingge</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">12</span>] getAcl /kingge</div><div class="line"><span class="string">'world,'</span>anyone</div><div class="line">: cdrwa</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">13</span>]</div></pre></td></tr></table></figure>
<p>可以看到默认的权限是： 对于所有用户都具有cdrwa。也就是任意操作</p>
<blockquote>
<p><strong>设置acl</strong></p>
</blockquote>
<p><strong>1.设置写和管理权限</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">13</span>] setAcl /kingge world:anyone:wa</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">14</span>] getAcl /kingge</div><div class="line"><span class="string">'world,'</span>anyone</div><div class="line">: wa</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">15</span>] get /kingge</div><div class="line">org.apache.zookeeper.KeeperException$NoAuthException: KeeperErrorCode = NoAuth <span class="keyword">for</span> /kingge</div><div class="line"></div><div class="line">你会发现，客户端已经失去了对kingge节点的读权限。</div></pre></td></tr></table></figure>
<h2 id="好的文档"><a href="#好的文档" class="headerlink" title="好的文档"></a>好的文档</h2><p><a href="https://blog.csdn.net/weixin_40861707/article/details/80403213" target="_blank" rel="external">https://blog.csdn.net/weixin_40861707/article/details/80403213</a></p>
<p><a href="https://blog.csdn.net/liuxiao723846/article/details/79391650" target="_blank" rel="external">https://blog.csdn.net/liuxiao723846/article/details/79391650</a></p>
<h1 id="zk客户端创建的三种方式"><a href="#zk客户端创建的三种方式" class="headerlink" title="zk客户端创建的三种方式"></a>zk客户端创建的三种方式</h1><h2 id="原生方式"><a href="#原生方式" class="headerlink" title="原生方式"></a>原生方式</h2><p>也就是直接使用ZooKeeper这个类构件一个client客户端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ZooKeeper keeper = new ZooKeeper(&quot;localhost:2181&quot;, 5000, new Watcher() &#123;</div><div class="line">	@Override</div><div class="line">	public void process(WatchedEvent event) &#123;</div><div class="line">		System.out.println( &quot;输出的事件：&quot;+ event.toString() );</div><div class="line">	&#125;</div><div class="line">&#125;);//；连接客户端</div><div class="line"></div><div class="line">//创建临时节点</div><div class="line">keeper.create(&quot;/app2&quot;, &quot;123&quot;.getBytes(), null, CreateMode.EPHEMERAL, null, null);</div><div class="line"></div><div class="line">//监听节点</div><div class="line">		Stat stat = new Stat();;</div><div class="line">keeper.getData(&quot;/app&quot;, new Watcher() &#123;</div><div class="line">	@Override</div><div class="line">	public void process(WatchedEvent event) &#123;</div><div class="line">		System.out.println( &quot;监听kinge节点输出的事件：&quot;+event );</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;, stat );//只能监听一次</div></pre></td></tr></table></figure>
<p>需要依赖的是，zookeeper的jar包，例如zookeeper-3.4.10.jar。</p>
<p><strong>先看看zookeeper本身自带的客户端的问题。</strong></p>
<p>1) ZooKeeper的Watcher是一次性的，用过了需要再注册（<strong>zk的特性，监听器只能够使用一次，如果需要重复监听，那么需要再注册）</strong></p>
<p>2) session的超时后没有自动重连，生产环境中如果网络出现不稳定情况，那么这种情况出现的更加明显；</p>
<p>3) 没有领导选举机制，集群情况下可能需要实现stand by，一个服务挂了，另一个需要接替的效果；</p>
<p>4) 客户端只提供了存储byte数组的接口，而项目中一般都会使用对象。</p>
<p>5) 客户端接口需要处理的异常太多，并且通常，我们也不知道如何处理这些异常。</p>
<h2 id="使用zkClient"><a href="#使用zkClient" class="headerlink" title="使用zkClient"></a>使用zkClient</h2><p>需要依赖 zkclient的jar包，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;com.101tec&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;0.10&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<pre><code>ZkClient client = new ZkClient(&quot;localhost:2181&quot;, 5000, 5000);//客户端
    client.createEphemeral(&quot;/app2&quot;, null);//创建临时节点

    //监听节点
    client.subscribeDataChanges(&quot;/app&quot;, new IZkDataListener() {

            @Override
            public void handleDataDeleted(String t) throws Exception {
                     System.out.println( &quot; handleDataDeleted :&quot; +  t);            
            }

            @Override
            public void handleDataChange(String arg0, Object arg1) throws Exception {

                System.out.println( &quot; handleDataChange :&quot; +  arg0  + &quot; - &quot; + arg1);            
            }
        });//可以多次监听，多次调用handleDataDeleted或者handleDataChange方法
</code></pre><p>解决了zookeeper原生客户端不能够多次监听的缺点。</p>
<h2 id="curator客户端"><a href="#curator客户端" class="headerlink" title="curator客户端"></a>curator客户端</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">		&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-client&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>，如果是导入jar的形式，则是依赖着三个：<img src="/2020/02/02/zookeeper源码解析/image-20200408161037598.png" alt="image-20200408161037598"></p>
<h1 id="zookeeper中zoo-cfg详解"><a href="#zookeeper中zoo-cfg详解" class="headerlink" title="zookeeper中zoo.cfg详解"></a>zookeeper中zoo.cfg详解</h1><p>zookeeper通常采用配置文件zoo.cfg加载配置，其可以配置的参数为：</p>
<ul>
<li><code>clientPort:</code>用于配置当前服务器<code>对客户端暴露的端口</code>，一般配置为2181,无默认值</li>
<li><code>dataDir:</code>用于配置zookeeper服务器存储快照文件（zookeeper 节点数据）的目录，无默认值</li>
<li><code>dataLogDir:</code>用于配置服务器存储事务日志文件的目录，有默认值dataDir,但是建议将两个目录分别配置，防止磁盘的并发读写，影响服务器性能。可将其配置在一个单独的磁盘上。</li>
<li><code>tickTime:</code>心跳时间，用于配置服务器最小时间的单位，默认值3000ms,心跳检测时间通常是该单位的倍数。如客户端与服务端之间的会话超时时间在2<em>tickTime~20</em>tickTime之间。</li>
<li><code>initLimit:</code>用于配置leader服务器等待Follewer服务器启动，并完成数据同步的时间，默认为10，表示10*tickTime</li>
<li><code>syncLimit:</code>用于配置leader服务器和Follewer服务器之间进行心跳检测的最大延时时间，默认为5，表示5*tickTime</li>
<li><code>minSessionTimeout &amp; maxSessionout:</code>用于服务端对客户端会话超时时间的限制，也就是客户端自定义的超时时间必须在minSessionTimeout~maxSessionout内，其默认为分别为2 和 20，时间表示为2<em>tickTime~20</em>tickTime</li>
<li><code>maxClientCnxns:</code>从socket层面限制单个客户端和单台服务器之间的最大并发连接数，即以IP地址粒度来进行连接数的限制，如果为0，表示不作限制，默认为60</li>
<li><code>clientPortAddress:</code>针对多网卡的机器，该参数允许为每个IP地址指定不同的监听端口</li>
<li><code>server.id=host:port:port:</code>用于配置组成zookeeper集群的机器列表，其中id为serverId,与myid文件中的值对应。第一个端口用于指定Leader服务器和Follewer服务器进行运行时通信和数据同步所使用的端口，第二个端口用于进行Leader选举过程中的投票通信</li>
<li><code>autopurge.snapRetainCount:</code>用于配置zookeeper在自动清理的时候需要保留的快照数据文件数量和对应的事务日志文件，默认为3，切自定义值小于3也会取值3</li>
</ul>
<hr>
<p>仅支持系统属性方式配置的参数：</p>
<ul>
<li><p><code>snapCount:</code>用于配置相邻两次数据快照之间的事务操作次数，即zookeeper会在snapCount次事务之后进行一次数据快照，默认为100000</p>
</li>
<li><p><code>preAllocSize:</code>用于配置zookeeper事务日志文件预分配的磁盘空间大小,默认为65536，单位KB,即64MB,与snapCount同时修改，如将snapCount设置为500，每次事务操作的数据量最多为1KB,则preAllocSize设置为500即可<br> <code>forceSync:</code>用于配置zookeeper是否在事务提交的时候，将日志写入操作强制刷入磁盘，默认为yes,表示强制刷盘<br> <code>skipAcl:</code>用于配置zookeeper是否跳过ACL权限检查，默认为mo，即会对每一个客户端请求进行权限检查</p>
</li>
</ul>
<p>zoo.cfg介绍<br> <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Flikui360%2Fp%2F5985588.html" target="_blank" rel="external">https://www.cnblogs.com/likui360/p/5985588.html</a></p>
<h1 id="单机模式"><a href="#单机模式" class="headerlink" title="########单机模式"></a>########单机模式</h1><h1 id="zk客户端源码解析"><a href="#zk客户端源码解析" class="headerlink" title="zk客户端源码解析"></a>zk客户端源码解析</h1><h2 id="使用zkCli-sh起送客户端"><a href="#使用zkCli-sh起送客户端" class="headerlink" title="使用zkCli.sh起送客户端"></a>使用zkCli.sh起送客户端</h2><p>我们来查看一下zkCli.sh文件的内容</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409083750078.png" alt="image-20200409083750078"></p>
<p>发现他最终是通过运行org.apache.zookeeper.ZooKeeperMain 这个类来启动客户端</p>
<h2 id="ZooKeeperMain源码-初始化zk客户端"><a href="#ZooKeeperMain源码-初始化zk客户端" class="headerlink" title="ZooKeeperMain源码 - 初始化zk客户端"></a>ZooKeeperMain源码 - 初始化zk客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connectToZK</span><span class="params">(String newHost)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (zk != <span class="keyword">null</span> &amp;&amp; zk.getState().isAlive()) &#123;</div><div class="line">            zk.close();</div><div class="line">        &#125;</div><div class="line">        host = newHost;</div><div class="line">        <span class="keyword">boolean</span> readOnly = cl.getOption(<span class="string">"readonly"</span>) != <span class="keyword">null</span>;</div><div class="line">        zk = <span class="keyword">new</span> ZooKeeper(host,</div><div class="line">                 Integer.parseInt(cl.getOption(<span class="string">"timeout"</span>)),</div><div class="line">                 <span class="keyword">new</span> MyWatcher(), readOnly);<span class="comment">//3.使用zk原生客户端连接方式，进行连接</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="comment">//1.首先执行main方法</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> KeeperException, IOException, InterruptedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        ZooKeeperMain main = <span class="keyword">new</span> ZooKeeperMain(args);</div><div class="line">        main.run();<span class="comment">//1.1 while循环，解析客户端命令行，然后判断操作类型，用connectToZK构建的zk客户端，请求服务端执行相应操作指令。例如客户端输入create /app 123  ，那么就会调用zk.create（"/app",123）请求服务端。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperMain</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">        cl.parseOptions(args);</div><div class="line">        System.out.println(<span class="string">"Connecting to "</span> + cl.getOption(<span class="string">"server"</span>));</div><div class="line">        connectToZK(cl.getOption(<span class="string">"server"</span>));<span class="comment">//2.构建zk连接</span></div><div class="line">        <span class="comment">//zk = new ZooKeeper(cl.getOption("server"),</span></div><div class="line"><span class="comment">//                Integer.parseInt(cl.getOption("timeout")), new MyWatcher());</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​    由上面可以得知，zkmain类，最终的目的是：解析命令行的参数，保存到MyCommandOptions配置类，然后通过zookeeper类，构建一个到服务端的连接。</p>
<h3 id="zookeeper构建连接源码"><a href="#zookeeper构建连接源码" class="headerlink" title="zookeeper构建连接源码"></a>zookeeper构建连接源码</h3><p>上面构建zk客户端的连接最终的调用的代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String connectString, <span class="keyword">int</span> sessionTimeout, Watcher watcher,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> canBeReadOnly)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        LOG.info(<span class="string">"Initiating client connection, connectString="</span> + connectString</div><div class="line">                + <span class="string">" sessionTimeout="</span> + sessionTimeout + <span class="string">" watcher="</span> + watcher);</div><div class="line"></div><div class="line">        watchManager.defaultWatcher = watcher;<span class="comment">//默认的总的监听器。</span></div><div class="line"></div><div class="line">        <span class="comment">//connectString可能是：localhost:2181,localhost:2182，这样的集群地址</span></div><div class="line">        ConnectStringParser connectStringParser = <span class="keyword">new</span> ConnectStringParser(</div><div class="line">                connectString);<span class="comment">//1.解析zk的server地址，因为有可能是集群，所以需要根据，分割</span></div><div class="line">        <span class="comment">//最后保存在ArrayList&lt;InetSocketAddress&gt; serverAddresses中</span></div><div class="line">        HostProvider hostProvider = <span class="keyword">new</span> StaticHostProvider(</div><div class="line">                connectStringParser.getServerAddresses());<span class="comment">//2.将上面解析到的server地址列表，赋值给HostProvider。同时StaticHostProvider类包含了如何选出集群中server地址，以便客户端连接。</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        cnxn = <span class="keyword">new</span> ClientCnxn(connectStringParser.getChrootPath(),</div><div class="line">                hostProvider, sessionTimeout, <span class="keyword">this</span>, watchManager,</div><div class="line">                getClientCnxnSocket(), canBeReadOnly);<span class="comment">//3.chrootPat默认是null，canBeReadOnly是否是只读模式</span></div><div class="line">        cnxn.start();<span class="comment">//4.启动ClientCnxn创建的两个线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//解释一下只读模式，假设集群有三台服务器，但是挂了两台，按道理整个集群是不可用的，但是我们可以开启只读模式，然后客户端还是能够请求集群获取数据，但是更新不了数据。</span></div></pre></td></tr></table></figure>
<p>​    <strong>代码1处</strong>，就是解析server端的地址，最后放到ConnectStringParser类的ArrayList<inetsocketaddress> serverAddresses 成员属性中。看里面的源码可以得知，connectString.split(“,”)，集群的地址，必须使用<code>,</code>分隔开。</inetsocketaddress></p>
<p><strong>代码2处</strong>，根据第一步解析出来的server端地址，然后<strong>打乱list里面的server地址</strong>，然后再<strong>随机取一个地址</strong>，进行连接。</p>
<p><strong>代码3处</strong>，首先根据getClientCnxnSocket()构建一个<strong>客户端连接服务端的socket</strong>，这里是通过NIO的形式（<strong>默认实现是ClientCnxnSocketNIO</strong>）。</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409085351851.png" alt="image-20200409085351851"></p>
<p>接着构建zk客户端连接 new ClientCnxn(..)。ClientCnxn可以理解创建了一个上下文<strong>，最终创建了两个线程</strong></p>
<p><strong>这两个线程很重要！！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClientCnxn</span><span class="params">(String chrootPath, HostProvider hostProvider, <span class="keyword">int</span> sessionTimeout, ZooKeeper zooKeeper,</span></span></div><div class="line"><span class="function"><span class="params">          ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket,</span></span></div><div class="line"><span class="function"><span class="params">          <span class="keyword">long</span> sessionId, <span class="keyword">byte</span>[] sessionPasswd, <span class="keyword">boolean</span> canBeReadOnly)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.zooKeeper = zooKeeper;</div><div class="line">      <span class="keyword">this</span>.watcher = watcher;</div><div class="line">      <span class="keyword">this</span>.sessionId = sessionId;</div><div class="line">      <span class="keyword">this</span>.sessionPasswd = sessionPasswd;</div><div class="line">      <span class="keyword">this</span>.sessionTimeout = sessionTimeout;</div><div class="line">      <span class="keyword">this</span>.hostProvider = hostProvider;</div><div class="line">      <span class="keyword">this</span>.chrootPath = chrootPath;</div><div class="line"><span class="comment">//连接超时时间</span></div><div class="line">      connectTimeout = sessionTimeout / hostProvider.size();</div><div class="line">      <span class="comment">//读超时 时间</span></div><div class="line">      readTimeout = sessionTimeout * <span class="number">2</span> / <span class="number">3</span>;</div><div class="line">      readOnly = canBeReadOnly;</div><div class="line"></div><div class="line">      sendThread = <span class="keyword">new</span> SendThread(clientCnxnSocket);<span class="comment">//我们可以看到sendThread是以ClientCnxnSocketNIO为入参说明他是负责发送请求给服务端的。具体实现：他是负责从outgoingqueue队列中获取客户端要发送的请求，然后发送给服务端 - 处理客户端请求的线程</span></div><div class="line">  eventThread = <span class="keyword">new</span> EventThread();<span class="comment">//处理watcher事件的线程，在后面的代码分析中你会发现EventThread处理event事件数据来源，是在从SendThread哪里进行赋值到waitEventQueue队列中的。</span></div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>代码4</strong>，启动上面创建的两个线程，sendThread开始处理客户端发出的请求，eventThread开始处理根据服务端发出的响应事件的请求，开始处理事件。</p>
<p>​    这两个线程都是通过生产者和消费者模式，进行工作的进行，将请求都放到队列中，然后在他们的run方法中逐个拿出请求进行处理。</p>
<h4 id="SendThread初始化NIO进行与server端的通信-负责发送请求给服务端"><a href="#SendThread初始化NIO进行与server端的通信-负责发送请求给服务端" class="headerlink" title="SendThread初始化NIO进行与server端的通信 - 负责发送请求给服务端"></a>SendThread初始化NIO进行与server端的通信 - 负责发送请求给服务端</h4><p>​    我们知道 cnxn.start()最终会启动两个线程，那么我们先看一下SendThread线程，看名字应该知道他是一个发送消息的线程，也就是发送我们客户端的操作命令，例如”ls /“。</p>
<p>​    <strong>我们直接来看他的run方法</strong></p>
<p>​    首先判断客户端<strong>是否已经连接</strong>服务端，那么会进入这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!clientCnxnSocket.isConnected()) &#123;<span class="comment">//socket是否已经连接</span></div><div class="line">    <span class="keyword">if</span>(!isFirstConnect)&#123;<span class="comment">//如果不是首次连接，那么需要随机睡一会</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(r.nextInt(<span class="number">1000</span>));</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            LOG.warn(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// don't re-establish connection if we are closing</span></div><div class="line">    <span class="keyword">if</span> (closing || !state.isAlive()) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rwServerAddress != <span class="keyword">null</span>) &#123;</div><div class="line">        serverAddress = rwServerAddress;</div><div class="line">        rwServerAddress = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        serverAddress = hostProvider.next(<span class="number">1000</span>);<span class="comment">//取下一个server连接的地址</span></div><div class="line">        <span class="comment">//如果是集群那么在next方法会进行逻辑判断，然后选取出下一个连接的server</span></div><div class="line">        <span class="comment">//地址,一般是调用Collections.shuffle()打乱地址列表然后随机获取</span></div><div class="line">    &#125;</div><div class="line">    startConnect(serverAddress);<span class="comment">//代码1处，最终会执行到，这里创建一个链接，接着调用 clientCnxnSocket.connect(addr);然后通过上面创建NIOorg.apache.zookeeper.ClientCnxnSocketNIO.connect(InetSocketAddress)，进行创建NIO连接</span></div><div class="line">    clientCnxnSocket.updateLastSendAndHeard();<span class="comment">//更新Socket最后一次发送以及收到消息的时间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们查看代码1处最终调用：一下方法都在ClientCnxnSocketNIO类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(InetSocketAddress addr)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    SocketChannel sock = createSock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">       registerAndConnect(sock, addr);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        LOG.error(<span class="string">"Unable to open socket to "</span> + addr);</div><div class="line">        sock.close();</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">    initialized = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Reset incomingBuffer</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    lenBuffer.clear();</div><div class="line">    incomingBuffer = lenBuffer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function">SocketChannel <span class="title">createSock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        SocketChannel sock;</div><div class="line">        sock = SocketChannel.open();</div><div class="line">        sock.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        sock.socket().setSoLinger(<span class="keyword">false</span>, -<span class="number">1</span>);</div><div class="line">        sock.socket().setTcpNoDelay(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> sock;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerAndConnect</span><span class="params">(SocketChannel sock, InetSocketAddress addr)</span> </span></div><div class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        sockKey = sock.register(selector, SelectionKey.OP_CONNECT);</div><div class="line">        <span class="keyword">boolean</span> immediateConnect = sock.connect(addr);</div><div class="line">        <span class="keyword">if</span> (immediateConnect) &#123;</div><div class="line">            sendThread.primeConnection();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="eventThread-处理watcher事件"><a href="#eventThread-处理watcher事件" class="headerlink" title="eventThread 处理watcher事件"></a>eventThread 处理watcher事件</h4><p><strong>关于这一章节的详细内容，在下面的《为什么监听的事件只处理一次之watcher源码解析中会讲到》</strong></p>
<h2 id="ZooKeeperMain-run-解析命令行，处理请求"><a href="#ZooKeeperMain-run-解析命令行，处理请求" class="headerlink" title="ZooKeeperMain.run() - 解析命令行，处理请求"></a>ZooKeeperMain.run() - 解析命令行，处理请求</h2><p><strong>经过上面初始化了zk客户端，那么接下来就是进行处理命令行的逻辑了。</strong></p>
<p>​    通过上面的分析，我们可以构建了一个zookeeper客户端，能够与服务端取得了连接，但是我们并没有看到在那里处理或者说，解析了命令行 。</p>
<p>​    例如我们输入 <code>create /kingge</code>创建一个节点，那么在那里解析这一行代码呢？</p>
<p><strong>那就是根据上面创建好的ZooKeeperMain，然后调用run方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, IOException, InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (cl.getCommand() == <span class="keyword">null</span>) &#123;</div><div class="line">        System.out.println(<span class="string">"Welcome to ZooKeeper!"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> jlinemissing = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">// only use jline if it's in the classpath</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; consoleC = Class.forName(<span class="string">"jline.ConsoleReader"</span>);<span class="comment">//这个类就是控制台</span></div><div class="line">            Class&lt;?&gt; completorC =</div><div class="line">                Class.forName(<span class="string">"org.apache.zookeeper.JLineZNodeCompletor"</span>);<span class="comment">//自动补齐类</span></div><div class="line"></div><div class="line">            System.out.println(<span class="string">"JLine support is enabled"</span>);</div><div class="line"></div><div class="line">            Object console =</div><div class="line">                consoleC.getConstructor().newInstance();</div><div class="line"></div><div class="line">            Object completor =</div><div class="line">                completorC.getConstructor(ZooKeeper.class).newInstance(zk);</div><div class="line">            Method addCompletor = consoleC.getMethod(<span class="string">"addCompletor"</span>,</div><div class="line">                    Class.forName(<span class="string">"jline.Completor"</span>));</div><div class="line">            addCompletor.invoke(console, completor);</div><div class="line"></div><div class="line">            String line;</div><div class="line">            Method readLine = consoleC.getMethod(<span class="string">"readLine"</span>, String.class);</div><div class="line">            <span class="keyword">while</span> ((line = (String)readLine.invoke(console, getPrompt())) != <span class="keyword">null</span>) &#123;</div><div class="line">                executeLine(line);<span class="comment">//while循环处理请求。在这里解析命令行的操作</span></div><div class="line">            &#125;</div><div class="line">            。。。。</div></pre></td></tr></table></figure>
<p>我们是否还记得，当我们通过zkClie.sh连接到服务端的时候，控制台会输出这样的一行前缀：</p>
<p><code>[zk: localhost:2181(CONNECTED) 1]</code>  那么这一段输出，其实就是通过这里的getPrompt()方法进行打印的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getPrompt</span><span class="params">()</span> </span>&#123;       </div><div class="line">    <span class="keyword">return</span> <span class="string">"[zk: "</span> + host + <span class="string">"("</span>+zk.getState()+<span class="string">")"</span> + <span class="string">" "</span> + commandCount + <span class="string">"] "</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们接着看executeLine()方法，发下他的内部实现，其实也很简单。最终调用processZKCmd()方法：</p>
<p>​    发现他就是通过，各种if对于命令的判断，然后执行相应的操作，例如输入的create命令，那么接着判断创建的是临时节点，还是持久化节点，等等，然后接着调用zk.create（）原生api进行节点的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (cmd.equals(<span class="string">"create"</span>) &amp;&amp; args.length &gt;= <span class="number">3</span>) &#123;</div><div class="line">           <span class="keyword">int</span> first = <span class="number">0</span>;</div><div class="line">           CreateMode flags = CreateMode.PERSISTENT;</div><div class="line">           <span class="keyword">if</span> ((args[<span class="number">1</span>].equals(<span class="string">"-e"</span>) &amp;&amp; args[<span class="number">2</span>].equals(<span class="string">"-s"</span>))</div><div class="line">                   || (args[<span class="number">1</span>]).equals(<span class="string">"-s"</span>) &amp;&amp; (args[<span class="number">2</span>].equals(<span class="string">"-e"</span>))) &#123;</div><div class="line">               first+=<span class="number">2</span>;</div><div class="line">               flags = CreateMode.EPHEMERAL_SEQUENTIAL;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>].equals(<span class="string">"-e"</span>)) &#123;</div><div class="line">               first++;</div><div class="line">               flags = CreateMode.EPHEMERAL;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">1</span>].equals(<span class="string">"-s"</span>)) &#123;</div><div class="line">               first++;</div><div class="line">               flags = CreateMode.PERSISTENT_SEQUENTIAL;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (args.length == first + <span class="number">4</span>) &#123;</div><div class="line">               acl = parseACLs(args[first+<span class="number">3</span>]);</div><div class="line">           &#125;</div><div class="line">           path = args[first + <span class="number">1</span>];</div><div class="line">           String newPath = zk.create(path, args[first+<span class="number">2</span>].getBytes(), acl,</div><div class="line">                   flags);<span class="comment">//这里的zk，就是前一步 ZooKeeperMain main = new ZooKeeperMain(args);创建出来的客户端。</span></div><div class="line">           System.err.println(<span class="string">"Created "</span> + newPath);<span class="comment">//控制台打印，创建节点路径</span></div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>​    下面我们就通过zk.create()这一种命令方式（<strong>其他的get，set命令类似的create的执行步骤，这里通过create命令进行分析</strong>），查看一下他的源码，分析一下，客户端究竟是怎么发送请求给服务端的。</p>
<h3 id="构建请求到请求队列中"><a href="#构建请求到请求队列中" class="headerlink" title="构建请求到请求队列中"></a>构建请求到请求队列中</h3><blockquote>
<p><strong>首先调用zookeeper.create（）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], List&lt;ACL&gt; acl,</span></span></div><div class="line"><span class="function"><span class="params">        CreateMode createMode)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">final</span> String clientPath = path;</div><div class="line">    PathUtils.validatePath(clientPath, createMode.isSequential());</div><div class="line"></div><div class="line">    <span class="keyword">final</span> String serverPath = prependChroot(clientPath);</div><div class="line"></div><div class="line">    RequestHeader h = <span class="keyword">new</span> RequestHeader();<span class="comment">//1.构建请求头</span></div><div class="line">    h.setType(ZooDefs.OpCode.create);<span class="comment">//2.请求类型，每种操作命令都对应着一个状态码，例如create命令是1，delete是2，getACL是6等等</span></div><div class="line">    CreateRequest request = <span class="keyword">new</span> CreateRequest();<span class="comment">//构建请求体</span></div><div class="line">    CreateResponse response = <span class="keyword">new</span> CreateResponse();<span class="comment">//构建响应，保存请求的结果</span></div><div class="line">    request.setData(data);</div><div class="line">    request.setFlags(createMode.toFlag());</div><div class="line">    request.setPath(serverPath);</div><div class="line">    <span class="keyword">if</span> (acl != <span class="keyword">null</span> &amp;&amp; acl.size() == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.InvalidACLException();</div><div class="line">    &#125;</div><div class="line">    request.setAcl(acl);</div><div class="line">    ReplyHeader r = cnxn.submitRequest(h, request, response, <span class="keyword">null</span>);<span class="comment">//3.提交请求</span></div><div class="line">    <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()),</div><div class="line">                clientPath);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (cnxn.chrootPath == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> response.getPath();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> response.getPath().substring(cnxn.chrootPath.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里着重的看一下cnxn.submitRequest()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ReplyHeader <span class="title">submitRequest</span><span class="params">(RequestHeader h, Record request,</span></span></div><div class="line"><span class="function"><span class="params">        Record response, WatchRegistration watchRegistration)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    ReplyHeader r = <span class="keyword">new</span> ReplyHeader();</div><div class="line">    Packet packet = queuePacket(h, r, request, response, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</div><div class="line">                <span class="keyword">null</span>, watchRegistration);<span class="comment">//会把请求信息包装成一个Packet，然后把Packet放到一个队列中，LinkedList&lt;Packet&gt; outgoingQueue，接着调用 sendThread.getClientCnxnSocket().wakeupCnxn();</span></div><div class="line">    <span class="keyword">synchronized</span> (packet) &#123;<span class="comment">//阻塞，等待响应结果</span></div><div class="line">        <span class="keyword">while</span> (!packet.finished) &#123;<span class="comment">//如果packet没有处理完成则阻塞等待，什么时候完成呢？详情参见下面的doIO的获取响应结果的代码 - finishPacket(packet)。</span></div><div class="line">            packet.wait();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line">    sendThread.getClientCnxnSocket().wakeupCnxn();</div></pre></td></tr></table></figure>
<p>​    换句话说，zk会把create命令封装的请求，放在一个outgoingQueue的链表中，然后退出queuePacket()方法，接着阻塞synchronized (packet) 等待响应结果。</p>
<p>​    看到这里你有没有发现一个问题，那就是，到这里为止，<strong>仅仅只是把请求放到outgoingQueue队列中，那么什么时候处理队列里面的数据呢？也就是什么时候处理封装好的请求呢？</strong></p>
<p>​    <strong>那就是SendThread的run方法。</strong></p>
<p>​    还记得我们在上面说过，在创建zk客户端的时候，创建了两个线程，并启动。其中一个就是SendThread，<strong>那么他调用run方法，内部实现是一个while循环，从outgoingqueue中拿出请求进行发送给服务端</strong></p>
<h3 id="SendThread的run方法循环处理客户端请求和服务端响应"><a href="#SendThread的run方法循环处理客户端请求和服务端响应" class="headerlink" title="SendThread的run方法循环处理客户端请求和服务端响应"></a>SendThread的run方法循环处理客户端请求和服务端响应</h3><p>run方法内部就是通过这样一个方法，进行处理outgoingQueue队列中的请求，该方法，最终调用的是：<code>org.apache.zookeeper.ClientCnxnSocketNIO.doTransport</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue, ClientCnxn.<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>然后看里面的代码，因为我们执行的是create命令，那么需要查看NIO通道是否可写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != <span class="number">0</span>) &#123;</div><div class="line">                doIO(pendingQueue, outgoingQueue, cnxn);<span class="comment">//判断通道读或者写是否就绪，如果读就绪说明服务端已经处理请求完毕返回响应。如果写就绪说明，可以将请求发送给服务端。</span></div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>也就是说，<strong>doIO方法是处理客户端请求和服务端响应的核心方法。</strong></p>
<h4 id="发送客户端请求给服务端"><a href="#发送客户端请求给服务端" class="headerlink" title="发送客户端请求给服务端"></a>发送客户端请求给服务端</h4><blockquote>
<p><strong>接着查看doIO方法 - 关于发送请求的部分代码</strong></p>
</blockquote>
<p>写请求部分关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (sockKey.isWritable()) &#123;</div><div class="line">           <span class="keyword">synchronized</span>(outgoingQueue) &#123;</div><div class="line">               Packet p = findSendablePacket(outgoingQueue,</div><div class="line">                       cnxn.sendThread.clientTunneledAuthenticationInProgress());<span class="comment">//拿出队列中第一个packet请求。</span></div><div class="line"></div><div class="line">               <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                   updateLastSend();</div><div class="line">                   <span class="comment">// If we already started writing p, p.bb will already exist</span></div><div class="line">                   <span class="keyword">if</span> (p.bb == <span class="keyword">null</span>) &#123;</div><div class="line">                       <span class="keyword">if</span> ((p.requestHeader != <span class="keyword">null</span>) &amp;&amp;</div><div class="line">                               (p.requestHeader.getType() != OpCode.ping) &amp;&amp;</div><div class="line">                               (p.requestHeader.getType() != OpCode.auth)) &#123;</div><div class="line">                           p.requestHeader.setXid(cnxn.getXid());</div><div class="line">                       &#125;</div><div class="line">                       p.createBB();<span class="comment">//序列化请求，zk自己的序列化工具jute。没有用java的序列化工具</span></div><div class="line">                   &#125;</div><div class="line">                   sock.write(p.bb);<span class="comment">//发送请求给服务端</span></div><div class="line">                   <span class="keyword">if</span> (!p.bb.hasRemaining()) &#123;<span class="comment">//</span></div><div class="line">                       sentCount++;</div><div class="line">                       outgoingQueue.removeFirstOccurrence(p);<span class="comment">//从队列中移除已经处理的请求</span></div><div class="line">                       <span class="keyword">if</span> (p.requestHeader != <span class="keyword">null</span></div><div class="line">                               &amp;&amp; p.requestHeader.getType() != OpCode.ping</div><div class="line">                               &amp;&amp; p.requestHeader.getType() != OpCode.auth) &#123;</div><div class="line">                           <span class="keyword">synchronized</span> (pendingQueue) &#123;<span class="comment">//将已经处理的请求放到pendingQueue队列中</span></div><div class="line">                               pendingQueue.add(p);</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div></pre></td></tr></table></figure>
<p>为什么要将已经处理的请求放到判定队列中呢？那是因为，上面代码仅仅只是发送请求成功， 但是<strong>服务端还没有响应数据。</strong> 但是我们已经把outgoingQueue中已经发出去的请求给删除了，那么我怎么知道请求有没有发送成功，服务端有没有响应呢？</p>
<p>​    <strong>所以需要把将已经处理的请求放到pendingQueue判定队列中，等待判定。</strong></p>
<h4 id="处理服务端返回的响应数据"><a href="#处理服务端返回的响应数据" class="headerlink" title="处理服务端返回的响应数据"></a>处理服务端返回的响应数据</h4><p>​    实际上得到服务端响应结果的代码也是在doIO中。<strong>服务端的写请求对应的是客户端的读请求。</strong>所以我们查看一下这代码段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (sockKey.isReadable()) &#123;<span class="comment">//服务端可读，说明服务端已经返回数据</span></div><div class="line">    <span class="keyword">int</span> rc = sock.read(incomingBuffer);</div><div class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(</div><div class="line">                <span class="string">"Unable to read additional data from server sessionid 0x"</span></div><div class="line">                        + Long.toHexString(sessionId)</div><div class="line">                        + <span class="string">", likely server has closed socket"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!incomingBuffer.hasRemaining()) &#123;</div><div class="line">        incomingBuffer.flip();</div><div class="line">        <span class="keyword">if</span> (incomingBuffer == lenBuffer) &#123;</div><div class="line">            recvCount++;</div><div class="line">            readLength();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!initialized) &#123;</div><div class="line">            readConnectResult();</div><div class="line">            enableRead();</div><div class="line">            <span class="keyword">if</span> (findSendablePacket(outgoingQueue,</div><div class="line">                    cnxn.sendThread.clientTunneledAuthenticationInProgress()) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Since SASL authentication has completed (if client is configured to do so),</span></div><div class="line">                <span class="comment">// outgoing packets waiting in the outgoingQueue can now be sent.</span></div><div class="line">                enableWrite();</div><div class="line">            &#125;</div><div class="line">            lenBuffer.clear();</div><div class="line">            incomingBuffer = lenBuffer;</div><div class="line">            updateLastHeard();</div><div class="line">            initialized = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sendThread.readResponse(incomingBuffer);<span class="comment">//获取结果，然后从pendingqueue中移除已经获取响应结果的packet，然后最终 finishPacket(packet);，标记请求的packet已经完成，然后唤醒监听packet节点的线程。 p.notifyAll();</span></div><div class="line">            lenBuffer.clear();</div><div class="line">            incomingBuffer = lenBuffer;</div><div class="line">            updateLastHeard();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="sendThread-readResponse-读取服务端返回的信息"><a href="#sendThread-readResponse-读取服务端返回的信息" class="headerlink" title="sendThread.readResponse() - 读取服务端返回的信息"></a><strong>sendThread.readResponse() - 读取服务端返回的信息</strong></h5><p>需要注意的是，这个方法可能还<strong>额外处理服务端发出的其他请求</strong>。<strong>例如触发事件的请求</strong>。</p>
<p><strong>设么意思呢？</strong></p>
<p>举个例子：</p>
<pre><code>客户端A，执行命令getData(&quot;/app&quot;,true)，这里的true代表是本次getData请求，在获取app节点数据的同时，告诉服务端我要顺便绑定一个在app节点监听器（使用zk客户端默认监听器），如果app节点有什么变动你要通知我。
</code></pre><p>​    那么也就意味着，服务端在处理请求getData的时候，返回app节点数据给客户端，然后再readResponse()方法执行。本次请求结束。</p>
<p>​    那么当客户端紧接着在请求setData(“app”,123)，服务端在<strong>响应客户端说，我处理成功了的同时</strong>，<strong>还会再发出一个响应</strong>，就是通知客户端说你上次在我这里绑定了关于app节点的监听器，你要触发一下。</p>
<p>​    那么本次客户端的setData请求，<strong>总共会得到两个响应</strong>，那么这两个响应都是在readResponse()方法处理。</p>
<p>​    那么客户端怎么知道本次响应时普通的操作响应还是时间触发响应呢？通过xid的值进行判断，当xid==-1时说明本次响应时触发事件响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   。。。。。。。<span class="comment">//省略部分代码</span></div><div class="line"></div><div class="line">    Packet packet;</div><div class="line">    <span class="keyword">synchronized</span> (pendingQueue) &#123;<span class="comment">//获取响应结果后，然后从pendingqueue中移除已经获取响应结果的请求packet</span></div><div class="line">        <span class="keyword">if</span> (pendingQueue.size() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Nothing in the queue, but got "</span></div><div class="line">                    + replyHdr.getXid());</div><div class="line">        &#125;</div><div class="line">        packet = pendingQueue.remove();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">                <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">4</span>) &#123;</div><div class="line">            <span class="comment">// -4 is the xid for AuthPacket               </span></div><div class="line">            <span class="keyword">if</span>(replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) &#123;</div><div class="line">                state = States.AUTH_FAILED;                    </div><div class="line">                eventThread.queueEvent( <span class="keyword">new</span> WatchedEvent(Watcher.Event.EventType.None, </div><div class="line">                        Watcher.Event.KeeperState.AuthFailed, <span class="keyword">null</span>) );            		            		</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                LOG.debug(<span class="string">"Got auth sessionid:0x"</span></div><div class="line">                        + Long.toHexString(sessionId));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (replyHdr.getXid() == -<span class="number">1</span>) &#123;<span class="comment">//处理服务端发出的触发事件的响应</span></div><div class="line">            <span class="comment">// -1 means notification</span></div><div class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                LOG.debug(<span class="string">"Got notification sessionid:0x"</span></div><div class="line">                    + Long.toHexString(sessionId));</div><div class="line">            &#125;</div><div class="line">            WatcherEvent event = <span class="keyword">new</span> WatcherEvent();</div><div class="line">            event.deserialize(bbia, <span class="string">"response"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// convert from a server path to a client path</span></div><div class="line">            <span class="keyword">if</span> (chrootPath != <span class="keyword">null</span>) &#123;</div><div class="line">                String serverPath = event.getPath();</div><div class="line">                <span class="keyword">if</span>(serverPath.compareTo(chrootPath)==<span class="number">0</span>)</div><div class="line">                    event.setPath(<span class="string">"/"</span>);</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length())</div><div class="line">                    event.setPath(serverPath.substring(chrootPath.length()));</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                	LOG.warn(<span class="string">"Got server path "</span> + event.getPath()</div><div class="line">                			+ <span class="string">" which is too short for chroot path "</span></div><div class="line">                			+ chrootPath);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            WatchedEvent we = <span class="keyword">new</span> WatchedEvent(event);</div><div class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                LOG.debug(<span class="string">"Got "</span> + we + <span class="string">" for sessionid 0x"</span></div><div class="line">                        + Long.toHexString(sessionId));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            eventThread.queueEvent( we );</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Since requests are processed in order, we better get a response</span></div><div class="line"><span class="comment">     * to the first request!</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</div><div class="line">            packet.replyHeader.setErr(</div><div class="line">                    KeeperException.Code.CONNECTIONLOSS.intValue());</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Xid out of order. Got Xid "</span></div><div class="line">                    + replyHdr.getXid() + <span class="string">" with err "</span> +</div><div class="line">                    + replyHdr.getErr() +</div><div class="line">                    <span class="string">" expected Xid "</span></div><div class="line">                    + packet.requestHeader.getXid()</div><div class="line">                    + <span class="string">" for a packet with details: "</span></div><div class="line">                    + packet );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        packet.replyHeader.setXid(replyHdr.getXid());</div><div class="line">        packet.replyHeader.setErr(replyHdr.getErr());</div><div class="line">        packet.replyHeader.setZxid(replyHdr.getZxid());</div><div class="line">        <span class="keyword">if</span> (replyHdr.getZxid() &gt; <span class="number">0</span>) &#123;</div><div class="line">            lastZxid = replyHdr.getZxid();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (packet.response != <span class="keyword">null</span> &amp;&amp; replyHdr.getErr() == <span class="number">0</span>) &#123;</div><div class="line">            packet.response.deserialize(bbia, <span class="string">"response"</span>);<span class="comment">//拿到响应，发到请求的packet中的response属性中，赋值。</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">            LOG.debug(<span class="string">"Reading reply sessionid:0x"</span></div><div class="line">                    + Long.toHexString(sessionId) + <span class="string">", packet:: "</span> + packet);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        finishPacket(packet);<span class="comment">//处理正常的请求响应。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="最后处理finishPacket-请求"><a href="#最后处理finishPacket-请求" class="headerlink" title="最后处理finishPacket()请求"></a><strong>最后处理finishPacket()请求</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishPacket</span><span class="params">(Packet p)</span> </span>&#123;</div><div class="line">    <span class="comment">//首先还记得，watchRegistration是在什么时候进行初始化么？例如在客户端调用api发出例如调用exists操作命令时，调用zk.exists()时，在exists()内部初始化。</span></div><div class="line">     <span class="comment">//create等命令是没有注册监听器的功能的，也就是说：实际上能够注册监听器的，也只有，exists、getDate，getChildren 这三个api才能绑定监听器。</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (p.watchRegistration != <span class="keyword">null</span>) &#123;</div><div class="line">        p.watchRegistration.register(p.replyHeader.getErr());<span class="comment">//重要！！！！这个方法，会把客户端注册某个节点路径的监听事件，放到hashmap中。 -- 回答了下面提出的问题。保存节点监听事件的map什么时候赋值。就这这个方法赋值。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (p.cb == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (p) &#123;</div><div class="line">            p.finished = <span class="keyword">true</span>;</div><div class="line">            p.notifyAll();<span class="comment">//唤醒之前客户端在cnxn.submitRequest()发送请求后，阻塞等待结果的线程</span></div><div class="line">            <span class="comment">//标识本次客户端请求，最终获得响应</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        p.finished = <span class="keyword">true</span>;</div><div class="line">        eventThread.queuePacket(p);<span class="comment">//然后开始处理监听事件 -- </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>开始注册对某个节点路径的监听到map中  p.watchRegistration.register</strong></p>
</blockquote>
<p>key是path-节点路径</p>
<p>value是注册的监听。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">int</span> rc)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shouldAddWatch(rc)) &#123;</div><div class="line">        Map&lt;String, Set&lt;Watcher&gt;&gt; watches = getWatches(rc);</div><div class="line">        <span class="keyword">synchronized</span>(watches) &#123;</div><div class="line">            Set&lt;Watcher&gt; watchers = watches.get(clientPath);</div><div class="line">            <span class="keyword">if</span> (watchers == <span class="keyword">null</span>) &#123;</div><div class="line">                watchers = <span class="keyword">new</span> HashSet&lt;Watcher&gt;();</div><div class="line">                watches.put(clientPath, watchers);</div><div class="line">            &#125;</div><div class="line">            watchers.add(watcher);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="eventThread处理监听事件"><a href="#eventThread处理监听事件" class="headerlink" title="eventThread处理监听事件"></a>eventThread处理监听事件</h4><p>waitingEvents保存需要处理的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;Object&gt; waitingEvents =</div><div class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;();</div></pre></td></tr></table></figure>
<p>//保存需要处理的事件到waitingEvents队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queuePacket</span><span class="params">(Packet packet)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (wasKilled) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (waitingEvents) &#123;</div><div class="line">         <span class="keyword">if</span> (isRunning) waitingEvents.add(packet);</div><div class="line">         <span class="keyword">else</span> processEvent(packet);</div><div class="line">      &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">      waitingEvents.add(packet);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>因为他跟SendThread一样是一个线程，同时也是遵循生产者和消费者模型，那么就会去执行run方法，所以最终处理事件的逻辑还是在run方法中。</strong></p>
<blockquote>
<p><strong>eventThread.run方法</strong></p>
</blockquote>
<p>处理事件的核心方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      isRunning = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">         Object event = waitingEvents.take();<span class="comment">//从等待处理事件队列中获取事件并处理。拿一个就移除一个 - 这个也就是为什么事件只能够监听一次的原因</span></div><div class="line">         <span class="keyword">if</span> (event == eventOfDeath) &#123;</div><div class="line">            wasKilled = <span class="keyword">true</span>;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">            processEvent(event);<span class="comment">//真正调用监听事件的逻辑，然后完成监听事件的触发。</span></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (wasKilled)</div><div class="line">            <span class="keyword">synchronized</span> (waitingEvents) &#123;</div><div class="line">               <span class="keyword">if</span> (waitingEvents.isEmpty()) &#123;</div><div class="line">                  isRunning = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      LOG.error(<span class="string">"Event thread exiting due to interruption"</span>, e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    LOG.info(<span class="string">"EventThread shut down for session: 0x&#123;&#125;"</span>,</div><div class="line">             Long.toHexString(getSessionId()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>那么waitingEvents事件队列在哪些地方还能赋值呢？</strong></p>
<p>在上面的sendThread.readResponse（）方法中。</p>
<p>对于服务端的响应类型if (replyHdr.getXid() == -1)  也会存放数据到waitingEvents事件队列中。</p>
<p>举个例子：</p>
<p>​    假设客户端调用的api是：zk.getData(“/app”,new wahcher(){})// 在app节点上注册了监听，那么当下次客户发出请求zk.setDate(“/app”,”123”)，是不是会触发事件？是的。</p>
<p>​    那么当服务端收到setData请求类型后，调用final处理器，然后调用dataTree.setData()最后持久化数据到内存，那么此时就需要给客户端一个通知，说我修改了数据，你要触发一下你在app节点注册的事件。然后此时设置replyHdr.getXid() = -1。</p>
<p>​    客户端收到响应后，在sendThread.readResponse（）方法中处理响应数据，发现replyHdr.getXid() == -1。说明app节点数据被修改，那么需要触发事件，那么就会把赋值数据到waitingEvents事件队列中。然后等到eventThread的run方法处理。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​    以上就是整个触发事件的逻辑。我们不难发现。如果客户端再某个节点上注册了监听事件，那么当他请求服务端时不会吧该监听事件一并发过去（例如客户端发起：zk.getData(“/app”,new wahcher(){})请求），只是发送了一个标志位watch==true，代表我再这个节点注册了监听。（因为最终处理监听事件的逻辑会在客户端）</p>
<p>​    服务端收到请求后，然后处理调用处理链处理请求，最后在final处理器中，判断发现，客户端在这个节点上注册了监听，那么服务端就需要记录一下，把记录的值放到<code>HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable</code>中。然后响应客户端的请求。整个逻辑结束。<strong>1.服务端收到需要触发事件通知然后保存触发事件的节点路径和通知客户端触发事件的cnx</strong></p>
<p>​    因为我们知道：zk.getData(“/app”,new wahcher(){})这样的请求，只是去拿zpp节点的数据，然后顺便绑定一个事件。并不会触发事件，只有当下次app节点数据修改了，才会触发事件。</p>
<p>​    那么当下次客户端调用zk.setDate(“/app”,”123”)时，服务端处理流程一样，也是通过处理链最后经过final处理器，但是唯一不同的是，这次操作是个更新操作，事务操作。那么最终会执行dataTree.setData()持久化数据到zk服务器内存。</p>
<p> 接着在dataTree.setData()最后，服务端会通知客户端触发事件，因为app节点的值修改了，你上次也绑定了一个事件。<strong>2.需要客户端触发事件</strong></p>
<p>​    那么服务端发出请求会通知客户端触发事件，通过ServercnxNIO发送通知，这个通知的xid设置为-1，表示这个请求是个触发事件的请求，然后从watchTable中移除相应事件（这个也就是为什么事件只能触发一次的原因，触发一次，就移除一次） – <strong>在这里我们不难发现服务端通知客户端触发事件并不能保证客户端一定能触发成功，他只是通知而已，服务端并没有确认是否触发成功机制</strong></p>
<p>​    接着客户端再sendThread.readRespose（）中获得服务端的请求，然后判断xid，如果等于1，那么说明服务端需要客户端触发事件，那么就把往waitingEvents中存放数据，然后等待eventThread线程的run方法执行，然后触发事件。 <strong>3.客户端触发事件，触发事件流程结束</strong></p>
<h2 id="！！为什么监听的事件只处理一次-watcher机制源码！！"><a href="#！！为什么监听的事件只处理一次-watcher机制源码！！" class="headerlink" title="！！为什么监听的事件只处理一次 - watcher机制源码！！"></a>！！为什么监听的事件只处理一次 - watcher机制源码！！</h2><p>在开始查看源码前，我们先思考几个问题，这样带着问题去读源码会更有效果。</p>
<p><strong>问题一：为什么监听的事件只能调用一次。</strong></p>
<blockquote>
<p>​    <strong>我们知道，原生的zk客户端监听节点事件的时候，只能够监听一次。</strong>那么他的本质是什么呢？为什么只有一次监听。</p>
<p>这里先说结论：</p>
<p>​    <strong>因为，服务端和客户端把对于某个节点的事件都放到一个列表中，每触发一个，就remove一个而不是take，所以只能够监听一次。（这里解释了为什么监听只会触发一次的原因）</strong></p>
</blockquote>
<p>详情代码验证，请看上面的<eventthread处理监听事件之eventthread.run方法分析>和下面<watcher监听事件机制之triggerwatch方法的分析></watcher监听事件机制之triggerwatch方法的分析></eventthread处理监听事件之eventthread.run方法分析></p>
<p><strong>问题二：客户端会把监听的watcher发送给服务端么？</strong></p>
<p>​    但是这个时候存在第二个疑问？那就是如果客户端监听了某个节点，那么在请求服务端操作的时候，会把监听器也一并发送给服务端么？例如如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Stat stat = <span class="keyword">new</span> Stat();;</div><div class="line">keeper.getData(<span class="string">"/app"</span>, <span class="keyword">new</span> Watcher() &#123;<span class="comment">//给app节点，创建新的监听器</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">		System.out.println( <span class="string">"监听kinge节点输出的事件："</span>+event );</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;, stat );<span class="comment">//那么此时给服务端你发送getdata请求时，会把new出来的watcher一并发送过去么？然后由服务端来调用new出来的watcher然后出发么？是怎么样的一个操作逻辑？？</span></div></pre></td></tr></table></figure>
<p>答案是：不会发送new出来的watcher给服务端，没有必要，只会发送标志位过去（会在请求中设置watch==true的标志位）</p>
<p><strong>问题三：zk客户端怎么存储监听的事件？</strong></p>
<p>​    为了方便直接出发监听器，那么存储的数据结构，应该是一个这样的结构<code>map&lt;string，Set&lt;Watcher&gt;&gt;</code>，key是保存着节点的路径，value是监听这个节点路径的所有watcher。</p>
<p>​    <strong>那么这样就可以轻松的触发某个节点的所有监听器。</strong></p>
<p>​    <strong>!!!!那么这个map是什么时候赋值的呢？!!!!!!</strong>  是在调用api的时候就马上put到map还是什么时候呢？例如调用keeper.exists(“/app”, true)。的时候就直接put监听器到map中么？</p>
<p>  这里先说答案：<strong>不是</strong>，<strong>只有当收到服务端响应请求后，再去注册事件，然后才把事件监听放到map中。然后再去触发。</strong>（详情参见上面代码分析&lt;<strong>最后处理finishPacket()请求</strong>&gt;）</p>
<blockquote>
<p><strong>zk能够注册监听的三种方式</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ZooKeeper keeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost:2181"</span>, <span class="number">5000</span>, <span class="keyword">new</span> Watcher() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;<span class="comment">//zk默认的总体的监听器，代码1</span></div><div class="line">			System.out.println( <span class="string">"输出的事件："</span>+ event.toString() );</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">keeper.exists(<span class="string">"/app"</span>, <span class="keyword">true</span>);<span class="comment">//注册的事件存放到existWatches</span></div><div class="line">keeper.getData(path, watcher, stat)<span class="comment">//注册的事件存放到dataWatches</span></div><div class="line">keeper.getChildren(path, watch, stat)<span class="comment">//注册的事件存放到childWatches</span></div><div class="line"></div><div class="line"><span class="comment">//也就是说zk只有在这三种操作的时候，才能够注册监听。如果在调用这三种api时，不指定新的watcher监听器，那么就会默认使用创建zk客户端时创建的监听器（代码1处）</span></div></pre></td></tr></table></figure>
<p>​    接下来我们就通过<code>keeper.exists(&quot;/app&quot;, true)&lt;这里的true表示监听app节点是否存在，并且使用默认的zk监听器&gt;</code> 来走一遍流程，探究一下watcher事件是如何触发的。</p>
<p>​    </p>
<p>结合问题三：我们发现这三种api对应的事件监听都会分别放到一个map中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">org.apache.zookeeper.ZooKeeper.ZKWatchManager  </div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; dataWatches =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; existWatches =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;Watcher&gt;&gt; childWatches =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;String, Set&lt;Watcher&gt;&gt;();</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>exists()源码</strong></p>
</blockquote>
<p>‘可以看到，如果是watch===true，那么就会使用zk默认的监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(String path, <span class="keyword">boolean</span> watch)</span> <span class="keyword">throws</span> KeeperException,</span></div><div class="line"><span class="function">    InterruptedException</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> exists(path, watch ? watchManager.defaultWatcher : <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//接着调用</span></div><div class="line"> <span class="function"><span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> KeeperException, InterruptedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">final</span> String clientPath = path;</div><div class="line">        PathUtils.validatePath(clientPath);</div><div class="line"></div><div class="line">        <span class="comment">// the watch contains the un-chroot path</span></div><div class="line">        WatchRegistration wcb = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</div><div class="line">            wcb = <span class="keyword">new</span> ExistsWatchRegistration(watcher, clientPath);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> String serverPath = prependChroot(clientPath);</div><div class="line"></div><div class="line">     <span class="comment">//下面这段代码，我们在上面的zk客户端发送create请求说过。最终发送的请求都会封装成一个request</span></div><div class="line">        RequestHeader h = <span class="keyword">new</span> RequestHeader();</div><div class="line">        h.setType(ZooDefs.OpCode.exists);</div><div class="line">        ExistsRequest request = <span class="keyword">new</span> ExistsRequest();</div><div class="line">        request.setPath(serverPath);<span class="comment">//设置请求节点路径</span></div><div class="line">        request.setWatch(watcher != <span class="keyword">null</span>);<span class="comment">//很关键，如果监听器不为空，那么说明当前调用是需要触发监听器的。</span></div><div class="line">        SetDataResponse response = <span class="keyword">new</span> SetDataResponse();</div><div class="line">        ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);<span class="comment">//提交请求</span></div><div class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (r.getErr() == KeeperException.Code.NONODE.intValue()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()),</div><div class="line">                    clientPath);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> response.getStat().getCzxid() == -<span class="number">1</span> ? <span class="keyword">null</span> : response.getStat();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​    <strong>在这段代码中，我们不难发现，实际上发送给服务端的请求，实际上，并没有带上注册的监听器，仅仅只是设置了一个标志位 request.setWatch（true） </strong>  —– <strong>验证了我们上面提出的问题二的结论</strong></p>
<blockquote>
<p><strong>接着调用cnx.submitRequest（）发送请求</strong></p>
</blockquote>
<p>​    关于这段代码的逻辑，在上面我们已经说过了，就不再具体说明。</p>
<p>​    简单说一下。在这个方法中会把请求信息包装成一个Packet，然后把Packet放到一个队列中，LinkedList<packet> outgoingQueue。然后结束。</packet></p>
<p>​    那么什么时候发送请求给服务端呢？通过SendThread的run方法进行发送。（sendThread线程在这之前就已经启动了）。</p>
<p>那么我们还记得在启动SendThread线程的同时，还启动了另外一个线程：<strong>EventThread线程</strong></p>
<p>那么他就是用来处理watcher事件的。</p>
<p>那么我们知道 <strong>调用cnx.submitRequest（）发送请求后。客户端会阻塞等待服务端响应，那么这个时候接下来就需要看server端处理请求的逻辑了 – 客户端执行逻辑到这里就结束了</strong>。</p>
<p>​    <strong>接下来的核心就是继续研究server端的处理请求逻辑了，我们跟踪到server端的final处理器，会发现，server端封装了两个hashmap来保存处理事件的监听机制(详情请看《watcher监听事件机制》)</strong></p>
<p>### </p>
<h2 id="客户端执行quit退出命令行操作会发生什么"><a href="#客户端执行quit退出命令行操作会发生什么" class="headerlink" title="客户端执行quit退出命令行操作会发生什么"></a>客户端执行quit退出命令行操作会发生什么</h2><p>​    我们知道，凡是客户端的操作，都会涉及到一个操作类型，例如是create，delete，getData，setAcl等等，那么quit操作，对应会发送一个closeSession的操作码给服务端，然后服务端，经过处理链的处理，最后在final处理器，删除session（客户端跟服务端的连接，都会维持一个session），删除在内存中的临时节点（我们知道临时节点在客户端断开连接后，自动会被删除）</p>
<h2 id="zookeeper集群优先选择连接节点改造"><a href="#zookeeper集群优先选择连接节点改造" class="headerlink" title="zookeeper集群优先选择连接节点改造"></a>zookeeper集群优先选择连接节点改造</h2><p>本质是修改StaticHostProvider类，选出下一个连接server的地址的逻辑。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>运行zkCli.sh文件最终发生这几部动作：</p>
<ul>
<li>创建zookeeper客户端<ul>
<li>创建ClientCnxnSocket，准确的说是：ClientCnxnSocketNIO</li>
<li>创建SendThread线程<ul>
<li>目的是通过NIO方式构建一个到服务端的连接</li>
</ul>
</li>
<li>创建EventThread线程</li>
<li>启动上面两个线程，SendThread初始化NIO的socket连接，发送请求给客户端。</li>
</ul>
</li>
<li>解析命令行，然后发送请求给服务端<ul>
<li>根据请求，封装成一个packet，放到outgoingqueue队列中，然后阻塞等待处理结果。</li>
<li>接着SendThread线程会在while循环中，不断的从outgoingqueue队列中取出请求的packet，通过初始化好的ClientCnxnSocketNIO，发送packet给服务端，然后将已经处理的packet节点从outgoingqueue中移除，并加入到pendingqueue中，等待处理结果。</li>
<li>根据doIO方法，处理outgoingqueue中的packet，然后把处理后的packet加入pendingqueue，等待服务端的响应</li>
<li>在doIO方法中处理服务端的响应，然后从pendingqueue移除已经处理的packet，然后标记当前packet节点为完成，finished=true。</li>
<li>然后服务端响应结果给客户端，完成请求。</li>
</ul>
</li>
</ul>
<ul>
<li>EventThread处理监听事件<ul>
<li>从waitEventQueue中获取事件，然后在run方法中触发调用。</li>
</ul>
</li>
</ul>
<p>​    <strong>我们可以发现，同一个客户端的请求，按其发送顺序依次执行。（根据outgoingqueue从头部逐个取出）</strong></p>
<p>​    客户端主要是通过两个线程进行主要的工作。其中SendThread主要是进行，请求的发送和处理服务端响应的结果。EventThread主要是处理触发的事件（客户端在操作节点时绑定的监听器）</p>
<p>​    <strong>同时我们发现doIO方法，会在处理正常客户端请求后服务端返回的响应数据，也会处理服务端发出触发事件的请求。</strong></p>
<p> 换句话说，EventThread线程处理的waitEventQueue队列数据的来源，就是在doIO中进行赋值。</p>
<h1 id="zk客户端连接服务端超时源码解析"><a href="#zk客户端连接服务端超时源码解析" class="headerlink" title="zk客户端连接服务端超时源码解析"></a>zk客户端连接服务端超时源码解析</h1><p>核心源码处理，就在SendThread线程中的run方法。而且我们知道<strong>run方法内部是一个while循环</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">       <span class="keyword">if</span> (state.isConnected()) &#123;</div><div class="line">             <span class="comment">// determine whether we need to send an AuthFailed event.</span></div><div class="line">             <span class="keyword">if</span> (zooKeeperSaslClient != <span class="keyword">null</span>) &#123;</div><div class="line">                 <span class="keyword">boolean</span> sendAuthEvent = <span class="keyword">false</span>;</div><div class="line">                 <span class="keyword">if</span> (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) &#123;</div><div class="line">                     <span class="keyword">try</span> &#123;</div><div class="line">                         zooKeeperSaslClient.initialize(ClientCnxn.<span class="keyword">this</span>);</div><div class="line">                     &#125; <span class="keyword">catch</span> (SaslException e) &#123;</div><div class="line">                        LOG.error(<span class="string">"SASL authentication with Zookeeper Quorum member failed: "</span> + e);</div><div class="line">                         state = States.AUTH_FAILED;</div><div class="line">                         sendAuthEvent = <span class="keyword">true</span>;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">                 KeeperState authState = zooKeeperSaslClient.getKeeperState();</div><div class="line">                 <span class="keyword">if</span> (authState != <span class="keyword">null</span>) &#123;</div><div class="line">                     <span class="keyword">if</span> (authState == KeeperState.AuthFailed) &#123;</div><div class="line">                         <span class="comment">// An authentication error occurred during authentication with the Zookeeper Server.</span></div><div class="line">                         state = States.AUTH_FAILED;</div><div class="line">                         sendAuthEvent = <span class="keyword">true</span>;</div><div class="line">                     &#125; <span class="keyword">else</span> &#123;</div><div class="line">                         <span class="keyword">if</span> (authState == KeeperState.SaslAuthenticated) &#123;</div><div class="line">                             sendAuthEvent = <span class="keyword">true</span>;</div><div class="line">                         &#125;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="keyword">if</span> (sendAuthEvent == <span class="keyword">true</span>) &#123;</div><div class="line">                     eventThread.queueEvent(<span class="keyword">new</span> WatchedEvent(</div><div class="line">                           Watcher.Event.EventType.None,</div><div class="line">                           authState,<span class="keyword">null</span>));</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">            <span class="comment">// 下一次超时时间</span></div><div class="line">             to = readTimeout - clientCnxnSocket.getIdleRecv();</div><div class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果还没连接上 重置当前剩余可连接时间</span></div><div class="line">             to = connectTimeout - clientCnxnSocket.getIdleRecv();</div><div class="line">         &#125;</div><div class="line"><span class="keyword">if</span> (to &lt;= <span class="number">0</span>) &#123;<span class="comment">//如果小于0，那么说明已经超时连接，就抛出异常，那么在哪里处理异常呢？还是在SendThread的run方法中，异常处理完成后，然后接着再次进入while循环，然后重新从server服务地址列表中，随机取一个地址进行连接（  serverAddress = hostProvider.next(1000);）</span></div><div class="line">                 String warnInfo;</div><div class="line">                 warnInfo = <span class="string">"Client session timed out, have not heard from server in "</span></div><div class="line">                     + clientCnxnSocket.getIdleRecv()</div><div class="line">                     + <span class="string">"ms"</span></div><div class="line">                     + <span class="string">" for sessionid 0x"</span></div><div class="line">                     + Long.toHexString(sessionId);</div><div class="line">                 LOG.warn(warnInfo);</div><div class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> SessionTimeoutException(warnInfo);</div><div class="line">             &#125;</div></pre></td></tr></table></figure>
<h1 id="zk服务端源码解析-单机模式"><a href="#zk服务端源码解析-单机模式" class="headerlink" title="zk服务端源码解析 - 单机模式"></a>zk服务端源码解析 - 单机模式</h1><p>​    我们知道，zk的服务端有单机模式和集群模式，实际上两者的区别，就是在zoo.cfg配置文件中，集群模式比单机模式多了，server.*这样的配置列表。</p>
<p>​    这里先说单机模式的服务端源码解析。</p>
<p>同理，启动服务端，调用的脚本文件是：zkServer.sh，最终会去执行org.apache.zookeeper.server.quorum.QuorumPeerMain#main类。</p>
<h2 id="QuorumPeerMain类源码"><a href="#QuorumPeerMain类源码" class="headerlink" title="QuorumPeerMain类源码"></a>QuorumPeerMain类源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ZooKeeperServerMain main = <span class="keyword">new</span> ZooKeeperServerMain();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        main.initializeAndRun(args);<span class="comment">//根据配置zoo.cfg文件，解析出配置的信息</span></div><div class="line">    &#125;</div><div class="line">。。。。。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着调用initializeAndRun方法，然后执行里面的 config.parse()，解析配置文件，最终所有配置信息，都会保存到QuorumPeerConfig类中。</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409113142773.png" alt="image-20200409113142773"></p>
<h3 id="解析zoo-cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略"><a href="#解析zoo-cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略" class="headerlink" title="解析zoo.cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略"></a>解析zoo.cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略</h3><p><strong>那么他是怎么识别是集群模式还是单机模式，就是在解析配置文件的过程中，进行判断的。</strong></p>
<p>解析的方法，最终会调用<code>org.apache.zookeeper.server.quorum.QuorumPeerConfig.parseProperties(Properties)</code></p>
<p>里面有一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(<span class="string">"server."</span>)) &#123;<span class="comment">//判断配置文件中是否存在，server.这样的配置信息，如果有，说明是集群模式，并把配置信息放到servers的Map中，保存，需要注意，如果server是观察者，那么需要放到observers中。因为观察者不参与投票，servsers中的节点是需要参与投票的。</span></div><div class="line">                <span class="keyword">int</span> dot = key.indexOf(<span class="string">'.'</span>);</div><div class="line">                <span class="keyword">long</span> sid = Long.parseLong(key.substring(dot + <span class="number">1</span>));</div><div class="line">                String parts[] = splitWithLeadingHostname(value);</div><div class="line">                <span class="keyword">if</span> ((parts.length != <span class="number">2</span>) &amp;&amp; (parts.length != <span class="number">3</span>) &amp;&amp; (parts.length !=<span class="number">4</span>)) &#123;</div><div class="line">                    LOG.error(value</div><div class="line">                       + <span class="string">" does not have the form host:port or host:port:port "</span> +</div><div class="line">                       <span class="string">" or host:port:port:type"</span>);</div><div class="line">                &#125;</div><div class="line">                LearnerType type = <span class="keyword">null</span>;</div><div class="line">                String hostname = parts[<span class="number">0</span>];</div><div class="line">                Integer port = Integer.parseInt(parts[<span class="number">1</span>]);</div><div class="line">                Integer electionPort = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">2</span>)&#123;</div><div class="line">                	electionPort=Integer.parseInt(parts[<span class="number">2</span>]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">3</span>)&#123;</div><div class="line">                    <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">"observer"</span>)) &#123;</div><div class="line">                        type = LearnerType.OBSERVER;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">"participant"</span>)) &#123;</div><div class="line">                        type = LearnerType.PARTICIPANT;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigException(<span class="string">"Unrecognised peertype: "</span> + value);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (type == LearnerType.OBSERVER)&#123;</div><div class="line">                    observers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    servers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<p>我们往下看你会发现，一个涉及到我们经常说的，半数选举策略。 <code>quorumVerifier = new QuorumMaj(servers.size());</code>  通过servers的数量获得半数数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuorumMaj</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.half = n/<span class="number">2</span>;<span class="comment">// 例如 13/2 == 6</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断启动的是单机版server还是集群模式"><a href="#判断启动的是单机版server还是集群模式" class="headerlink" title="判断启动的是单机版server还是集群模式"></a>判断启动的是单机版server还是集群模式</h3><p>配置信息解析完成后，下一步就是启动server，那么在启动之前，会涉及到单机模式还是集群模式的判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeAndRun</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> ConfigException, IOException</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    QuorumPeerConfig config = <span class="keyword">new</span> QuorumPeerConfig();</div><div class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</div><div class="line">        config.parse(args[<span class="number">0</span>]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Start and schedule the the purge task</span></div><div class="line">    DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(config</div><div class="line">            .getDataDir(), config.getDataLogDir(), config</div><div class="line">            .getSnapRetainCount(), config.getPurgeInterval());</div><div class="line">    purgeMgr.start();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.servers.size() &gt; <span class="number">0</span>) &#123;<span class="comment">//集群模式</span></div><div class="line">        runFromConfig(config);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//单机模式</span></div><div class="line">        LOG.warn(<span class="string">"Either no config or no quorum defined in config, running "</span></div><div class="line">                + <span class="string">" in standalone mode"</span>);</div><div class="line">        <span class="comment">// there is only server in the quorum -- run as standalone</span></div><div class="line">        ZooKeeperServerMain.main(args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    因为这里分析的是单机模式的server，所以最后最终调用的是，<code>ZooKeeperServerMain.main(args);</code>  ， 然后紧接着最终调用的是<code>org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig(ServerConfig)</code></p>
<p><strong>启动单机模式的server。</strong></p>
<h3 id="启动单机版server"><a href="#启动单机版server" class="headerlink" title="启动单机版server"></a>启动单机版server</h3><p>我们查看一下，启动单机模式的server主要代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(ServerConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    LOG.info(<span class="string">"Starting server"</span>);</div><div class="line">    FileTxnSnapLog txnLog = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">final</span> ZooKeeperServer zkServer = <span class="keyword">new</span> ZooKeeperServer();<span class="comment">//zk服务端，对应客户端的Zookeeper,负责维护一个处理器链表processor chain</span></div><div class="line"></div><div class="line">        <span class="keyword">final</span> CountDownLatch shutdownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);<span class="comment">//使用cd，启动server后挂起，直到server出异常或者被关闭，执行countDown()，然后唤醒当前main线程，执行关闭服务操作</span></div><div class="line">        zkServer.registerServerShutdownHandler(</div><div class="line">                <span class="keyword">new</span> ZooKeeperServerShutdownHandler(shutdownLatch));</div><div class="line"></div><div class="line">        txnLog = <span class="keyword">new</span> FileTxnSnapLog(<span class="keyword">new</span> File(config.dataLogDir), <span class="keyword">new</span> File(</div><div class="line">                config.dataDir));<span class="comment">//FileTxnSnapLog,管理FileTxLog和FileSnap</span></div><div class="line">        txnLog.setServerStats(zkServer.serverStats());</div><div class="line">        zkServer.setTxnLogFactory(txnLog);</div><div class="line">        zkServer.setTickTime(config.tickTime);</div><div class="line">        zkServer.setMinSessionTimeout(config.minSessionTimeout);</div><div class="line">        zkServer.setMaxSessionTimeout(config.maxSessionTimeout);</div><div class="line">         <span class="comment">// 建立socket,默认是NIOServerCnxnFactory（是一个线程）</span></div><div class="line">        cnxnFactory = ServerCnxnFactory.createFactory();<span class="comment">//代码1，创建一个上下文处理器,管理来自客户端的连接，</span></div><div class="line">        cnxnFactory.configure(config.getClientPortAddress(),</div><div class="line">                config.getMaxClientCnxns());</div><div class="line">        cnxnFactory.startup(zkServer);</div><div class="line">        shutdownLatch.await();<span class="comment">//启动后，等待countDown()，如果触发，那么说明，server需要关闭，那么main线程被唤醒，继续往下执行shutdown()方法</span></div><div class="line">        shutdown();</div><div class="line"></div><div class="line">        cnxnFactory.join();</div><div class="line">        <span class="keyword">if</span> (zkServer.canShutdown()) &#123;</div><div class="line">            zkServer.shutdown(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        <span class="comment">// warn, but generally this is ok</span></div><div class="line">        LOG.warn(<span class="string">"Server interrupted"</span>, e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (txnLog != <span class="keyword">null</span>) &#123;</div><div class="line">            txnLog.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看一下代码1，默认创建的也是一个NIO的上下文，<strong>负责处理客户端的连接</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> ServerCnxnFactory <span class="title">createFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    String serverCnxnFactoryName =</div><div class="line">        System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);</div><div class="line">    <span class="keyword">if</span> (serverCnxnFactoryName == <span class="keyword">null</span>) &#123;</div><div class="line">        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();<span class="comment">//NIOServer</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)</div><div class="line">                .getDeclaredConstructor().newInstance();</div><div class="line">        LOG.info(<span class="string">"Using &#123;&#125; as server connection factory"</span>, serverCnxnFactoryName);</div><div class="line">        <span class="keyword">return</span> serverCnxnFactory;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        IOException ioe = <span class="keyword">new</span> IOException(<span class="string">"Couldn't instantiate "</span></div><div class="line">                + serverCnxnFactoryName);</div><div class="line">        ioe.initCause(e);</div><div class="line">        <span class="keyword">throw</span> ioe;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="根据NIOServerCnxnFactory建立socket，监听客户端连接"><a href="#根据NIOServerCnxnFactory建立socket，监听客户端连接" class="headerlink" title="根据NIOServerCnxnFactory建立socket，监听客户端连接"></a>根据NIOServerCnxnFactory建立socket，监听客户端连接</h4><p>调用 cnxnFactory.configure(config.getClientPortAddress(),<br>                config.getMaxClientCnxns());</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(InetSocketAddress addr, <span class="keyword">int</span> maxcc)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    configureSaslLogin();</div><div class="line"></div><div class="line">    <span class="comment">// 把当前类作为线程</span></div><div class="line">    thread = <span class="keyword">new</span> ZooKeeperThread(<span class="keyword">this</span>, <span class="string">"NIOServerCxn.Factory:"</span> + addr);</div><div class="line">    <span class="comment">// java中线程分为两种类型：用户线程和守护线程。</span></div><div class="line">    <span class="comment">// 通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。</span></div><div class="line">    <span class="comment">// 如果不设置次属性，默认为用户线程。</span></div><div class="line">    <span class="comment">// 守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。</span></div><div class="line">    <span class="comment">// 那Java的守护线程是什么样子的呢。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出</span></div><div class="line">    <span class="comment">// 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。</span></div><div class="line">    <span class="comment">// 它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</span></div><div class="line"></div><div class="line">    <span class="comment">// 所以这里的这个线程是为了和JVM生命周期绑定，只剩下这个线程时已经没有意义了，应该关闭掉。</span></div><div class="line">    thread.setDaemon(<span class="keyword">true</span>);</div><div class="line">    maxClientCnxns = maxcc;</div><div class="line">    <span class="keyword">this</span>.ss = ServerSocketChannel.open();</div><div class="line">    ss.socket().setReuseAddress(<span class="keyword">true</span>);</div><div class="line">    LOG.info(<span class="string">"binding to port "</span> + addr);</div><div class="line">    ss.socket().bind(addr);</div><div class="line">    ss.configureBlocking(<span class="keyword">false</span>);</div><div class="line">    ss.register(selector, SelectionKey.OP_ACCEPT);<span class="comment">//注册连接事件，监听客户端的连接</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="启动NIOServerCnxnFactory线程，接受客户端的请求"><a href="#启动NIOServerCnxnFactory线程，接受客户端的请求" class="headerlink" title="启动NIOServerCnxnFactory线程，接受客户端的请求"></a>启动NIOServerCnxnFactory线程，接受客户端的请求</h4><p>​    cnxnFactory.startup(zkServer);主要是做三件事情：<strong>启动NIOServerCnxnFactory线程、加载快照数据到内存、初始化请求处理链。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">(ZooKeeperServer zks)</span> <span class="keyword">throws</span> IOException,InterruptedException </span>&#123;</div><div class="line">    <span class="comment">// 启动线程</span></div><div class="line">    start();</div><div class="line">    <span class="comment">// 初始化zkServer</span></div><div class="line">    setZooKeeperServer(zks);</div><div class="line">    <span class="comment">// 加载数据</span></div><div class="line">    zks.startdata();</div><div class="line">    <span class="comment">// 设置请求处理器链</span></div><div class="line">    zks.startup();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>// 1.启动线程NIOServerCnxnFactory</strong>，监听客户端请求</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!ss.socket().isClosed()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            selector.select(<span class="number">1000</span>);</div><div class="line">            Set&lt;SelectionKey&gt; selected;</div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                selected = selector.selectedKeys();</div><div class="line">            &#125;</div><div class="line">            ArrayList&lt;SelectionKey&gt; selectedList = <span class="keyword">new</span> ArrayList&lt;SelectionKey&gt;(</div><div class="line">                    selected);</div><div class="line">            Collections.shuffle(selectedList);</div><div class="line">            <span class="keyword">for</span> (SelectionKey k : selectedList) &#123;</div><div class="line">                <span class="keyword">if</span> ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 建立连接</span></div><div class="line">                    SocketChannel sc = ((ServerSocketChannel) k</div><div class="line">                            .channel()).accept();</div><div class="line">                    InetAddress ia = sc.socket().getInetAddress();</div><div class="line">                    <span class="keyword">int</span> cnxncount = getClientCnxnCount(ia);</div><div class="line">                    <span class="keyword">if</span> (maxClientCnxns &gt; <span class="number">0</span> &amp;&amp; cnxncount &gt;= maxClientCnxns)&#123;</div><div class="line">                        LOG.warn(<span class="string">"Too many connections from "</span> + ia</div><div class="line">                                 + <span class="string">" - max is "</span> + maxClientCnxns );</div><div class="line">                        sc.close();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        LOG.info(<span class="string">"Accepted socket connection from "</span></div><div class="line">                                 + sc.socket().getRemoteSocketAddress());</div><div class="line">                        sc.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                        SelectionKey sk = sc.register(selector,</div><div class="line">                                SelectionKey.OP_READ);</div><div class="line"></div><div class="line">                        <span class="comment">// 创建连接</span></div><div class="line">                        NIOServerCnxn cnxn = createConnection(sc, sk);</div><div class="line">                        sk.attach(cnxn);</div><div class="line">                        addCnxn(cnxn);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 接收数据,这里会间歇性的接收到客户端的ping</span></div><div class="line">                    NIOServerCnxn c = (NIOServerCnxn) k.attachment();</div><div class="line">                    <span class="comment">// 处理客户端请求</span></div><div class="line">                    c.doIO(k);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">                        LOG.debug(<span class="string">"Unexpected ops in select "</span></div><div class="line">                                  + k.readyOps());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            selected.clear();</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">            LOG.warn(<span class="string">"Ignoring unexpected runtime exception"</span>, e);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            LOG.warn(<span class="string">"Ignoring exception"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    closeAll();</div><div class="line">    LOG.info(<span class="string">"NIOServerCnxn factory exited run method"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>zks.startdata()加载数据</strong></p>
</blockquote>
<p>因为我们知道，server端可能已经存在数据，那么在启动server端后，应该重放数据，把数据加载到内存中。</p>
<p>zk的数据由两个部分组成：<strong>日志和快照。</strong>  <strong>他们都是保存在磁盘中。</strong> server服务器启动时，会通过磁盘上的事务日志和快照数据文件恢复成完整的内存数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startdata</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">    <span class="comment">//check to see if zkDb is not null</span></div><div class="line">    <span class="keyword">if</span> (zkDb == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// txnLogFactory就是存储日志文件与快照的工具类，在ZooKeeperServerMain中赋值的</span></div><div class="line">        zkDb = <span class="keyword">new</span> ZKDatabase(<span class="keyword">this</span>.txnLogFactory);</div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (!zkDb.isInitialized()) &#123;<span class="comment">// 一开始为false</span></div><div class="line">        <span class="comment">// 没有初始化，加载数据</span></div><div class="line">        loadData();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span>(zkDb.isInitialized())&#123;</div><div class="line">        <span class="comment">// 已经初始化</span></div><div class="line">        setZxid(zkDb.getDataTreeLastProcessedZxid());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有初始化</span></div><div class="line">        setZxid(zkDb.loadDataBase());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 找到过期的session</span></div><div class="line">    LinkedList&lt;Long&gt; deadSessions = <span class="keyword">new</span> LinkedList&lt;Long&gt;();</div><div class="line">    <span class="keyword">for</span> (Long session : zkDb.getSessions()) &#123;</div><div class="line">        <span class="keyword">if</span> (zkDb.getSessionWithTimeOuts().get(session) == <span class="keyword">null</span>) &#123;</div><div class="line">            deadSessions.add(session);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置initialized为true，表示已经初始化</span></div><div class="line">    zkDb.setDataTreeInit(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 清除过期的session</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> session : deadSessions) &#123;</div><div class="line">        killSession(session, zkDb.getDataTreeLastProcessedZxid());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>zks.startup()初始化请求处理链</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// session跟踪器</span></div><div class="line">        createSessionTracker();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 启动session跟踪器，它是一个线程</span></div><div class="line">    startSessionTracker();</div><div class="line"></div><div class="line">    <span class="comment">// setupRequestProcessors()建立请求处理器链</span></div><div class="line">    setupRequestProcessors();</div><div class="line"></div><div class="line">    registerJMX();</div><div class="line"></div><div class="line">    setState(State.RUNNING);</div><div class="line">    notifyAll();</div><div class="line">&#125;</div><div class="line"></div><div class="line">这三个请求处理器都是线程，组成一条请求链</div><div class="line">PrepRequestProcessor ———&gt;&gt; SyncRequestProcessor ———&gt;&gt; FinalRequestProcessor</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 最后一个执行的请求处理器</span></div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// 第二个执行的请求处理器，封装了下一个执行的处理器finalProcessor</span></div><div class="line">RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</div><div class="line">        finalProcessor);</div><div class="line">((SyncRequestProcessor)syncProcessor).start();</div><div class="line"></div><div class="line"><span class="comment">// 第一个执行的请求处理器，封装了下一个执行的处理器syncProcessor</span></div><div class="line">firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);</div><div class="line">((PrepRequestProcessor)firstProcessor).start();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是已经做完了，server的启动工作，已经准备好接受和处理客户端请求。</p>
<h2 id="c-doIO-k-处理客户端请求"><a href="#c-doIO-k-处理客户端请求" class="headerlink" title="c.doIO(k)处理客户端请求"></a>c.doIO(k)处理客户端请求</h2><p>这个代码在<code>org.apache.zookeeper.server.NIOServerCnxnFactory.run()</code> ，也就是之前启动的线程。</p>
<p>接下来查看<code>org.apache.zookeeper.server.NIOServerCnxn.doIO(SelectionKey)</code> 怎么处理客户端的请求</p>
<p>在doIO方法中，最终会调用 <code>readPayload();</code> 处理请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readPayload</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (incomingBuffer.remaining() != <span class="number">0</span>) &#123; <span class="comment">// have we read length bytes?</span></div><div class="line">        <span class="keyword">int</span> rc = sock.read(incomingBuffer); <span class="comment">// sock is non-blocking, so ok</span></div><div class="line">        <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EndOfStreamException(</div><div class="line">                    <span class="string">"Unable to read additional data from client sessionid 0x"</span></div><div class="line">                    + Long.toHexString(sessionId)</div><div class="line">                    + <span class="string">", likely client has closed socket"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (incomingBuffer.remaining() == <span class="number">0</span>) &#123; <span class="comment">// have we read length bytes?</span></div><div class="line">        <span class="comment">// 计数</span></div><div class="line">        packetReceived();</div><div class="line">        incomingBuffer.flip();</div><div class="line">        <span class="keyword">if</span> (!initialized) &#123;</div><div class="line">            readConnectRequest();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 已连接，读取请求</span></div><div class="line">            readRequest();</div><div class="line">        &#125;</div><div class="line">        lenBuffer.clear();</div><div class="line">        incomingBuffer = lenBuffer;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着调用 readRequest()读取请求</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">- 这里的zkServer是在执行NIOServerCnxnFactory的run()-&gt;createConnection()</span></div><div class="line"><span class="comment">- 执行构造函数初始化的</span></div><div class="line"><span class="comment">*/</span></div><div class="line">   zkServer.processPacket(<span class="keyword">this</span>, incomingBuffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用ZooKeeperServer的processPacket处理请求"><a href="#使用ZooKeeperServer的processPacket处理请求" class="headerlink" title="使用ZooKeeperServer的processPacket处理请求"></a>使用ZooKeeperServer的processPacket处理请求</h3><p>​    </p>
<p>根据OpCode操作的类型，例如create还是delete，走相应的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 例如create命令就会走到这里来</span></div><div class="line"><span class="comment">// 构建Request</span></div><div class="line">Request si = <span class="keyword">new</span> Request(cnxn, cnxn.getSessionId(), h.getXid(),</div><div class="line">h.getType(), incomingBuffer, cnxn.getAuthInfo());</div><div class="line">si.setOwner(ServerCnxn.me);</div><div class="line"></div><div class="line"><span class="comment">// 提交请求。开始进入处理链处理逻辑</span></div><div class="line">submitRequest(si);</div></pre></td></tr></table></figure>
<h3 id="根据请求处理链，处理请求"><a href="#根据请求处理链，处理请求" class="headerlink" title="根据请求处理链，处理请求"></a>根据请求处理链，处理请求</h3><h4 id="请求处理器PrepRequestProcessor"><a href="#请求处理器PrepRequestProcessor" class="headerlink" title="请求处理器PrepRequestProcessor"></a>请求处理器PrepRequestProcessor</h4><blockquote>
<p><strong>submitRequest交由请求处理器处理数据</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(Request si)</span> </span>&#123;</div><div class="line">    <span class="comment">// 请求处理器PrepRequestProcessor，主要是做一些校验工作</span></div><div class="line">    <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (state == State.INITIAL) &#123;</div><div class="line">                    wait(<span class="number">1000</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                LOG.warn(<span class="string">"Unexpected interruption"</span>, e);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (firstProcessor == <span class="keyword">null</span> || state != State.RUNNING) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not started"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        touch(si.cnxn);<span class="comment">//客户端和服务端session会话管理功能，验证是否过期超时等等</span></div><div class="line">        <span class="comment">// 校验请求是否合法</span></div><div class="line">        <span class="keyword">boolean</span> validpacket = Request.isValid(si.type);</div><div class="line">        <span class="keyword">if</span> (validpacket) &#123;</div><div class="line">            <span class="comment">// 执行请求处理器，交由请求处理器处理</span></div><div class="line">            firstProcessor.processRequest(si);</div><div class="line">            <span class="keyword">if</span> (si.cnxn != <span class="keyword">null</span>) &#123;</div><div class="line">                incInProcess();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            LOG.warn(<span class="string">"Received packet at server of unknown type "</span> + si.type);</div><div class="line">            <span class="keyword">new</span> UnimplementedRequestProcessor().processRequest(si);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (MissingSessionException e) &#123;</div><div class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">            LOG.debug(<span class="string">"Dropping request: "</span> + e.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</div><div class="line">        LOG.error(<span class="string">"Unable to process request:"</span> + e.getMessage(), e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着将请求放到队列中submittedRequests</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> LinkedBlockingQueue&lt;Request&gt; submittedRequests = <span class="keyword">new</span> LinkedBlockingQueue&lt;Request&gt;();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">    <span class="comment">// request.addRQRec("&gt;prep="+zks.outstandingChanges.size());</span></div><div class="line">    submittedRequests.add(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到队列我们第一反应，应该是生产者消费者模型，肯定有个线程是从队列中取数据进行处理。那么处理逻辑在那里呢？</p>
<blockquote>
<p><strong>prep处理器的run方法 - 处理队列中的请求</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Request request = submittedRequests.take();<span class="comment">//从队列中拿到请求进行处理</span></div><div class="line">            <span class="keyword">long</span> traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;</div><div class="line">            <span class="keyword">if</span> (request.type == OpCode.ping) &#123;</div><div class="line">                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</div><div class="line">                ZooTrace.logRequest(LOG, traceMask, <span class="string">'P'</span>, request, <span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (Request.requestOfDeath == request) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            pRequest(request);<span class="comment">//最终走到这里</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</div><div class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> XidRolloverException) &#123;</div><div class="line">            LOG.info(e.getCause().getMessage());</div><div class="line">        &#125;</div><div class="line">        handleException(<span class="keyword">this</span>.getName(), e);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        handleException(<span class="keyword">this</span>.getName(), e);</div><div class="line">    &#125;</div><div class="line">    LOG.info(<span class="string">"PrepRequestProcessor exited loop!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着调用prep处理器的pRequest()方法处理请求</strong></p>
</blockquote>
<p><strong>他会从请求中，拿到请求的操作类型，来进行相应的逻辑。</strong>最终调用pRequest2Txn()方法或者检查session，最终调用下一个处理器继续处理请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pRequest</span><span class="params">(Request request)</span> <span class="keyword">throws</span> RequestProcessorException </span>&#123;</div><div class="line">    <span class="comment">// LOG.info("Prep&gt;&gt;&gt; cxid = " + request.cxid + " type = " +</span></div><div class="line">    <span class="comment">// request.type + " id = 0x" + Long.toHexString(request.sessionId));</span></div><div class="line">    request.hdr = <span class="keyword">null</span>;</div><div class="line">    request.txn = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">switch</span> (request.type) &#123;</div><div class="line">            <span class="keyword">case</span> OpCode.create:</div><div class="line">            CreateRequest createRequest = <span class="keyword">new</span> CreateRequest();</div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, createRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.delete:</div><div class="line">            DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest();               </div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.setData:</div><div class="line">            SetDataRequest setDataRequest = <span class="keyword">new</span> SetDataRequest();                </div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.setACL:</div><div class="line">            SetACLRequest setAclRequest = <span class="keyword">new</span> SetACLRequest();                </div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.check:</div><div class="line">            CheckVersionRequest checkRequest = <span class="keyword">new</span> CheckVersionRequest();              </div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OpCode.multi:</div><div class="line">           <span class="comment">//。。。。。省略部分代码</span></div><div class="line">            </div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">//create/close session don't require request record</span></div><div class="line">        <span class="keyword">case</span> OpCode.createSession:</div><div class="line">        <span class="keyword">case</span> OpCode.closeSession:</div><div class="line">            pRequest2Txn(request.type, zks.getNextZxid(), request, <span class="keyword">null</span>, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"> </div><div class="line">        <span class="comment">//All the rest don't need to create a Txn - just verify session</span></div><div class="line">                <span class="comment">//也就是说如果客户端发出的请求的操作命令是如下这些，那么不进行任何事务操作，只是检查session是否过期，然后将这些请求继续转发给下一个处理器 -- 也就是sync处理器</span></div><div class="line">        <span class="keyword">case</span> OpCode.sync:</div><div class="line">        <span class="keyword">case</span> OpCode.exists:</div><div class="line">        <span class="keyword">case</span> OpCode.getData:</div><div class="line">        <span class="keyword">case</span> OpCode.getACL:</div><div class="line">        <span class="keyword">case</span> OpCode.getChildren:</div><div class="line">        <span class="keyword">case</span> OpCode.getChildren2:</div><div class="line">        <span class="keyword">case</span> OpCode.ping:</div><div class="line">        <span class="keyword">case</span> OpCode.setWatches:</div><div class="line">            zks.sessionTracker.checkSession(request.sessionId,</div><div class="line">                    request.getOwner());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            LOG.warn(<span class="string">"unknown type "</span> + request.type);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"> 。。。。。。。。<span class="comment">//省略部分代码</span></div><div class="line">    request.zxid = zks.getZxid();</div><div class="line">    nextProcessor.processRequest(request);<span class="comment">//调用下一个处理器处理请求 -- sync处理器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="处理器SyncRequestProcessor持久化（快照）操作"><a href="#处理器SyncRequestProcessor持久化（快照）操作" class="headerlink" title="处理器SyncRequestProcessor持久化（快照）操作"></a>处理器SyncRequestProcessor持久化（快照）操作</h4><blockquote>
<p><strong>接着调用sync处理器的processRequest（）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">     <span class="comment">// request.addRQRec("&gt;sync");</span></div><div class="line">     queuedRequests.add(request);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>你会发现，sync处理器也是把请求放到队列中，所以很明显他跟prep处理器一样，也是生产消费模型。最终也是用过sync处理器的run方法从queuedRequests队列中拿到请求进行处理。</p>
<p>那么我们直接看sync处理器的run方法</p>
<blockquote>
<p><strong>sync处理器run()</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> logCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// we do this in an attempt to ensure that not all of the servers</span></div><div class="line">        <span class="comment">// in the ensemble take a snapshot at the same time</span></div><div class="line">        setRandRoll(r.nextInt(snapCount/<span class="number">2</span>));</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Request si = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</div><div class="line">                si = queuedRequests.take();<span class="comment">//拿出请求进行处理</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                si = queuedRequests.poll();</div><div class="line">                <span class="keyword">if</span> (si == <span class="keyword">null</span>) &#123;</div><div class="line">                    flush(toFlush);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (si == requestOfDeath) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;<span class="comment">//将请求持久化到磁盘中</span></div><div class="line">                <span class="comment">// track the number of records written to the log</span></div><div class="line">                <span class="keyword">if</span> (zks.getZKDatabase().append(si)) &#123;</div><div class="line">                    logCount++;</div><div class="line">                    <span class="keyword">if</span> (logCount &gt; (snapCount / <span class="number">2</span> + randRoll)) &#123;</div><div class="line">                        setRandRoll(r.nextInt(snapCount/<span class="number">2</span>));</div><div class="line">                        <span class="comment">// roll the log</span></div><div class="line">                        zks.getZKDatabase().rollLog();</div><div class="line">                        <span class="comment">// take a snapshot</span></div><div class="line">                        <span class="keyword">if</span> (snapInProcess != <span class="keyword">null</span> &amp;&amp; snapInProcess.isAlive()) &#123;</div><div class="line">                            LOG.warn(<span class="string">"Too busy to snap, skipping"</span>);</div><div class="line">                         &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            snapInProcess = <span class="keyword">new</span> ZooKeeperThread(<span class="string">"Snapshot Thread"</span>) &#123;</div><div class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                        <span class="keyword">try</span> &#123;</div><div class="line">                                            zks.takeSnapshot();</div><div class="line">                                        &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">                                            LOG.warn(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;</div><div class="line">                                &#125;;</div><div class="line">                            snapInProcess.start();</div><div class="line">                        &#125;</div><div class="line">                        logCount = <span class="number">0</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (toFlush.isEmpty()) &#123;</div><div class="line">     </div><div class="line">                    <span class="keyword">if</span> (nextProcessor != <span class="keyword">null</span>) &#123;<span class="comment">//然后将请求传给下一个处理器 -- final处理器</span></div><div class="line">                        nextProcessor.processRequest(si);</div><div class="line">                        <span class="keyword">if</span> (nextProcessor <span class="keyword">instanceof</span> Flushable) &#123;</div><div class="line">                            ((Flushable)nextProcessor).flush();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                toFlush.add(si);</div><div class="line">                <span class="keyword">if</span> (toFlush.size() &gt; <span class="number">1000</span>) &#123;</div><div class="line">                    flush(toFlush);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        handleException(<span class="keyword">this</span>.getName(), t);</div><div class="line">        running = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    LOG.info(<span class="string">"SyncRequestProcessor exited!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="处理器FinalRequestProcessor从队列中拿出数据进行内存操作"><a href="#处理器FinalRequestProcessor从队列中拿出数据进行内存操作" class="headerlink" title="处理器FinalRequestProcessor从队列中拿出数据进行内存操作"></a>处理器FinalRequestProcessor从队列中拿出数据进行内存操作</h4><p><strong>这是三个处理器里面唯一一个不是线程的处理器。</strong>也是本次处理请求中，最后一个处理器。</p>
<p>然后接着调用    public void processRequest(Request request) {}方法处理请求</p>
<blockquote>
<p><strong>processRequest()关键代码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">。。。。。。。<span class="comment">//省略部分代码</span></div><div class="line">          <span class="keyword">if</span> (request.hdr != <span class="keyword">null</span>) &#123;</div><div class="line">               TxnHeader hdr = request.hdr;</div><div class="line">               Record txn = request.txn;</div><div class="line">               rc = zks.processTxn(hdr, txn);<span class="comment">//1.这段代码，就是将请求处理后，加载数据到内存中也就是 - 存储在datatree中（我们zk的数据结构就是一个树形结构，那么他在代码中的对应结构就是DataTree，每个节点是DataNode）</span></div><div class="line">            &#125;</div><div class="line">      <span class="comment">//然后根据请求的类型处理相应的逻辑代码块-- 我们这里看两个操作的代码块（create和exists）</span></div><div class="line">              <span class="keyword">case</span> OpCode.create: &#123;</div><div class="line">                lastOp = <span class="string">"CREA"</span>;</div><div class="line">                rsp = <span class="keyword">new</span> CreateResponse(rc.path);<span class="comment">//构建请求响应，返回给客户端</span></div><div class="line">                err = Code.get(rc.err);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">case</span> OpCode.exists: &#123;</div><div class="line">                lastOp = <span class="string">"EXIS"</span>;</div><div class="line">                <span class="comment">// TODO we need to figure out the security requirement for this!</span></div><div class="line">                ExistsRequest existsRequest = <span class="keyword">new</span> ExistsRequest();</div><div class="line">                ByteBufferInputStream.byteBuffer2Record(request.request,</div><div class="line">                        existsRequest);</div><div class="line">                String path = existsRequest.getPath();</div><div class="line">                <span class="keyword">if</span> (path.indexOf(<span class="string">'\0'</span>) != -<span class="number">1</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.BadArgumentsException();</div><div class="line">                &#125;</div><div class="line">                Stat stat = zks.getZKDatabase().statNode(path, existsRequest</div><div class="line">                        .getWatch() ? cnxn : <span class="keyword">null</span>);<span class="comment">//关键代码：如果客户端再请求服务端的时候，他监听了 某个节点，那么 existsRequest.getWatch() 的值肯定是true，那么如果是true，他会传入cnxn类（server端的网络处理类，通过这个类发送响应给服务端）</span></div><div class="line">                rsp = <span class="keyword">new</span> ExistsResponse(stat);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">      <span class="comment">//数据写入内存成功后，最后</span></div><div class="line"><span class="comment">// 发送命令处理完成后的结果，默认是NIOServerCnxn，执行到这里代表服务端处理请求成功，完成。</span></div><div class="line">cnxn.sendResponse(hdr, rsp, <span class="string">"response"</span>);</div></pre></td></tr></table></figure>
<h5 id="watcher监听事件机制"><a href="#watcher监听事件机制" class="headerlink" title="watcher监听事件机制"></a>watcher监听事件机制</h5><p>我们知道，服务端处理客户端发出的某个节点的监听事件的关键代码是：<code>zks.getZKDatabase().statNode(path, existsRequest .getWatch() ? cnxn : null);</code></p>
<blockquote>
<p><strong>查看ZKDatabase.statNode(String, ServerCnxn)</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">statNode</span><span class="params">(String path, ServerCnxn serverCnxn)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</div><div class="line">    <span class="keyword">return</span> dataTree.statNode(path, serverCnxn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着调用dataTree.statNode()</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">statNode</span><span class="params">(String path, Watcher watcher)</span><span class="comment">//path就是节点的路径，watcher并不是监听器，他实际上就是一个网络通信类，用户处理客户端发过来的请求，他的实现是--NIOServerCnxn</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</div><div class="line">    Stat stat = <span class="keyword">new</span> Stat();</div><div class="line">    DataNode n = nodes.get(path);</div><div class="line">    <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</div><div class="line">        dataWatches.addWatch(path, watcher);<span class="comment">//接着执行这段代码，将path和watcher存入一个中  hashmap中</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (n) &#123;</div><div class="line">        n.copyStat(stat);</div><div class="line">        <span class="keyword">return</span> stat;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>  <strong>执行dataWatches.addWatch(path, watcher);</strong></p>
</blockquote>
<p>​    org.apache.zookeeper.server.WatchManager.addWatch(String, Watcher)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addWatch</span><span class="params">(String path, Watcher watcher)</span> </span>&#123;</div><div class="line">    HashSet&lt;Watcher&gt; list = watchTable.get(path);</div><div class="line">    <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// don't waste memory if there are few watches on a node</span></div><div class="line">        <span class="comment">// rehash when the 4th entry is added, doubling size thereafter</span></div><div class="line">        <span class="comment">// seems like a good compromise</span></div><div class="line">        list = <span class="keyword">new</span> HashSet&lt;Watcher&gt;(<span class="number">4</span>);</div><div class="line">        watchTable.put(path, list);</div><div class="line">    &#125;</div><div class="line">    list.add(watcher);</div><div class="line">   <span class="comment">//在这之前，hashmap的key是path，value是watcher（servercnx）</span></div><div class="line">    HashSet&lt;String&gt; paths = watch2Paths.get(watcher);<span class="comment">//反转hashmap，key转变为watcher（servercnx），value是path</span></div><div class="line">    <span class="keyword">if</span> (paths == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// cnxns typically have many watches, so use default cap here</span></div><div class="line">        paths = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        watch2Paths.put(watcher, paths);</div><div class="line">    &#125;</div><div class="line">    paths.add(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后将构造一个两个hashmap一个未反转key-value的，一个是已经反转key和value的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable =</div><div class="line">    <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;Watcher&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;Watcher, HashSet&lt;String&gt;&gt;();</div></pre></td></tr></table></figure>
<p>提醒：<strong>我们注意这里的watch并不是我们客户端的注册的监听实现，而是ServerCnx，是server端的一个通信类，所以说客户端注册的时间监听不会在服务端实现触发逻辑！！！！！</strong></p>
<p><strong>那么什么时候从watchTable中拿数据发送呢？或者什么时候触发事件呢？</strong></p>
<p>我们先梳理一下整个流程，假设客户端调用getData(“/app”,new Watch())，那么服务端知道你会在这个app节点注册监听，那么会执行到dataWatches.addWatch()代码。</p>
<p>​    然后往watchTable存放数据，<strong>key是/app，value是servercnx。</strong></p>
<p>​    那么当下次客户端调用setData(“/app”,”213”)，设置数据时，很明显这个时候我们需要响应客户端的事件，因为在这个节点上上次客户端创建了一个监听，所以服务端需要通知客户端，app节点修改了，你注册的事件你自己要触发一下。</p>
<pre><code>那么服务端是怎么通知客户端要出发监听事件呢？
</code></pre><p> 我们接着看代码，服务端收到setDate事件后，走处理链处理请求，最终会走到final处理器，然后最终调用datatree设置内存内存数据。</p>
<p><code>org.apache.zookeeper.server.DataTree.setData(String, byte[], int, long, long)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Stat <span class="title">setData</span><span class="params">(String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version, <span class="keyword">long</span> zxid,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">long</span> time)</span> <span class="keyword">throws</span> KeeperException.NoNodeException </span>&#123;</div><div class="line">    Stat s = <span class="keyword">new</span> Stat();</div><div class="line">    DataNode n = nodes.get(path);</div><div class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.NoNodeException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">byte</span> lastdata[] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">synchronized</span> (n) &#123;</div><div class="line">        lastdata = n.data;</div><div class="line">        n.data = data;</div><div class="line">        n.stat.setMtime(time);</div><div class="line">        n.stat.setMzxid(zxid);</div><div class="line">        n.stat.setVersion(version);</div><div class="line">        n.copyStat(s);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// now update if the path is in a quota subtree.</span></div><div class="line">    String lastPrefix;</div><div class="line">    <span class="keyword">if</span>((lastPrefix = getMaxPrefixWithQuota(path)) != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.updateBytes(lastPrefix, (data == <span class="keyword">null</span> ? <span class="number">0</span> : data.length)</div><div class="line">          - (lastdata == <span class="keyword">null</span> ? <span class="number">0</span> : lastdata.length));</div><div class="line">    &#125;</div><div class="line">    dataWatches.triggerWatch(path, EventType.NodeDataChanged);<span class="comment">//触发监听</span></div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么设置完成后，代表客户端的setdata请求，服务端处理成功，那么就需要通知客户端触发事件了。</p>
<p>最终调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> </span>&#123;</div><div class="line">    WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type,</div><div class="line">            KeeperState.SyncConnected, path);</div><div class="line">    HashSet&lt;Watcher&gt; watchers;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        watchers = watchTable.remove(path);<span class="comment">//可以看到触发一个时间，就删除一个，这个就是为什么事件只能触发一次的原因。回答上面问题1的提问</span></div><div class="line">        <span class="keyword">if</span> (watchers == <span class="keyword">null</span> || watchers.isEmpty()) &#123;</div><div class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</div><div class="line">                ZooTrace.logTraceMessage(LOG,</div><div class="line">                        ZooTrace.EVENT_DELIVERY_TRACE_MASK,</div><div class="line">                        <span class="string">"No watchers for "</span> + path);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Watcher w : watchers) &#123;</div><div class="line">            HashSet&lt;String&gt; paths = watch2Paths.get(w);</div><div class="line">            <span class="keyword">if</span> (paths != <span class="keyword">null</span>) &#123;</div><div class="line">                paths.remove(path);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (Watcher w : watchers) &#123;</div><div class="line">        <span class="keyword">if</span> (supress != <span class="keyword">null</span> &amp;&amp; supress.contains(w)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        w.process(e);<span class="comment">//触发监听事件</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> watchers;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终调用<code>org.apache.zookeeper.server.NIOServerCnxn.process(WatchedEvent)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">    ReplyHeader h = <span class="keyword">new</span> ReplyHeader(-<span class="number">1</span>, -<span class="number">1L</span>, <span class="number">0</span>);<span class="comment">//重点，发送的是xid == -1，这个参数在《sendThread.readResponse() - 读取服务端返回的信息》处理服务端响应的代码中，有个判断if (replyHdr.getXid() == -1)  判断成功，说明需要客户端执行事件。那么客户端就把事件放到waitEvenQueue中等到eventThread的run方法进行处理。</span></div><div class="line">    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</div><div class="line">        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK,</div><div class="line">                                 <span class="string">"Deliver event "</span> + event + <span class="string">" to 0x"</span></div><div class="line">                                 + Long.toHexString(<span class="keyword">this</span>.sessionId)</div><div class="line">                                 + <span class="string">" through "</span> + <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Convert WatchedEvent to a type that can be sent over the wire</span></div><div class="line">    WatcherEvent e = event.getWrapper();</div><div class="line"></div><div class="line">    sendResponse(h, e, <span class="string">"notification"</span>);<span class="comment">//发送通知给客户端，请求触发事件</span></div><div class="line">    <span class="comment">//接着在客户端的sendThread.readResponse()中处理请求，然后判断xid，然后做响应触发事件逻辑</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整的请求处理链</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409153236451.png" alt="image-20200409153236451"></p>
<p>​    也就是说，处理请求的时候，会经过三个处理器，进行处理。其中sync处理器的目的就是，将请求写入磁盘日志，并熟悉快照。</p>
<p>​    接着使用最后一个处理器final，将请求写到内存（方便读请求直接获取内存数据并返回），触发监听器，返回结果给客户端，完成请求。</p>
<p>​    如果客户端监听了某个节点，那么这个时候就会收到服务端发出的事件（通过socket的方式发送一个通知给客户端），然后客户端再进行相应处理。</p>
<p>详情参见：<a href="https://blog.csdn.net/yu_kang/article/details/88573304" target="_blank" rel="external">https://blog.csdn.net/yu_kang/article/details/88573304</a></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在Zookeeper中，数据存储分为两部分：内存数据存储和磁盘数据存储。</p>
<p>客户端的写请求，必须先写入磁盘后，才写入内存中，最后返回给客户端，整个读写请求完成。</p>
<p>单机模式下，客户端的请求，通过处理链进行处理，处理链上有三个处理器。</p>
<p><strong>单机模式下，server保证了高并发的安全性，因为请求会放到队列中，然后逐渐经过处理链，逐个处理。保证了每个请求的顺序性</strong></p>
<h2 id="好的文档-1"><a href="#好的文档-1" class="headerlink" title="好的文档"></a>好的文档</h2><p><a href="https://blog.csdn.net/yu_kang/article/details/88573304" target="_blank" rel="external">https://blog.csdn.net/yu_kang/article/details/88573304</a></p>
<p><a href="https://www.jianshu.com/nb/33061765" target="_blank" rel="external">https://www.jianshu.com/nb/33061765</a> - zk专栏</p>
<p><a href="http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/" target="_blank" rel="external">http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/</a> 阿里中间件专栏</p>
<p><a href="https://yq.aliyun.com/articles/227260" target="_blank" rel="external">https://yq.aliyun.com/articles/227260</a> zk开发中遇到的坑</p>
<h1 id="单机模式-end"><a href="#单机模式-end" class="headerlink" title="########单机模式 end"></a>########单机模式 end</h1><h1 id="集群模式"><a href="#集群模式" class="headerlink" title="########集群模式"></a>########集群模式</h1><h1 id="集群模式下的服务端启动源码解析（如何保证数据一致性）"><a href="#集群模式下的服务端启动源码解析（如何保证数据一致性）" class="headerlink" title="集群模式下的服务端启动源码解析（如何保证数据一致性）"></a>集群模式下的服务端启动源码解析（如何保证数据一致性）</h1><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>​    集群的选举，涉及到，<strong>myid（sid）、epoch（第几轮投票）、选举状态</strong>（LOOKING、FOLLOWING、LEADING、OBSERVERING）， 这三个值是很重要的。</p>
<p><strong>在集群中，一般会存在三种类型的网络通信：</strong>所以在下面讲解集群的某些类中，你会发现某些类的io通信的作用是下面三个中的一个。</p>
<ul>
<li>选举需要网络通信（多个server之间）</li>
<li>集群接受客户端请求</li>
<li>集群数据同步（learner同步leader数据）</li>
</ul>
<p>集群需要实现的功能：</p>
<ul>
<li><p>数据存储、持久化存储</p>
</li>
<li><p>数据同步流程</p>
</li>
<li><p>watcher监听怎么实现</p>
</li>
</ul>
<p><strong>所以上面这六个问题是我们在阅读源码所以带着的问题。</strong></p>
<h2 id="初始化集群配置信息"><a href="#初始化集群配置信息" class="headerlink" title="初始化集群配置信息"></a>初始化集群配置信息</h2><p>其实他跟启动单机版服务端的，初始化配置信息的操作是差不多的，为了重温只是，这里再贴出来</p>
<p>zkServer.sh文件最终会访问这个类启动服务端</p>
<blockquote>
<p><strong>1.QuorumPeerMain类源码</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ZooKeeperServerMain main = <span class="keyword">new</span> ZooKeeperServerMain();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        main.initializeAndRun(args);<span class="comment">//根据配置zoo.cfg文件，解析出配置的信息</span></div><div class="line">    &#125;</div><div class="line">。。。。。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    接着调用initializeAndRun方法，然后执行里面的 config.parse()，<strong>解析zoo.cfg配置文</strong>件，最终所有配置信息，都会<strong>保存到QuorumPeerConfig类</strong>中（包括，集群所有服务器地址，以及ob服务器，以及zk数据存储的位置，以及日志存储位置等等信息）</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200409113142773.png" alt="image-20200409113142773"></p>
<blockquote>
<p><strong>2.解析zoo.cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数数量</strong></p>
</blockquote>
<p><strong>那么他是怎么识别是集群模式还是单机模式，就是在解析配置文件的过程中，进行判断的。</strong></p>
<p>解析的方法，最终会调用<code>org.apache.zookeeper.server.quorum.QuorumPeerConfig.parseProperties(Properties)</code></p>
<p>里面有一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key.startsWith(<span class="string">"server."</span>)) &#123;<span class="comment">//判断配置文件中是否存在，server.这样的配置信息，如果有，说明是集群模式，并把配置信息放到servers的Map中，保存，需要注意，如果server是观察者，那么需要放到observers中。因为观察者不参与投票，servsers中的节点是需要参与投票的。</span></div><div class="line">                <span class="keyword">int</span> dot = key.indexOf(<span class="string">'.'</span>);</div><div class="line">                <span class="keyword">long</span> sid = Long.parseLong(key.substring(dot + <span class="number">1</span>));</div><div class="line">                String parts[] = splitWithLeadingHostname(value);</div><div class="line">                <span class="keyword">if</span> ((parts.length != <span class="number">2</span>) &amp;&amp; (parts.length != <span class="number">3</span>) &amp;&amp; (parts.length !=<span class="number">4</span>)) &#123;</div><div class="line">                    LOG.error(value</div><div class="line">                       + <span class="string">" does not have the form host:port or host:port:port "</span> +</div><div class="line">                       <span class="string">" or host:port:port:type"</span>);</div><div class="line">                &#125;</div><div class="line">                LearnerType type = <span class="keyword">null</span>;</div><div class="line">                String hostname = parts[<span class="number">0</span>];</div><div class="line">                Integer port = Integer.parseInt(parts[<span class="number">1</span>]);</div><div class="line">                Integer electionPort = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">2</span>)&#123;</div><div class="line">                	electionPort=Integer.parseInt(parts[<span class="number">2</span>]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (parts.length &gt; <span class="number">3</span>)&#123;</div><div class="line">                    <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">"observer"</span>)) &#123;</div><div class="line">                        type = LearnerType.OBSERVER;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">3</span>].toLowerCase().equals(<span class="string">"participant"</span>)) &#123;</div><div class="line">                        type = LearnerType.PARTICIPANT;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConfigException(<span class="string">"Unrecognised peertype: "</span> + value);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (type == LearnerType.OBSERVER)&#123;</div><div class="line">                    observers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    servers.put(Long.valueOf(sid), <span class="keyword">new</span> QuorumServer(sid, hostname, port, electionPort, type));</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<p>我们往下看你会发现，一个涉及到我们经常说的，半数选举策略。 <code>quorumVerifier = new QuorumMaj(servers.size());</code>  通过<strong>servers的数量获得半数数量</strong>。这里可以看到observer 并没有参与选举数量的确定，在确定半数数量后，ob最终会加到servers中（<strong>因为他也是能够处理客户端请求的</strong>）。</p>
<pre><code>public QuorumMaj(int n){
    this.half = n/2;// 例如 13/2 == 6
}

  // Now add observers to servers, once the quorums have been
 // figured out
 servers.putAll(observers);//ob最终会加到servers中
</code></pre><p>​    同时在parseProperties方法中，还会做一些校验工作，例如集群server必须是大于2的，而且如果集群数量是2的倍数，会提示建议使用奇数个server。</p>
<p>​    </p>
<h2 id="runFromConfig-config-启动服务器"><a href="#runFromConfig-config-启动服务器" class="headerlink" title="runFromConfig(config)启动服务器"></a>runFromConfig(config)启动服务器</h2><p>初始化完成集群总体配置信息过后，那么就开始进入当前server服务器集群初始化和启动工作。</p>
<p>调用runFromConfig（）方法，QuorumPeerMain启动类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">org.apache.zookeeper.server.quorum.QuorumPeerMain.runFromConfig(QuorumPeerConfig)</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          ManagedUtil.registerLog4jMBeans();</div><div class="line">      &#125; <span class="keyword">catch</span> (JMException e) &#123;</div><div class="line">          LOG.warn(<span class="string">"Unable to register log4j JMX control"</span>, e);</div><div class="line">      &#125;</div><div class="line">  </div><div class="line">      LOG.info(<span class="string">"Starting quorum peer"</span>);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();</div><div class="line">          cnxnFactory.configure(config.getClientPortAddress(),</div><div class="line">                                config.getMaxClientCnxns());<span class="comment">//跟单节点的服务端启动一样，// 建立socket,默认是NIOServerCnxnFactory（是一个线程），管理来自客户端的连接，监听ClientPortAddress。</span></div><div class="line">          <span class="comment">//这个时候NIOServerCnxnFactory线程还未启动，因为没有调用start</span></div><div class="line"></div><div class="line">          quorumPeer = getQuorumPeer();</div><div class="line"></div><div class="line">          quorumPeer.setQuorumPeers(config.getServers());</div><div class="line">          quorumPeer.setTxnFactory(<span class="keyword">new</span> FileTxnSnapLog(</div><div class="line">                  <span class="keyword">new</span> File(config.getDataLogDir()),</div><div class="line">                  <span class="keyword">new</span> File(config.getDataDir())));</div><div class="line">          quorumPeer.setElectionType(config.getElectionAlg());</div><div class="line">          quorumPeer.setMyid(config.getServerId());</div><div class="line">          quorumPeer.setTickTime(config.getTickTime());</div><div class="line">          quorumPeer.setInitLimit(config.getInitLimit());</div><div class="line">          quorumPeer.setSyncLimit(config.getSyncLimit());</div><div class="line">          quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());</div><div class="line">          quorumPeer.setCnxnFactory(cnxnFactory);</div><div class="line">          quorumPeer.setQuorumVerifier(config.getQuorumVerifier());</div><div class="line">          quorumPeer.setClientPortAddress(config.getClientPortAddress());</div><div class="line">          quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());</div><div class="line">          quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());</div><div class="line">          quorumPeer.setZKDatabase(<span class="keyword">new</span> ZKDatabase(quorumPeer.getTxnFactory()));</div><div class="line">          quorumPeer.setLearnerType(config.getPeerType());<span class="comment">//设置当前server的状态，默认设置的是learner状态中的PARTICIPANT（参与者）。learner一共有两种状态（PARTICIPANT，OBSERVER）</span></div><div class="line">          quorumPeer.setSyncEnabled(config.getSyncEnabled());</div><div class="line"></div><div class="line">          <span class="comment">// sets quorum sasl authentication configurations</span></div><div class="line">          quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);</div><div class="line">          <span class="keyword">if</span>(quorumPeer.isQuorumSaslAuthEnabled())&#123;</div><div class="line">              quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);</div><div class="line">              quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);</div><div class="line">              quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);</div><div class="line">              quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);</div><div class="line">              quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);</div><div class="line">          quorumPeer.initialize();</div><div class="line"></div><div class="line">          quorumPeer.start();<span class="comment">//启动server服务器，做初始化工作。需要注意，这里只是启动服务器做初始化工作，例如选举leader、数据同步等等操作，并不是马上就能接受客户端请求。具体逻辑在QuorumPeer的start()方法中。</span></div><div class="line">          quorumPeer.join();<span class="comment">//等待quorumPeer线程执行完毕，那么当前服务器退出。</span></div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">          <span class="comment">// warn, but generally this is ok</span></div><div class="line">          LOG.warn(<span class="string">"Quorum Peer interrupted"</span>, e);</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>​    接着创建一个QuorumPeer类(是一个线程)，保存当前server的配置信息（实际上就是用QuorumPeerConfig将部分配置信息赋值给QuorumPeer）。<strong>接着启动QuorumPeer.start().</strong></p>
<blockquote>
<p> <strong>quorumPeer.start()</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    loadDataBase();<span class="comment">//首先加载本地数据（根据快照和日志文件，重放数据到内存中），保持数据一致性关键</span></div><div class="line">    cnxnFactory.start();  <span class="comment">//启动NIOServerCnxnFactory线程（上面创建的）      </span></div><div class="line">    startLeaderElection();<span class="comment">//确定选举leader的策略，实际上有四种策略，但是其他三种都是过时的，目前只有FastLeaderElection策略才能够使用</span></div><div class="line">    <span class="keyword">super</span>.start();<span class="comment">//启动线程quorumPeer，执行run方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="loadDataBase-重放数据到服务器内存"><a href="#loadDataBase-重放数据到服务器内存" class="headerlink" title="loadDataBase()重放数据到服务器内存"></a>loadDataBase()重放数据到服务器内存</h3><p>这个在上面的单机版服务的server说过了，类似的，这里就不再说了。</p>
<h3 id="cnxnFactory-start-初始化启动NIOServerCnxnFactory线程"><a href="#cnxnFactory-start-初始化启动NIOServerCnxnFactory线程" class="headerlink" title="cnxnFactory.start()初始化启动NIOServerCnxnFactory线程"></a>cnxnFactory.start()初始化启动NIOServerCnxnFactory线程</h3><p> <strong>cnxnFactory.start()，启动NIOServerCnxnFactory线程，处理客户端请求（也就是说处理客户端请求逻辑在这里）</strong> </p>
<p>​    最终会去执行NIOServerCnxnFactory的run方法，在while循环中，获取客户端请求。如果nio监听到读写事件，那么就调用doIO进行处理请求。</p>
<p>​    <strong>特别注意：</strong>doIO在处理请求的时候，如果server的状态并不是 State.RUNNING，那么就会抛出异常<code>throw new IOException(&quot;ZooKeeperServer not running&quot;);</code></p>
<p>​    <strong>这个时候说明集群并没有准备好，那么不处理任何请求。</strong></p>
<p>​    <strong>！！！！那么此刻很明显当前server肯定不是RUNNING状态，因为没有在这之前没有看到任何代码将当前服务器启动并设置状态为RUNNING，所以代码运行到这里，服务器是不能接受客户端请求的，就算接受了也会抛异常（从逻辑上此时server也不可能响应客户端请求，因为当前server还没有确定自己的状态，是leader还是follower还是observer，数据是否是最新的？等等之类的问题，那么他此刻肯定不能响应客户端请求）！！！！！！！！！！</strong></p>
<p>​    <strong>总而言之，就是监听2181端口，接口客户端请求。</strong></p>
<p>这方法的代码，主要的是就是讲述我们的 <strong>集群接受客户端请求</strong> 通信的内容了。</p>
<h3 id="startLeaderElection（）确定选举策略和先投自己一票"><a href="#startLeaderElection（）确定选举策略和先投自己一票" class="headerlink" title="startLeaderElection（）确定选举策略和先投自己一票"></a>startLeaderElection（）确定选举策略和先投自己一票</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//myid不用说了，就是我们自己配置的。getLastLoggedZxid：获取当前server最新的zxid，getCurrentEpoch（）获取当前服务器目前是在第几轮（在哪个朝代，是哪个leader领导的）</span></div><div class="line">		currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());<span class="comment">//你会发现这里的开始就先构建一个投票信息。表示你要投自己一票。CurrentEpoch的意思是，当前是第几轮投票。（这三个参数是在选举leader中是需要做比较的）</span></div><div class="line">	&#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">		RuntimeException re = <span class="keyword">new</span> RuntimeException(e.getMessage());</div><div class="line">		re.setStackTrace(e.getStackTrace());</div><div class="line">		<span class="keyword">throw</span> re;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//getView()返回的是，我们在zoo.cfg中配置的集群server列表（包括observer）</span></div><div class="line">    <span class="keyword">for</span> (QuorumServer p : getView().values()) &#123;<span class="comment">//通过myid，获取当前server的ip</span></div><div class="line">        <span class="keyword">if</span> (p.id == myid) &#123;</div><div class="line">            myQuorumAddr = p.addr;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (myQuorumAddr == <span class="keyword">null</span>) &#123;<span class="comment">//如果地址为空，那么说明当前服务器不在集群中，那么启动失败。</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"My id "</span> + myid + <span class="string">" not in the peer list"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;<span class="comment">//选举策略，默认是3，这个值的赋值是在QuorumPeerMain.runFromConfig()的方法中配置。也就是说，我们可以通过在zoo.cfg中配置electionType的值确定不通的选举策略。</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            udpSocket = <span class="keyword">new</span> DatagramSocket(myQuorumAddr.getPort());</div><div class="line">            responder = <span class="keyword">new</span> ResponderThread();</div><div class="line">            responder.start();</div><div class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);<span class="comment">//根据选举策略标志位获取选举策略，实际上除了FastLeaderElection这种策略，其他的都失效了。所以这里默认创建FastLeaderElection选举策略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p> <strong>createElectionAlgorithm(electionType)</strong></p>
</blockquote>
<p>创建选举策略，只有case等于3的策略才能使用，其他的都已经失效了，<strong>建立投票监听</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span></span>&#123;</div><div class="line">    Election le=<span class="keyword">null</span>;</div><div class="line">            </div><div class="line">    <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></div><div class="line">    <span class="keyword">switch</span> (electionAlgorithm) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        le = <span class="keyword">new</span> LeaderElection(<span class="keyword">this</span>);<span class="comment">//已经失效，不能使用</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>);<span class="comment">//已经失效，不能使用</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>, <span class="keyword">true</span>);<span class="comment">//已经失效，不能使用</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//只能使用</span></div><div class="line">        qcm = createCnxnManager();</div><div class="line">        QuorumCnxManager.Listener listener = qcm.listener;</div><div class="line">        <span class="keyword">if</span>(listener != <span class="keyword">null</span>)&#123;</div><div class="line">            listener.start();</div><div class="line">            <span class="comment">//FastLeaderElection</span></div><div class="line">            le = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            LOG.error(<span class="string">"Null listener when initializing cnx manager"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> le;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到他创建了FastLeaderElection选举算法，但是在那里创建了其他服务器的投票监听呢？</p>
<blockquote>
<p><strong>（1）createCnxnManager()方法，最终创建QuorumCnxManager类。 - 创建投票监听listener</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// visible for testing</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuorumCnxManager</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> mySid,</span></span></div><div class="line"><span class="function"><span class="params">                        Map&lt;Long,QuorumPeer.QuorumServer&gt; view,</span></span></div><div class="line"><span class="function"><span class="params">                        QuorumAuthServer authServer,</span></span></div><div class="line"><span class="function"><span class="params">                        QuorumAuthLearner authLearner,</span></span></div><div class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> socketTimeout,</span></span></div><div class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> listenOnAllIPs,</span></span></div><div class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> quorumCnxnThreadsSize,</span></span></div><div class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> quorumSaslAuthEnabled,</span></span></div><div class="line"><span class="function"><span class="params">                        ConcurrentHashMap&lt;Long, SendWorker&gt; senderWorkerMap)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.senderWorkerMap = senderWorkerMap;<span class="comment">//针对要发送投票信息给服务器数量，创建map，保存相应数量的SendWorker线程，每个线程都负责发送投票信息给服务器</span></div><div class="line"></div><div class="line">    <span class="keyword">this</span>.recvQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Message&gt;(RECV_CAPACITY);<span class="comment">//保存收到的投票信息</span></div><div class="line">    <span class="keyword">this</span>.queueSendMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, ArrayBlockingQueue&lt;ByteBuffer&gt;&gt;();<span class="comment">//保存要发送给每台服务器的数据，senderWorkerMap就是从这里取数据发送</span></div><div class="line">    <span class="keyword">this</span>.lastMessageSent = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, ByteBuffer&gt;();<span class="comment">//最近一次发送的数据</span></div><div class="line">    String cnxToValue = System.getProperty(<span class="string">"zookeeper.cnxTimeout"</span>);</div><div class="line">    <span class="keyword">if</span>(cnxToValue != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.cnxTO = Integer.parseInt(cnxToValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.mySid = mySid;</div><div class="line">    <span class="keyword">this</span>.socketTimeout = socketTimeout;</div><div class="line">    <span class="keyword">this</span>.view = view;</div><div class="line">    <span class="keyword">this</span>.listenOnAllIPs = listenOnAllIPs;</div><div class="line"></div><div class="line">    initializeAuth(mySid, authServer, authLearner, quorumCnxnThreadsSize,</div><div class="line">            quorumSaslAuthEnabled);</div><div class="line"></div><div class="line">    <span class="comment">// Starts listener thread that waits for connection requests </span></div><div class="line">    listener = <span class="keyword">new</span> Listener();<span class="comment">//很关键这个listnner，建立连接接受其他服务端的投票请求</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    换言之，这个类主要创建两个map去负责发送数据，其中一个map是发送线程map，另一个map是保存线程要发送的数据。创建一个队列来接受数据。</p>
<blockquote>
<p><strong>（1.1）new Listener() - 创建投票监听</strong></p>
</blockquote>
<p>​    实际上是创建一个线程，但是这个listenner什么时候启动呢？<strong>在createElectionAlgorithm方法中 执行了listener.start()启动</strong>，然后执行rlistener的run方法，run方法中创建一个<strong>原生的ServerSocket，接受其他server端的投票请求。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> numRetries = <span class="number">0</span>;</div><div class="line">    InetSocketAddress addr;</div><div class="line">    <span class="keyword">while</span>((!shutdown) &amp;&amp; (numRetries &lt; <span class="number">3</span>))&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ss = <span class="keyword">new</span> ServerSocket();<span class="comment">//为什么不用NIO，而是用了阻塞的bio呢？因为集群中投票的节点不会太多，所以没有关系</span></div><div class="line">            ss.setReuseAddress(<span class="keyword">true</span>);</div><div class="line">            <span class="keyword">if</span> (listenOnAllIPs) &#123;</div><div class="line">                <span class="keyword">int</span> port = view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid)</div><div class="line">                    .electionAddr.getPort();</div><div class="line">                addr = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                addr = view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid)</div><div class="line">                    .electionAddr;</div><div class="line">            &#125;</div><div class="line">            LOG.info(<span class="string">"My election bind port: "</span> + addr.toString());</div><div class="line">            setName(view.get(QuorumCnxManager.<span class="keyword">this</span>.mySid)</div><div class="line">                    .electionAddr.toString());</div><div class="line">            ss.bind(addr);<span class="comment">//绑定的addr地址，是选举地址，也就是当前服务器的选举地址。也就是监听localhost:3887。</span></div><div class="line">            <span class="comment">//server.1=localhost:2887:3887</span></div><div class="line">            <span class="keyword">while</span> (!shutdown) &#123;<span class="comment">//无线遍历，处理来自其他server的投票信息</span></div><div class="line">                    Socket client = ss.accept();</div><div class="line">                    setSockOpts(client);</div><div class="line">                    LOG.info(<span class="string">"Received connection request "</span></div><div class="line">                            + client.getRemoteSocketAddress());</div><div class="line"></div><div class="line">                    <span class="comment">// Receive and handle the connection request</span></div><div class="line">                    <span class="comment">// asynchronously if the quorum sasl authentication is</span></div><div class="line">                    <span class="comment">// enabled. This is required because sasl server</span></div><div class="line">                    <span class="comment">// authentication process may take few seconds to finish,</span></div><div class="line">                    <span class="comment">// this may delay next peer connection requests.</span></div><div class="line">                    <span class="keyword">if</span> (quorumSaslAuthEnabled) &#123;</div><div class="line">                        receiveConnectionAsync(client);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        receiveConnection(client);<span class="comment">//处理收到的请求，最终调用handleConnection处理请求</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    numRetries = <span class="number">0</span>;</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>handleConnection，新建两个线程发送自己的投票数据和接受其他服务器的投票数据</strong></p>
</blockquote>
<p><strong>也就是新建 SendWorker 和 RecvWorker 线程。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleConnection</span><span class="params">(Socket sock, DataInputStream din)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Long sid = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// Read server id</span></div><div class="line">        sid = din.readLong();</div><div class="line">        <span class="keyword">if</span> (sid &lt; <span class="number">0</span>) &#123; <span class="comment">// this is not a server id but a protocol version (see ZOOKEEPER-1633)</span></div><div class="line">            sid = din.readLong();</div><div class="line"></div><div class="line">            <span class="comment">// next comes the #bytes in the remainder of the message</span></div><div class="line">            <span class="comment">// note that 0 bytes is fine (old servers)</span></div><div class="line">            <span class="keyword">int</span> num_remaining_bytes = din.readInt();</div><div class="line">            <span class="keyword">if</span> (num_remaining_bytes &lt; <span class="number">0</span> || num_remaining_bytes &gt; maxBuffer) &#123;</div><div class="line">                LOG.error(<span class="string">"Unreasonable buffer length: &#123;&#125;"</span>, num_remaining_bytes);</div><div class="line">                closeSocket(sock);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[num_remaining_bytes];</div><div class="line"></div><div class="line">            <span class="comment">// remove the remainder of the message from din</span></div><div class="line">            <span class="keyword">int</span> num_read = din.read(b);</div><div class="line">            <span class="keyword">if</span> (num_read != num_remaining_bytes) &#123;</div><div class="line">                LOG.error(<span class="string">"Read only "</span> + num_read + <span class="string">" bytes out of "</span> + num_remaining_bytes + <span class="string">" sent by server "</span> + sid);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sid == QuorumPeer.OBSERVER_ID) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line"><span class="comment">             * Choose identifier at random. We need a value to identify</span></div><div class="line"><span class="comment">             * the connection.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            sid = observerCounter.getAndDecrement();</div><div class="line">            LOG.info(<span class="string">"Setting arbitrary identifier to observer: "</span> + sid);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        closeSocket(sock);</div><div class="line">        LOG.warn(<span class="string">"Exception reading or writing challenge: "</span> + e.toString());</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// do authenticating learner</span></div><div class="line">    LOG.debug(<span class="string">"Authenticating learner server.id: &#123;&#125;"</span>, sid);</div><div class="line">    authServer.authenticate(sock, din);</div><div class="line"></div><div class="line">    <span class="comment">//If wins the challenge, then close the new connection.</span></div><div class="line">    <span class="keyword">if</span> (sid &lt; <span class="keyword">this</span>.mySid) &#123;<span class="comment">//</span></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * This replica might still believe that the connection to sid is</span></div><div class="line"><span class="comment">         * up, so we have to shut down the workers before trying to open a</span></div><div class="line"><span class="comment">         * new connection.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        SendWorker sw = senderWorkerMap.get(sid);</div><div class="line">        <span class="keyword">if</span> (sw != <span class="keyword">null</span>) &#123;</div><div class="line">            sw.finish();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Now we start a new connection</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        LOG.debug(<span class="string">"Create new connection to server: "</span> + sid);</div><div class="line">        closeSocket(sock);</div><div class="line">        connectOne(sid);</div><div class="line"></div><div class="line">        <span class="comment">// Otherwise start worker threads to receive data.</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//为上面创建的senderWorkerMap和queueSendMap赋值，同时启动SendWorker发送投票信息的同时，启动一个相应的RecvWorker线程接受请求。也即是为每一台server都创建一条发送和接受的专线。假设有三个sever，那么就需要三条专线，其中三个SendWorker和三个RecvWorker。</span></div><div class="line">        SendWorker sw = <span class="keyword">new</span> SendWorker(sock, sid);</div><div class="line">        RecvWorker rw = <span class="keyword">new</span> RecvWorker(sock, din, sid, sw);</div><div class="line">        sw.setRecv(rw);</div><div class="line"></div><div class="line">        SendWorker vsw = senderWorkerMap.get(sid);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(vsw != <span class="keyword">null</span>)</div><div class="line">            vsw.finish();</div><div class="line">        </div><div class="line">        senderWorkerMap.put(sid, sw);<span class="comment">//保存数据</span></div><div class="line">        queueSendMap.putIfAbsent(sid, <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(SEND_CAPACITY));<span class="comment">//保存数据</span></div><div class="line">        </div><div class="line">        sw.start();<span class="comment">//启动sendWorker线程，从sendqueue中拿出自己要投票给其他服务器的数据，进行发送</span></div><div class="line">        <span class="comment">//那么queueSendMap的数据是打哪儿来的呢？参加下面的《1.1sendNotifications()方法》</span></div><div class="line">        rw.start();<span class="comment">//启动recvWorker线程，获取其他服务器的投票数据</span></div><div class="line">        <span class="comment">//那么RecvWorker是负责接受其他服务器的投票数据，然后放到LinkedBlockingQueue&lt;Notification&gt; recvqueue;中，那么这些数据什么时候使用呢？在哪里使用嗯？  参见后面的super.start()调用run方法中，在执行  sendNotifications();之后的逻辑，也即是下面的《1.2处理接受到其他服务端的投票数据》</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>​    （1）你会发现这个方法，只是启动了其他服务器向自己投票的监听，和初始化了一个FastLeaderElection选举策略。</p>
<p>​    （2）<strong>listener通过新建两个线程来负责发送自己的投票信息和接受其他服务器的投票信息。</strong></p>
<p>需要注意的是：假设有a,b,c三台服务器，那么a向b,c发送投票数据，要分别为b，c服务器分别创建一对线程（SendWorker和RecvWorker），也就是一共创建两对线程，也即是两个SendWorker和两个RecvWorker。并不是b，c服务器公用一对SendWorker和RecvWorker。</p>
<p>  保证了a与其他服务器，都有一对单独线程处理发送投票和接受投票。</p>
<p>​       <strong>也就是说，执行到这里，发送自己票据和接受其他服务器票据的服务已经启动（现在就等待往sendQueue中添加数据和从recvQueue中拿输出处理了）。</strong></p>
<p>流程图：</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-2020041210123330920.png" alt="image-20200413200707940"></p>
<p>​    <strong>本方法并没有真正leader选举的代码逻辑。</strong>   那么leader选举的逻辑在那里实现呢？请往下看</p>
<h3 id="super-start-–-根据选定策略执行leader选举-投票代码"><a href="#super-start-–-根据选定策略执行leader选举-投票代码" class="headerlink" title="super.start() – 根据选定策略执行leader选举-投票代码"></a>super.start() – 根据选定策略执行leader选举-投票代码</h3><p>​    真正的leader投票，在 super.start();启动之后，判断当前server的节点状态，如果是LOKING，那么说明需要进入leader选举。</p>
<blockquote>
<p><strong>选举整体思路</strong></p>
</blockquote>
<p>​    那么选举leader是根据什么条件选择呢？<strong>主要是三个：事务id（也就是zxid，即是比较哪台server的数据是最新的）、myid、epoch</strong></p>
<p>​    <strong>首先比较的是epoch，这里假设epoch相等。那么接着比较zxid，也就是比较那台数据最新。如果zxid一样，那么就比较myid的大小。</strong></p>
<p>​    例如有三台server，他们的zxid和myid信息如下（<strong>假设epoch相等</strong>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A:zxid=1,myid=1,epoch=1  B:zxid=2,myid=2,epoch=1   C:zxid=2,myid=3 ,epoch=1    一共三台server，半数是1。那么最少有两台server启动才能确定leader</div></pre></td></tr></table></figure>
<p>A先启动，发现，<strong>没有过半数，则继续LOKING</strong>。紧接着B启动，半数原则达到，然后开始选举。</p>
<p><strong>首先他们都会各自投自己一票</strong>，然后把信息发给对方。<strong>假设他们吧投票信息都放到一个map中，key是zxid。</strong></p>
<p>此时，A：{<a，1>}，B：{<b，2>}。然后把投票信息发给对方。</b，2></a，1></p>
<p>​    此时，A：{<a，1>，<b，2>}，B：{<b，2>，<a，1>}。A服务器开始判断zxid大小，发现B的zxid更大，那么就会把投自己一票的那一票给丢弃，换成投给B，此时<strong>A：{<a，1>，<b，2>} —&gt;  A：{<b，2>，<b，2>}</b，2></b，2></b，2></a，1></strong></a，1></b，2></b，2></a，1></p>
<p>​    然后A把投票结果发给B，也会把，A的那票给失效，此时<strong>B：{<b，2>，<a，1>} —&gt;  A：{<b，2>，<b，2>}</b，2></b，2></a，1></b，2></strong></p>
<p>​    最终确定B当选leader。</p>
<p><strong>那么如果zxid一样，那么就要重新根据myid投票，投票过程是一样的。</strong></p>
<p><strong>领导选举的，关键代码在QuorumPeer线程的run方法。</strong></p>
<blockquote>
<p><strong>源码分析</strong></p>
</blockquote>
<p>​    查看QuorumPeer的run方法：</p>
<p>首席服务器启动是，他的服务状态肯定是<strong>LOOKING</strong>。因为默认QuorumPeer默认<code>private ServerState state = ServerState.LOOKING;</code>.</p>
<p><strong>所以进入case LOOKING的代码逻辑。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">switch</span> (getPeerState()) &#123;</div><div class="line">         <span class="keyword">case</span> LOOKING:<span class="comment">//如果服务器状态是loking，那么说明需要领导选举</span></div><div class="line">         </div><div class="line">           setBCVote(<span class="keyword">null</span>);</div><div class="line">        <span class="comment">//默认当前选的是自己为leader，但是随着选举的逻辑进行，可能currentVote的值就不是自己了</span></div><div class="line">           setCurrentVote(makeLEStrategy().lookForLeader());<span class="comment">//投票关键代码</span></div><div class="line">         。。。。。。省略部分代码</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>查看FastLeaderElection.lookForLeader()确定选举细节</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Vote <span class="title">lookForLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">            。。。。。。。。。</div><div class="line"></div><div class="line">            <span class="comment">//收到的投票，就是投票箱的概念</span></div><div class="line">            HashMap&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</div><div class="line">            <span class="comment">//发出去的投票</span></div><div class="line">            HashMap&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> HashMap&lt;Long, Vote&gt;();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> notTimeout = finalizeWait;</div><div class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;<span class="comment">//没选举一轮，那么epoch就会自增1</span></div><div class="line">                logicalclock.incrementAndGet();<span class="comment">//原子long类型，增加逻辑时钟，就是epoch</span></div><div class="line">                <span class="comment">//更新选举提议，myid  zxid  epoch，这里面的信息也就是自己的myid，zxid，和currentEpoch。 </span></div><div class="line">                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            LOG.info(<span class="string">"New election. My id =  "</span> + self.getId() +</div><div class="line">                    <span class="string">", proposed zxid=0x"</span> + Long.toHexString(proposedZxid));</div><div class="line">            <span class="comment">//（1）发送投票提议给所有的节点，需要注意，也会发送给自己.只会发送给需要参与投票的节点服务器，也即是//server.type == LearnerType.，不包括observer节点</span></div><div class="line">            sendNotifications();</div><div class="line"></div><div class="line">            <span class="comment">//（2）发送完自己的提议，那么开始处理收到的票据。</span></div><div class="line">        </div><div class="line">            <span class="comment">//如果还是是looking状态，我们会一直去和其他节点交互信息，直到选举出leader</span></div><div class="line">            <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</div><div class="line">                    (!stop))&#123;</div><div class="line">        </div><div class="line">                <span class="comment">//从接收队列中拿到投票信息，拿到其他server的投票信息。</span></div><div class="line">                <span class="comment">//疑问？？</span></div><div class="line">                <span class="comment">//recvQueue中的是数据是哪里来的呢？我们还记得在startLeaderElection()方法中创建的listener中创建的RecvWorker线程么？</span></div><div class="line">                <span class="comment">//就是通过这个线程去接受其他服务端的投票，然后放到recvQueue中。</span></div><div class="line">                Notification n = recvqueue.poll(notTimeout,</div><div class="line">                        TimeUnit.MILLISECONDS);<span class="comment">//然后从队列中取出一个票据</span></div><div class="line"></div><div class="line">                <span class="comment">/*</span></div><div class="line"><span class="comment">                 * Sends more notifications if haven't received enough.</span></div><div class="line"><span class="comment">                 * Otherwise processes new notification.</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keyword">if</span>(n == <span class="keyword">null</span>)&#123;<span class="comment">//如果取出的票据为空，那么说明没有其他服务器发送过来他们的票据</span></div><div class="line">                    <span class="keyword">if</span>(manager.haveDelivered())&#123;  <span class="comment">//检查所有的队列是否为空</span></div><div class="line">                        sendNotifications();        <span class="comment">//如果为空发送通知</span></div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        manager.connectAll();  <span class="comment">//如果没有投递出去，可能是其他server还没有启动，尝试连接</span></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">/*</span></div><div class="line"><span class="comment">                     * Exponential backoff</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">                    <span class="keyword">int</span> tmpTimeOut = notTimeout*<span class="number">2</span>;</div><div class="line">                    notTimeout = (tmpTimeOut &lt; maxNotificationInterval?</div><div class="line">                            tmpTimeOut : maxNotificationInterval);</div><div class="line">                    LOG.info(<span class="string">"Notification time out: "</span> + notTimeout);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//判断收到的投票的sid,</span></div><div class="line">                <span class="comment">//这里判断的是收到的sid是不是属于当前集群内的</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123;</div><div class="line"></div><div class="line">                    <span class="keyword">switch</span> (n.state) &#123; <span class="comment">//判断当前票据状态状态 - 因为是选举阶段，那么票据肯定是LOOKING状态</span></div><div class="line">                    <span class="keyword">case</span> LOOKING:</div><div class="line">                      </div><div class="line">                        <span class="comment">//收到的票据中的epoch是不是比当前选举的epoch要大，如果大那么代表是新一轮选举</span></div><div class="line">                        <span class="comment">//那就说明，自己现在的投票轮数不是最新的，那么需要更新为最新，然后再参与投票。例如别人都已经是第三轮投票了，你现在还是第二轮。</span></div><div class="line">                        <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;</div><div class="line">                            logicalclock.set(n.electionEpoch);  <span class="comment">//更新当前epoch</span></div><div class="line">                            recvset.clear();  <span class="comment">//情况收到的投票</span></div><div class="line">                            <span class="comment">//进行投票</span></div><div class="line"></div><div class="line">                            <span class="comment">/*</span></div><div class="line"><span class="comment">                            totalOrderPredicate方法逻辑</span></div><div class="line"><span class="comment">                             * We return true if one of the following three cases hold:</span></div><div class="line"><span class="comment">                             * 1- New epoch is higher</span></div><div class="line"><span class="comment">                             * 收到的epoch大于当前的epoch 胜出选举</span></div><div class="line"><span class="comment">                             * 2- New epoch is the same as current epoch, but new zxid is higher</span></div><div class="line"><span class="comment">                             * 如果收到的epoch等于当前epoch,那么收到的zxid大于当前zxid胜出选举</span></div><div class="line"><span class="comment">                             * 3- New epoch is the same as current epoch, new zxid is the same</span></div><div class="line"><span class="comment">                             *  as current zxid, but server id is higher.</span></div><div class="line"><span class="comment">                             * 如果收到的epoch等于当前epoch，zxid等于当前zxid,</span></div><div class="line"><span class="comment">                             * 那么收到的myid大于当前myid的胜出选举</span></div><div class="line"><span class="comment">                             */</span></div><div class="line">                            <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                    getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</div><div class="line">                                updateProposal(n.leader, n.zxid, n.peerEpoch); <span class="comment">//把胜出的消息更新到投票提议中</span></div><div class="line">                            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果收到消息没有胜出，那么选择当前的消息更新到投票提议中</span></div><div class="line">                                updateProposal(getInitId(),</div><div class="line">                                        getInitLastLoggedZxid(),</div><div class="line">                                        getPeerEpoch());</div><div class="line">                            &#125;</div><div class="line">                            sendNotifications();  <span class="comment">//发送投票消息</span></div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;  <span class="comment">//如果收到的逻辑时钟小，那么表示这个投票无效</span></div><div class="line">                            <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">                                LOG.debug(<span class="string">"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x"</span></div><div class="line">                                        + Long.toHexString(n.electionEpoch)</div><div class="line">                                        + <span class="string">", logicalclock=0x"</span> + Long.toHexString(logicalclock.get()));</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                            <span class="comment">//如果收到的逻辑时钟相等，则去对比myid 、zxid、epoch</span></div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                proposedLeader, proposedZxid, proposedEpoch)) &#123;</div><div class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                            sendNotifications();</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">                            LOG.debug(<span class="string">"Adding vote: from="</span> + n.sid +</div><div class="line">                                    <span class="string">", proposed leader="</span> + n.leader +</div><div class="line">                                    <span class="string">", proposed zxid=0x"</span> + Long.toHexString(n.zxid) +</div><div class="line">                                    <span class="string">", proposed election epoch=0x"</span> + Long.toHexString(n.electionEpoch));</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="comment">//把投票结果存到本地，用来做最终判断</span></div><div class="line">                        recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</div><div class="line"></div><div class="line">                        <span class="comment">//判断选举是否结束，默认算法过半同意</span></div><div class="line">                        <span class="keyword">if</span> (termPredicate(recvset,</div><div class="line">                                <span class="keyword">new</span> Vote(proposedLeader, proposedZxid,</div><div class="line">                                        logicalclock.get(), proposedEpoch))) &#123;</div><div class="line"></div><div class="line">                            <span class="comment">// Verify if there is any change in the proposed leader</span></div><div class="line">                            <span class="keyword">while</span>((n = recvqueue.poll(finalizeWait,</div><div class="line">                                    TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>)&#123;</div><div class="line">                                <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                        proposedLeader, proposedZxid, proposedEpoch))&#123;</div><div class="line">                                    recvqueue.put(n);<span class="comment">//获得最新的记过</span></div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</div><div class="line">                                self.setPeerState((proposedLeader == self.getId()) ?</div><div class="line">                                        ServerState.LEADING: learningState());</div><div class="line"></div><div class="line">                                Vote endVote = <span class="keyword">new</span> Vote(proposedLeader,</div><div class="line">                                        proposedZxid, proposedEpoch);</div><div class="line">                                leaveInstance(endVote);</div><div class="line">                                <span class="keyword">return</span> endVote;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> OBSERVING:  <span class="comment">//如果是</span></div><div class="line">                        LOG.debug(<span class="string">"Notification from observer: "</span> + n.sid);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> FOLLOWING:</div><div class="line">                    <span class="keyword">case</span> LEADING:</div><div class="line">                        <span class="comment">/*</span></div><div class="line"><span class="comment">                         * Consider all notifications from the same epoch</span></div><div class="line"><span class="comment">                         * together.</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        <span class="keyword">if</span>(n.electionEpoch == logicalclock.get())&#123;</div><div class="line">                            recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</div><div class="line">                            <span class="keyword">if</span>(termPredicate(recvset, <span class="keyword">new</span> Vote(n.leader,</div><div class="line">                                            n.zxid, n.electionEpoch, n.peerEpoch, n.state))</div><div class="line">                                            &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</div><div class="line">                                self.setPeerState((n.leader == self.getId()) ?</div><div class="line">                                        ServerState.LEADING: learningState());</div><div class="line"></div><div class="line">                                Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                                leaveInstance(endVote);</div><div class="line">                                <span class="keyword">return</span> endVote;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="comment">/*</span></div><div class="line"><span class="comment">                         * Before joining an established ensemble, verify that</span></div><div class="line"><span class="comment">                         * a majority are following the same leader.</span></div><div class="line"><span class="comment">                         * Only peer epoch is used to check that the votes come</span></div><div class="line"><span class="comment">                         * from the same ensemble. This is because there is at</span></div><div class="line"><span class="comment">                         * least one corner case in which the ensemble can be</span></div><div class="line"><span class="comment">                         * created with inconsistent zxid and election epoch</span></div><div class="line"><span class="comment">                         * info. However, given that only one ensemble can be</span></div><div class="line"><span class="comment">                         * running at a single point in time and that each </span></div><div class="line"><span class="comment">                         * epoch is used only once, using only the epoch to </span></div><div class="line"><span class="comment">                         * compare the votes is sufficient.</span></div><div class="line"><span class="comment">                         * </span></div><div class="line"><span class="comment">                         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.leader, </div><div class="line">                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));</div><div class="line">                        <span class="keyword">if</span> (termPredicate(outofelection, <span class="keyword">new</span> Vote(n.leader,</div><div class="line">                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state))</div><div class="line">                                &amp;&amp; checkLeader(outofelection, n.leader, IGNOREVALUE)) &#123;</div><div class="line">                            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                                logicalclock.set(n.electionEpoch);</div><div class="line">                                self.setPeerState((n.leader == self.getId()) ?</div><div class="line">                                        ServerState.LEADING: learningState());</div><div class="line">                            &#125;</div><div class="line">                            Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                            leaveInstance(endVote);</div><div class="line">                            <span class="keyword">return</span> endVote;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">default</span>:</div><div class="line">                        LOG.warn(<span class="string">"Notification state unrecoginized: "</span> + n.state</div><div class="line">                              + <span class="string">" (n.state), "</span> + n.sid + <span class="string">" (n.sid)"</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!validVoter(n.leader)) &#123;</div><div class="line">                        LOG.warn(<span class="string">"Ignoring notification for non-cluster member sid &#123;&#125; from sid &#123;&#125;"</span>, n.leader, n.sid);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!validVoter(n.sid)) &#123;</div><div class="line">                        LOG.warn(<span class="string">"Ignoring notification for sid &#123;&#125; from non-quorum member sid &#123;&#125;"</span>, n.leader, n.sid);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span>(self.jmxLeaderElectionBean != <span class="keyword">null</span>)&#123;</div><div class="line">                    MBeanRegistry.getInstance().unregister(</div><div class="line">                            self.jmxLeaderElectionBean);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOG.warn(<span class="string">"Failed to unregister with JMX"</span>, e);</div><div class="line">            &#125;</div><div class="line">            self.jmxLeaderElectionBean = <span class="keyword">null</span>;</div><div class="line">            LOG.debug(<span class="string">"Number of connection processing threads: &#123;&#125;"</span>,</div><div class="line">                    manager.getConnectionThreadCount());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="1-1sendNotifications自己的投票提议给其他server-保存需要投票的数据到sendqueue中"><a href="#1-1sendNotifications自己的投票提议给其他server-保存需要投票的数据到sendqueue中" class="headerlink" title="1.1sendNotifications自己的投票提议给其他server - 保存需要投票的数据到sendqueue中"></a>1.1sendNotifications自己的投票提议给其他server - 保存需要投票的数据到sendqueue中</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Send notifications to all peers upon a change in our vote</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNotifications</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (QuorumServer server : self.getVotingView().values()) &#123;</div><div class="line">        <span class="keyword">long</span> sid = server.id;</div><div class="line"></div><div class="line">        ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</div><div class="line">                proposedLeader,<span class="comment">//当前server的myid</span></div><div class="line">                proposedZxid,<span class="comment">//当前server的zxid</span></div><div class="line">                logicalclock.get(),<span class="comment">//epoch,当前发起提议的epoch</span></div><div class="line">                QuorumPeer.ServerState.LOOKING,<span class="comment">//当前server的状态，肯定looking，因为是选举</span></div><div class="line">                sid,<span class="comment">//当前server的zxid</span></div><div class="line">                proposedEpoch);<span class="comment">//当前票据的epoch，默认是currentEpoch。有可能这个跟上面的 logicalclock.get()获取的值不同。假设当前服务器是刚启动的，那么logicalclock是刚初始化，则 logicalclock.get()等于1。可能服务器砸启动之前就已经参加过几轮的选举，假设currentepoch的值是4.那么此时就不一样。</span></div><div class="line">        <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">            LOG.debug(<span class="string">"Sending Notification: "</span> + proposedLeader + <span class="string">" (n.leader), 0x"</span>  +</div><div class="line">                  Long.toHexString(proposedZxid) + <span class="string">" (n.zxid), 0x"</span> + Long.toHexString(logicalclock.get())  +</div><div class="line">                  <span class="string">" (n.round), "</span> + sid + <span class="string">" (recipient), "</span> + self.getId() +</div><div class="line">                  <span class="string">" (myid), 0x"</span> + Long.toHexString(proposedEpoch) + <span class="string">" (n.peerEpoch)"</span>);</div><div class="line">        &#125;</div><div class="line">        sendqueue.offer(notmsg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    最后把消息放到LinkedBlockingQueue<tosend> sendqueue; 中。<strong>但是什么时候发送呢？</strong>看到阻塞队列我们肯定想到生产者和消费者模式，那么也就是说，肯定有一个线程在实时的去读取sendqueue中的队列，然后进行发送。</tosend></p>
<p>​    <strong>在那里取得sendqueue中自己的票据进行发送呢？</strong> 答案是：<strong>WorkerSender线程。</strong></p>
<p>​     <strong>是在startLeaderElection()方法中创建的listener中创建的WorkerSender线程。在那个时候，WorkerSender线程已经启动，并开始执行从sendqueue队列中取出自己要发给其他服务器的票据。</strong></p>
<p>​    那么代码的执行逻辑走到 – &gt; sendNotifications（）方法之后，也就是上面的run方法（）的 sendNotifications（）方法之后。</p>
<h4 id="1-2处理接受到其他服务端的投票数据-确定最终leader"><a href="#1-2处理接受到其他服务端的投票数据-确定最终leader" class="headerlink" title="1.2处理接受到其他服务端的投票数据 - 确定最终leader"></a>1.2处理接受到其他服务端的投票数据 - 确定最终leader</h4><p>​    首先我们要知道收到的投票数据，是放在recvQueue中的。</p>
<p>​    那么recvQueue中的数据，是打哪儿来的？是在startLeaderElection()方法中创建的listener中创建的RecvWorker线程接受后放进去的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">        <span class="comment">//如果还是是looking状态，我们会一直去和其他节点交互信息，直到选举出leader</span></div><div class="line"><span class="comment">//while循环知道直到确定leader</span></div><div class="line">        <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;</div><div class="line">                (!stop))&#123;</div><div class="line">    </div><div class="line">            <span class="comment">//从接收队列中拿到投票信息，拿到其他server的投票信息。</span></div><div class="line">            <span class="comment">//疑问？？</span></div><div class="line">            <span class="comment">//recvQueue中的是数据是哪里来的呢？我们还记得在startLeaderElection()方法中创建的listener中创建的RecvWorker线程么？</span></div><div class="line">            <span class="comment">//就是通过这个线程去接受其他服务端的投票，然后放到recvQueue中。</span></div><div class="line">            Notification n = recvqueue.poll(notTimeout,</div><div class="line">                    TimeUnit.MILLISECONDS);</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(n == <span class="keyword">null</span>)&#123;<span class="comment">//这里为空，说明，目前没有收到其他服务器发送过来的投票数据</span></div><div class="line">                <span class="keyword">if</span>(manager.haveDelivered())&#123;  <span class="comment">//检查所有的队列是否为空</span></div><div class="line">                    sendNotifications();        <span class="comment">//如果为空发送通知</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    manager.connectAll();  <span class="comment">//如果没有投递出去，可能是其他server还没有启动，尝试连接</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">/*</span></div><div class="line"><span class="comment">                 * Exponential backoff</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keyword">int</span> tmpTimeOut = notTimeout*<span class="number">2</span>;</div><div class="line">                notTimeout = (tmpTimeOut &lt; maxNotificationInterval?</div><div class="line">                        tmpTimeOut : maxNotificationInterval);</div><div class="line">                LOG.info(<span class="string">"Notification time out: "</span> + notTimeout);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//判断收到的投票的sid,</span></div><div class="line">            <span class="comment">//这里判断的是收到的sid是不是属于当前集群内的</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (validVoter(n.sid) &amp;&amp; validVoter(n.leader)) &#123;</div><div class="line">  </div><div class="line">                <span class="keyword">switch</span> (n.state) &#123;<span class="comment">//判断当前票据状态状态 - 因为是选举阶段，那么票据肯定是LOOKING状态</span></div><div class="line">                <span class="keyword">case</span> LOOKING:</div><div class="line">               </div><div class="line">                    <span class="comment">//收到其他服务的投票的epoch是不是比当前选举的epoch要大，如果大那么代表是新一轮选举</span></div><div class="line">                    <span class="comment">//那就说明，自己现在的投票轮数不是最新的，那么需要更新为最新，然后再参与投票。例如别人都已经是第三轮投票了，你现在还是第二轮。</span></div><div class="line">                    <span class="keyword">if</span> (n.electionEpoch &gt; logicalclock.get()) &#123;</div><div class="line">                        logicalclock.set(n.electionEpoch);  <span class="comment">//更新自己的epoch为当前最新的epoch</span></div><div class="line">                        recvset.clear();  <span class="comment">//清空收到的投票</span></div><div class="line">                        <span class="comment">//进行投票</span></div><div class="line"></div><div class="line">                        <span class="comment">/*</span></div><div class="line"><span class="comment">                        totalOrderPredicate方法逻辑</span></div><div class="line"><span class="comment">                    </span></div><div class="line"><span class="comment">                         * 1.收到的epoch大于当前的epoch 胜出选举</span></div><div class="line"><span class="comment">                         * 2.如果收到的epoch等于当前epoch,那么收到的zxid大于当前zxid胜出选举</span></div><div class="line"><span class="comment">                         * 3.如果收到的epoch等于当前epoch，zxid等于当前zxid,</span></div><div class="line"><span class="comment">                         * 4.那么收到的myid大于当前myid的胜出选举</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) &#123;</div><div class="line">                            <span class="comment">//Proposal默认就是当前服务器的myid、zxid、epoche。</span></div><div class="line">                            <span class="comment">//但是如果跟其他服务器发送过来的票据相比，比对没有胜出，那么就说明，我不能当选leader，胜出的票据代表的服务获得当选leader的机会，那么我就要自己放弃对自己的投票，投那台服务器一票</span></div><div class="line">                            updateProposal(n.leader, n.zxid, n.peerEpoch); <span class="comment">//把胜出的消息更新到投票提议中</span></div><div class="line">                        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果收到消息没有胜出，那么选择当前的消息（有可能是自己的，也有可能是上一次比对胜出的）更新到投票提议中</span></div><div class="line">                            updateProposal(getInitId(),</div><div class="line">                                    getInitLastLoggedZxid(),</div><div class="line">                                    getPeerEpoch());</div><div class="line">                        &#125;<span class="comment">//也就是说这段代码的作用就是，决定自己要给谁投一票。也有可能是给自己投一票。</span></div><div class="line">                        sendNotifications();  <span class="comment">//发送最新的投票消息，开始下一次循环的判断</span></div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n.electionEpoch &lt; logicalclock.get()) &#123;  <span class="comment">//如果收到的逻辑时钟（epoch）小，那么表示这个投票无效。</span></div><div class="line">                        <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">                            LOG.debug(<span class="string">"Notification election epoch is smaller than logicalclock. n.electionEpoch = 0x"</span></div><div class="line">                                    + Long.toHexString(n.electionEpoch)</div><div class="line">                                    + <span class="string">", logicalclock=0x"</span> + Long.toHexString(logicalclock.get()));</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                        <span class="comment">//如果收到的逻辑时钟epoch相等，则去对比myid 、zxid、epoch</span></div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                            proposedLeader, proposedZxid, proposedEpoch)) &#123;</div><div class="line">                        updateProposal(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                        sendNotifications();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</div><div class="line">                        LOG.debug(<span class="string">"Adding vote: from="</span> + n.sid +</div><div class="line">                                <span class="string">", proposed leader="</span> + n.leader +</div><div class="line">                                <span class="string">", proposed zxid=0x"</span> + Long.toHexString(n.zxid) +</div><div class="line">                                <span class="string">", proposed election epoch=0x"</span> + Long.toHexString(n.electionEpoch));</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">//把对方发送过来的票据存到本地，用来做最终判断</span></div><div class="line">                    recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</div><div class="line"></div><div class="line">                    <span class="comment">//判断选举是否结束，默认算法过半同意 - 最终判断</span></div><div class="line">                    <span class="keyword">if</span> (termPredicate(recvset,</div><div class="line">                            <span class="keyword">new</span> Vote(proposedLeader, proposedZxid,</div><div class="line">                                    logicalclock.get(), proposedEpoch))) &#123;</div><div class="line"></div><div class="line">                        <span class="comment">// Verify if there is any change in the proposed leader</span></div><div class="line">                        <span class="keyword">while</span>((n = recvqueue.poll(finalizeWait,</div><div class="line">                                TimeUnit.MILLISECONDS)) != <span class="keyword">null</span>)&#123;</div><div class="line">                            <span class="keyword">if</span>(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,</div><div class="line">                                    proposedLeader, proposedZxid, proposedEpoch))&#123;</div><div class="line">                                recvqueue.put(n);<span class="comment">//获得最新的记过</span></div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="comment">/*</span></div><div class="line"><span class="comment">                         * This predicate is true once we don't read any new</span></div><div class="line"><span class="comment">                         * relevant message from the reception queue</span></div><div class="line"><span class="comment">                         */</span></div><div class="line">                        <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</div><div class="line">                            self.setPeerState((proposedLeader == self.getId()) ?</div><div class="line">                                    ServerState.LEADING: learningState());</div><div class="line"></div><div class="line">                            Vote endVote = <span class="keyword">new</span> Vote(proposedLeader,</div><div class="line">                                    proposedZxid, proposedEpoch);</div><div class="line">                            leaveInstance(endVote);</div><div class="line">                            <span class="keyword">return</span> endVote;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> OBSERVING:  <span class="comment">//如果是</span></div><div class="line">                    LOG.debug(<span class="string">"Notification from observer: "</span> + n.sid);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> FOLLOWING:</div><div class="line">                <span class="keyword">case</span> LEADING:</div><div class="line">                    <span class="comment">/*</span></div><div class="line"><span class="comment">                     * Consider all notifications from the same epoch</span></div><div class="line"><span class="comment">                     * together.</span></div><div class="line"><span class="comment">                     */</span></div><div class="line">                    <span class="keyword">if</span>(n.electionEpoch == logicalclock.get())&#123;</div><div class="line">                        recvset.put(n.sid, <span class="keyword">new</span> Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));</div><div class="line">                        <span class="keyword">if</span>(termPredicate(recvset, <span class="keyword">new</span> Vote(n.leader,</div><div class="line">                                        n.zxid, n.electionEpoch, n.peerEpoch, n.state))</div><div class="line">                                        &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) &#123;</div><div class="line">                            self.setPeerState((n.leader == self.getId()) ?</div><div class="line">                                    ServerState.LEADING: learningState());</div><div class="line"></div><div class="line">                            Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                            leaveInstance(endVote);</div><div class="line">                            <span class="keyword">return</span> endVote;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">         </div><div class="line">                    outofelection.put(n.sid, <span class="keyword">new</span> Vote(n.leader, </div><div class="line">                            IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));</div><div class="line">                    <span class="keyword">if</span> (termPredicate(outofelection, <span class="keyword">new</span> Vote(n.leader,</div><div class="line">                            IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state))</div><div class="line">                            &amp;&amp; checkLeader(outofelection, n.leader, IGNOREVALUE)) &#123;</div><div class="line">                        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">                            logicalclock.set(n.electionEpoch);</div><div class="line">                            self.setPeerState((n.leader == self.getId()) ?</div><div class="line">                                    ServerState.LEADING: learningState());</div><div class="line">                        &#125;</div><div class="line">                        Vote endVote = <span class="keyword">new</span> Vote(n.leader, n.zxid, n.peerEpoch);</div><div class="line">                        leaveInstance(endVote);</div><div class="line">                        <span class="keyword">return</span> endVote;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    LOG.warn(<span class="string">"Notification state unrecoginized: "</span> + n.state</div><div class="line">                          + <span class="string">" (n.state), "</span> + n.sid + <span class="string">" (n.sid)"</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!validVoter(n.leader)) &#123;</div><div class="line">                    LOG.warn(<span class="string">"Ignoring notification for non-cluster member sid &#123;&#125; from sid &#123;&#125;"</span>, n.leader, n.sid);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!validVoter(n.sid)) &#123;</div><div class="line">                    LOG.warn(<span class="string">"Ignoring notification for sid &#123;&#125; from non-quorum member sid &#123;&#125;"</span>, n.leader, n.sid);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>通过上面的决策，我们就可以得出leader是那台服务器。</p>
<p>参考：<a href="https://blog.csdn.net/u010994966/article/details/95937323" target="_blank" rel="external">https://blog.csdn.net/u010994966/article/details/95937323</a></p>
<h3 id="如果集群中，某台server挂掉，那么怎么重新进行选举？"><a href="#如果集群中，某台server挂掉，那么怎么重新进行选举？" class="headerlink" title="如果集群中，某台server挂掉，那么怎么重新进行选举？"></a>如果集群中，某台server挂掉，那么怎么重新进行选举？</h3><p>org.apache.zookeeper.server.quorum.QuorumPeer.run()</p>
<p>首先挂掉，分两种情况：follower挂掉、leader挂掉。</p>
<p>​    首先，如果是leader挂掉怎么重新选举？把自己状态设置为loking，重新选举。此时follower同步leader数据会报异常。</p>
<p>​    如果是follower挂掉，怎么判断是否需要选举? leader会循环去判断，去ping所有的follower，判断是否有超过半数的follower已经ping不通，如果是，就会shutdown自己，然后把自己状态设置为loking，重新选举。</p>
<h3 id="新加入的服务器怎么进行选举？怎么知道哪台是leader"><a href="#新加入的服务器怎么进行选举？怎么知道哪台是leader" class="headerlink" title="新加入的服务器怎么进行选举？怎么知道哪台是leader"></a>新加入的服务器怎么进行选举？怎么知道哪台是leader</h3><p>我们知道新机器的状态肯定是looking。</p>
<p>首先，如果在加入之前，集群中已经选出了leader，那么还是会走投票流程，然后确定leader（并不是重新选举，此时的投票只是为了让新加入的机器，确认哪台是leader）</p>
<h3 id="leader选举总结"><a href="#leader选举总结" class="headerlink" title="leader选举总结"></a>leader选举总结</h3><p>​    在选举过程中，每台机器都会相互发送一个投票数据（Vote<myid，zxid，epoch>），如果是首轮leader 选举，那么epoch是1，每次投票epoch都会自增1.</myid，zxid，epoch></p>
<p>​    怎么决定哪个server当leader 呢？会根据vote的三个参数进行判断。</p>
<p>​        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1.首先比较epoch：</div><div class="line">	收到的epoch大于当前的epoch 胜出选举</div><div class="line">2.epoch相等比较zxid：数据最新者胜出</div><div class="line">	如果收到的epoch等于当前epoch,那么收到的zxid大于当前zxid胜出选举</div><div class="line">3.zxid相等，比较myid：</div><div class="line">	如果收到的epoch等于当前epoch，zxid等于当前zxid,</div><div class="line">	那么收到的myid大于当前myid的胜出选举</div></pre></td></tr></table></figure>
<p>​    举个例子，假设集群中有三台机器，那么需要至少启动两台才能够完成leader选举。这里为了方便说明，我就假设只启动两台，来看他们是怎么投票的。</p>
<p>​    </p>
<table>
<thead>
<tr>
<th>server<myid,zxid,epoch></myid,zxid,epoch></th>
<th>是否启动</th>
</tr>
</thead>
<tbody>
<tr>
<td>a<1,1,1></1,1,1></td>
<td>是</td>
</tr>
<tr>
<td>b<2,1,1></2,1,1></td>
<td>是</td>
</tr>
<tr>
<td>c<3,1,1></3,1,1></td>
<td>否</td>
</tr>
</tbody>
</table>
<p>​    因为是新集群，所以他们的数据都是一致的，所以zxid都是1。因为是第一轮投票，所以epoch是1.</p>
<p>​    a服务器启动，因为是LOOKING状态，那么就需要走选举leader流程，那么<strong>默认投自己一票</strong>，给其他server发送投票信息 <strong>vote<1,1,1></1,1,1></strong>，并监听其他服务器发送给自己的投票信息。</p>
<p>​    b服务器启动，因为是LOOKING状态，那么就需要走选举leader流程，那么<strong>默认投自己一票</strong>，给其他server发送投票信息 <strong>vote<2,1,1></2,1,1></strong>，并监听其他服务器发送给自己的投票信息。此时收到a服务器的投票信息<strong>vote<1,1,1></1,1,1></strong>，开始比较投票的信息，<strong>此时一共有两个投票</strong>。那么因为epoch和zxid都是相等的，那么myid大的获胜，此时b服务胜出。所以b服务器丢弃a服务器的投票信息，还是投自己一票。给其他server发送投票信息 <strong>vote<2,1,1></2,1,1></strong>。<strong>b服务器第一轮投票结束。</strong>开始第二轮</p>
<p>  a服务器此时收到b服务器的投票信息<strong>vote<2,1,1></2,1,1></strong>，开始比较投票的信息，<strong>此时一共有两个投票</strong>。那么因为epoch和zxid都是相等的，那么myid大的获胜，此时b服务胜出。所以<strong>a服务器丢弃自己服务器的投票信息</strong>，改投b服务器一票。给其他server发送投票信息 <strong>vote<2,1,1></2,1,1></strong>。<strong>a服务器第一轮投票结束。</strong>开始第二轮</p>
<p><strong>接着进行第二轮投票，此时epoch递增为2。</strong></p>
<p>​    同理a服务器向b发送投票信息。<strong>vote<2,1,1></2,1,1></strong>，那么b服务器收到之后，检测，发现对于<strong>自己的被选的票数已经大于半数</strong>，所以b服务器升级为leader。</p>
<p>​    a服务器收到的b服务器发送的投票信息，<strong>vote<2,1,1></2,1,1></strong>，检测，发现对于<strong>b服务器被选的票数已经大于半数</strong>，所以确定b服务器升级为leader。，那么a服务器设置为follower。</p>
<p> 接着开始同步集群数据，所有learner都向leader同步数据。（<strong>此时集群还没有启动，还不能接受客户端请求</strong>）</p>
<p><strong>数据同步成功后，所有服务器，各自调用zkserver.start（）启动服务。开始接受处理客户端的请求。</strong></p>
<p>整个流程图：</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200413205835549.png" alt="image-20200413205835549"></p>
<h2 id="怎么保证数据一致性（已经确定leader）"><a href="#怎么保证数据一致性（已经确定leader）" class="headerlink" title="怎么保证数据一致性（已经确定leader）"></a>怎么保证数据一致性（已经确定leader）</h2><p><strong>首先我们要明确一点，那就是此时，整个集群各台服务器的角色已经确定好了。接下来就是learner和leader数据同步</strong></p>
<p>看到这个问题，我们首先考虑一下，什么时候会发生数据不一致？</p>
<ul>
<li>一台新服务器加入集群。这台服务器是没有数据的。</li>
<li>原先存在集群中的服务器，突然挂掉了。数据不是最新的</li>
<li>原先存在集群中的服务器，正在写数据（事务日志已经写了），突然挂掉了。数据不是最新的</li>
</ul>
<p>​    <strong>上面这三种情况，在重启服务器后，都会向leader请求同步数据，保持数据一致性，在这期间，他们不接受任何请求。（刚启动的服务器，状态都是LOOKING，然后发起投票，从而获得现在哪台是leader，然后跟leader同步数据 –  注意这里的投票并不是重新选举leader，而是让重启的服务器确定哪台是leader）</strong></p>
<h3 id="执行loadDataBase加载本地快照数据到内存"><a href="#执行loadDataBase加载本地快照数据到内存" class="headerlink" title="执行loadDataBase加载本地快照数据到内存"></a>执行loadDataBase加载本地快照数据到内存</h3><p>实际上就是通过 <code>loadDataBase();</code> 进行再服务器启动的时候，通过日志快照重放数据到内存。</p>
<p>我们知道服务器启动的时候，会启动线程：<strong>quorumPeer.start()</strong> 它里面的代码就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    loadDataBase();<span class="comment">//加载快照数据到内存，重点讲</span></div><div class="line">    cnxnFactory.start();      <span class="comment">//  </span></div><div class="line">    startLeaderElection();</div><div class="line">    <span class="keyword">super</span>.start();<span class="comment">//重点讲 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>接着调用 zkDb.loadDataBase();</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">loadDataBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">long</span> zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);</div><div class="line">    initialized = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> zxid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * this function restores the server </span></div><div class="line"><span class="comment"> * database after reading from the </span></div><div class="line"><span class="comment"> * snapshots and transaction logs</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> dt the datatree to be restored</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> sessions the sessions to be restored</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> listener the playback listener to run on the </span></div><div class="line"><span class="comment"> * database restoration</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> the highest zxid restored</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">restore</span><span class="params">(DataTree dt, Map&lt;Long, Integer&gt; sessions, </span></span></div><div class="line"><span class="function"><span class="params">        PlayBackListener listener)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    snapLog.deserialize(dt, sessions);</div><div class="line">    <span class="keyword">return</span> fastForwardFromEdits(dt, sessions, listener);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>调用fastForwardFromEdits()重放日志快照数据到内存</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fastForwardFromEdits</span><span class="params">(DataTree dt, Map&lt;Long, Integer&gt; sessions,</span></span></div><div class="line"><span class="function"><span class="params">                                 PlayBackListener listener)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    FileTxnLog txnLog = <span class="keyword">new</span> FileTxnLog(dataDir);<span class="comment">//获取快照日志</span></div><div class="line">    TxnIterator itr = txnLog.read(dt.lastProcessedZxid+<span class="number">1</span>);<span class="comment">//从最新一次事务</span></div><div class="line">    <span class="keyword">long</span> highestZxid = dt.lastProcessedZxid;</div><div class="line">    TxnHeader hdr;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">// iterator points to </span></div><div class="line">            <span class="comment">// the first valid txn when initialized</span></div><div class="line">            hdr = itr.getHeader();</div><div class="line">            <span class="keyword">if</span> (hdr == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//empty logs </span></div><div class="line">                <span class="keyword">return</span> dt.lastProcessedZxid;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (hdr.getZxid() &lt; highestZxid &amp;&amp; highestZxid != <span class="number">0</span>) &#123;</div><div class="line">                LOG.error(<span class="string">"&#123;&#125;(higestZxid) &gt; &#123;&#125;(next log) for type &#123;&#125;"</span>,</div><div class="line">                        <span class="keyword">new</span> Object[] &#123; highestZxid, hdr.getZxid(),</div><div class="line">                                hdr.getType() &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                highestZxid = hdr.getZxid();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                processTransaction(hdr,dt,sessions, itr.getTxn());<span class="comment">//更新数据到内存中</span></div><div class="line">            &#125; <span class="keyword">catch</span>(KeeperException.NoNodeException e) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to process transaction type: "</span> +</div><div class="line">                     hdr.getType() + <span class="string">" error: "</span> + e.getMessage(), e);</div><div class="line">            &#125;</div><div class="line">            listener.onTxnLoaded(hdr, itr.getTxn());</div><div class="line">            <span class="keyword">if</span> (!itr.next()) </div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (itr != <span class="keyword">null</span>) &#123;</div><div class="line">            itr.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> highestZxid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="启动quorumPeer线程执行run方法"><a href="#启动quorumPeer线程执行run方法" class="headerlink" title="启动quorumPeer线程执行run方法"></a>启动quorumPeer线程执行run方法</h3><p>​    通过上面的领导选举学习，我们知道QuorumPeer的run方法，核心的内容包括，<strong>领导选举。</strong>首先根据启动服务器的状态（LOOKING, FOLLOWING, LEADING, OBSERVING;）走相应的逻辑。</p>
<p><strong>那么只有确定了leader，我们才能够往下了解follower/observer跟leader的通信过程。</strong></p>
<p>通信的目的，<strong>就是为了实时同步leader的最新数据。</strong>  <strong>不然上面的loadDataBase只是加载本地的快照信息，可能不是目前集群中最新的数据</strong></p>
<h4 id="leader为每一个learner开启线程接受请求。"><a href="#leader为每一个learner开启线程接受请求。" class="headerlink" title="leader为每一个learner开启线程接受请求。"></a>leader为每一个learner开启线程接受请求。</h4><p>​    假设通过领导选举成功，当前服务器是leader，那么他就会执行。<strong>QuorumPeer的run方法的LEADER代码块。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> LEADING:</div><div class="line">    LOG.info(<span class="string">"LEADING"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        setLeader(makeLeader(logFactory));</div><div class="line">        leader.lead();<span class="comment">//执行lead方法</span></div><div class="line">        setLeader(<span class="keyword">null</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        LOG.warn(<span class="string">"Unexpected exception"</span>,e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (leader != <span class="keyword">null</span>) &#123;</div><div class="line">            leader.shutdown(<span class="string">"Forcing shutdown"</span>);</div><div class="line">            setLeader(<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        setPeerState(ServerState.LOOKING);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>lead()方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lead</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">           。。。。。</div><div class="line">        <span class="comment">// Start thread that waits for connection requests from </span></div><div class="line">        <span class="comment">// new followers.</span></div><div class="line">        cnxAcceptor = <span class="keyword">new</span> LearnerCnxAcceptor();<span class="comment">//为每一个learner开启一个处理线程</span></div><div class="line">        cnxAcceptor.start();<span class="comment">//启动LearnerCnxAcceptor线程</span></div><div class="line">        。。。。。。忽略部分代码</div></pre></td></tr></table></figure>
<p><strong>（1）LearnerCnxAcceptor的run方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (!stop) &#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                Socket s = ss.accept();<span class="comment">//阻塞等待learner的连接，这里使用的是bio的方式</span></div><div class="line">                <span class="comment">// start with the initLimit, once the ack is processed</span></div><div class="line">                <span class="comment">// in LearnerHandler switch to the syncLimit</span></div><div class="line">                s.setSoTimeout(self.tickTime * self.initLimit);</div><div class="line">                s.setTcpNoDelay(nodelay);</div><div class="line">                BufferedInputStream is = <span class="keyword">new</span> BufferedInputStream(</div><div class="line">                        s.getInputStream());</div><div class="line">                LearnerHandler fh = <span class="keyword">new</span> LearnerHandler(s, is, Leader.<span class="keyword">this</span>);<span class="comment">//learner连接后，新建LearnerHandler线程处理连接 - 也就是我们上面所说的，为每一个learner的请求创建一个单独的线程处理</span></div><div class="line">                fh.start();</div></pre></td></tr></table></figure>
<p><strong>（2）查看LearnerHandler的run方法</strong></p>
<h4 id="learner请求leader"><a href="#learner请求leader" class="headerlink" title="learner请求leader"></a>learner请求leader</h4><p>同理，当前服务器如果是follower或者observer，那么也会走。<strong>QuorumPeer的run方法的follower/observer代码块。</strong></p>
<p>实际上，observer的代码块跟follower的代码块执行的逻辑差不多，那么我们这里只看一下follower的代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> FOLLOWING:</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        LOG.info(<span class="string">"FOLLOWING"</span>);</div><div class="line">        setFollower(makeFollower(logFactory));</div><div class="line">        follower.followLeader();<span class="comment">//关键代码</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        LOG.warn(<span class="string">"Unexpected exception"</span>,e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        follower.shutdown();</div><div class="line">        setFollower(<span class="keyword">null</span>);</div><div class="line">        setPeerState(ServerState.LOOKING);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>follower.followLeader()请求leader</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    。。。。。。</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        QuorumServer leaderServer = findLeader();<span class="comment">//首先找到leander相关的信息，方便后面创建连接    </span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connectToLeader(leaderServer.addr, leaderServer.hostname);<span class="comment">//建立跟leader的连接</span></div><div class="line">            <span class="keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);<span class="comment">//这里会向leader发送数据</span></div><div class="line">            。。。。。。。。。。。</div></pre></td></tr></table></figure>
<h4 id="开始同步数据"><a href="#开始同步数据" class="headerlink" title="开始同步数据"></a>开始同步数据</h4><p>经过上面的leader跟learner的连接和设置目前最大投票版本号，接下来就需要开始进行数据同步。</p>
<h5 id="leader怎么处理"><a href="#leader怎么处理" class="headerlink" title="leader怎么处理"></a>leader怎么处理</h5><p>首先我们知道，<strong>所有的learner的数据肯定要以leader的为主</strong>。如果learner的数据多了（事务id比leader的大），那么leader会发送消息让learner回滚数据。</p>
<p>​    那么如果learner的数据不是最新的（zxid事务id比leader小）</p>
<ul>
<li><p>​    第一种情况， learner是刚加入集群的，<strong>什么数据都没有</strong>，那么怎么同步leader的数据呢？</p>
<ul>
<li><p>首先，leader发送他自己的快照给learner，但是leader的快照可能不是最新的，因为我们知道快照是每隔一部分client的写请求就打一次，并不是每次请求都打。所以leader仅仅只是发送他自己的快照远远不够，那么我们这个时候就想，能不能发leader已经收到的所有更新请求日志呢？也一并发给learner。</p>
</li>
<li><p>那么learner一共收到两份东西，一份是：<strong>leader快照、一份是更新日志。</strong></p>
</li>
<li><p><strong>这样，learner就可以根据快照和操作日志，同步数据。</strong></p>
</li>
<li><p>疑问？那么快照我们知道在dataDir目录下，但是操作日志在哪里呢？我们还记得服务端处理client请求时经过的处理链，最后一个final处理器，他的org.apache.zookeeper.server.FinalRequestProcessor.processRequest(Request)处理方法中，有一段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">   <span class="comment">// do not add non quorum packets to the queue.</span></div><div class="line">        <span class="keyword">if</span> (Request.isQuorum(request.type)) &#123;</div><div class="line">            zks.getZKDatabase().addCommittedProposal(request);</div><div class="line">        &#125;</div><div class="line">会把所有的请求都保存到 <span class="keyword">protected</span> LinkedList&lt;Proposal&gt; committedLog = <span class="keyword">new</span> LinkedList&lt;Proposal&gt;();中。</div><div class="line">    所以committedLog就是我们需要找的更新日志</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第二种情况，learner是有数据的，但是数据不是最新的（zxid事务id比leader小）。</p>
<ul>
<li>那么这种情况，很明显就不需要发送leader快照了，我们只需要发送learner跟leader差异的部分，即可。例如learner当前zxid是20，但是leader的zxid是50，那么我们只需要从leader发送21-50的部分操作日志给learner即可。</li>
</ul>
</li>
</ul>
<p>我们接下来看同步数据代码的区域：org.apache.zookeeper.server.quorum.LearnerHandler.run()。也是在leader为每个learner分配的处理连接的线程中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">            <span class="comment">/* the default to send to the follower */</span></div><div class="line">            <span class="keyword">int</span> packetToSend = Leader.SNAP;<span class="comment">//默认传送leader快照 </span></div><div class="line">            <span class="keyword">long</span> zxidToSend = <span class="number">0</span>;</div><div class="line">            <span class="keyword">long</span> leaderLastZxid = <span class="number">0</span>;</div><div class="line">            <span class="comment">/** the packets that the follower needs to get updates from **/</span></div><div class="line">            <span class="keyword">long</span> updates = peerLastZxid;        </div><div class="line"><span class="comment">/* we are sending the diff check if we have proposals in memory to be able to </span></div><div class="line"><span class="comment">         * send a diff to the </span></div><div class="line"><span class="comment">         */</span> </div><div class="line">        ReentrantReadWriteLock lock = leader.zk.getZKDatabase().getLogLock();</div><div class="line">        ReadLock rl = lock.readLock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            rl.lock();        </div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> maxCommittedLog = leader.zk.getZKDatabase().getmaxCommittedLog();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> minCommittedLog = leader.zk.getZKDatabase().getminCommittedLog();</div><div class="line">            LOG.info(<span class="string">"Synchronizing with Follower sid: "</span> + sid</div><div class="line">                    +<span class="string">" maxCommittedLog=0x"</span>+Long.toHexString(maxCommittedLog)</div><div class="line">                    +<span class="string">" minCommittedLog=0x"</span>+Long.toHexString(minCommittedLog)</div><div class="line">                    +<span class="string">" peerLastZxid=0x"</span>+Long.toHexString(peerLastZxid));</div><div class="line"></div><div class="line">            LinkedList&lt;Proposal&gt; proposals leader.zk.getZKDatabase().getCommittedLog();<span class="comment">//可以看到会去获取final处理器中保存的已经提交的操作日志</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (peerLastZxid == leader.zk.getZKDatabase().getDataTreeLastProcessedZxid()) &#123;<span class="comment">//如果learner跟leader的事务id一致，那么说明数据一致，不需要同步</span></div><div class="line">                <span class="comment">// Follower is already sync with us, send empty diff</span></div><div class="line">                LOG.info(<span class="string">"leader and follower are in sync, zxid=0x&#123;&#125;"</span>,</div><div class="line">                        Long.toHexString(peerLastZxid));</div><div class="line">                packetToSend = Leader.DIFF;</div><div class="line">                zxidToSend = peerLastZxid;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proposals.size() != <span class="number">0</span>) &#123;<span class="comment">//说明当前服务器</span></div><div class="line">                LOG.debug(<span class="string">"proposal size is &#123;&#125;"</span>, proposals.size());</div><div class="line">                <span class="keyword">if</span> ((maxCommittedLog &gt;= peerLastZxid)</div><div class="line">                        &amp;&amp; (minCommittedLog &lt;= peerLastZxid)) &#123;</div><div class="line">                    LOG.debug(<span class="string">"Sending proposals to follower"</span>);</div><div class="line"></div><div class="line">                    <span class="comment">// as we look through proposals, this variable keeps track of previous</span></div><div class="line">                    <span class="comment">// proposal Id.</span></div><div class="line">                    <span class="keyword">long</span> prevProposalZxid = minCommittedLog;</div><div class="line"></div><div class="line">                    <span class="comment">// Keep track of whether we are about to send the first packet.</span></div><div class="line">                    <span class="comment">// Before sending the first packet, we have to tell the learner</span></div><div class="line">                    <span class="comment">// whether to expect a trunc or a diff</span></div><div class="line">                    <span class="keyword">boolean</span> firstPacket=<span class="keyword">true</span>;</div><div class="line"></div><div class="line">                    <span class="comment">// If we are here, we can use committedLog to sync with</span></div><div class="line">                    <span class="comment">// follower. Then we only need to decide whether to</span></div><div class="line">                    <span class="comment">// send trunc or not</span></div><div class="line">                    packetToSend = Leader.DIFF;</div><div class="line">                    zxidToSend = maxCommittedLog;</div><div class="line"></div><div class="line">                    <span class="keyword">for</span> (Proposal propose: proposals) &#123;</div><div class="line">                        <span class="comment">// skip the proposals the peer already has</span></div><div class="line">                        <span class="keyword">if</span> (propose.packet.getZxid() &lt;= peerLastZxid) &#123;</div><div class="line">                            prevProposalZxid = propose.packet.getZxid();</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="comment">// If we are sending the first packet, figure out whether to trunc</span></div><div class="line">                            <span class="comment">// in case the follower has some proposals that the leader doesn't</span></div><div class="line">                            <span class="keyword">if</span> (firstPacket) &#123;</div><div class="line">                                firstPacket = <span class="keyword">false</span>;</div><div class="line">                                <span class="comment">// Does the peer have some proposals that the leader hasn't seen yet</span></div><div class="line">                                <span class="keyword">if</span> (prevProposalZxid &lt; peerLastZxid) &#123;</div><div class="line">                                    <span class="comment">// send a trunc message before sending the diff</span></div><div class="line">                                    packetToSend = Leader.TRUNC;                                        </div><div class="line">                                    zxidToSend = prevProposalZxid;</div><div class="line">                                    updates = zxidToSend;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            queuePacket(propose.packet);</div><div class="line">                            QuorumPacket qcommit = <span class="keyword">new</span> QuorumPacket(Leader.COMMIT, propose.packet.getZxid(),</div><div class="line">                                    <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                            queuePacket(qcommit);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (peerLastZxid &gt; maxCommittedLog) &#123;<span class="comment">//如果learner的事务id大于leader的事务id，那么发送回滚删除命令给learner</span></div><div class="line">                    LOG.debug(<span class="string">"Sending TRUNC to follower zxidToSend=0x&#123;&#125; updates=0x&#123;&#125;"</span>,</div><div class="line">                            Long.toHexString(maxCommittedLog),</div><div class="line">                            Long.toHexString(updates));</div><div class="line"></div><div class="line">                    packetToSend = Leader.TRUNC;</div><div class="line">                    zxidToSend = maxCommittedLog;</div><div class="line">                    updates = zxidToSend;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    LOG.warn(<span class="string">"Unhandled proposal scenario"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// just let the state transfer happen</span></div><div class="line">                LOG.debug(<span class="string">"proposals is empty"</span>);</div><div class="line">            &#125;               </div><div class="line"></div><div class="line">            LOG.info(<span class="string">"Sending "</span> + Leader.getPacketType(packetToSend));</div><div class="line">            leaderLastZxid = leader.startForwarding(<span class="keyword">this</span>, updates);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            rl.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">。。。。。</div><div class="line">                <span class="comment">// Start sending packets</span></div><div class="line">            <span class="keyword">new</span> Thread() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    Thread.currentThread().setName(</div><div class="line">                            <span class="string">"Sender-"</span> + sock.getRemoteSocketAddress());</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        sendPackets();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        LOG.warn(<span class="string">"Unexpected interruption"</span>,e);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;.start();<span class="comment">//开始发送数据给learner</span></div></pre></td></tr></table></figure>
<p>经过上面的操作，leader把跟learner差异的数据发送给了learner，那么learner怎么处理呢？</p>
<h5 id="learner怎么处理"><a href="#learner怎么处理" class="headerlink" title="learner怎么处理"></a>learner怎么处理</h5><p>会在followLeader()方法中调用org.apache.zookeeper.server.quorum.Learner.syncWithLeader(long)。进行数据同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">根据    leader发送的qp.getType() 类型，处理相应的逻辑</div><div class="line"><span class="keyword">synchronized</span> (zk) &#123;</div><div class="line">        <span class="keyword">if</span> (qp.getType() == Leader.DIFF) &#123;</div><div class="line">            LOG.info(<span class="string">"Getting a diff from the leader 0x&#123;&#125;"</span>, Long.toHexString(qp.getZxid()));</div><div class="line">            snapshotNeeded = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (qp.getType() == Leader.SNAP) &#123;</div><div class="line">        。。。。。。</div></pre></td></tr></table></figure>
<h5 id="leader在哪里处理learner转发client的写请求？"><a href="#leader在哪里处理learner转发client的写请求？" class="headerlink" title="leader在哪里处理learner转发client的写请求？"></a>leader在哪里处理learner转发client的写请求？</h5><p>我们知道learner对于client客户端而言，如果发送更新请求，那么learner是会把写请求发送给leader进行处理的。</p>
<p>​    那么leader在哪里处理learner发送过来的更新请求呢？就在Learnerhandler的run方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> Leader.REQUEST:                    </div><div class="line">    bb = ByteBuffer.wrap(qp.getData());</div><div class="line">    sessionId = bb.getLong();</div><div class="line">    cxid = bb.getInt();</div><div class="line">    type = bb.getInt();</div><div class="line">    bb = bb.slice();</div><div class="line">    Request si;</div><div class="line">    <span class="keyword">if</span>(type == OpCode.sync)&#123;</div><div class="line">        si = <span class="keyword">new</span> LearnerSyncRequest(<span class="keyword">this</span>, sessionId, cxid, type, bb, qp.getAuthinfo());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        si = <span class="keyword">new</span> Request(<span class="keyword">null</span>, sessionId, cxid, type, bb, qp.getAuthinfo());</div><div class="line">    &#125;</div><div class="line">    si.setOwner(<span class="keyword">this</span>);</div><div class="line">    leader.zk.submitRequest(si);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<h1 id="集群模式-end"><a href="#集群模式-end" class="headerlink" title="########集群模式 end"></a>########集群模式 end</h1><h1 id="zk实现分布式锁和分布式配置中心"><a href="#zk实现分布式锁和分布式配置中心" class="headerlink" title="zk实现分布式锁和分布式配置中心"></a>zk实现分布式锁和分布式配置中心</h1><h2 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h2><p>实际上实现分布式锁的方式有两种：</p>
<ul>
<li>​    使用类似lock的规则，多个客户端同时去创建一个临时节点，创建成功者则代表他获得锁，否则就监听节点的删除操作（代表释放锁），如果节点被删除那么<strong>会通知所有客户端</strong>再去创建同样的临时节点，同理创建成功则获取锁。以此类推。<ul>
<li>那么这种方式的好处就是实现非常简单，但是坏处就是容易发生惊群效应。锁被释放时，都会去通知所有监听该节点的客户端，然后所有客户端同时请求zk创建节点以求获取锁。那么这样对于zk而言就会造成没有必要的请求（虽然zk服务端也会把请求放到队列中一个一个的处理的，但是能够处理成功的也就只有一个，后面的创建节点都会失败。）</li>
</ul>
</li>
<li>多个客户端同时创建多个临时顺序节点，序号最小的获取锁。然后次小的序号监听当前序号的释放。以此类推。那么只要锁被释放那么监听该节点的客户端 收到事件然后获取锁。<ul>
<li>这样就解决了第一种实现方式的弊端。使用这种方式，每次都只通知比他序号小的那个节点获取锁。不用通知所有客户端。</li>
<li>他的思路就相当于juc包里面，lock或者synchronized的实现，每次都尝试获取锁–也就是判断自己创建的节点是不是序号最小的（类似于Lock的trylock方法），如果不是那么就监听比他小的那个节点的释放（类似于Lock的，tryLock失败后，那么阻塞，加入aqs阻塞队列等待唤醒）（而且在juc中每次都会从aqs阻塞队列中获取队列首节点获取锁类似于zk 的当前节点被删除后，那么就通知他的后一个节点获取锁）</li>
<li>也就是说，这种方式的实现，类似于Lock公平锁模式的实现。</li>
</ul>
</li>
</ul>
<p><strong>zk 的什么特性保证了分布式锁的实现呢：</strong></p>
<ul>
<li><p>​    监听机制</p>
</li>
<li><p>​    相同目录下节点名称不能相同</p>
</li>
<li><p>​    临时顺序节点</p>
</li>
<li><p>​    关于更新请求统一逐个交由leader进行处理，其他learner只能读不能处理写请求。</p>
</li>
<li>​    数据的顺序一致性</li>
</ul>
<p>​    <strong>下面就粗略的实现了分布式锁的代码，但是并没有保证线程安全。只是个参考，重要的是实现的思路，因为在真是开发中，我们肯定使用的是已经封装好的，一般不会自己写。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.zookeeper.kingge;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.EventType;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</div><div class="line"><span class="comment">//可以看到整体的思路是模仿了juc中Lock的实现。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKLock</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> String connectString = <span class="string">"localhost:2181,localhost:2182"</span>;<span class="comment">//zk集群地址</span></div><div class="line">	<span class="keyword">private</span> ZooKeeper client = <span class="keyword">null</span>;<span class="comment">//zk客户端</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String  PARENT_PATH = <span class="string">"/lock"</span>;<span class="comment">//我们在这个节点下面创建临时顺序节点</span></div><div class="line">	</div><div class="line">	<span class="keyword">private</span>  String createNodeName;<span class="comment">//创建节点名称</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">initZKClient</span><span class="params">()</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>( client == <span class="keyword">null</span> )</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				client = <span class="keyword">new</span> ZooKeeper(connectString, <span class="number">2000</span>, <span class="keyword">new</span> Watcher() &#123;</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">						System.out.println( <span class="string">"zk默认监听器收到事件："</span>+ event  );</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">				Stat exists = client.exists(PARENT_PATH, <span class="keyword">false</span>);</div><div class="line">				<span class="keyword">if</span>( exists == <span class="keyword">null</span> ) &#123;<span class="comment">//说明父节点不存在，则需要创建</span></div><div class="line">					client.create(PARENT_PATH, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], </div><div class="line">							ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(tryLock()) &#123;</div><div class="line">			System.out.println( <span class="string">"成功获取锁"</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</div><div class="line">		String nodeName =  PARENT_PATH+<span class="string">"/zk_"</span>;<span class="comment">//创建子节点路径</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//创建节点</span></div><div class="line">			 createNodeName = client.create(nodeName, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], </div><div class="line">					ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<span class="comment">//这里返回的是创建节点的全路径，例如/lock/zk_0</span></div><div class="line">			<span class="comment">//判断当前节点是否是最小节点</span></div><div class="line">			List&lt;String&gt; children = client.getChildren(PARENT_PATH, <span class="keyword">false</span>);<span class="comment">//这里返回的节点类型是 zk_0,zk_1,zk_2</span></div><div class="line">			Collections.sort(children);</div><div class="line">			String minNodeName = children.get(<span class="number">0</span>);<span class="comment">//获得最小的节点名称</span></div><div class="line">			<span class="comment">//比较节点</span></div><div class="line">			<span class="keyword">if</span>( createNodeName.equals(PARENT_PATH+<span class="string">"/"</span>+minNodeName) ) &#123;</div><div class="line">				System.out.println(  createNodeName +<span class="string">" 是最小节点，成功获取锁"</span> );</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//说明当前创建的节点是最小节点，那么获取锁</span></div><div class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//否则，监听比他小的节点</span></div><div class="line">				<span class="comment">//获取当前节点在children中下标位置</span></div><div class="line">				String substring = createNodeName.substring(createNodeName.lastIndexOf(<span class="string">"/"</span>)+<span class="number">1</span>);<span class="comment">//实际上就是截取出类似于，zk_0这样的字符串</span></div><div class="line">				<span class="keyword">int</span> indexOf = children.indexOf(substring);</div><div class="line">				<span class="comment">//获取他前一个节点</span></div><div class="line">				String preNode = children.get(indexOf-<span class="number">1</span>);</div><div class="line">				<span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">				<span class="comment">//然后监听该节点是否存在</span></div><div class="line">				client.exists(PARENT_PATH+<span class="string">"/"</span>+preNode, <span class="keyword">new</span> Watcher() &#123;</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">						<span class="keyword">if</span>( Event.EventType.NodeDeleted.equals(event.getType()) ) &#123;<span class="comment">//节点删除，那么说明当前节点可以获取锁</span></div><div class="line">							System.out.println( createNodeName + <span class="string">"，开始获取锁"</span> );</div><div class="line">							countDownLatch.countDown();</div><div class="line">						&#125;  </div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">				System.out.println(  createNodeName +<span class="string">"，节点等待锁中。。。"</span> );</div><div class="line">				countDownLatch.await();<span class="comment">//阻塞等待，当前节点获取锁。不阻塞的话当前方法执行完毕就直接返回了，上面监听判断获取锁的代码就不会生效了。</span></div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125; </div><div class="line">			</div><div class="line">		&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//其实这一步不用实现，因为临时节点，断开连接后自动会删除节点。但是为了代码逻辑的完整性，这里还是手动删除一下节点</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			client.delete(createNodeName, -<span class="number">1</span>);<span class="comment">//这里的-1是版本号，表示在删除节点的时候不需要检查版本号。因为zk在进行删除操作的时候</span></div><div class="line">			<span class="comment">//会检查客户端发送过来的版本号跟服务端节点的版本号是否一致，如果是才能删除，否则删除失败。</span></div><div class="line">			createNodeName = <span class="string">""</span>;</div><div class="line">			client.close();</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ZKLock zkLock = <span class="keyword">new</span> ZKLock();</div><div class="line">		zkLock.initZKClient();</div><div class="line">		zkLock.tryLock();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h2><p>​    目的就是，统一管理所有服务器的配置信息，这样我们只需要在配置中心修改后，所有服务器自动同步修改后的配置信息。（是不是马上就想到了监听）</p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> org.apache.zookeeper.kingge;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCache;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.RetryNTimes;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConfig</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String connectString = <span class="string">"localhost:2181,localhost:2182"</span>;<span class="comment">//zk集群地址</span></div><div class="line">	<span class="keyword">private</span> Map&lt;String,String&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//配置信息的缓存</span></div><div class="line">	<span class="keyword">private</span> CuratorFramework client;<span class="comment">//这里使用的是curator框架创建zk客户端</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String  PARENT_PATH = <span class="string">"/config"</span>;<span class="comment">//存放配置信息的根节点</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ZKConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.client = CuratorFrameworkFactory.newClient(connectString, <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">1000</span>));</div><div class="line">		client.start();</div><div class="line">		</div><div class="line">		init();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//初始化所有配置项的信息到本地缓存</span></div><div class="line">			List&lt;String&gt; forPath = client.getChildren().forPath(PARENT_PATH);</div><div class="line">			 <span class="keyword">for</span> (String name : forPath) &#123;</div><div class="line">				 <span class="comment">//根据路径获取，每个节点的配置信息</span></div><div class="line">				String value = <span class="keyword">new</span> String( client.getData().forPath(PARENT_PATH + <span class="string">"/"</span> + name) );</div><div class="line">				cache.put(name, value);</div><div class="line">			&#125;</div><div class="line">			 </div><div class="line">			 <span class="comment">//同时监听在PARENT_PATH目录下面所有孩子的</span></div><div class="line">			 <span class="comment">//新增，删除，修改操作。如果发生了以上三个事件，那么就需要在监听器中同步更新cache配置信息</span></div><div class="line">			 PathChildrenCache watcher = <span class="keyword">new</span> PathChildrenCache(client, PARENT_PATH, <span class="keyword">true</span>);</div><div class="line">			 watcher.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">					</div><div class="line">					String path = event.getData().getPath();<span class="comment">//获得节点的全路径 例如/config/zk1</span></div><div class="line">					<span class="keyword">if</span>( path.startsWith(PARENT_PATH) ) &#123;<span class="comment">//表示如果事件是发生在PARENT_PATH下面的节点之上，才会执行下面逻辑。</span></div><div class="line">							String key = path.replace(PARENT_PATH+<span class="string">"/"</span>, <span class="string">""</span>);<span class="comment">//也就是抽取出节点的后缀路径 -- /config/zk1 ---》 zk1</span></div><div class="line">							<span class="keyword">if</span>( PathChildrenCacheEvent.Type.CHILD_ADDED.equals(event.getType()) ) &#123;<span class="comment">//新增了子节点</span></div><div class="line">								System.out.println( <span class="string">"触发了 CHILD_ADDED 事件"</span> );</div><div class="line">								cache.put(key, <span class="keyword">new</span> String(event.getData().getData()));</div><div class="line">							&#125;</div><div class="line">							<span class="keyword">if</span>( PathChildrenCacheEvent.Type.CHILD_UPDATED.equals(event.getType()) ) &#123;<span class="comment">//修改了子节点</span></div><div class="line">								System.out.println( <span class="string">"触发了 CHILD_UPDATED 事件"</span> );</div><div class="line">								cache.put(key, <span class="keyword">new</span> String(event.getData().getData()));</div><div class="line">							&#125;</div><div class="line">							<span class="keyword">if</span>( PathChildrenCacheEvent.Type.CHILD_REMOVED.equals(event.getType()) ) &#123;<span class="comment">//删除了子节点</span></div><div class="line">								System.out.println( <span class="string">"触发了 CHILD_REMOVED 事件"</span> );</div><div class="line">								cache.remove(key);</div><div class="line">							&#125;</div><div class="line">					&#125;</div><div class="line">					</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">			 watcher.start();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">saveNodeConfig</span><span class="params">(String name,String value)</span> </span>&#123;<span class="comment">//存放配置信息到某个节点</span></div><div class="line">		String lookPath = PARENT_PATH + <span class="string">"/"</span> + name;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Stat forPath = client.checkExists().forPath(lookPath);</div><div class="line">			<span class="keyword">if</span>( forPath == <span class="keyword">null</span> ) &#123;<span class="comment">//不存在则创建节点，并保存配置信息</span></div><div class="line">				client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(lookPath,value.getBytes());</div><div class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//节点存在则更新值</span></div><div class="line">				client.setData().forPath(lookPath,value.getBytes());</div><div class="line">			&#125;</div><div class="line">			cache.put(name, value);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getNodeConfig</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> cache.get(name);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		ZKConfig config = <span class="keyword">new</span> ZKConfig();</div><div class="line">		config.saveNodeConfig(<span class="string">"erukaServers"</span>, <span class="string">"192.168.1.1,192.168.1.2"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">			System.out.println( <span class="string">"获取配置信息："</span>+config.getNodeConfig(<span class="string">"erukaServers"</span>) );</div><div class="line">			System.out.println( config.cache );</div><div class="line">			TimeUnit.SECONDS.sleep(<span class="number">5</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>实际上他跟配置中心的实现也是一样的</p>
<h1 id="！！！！！疑问！！！！！！！！！！！"><a href="#！！！！！疑问！！！！！！！！！！！" class="headerlink" title="！！！！！疑问！！！！！！！！！！！"></a>！！！！！疑问！！！！！！！！！！！</h1><blockquote>
<p>​    <strong>上面说加入OB服务器，虽然不参与投票，那么zk转化为AP，那么假设ob服务器启动后，怎么同步leader的数据？？？？怎么保证数据一致性？</strong></p>
</blockquote>
<p> <strong>答案：不会，learner启动后，必须跟leader同步数据完成后，才会调用 zk.startup()启动服务，接受客户端请求。</strong></p>
<blockquote>
<p>​    <strong>如果某个节点，没有同步数据，那么客户端会不会读到不是最新的数据（假设有5台机器，其中三台写入数据成功，那么就认为整个更新操作成功。也就是说，客户端的读请求会不会发送到这两台未同步最新数据的server 上？）</strong></p>
</blockquote>
<p> <strong>答案：可能会读到旧数据，因为此时，这两台可能还没有进入同步leader数据的逻辑，那么这个时候刚好客户端发来请求，那么就会访问到旧数据。所以zk是保证在一定时间范围内数据是一致性的-是弱一致性</strong></p>
<p>​    </p>
<blockquote>
<p><strong>为什么leader跟follower的通讯用的是bio而不是nio？（leader.lead（）方法，可以看到leader为每一个learner的交互使用bio且都new了一个线程）</strong></p>
</blockquote>
<p>暂无答案</p>
<blockquote>
<p><strong>数据同步过程中，集群能够接受请求么？代码哪里证明？</strong></p>
</blockquote>
<p>   答案：在进行了数据同步之后，我们发现这个时候server还只是初始化状态，state并不是Running。</p>
<p>Leader.lead()方法中会调用  startZkServer();启动服务无，设置无服务状态为Running，并设置处理链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startZkServer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Update lastCommitted and Db's zxid to a value representing the new epoch</span></div><div class="line">    lastCommitted = zk.getZxid();</div><div class="line">    LOG.info(<span class="string">"Have quorum of supporters, sids: [ "</span></div><div class="line">            + getSidSetString(newLeaderProposal.ackSet)</div><div class="line">            + <span class="string">" ]; starting up and setting last processed zxid: 0x&#123;&#125;"</span>,</div><div class="line">            Long.toHexString(zk.getZxid()));</div><div class="line">    zk.startup();<span class="comment">//启动服务，开始接受请求</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Update the election vote here to ensure that all members of the</span></div><div class="line"><span class="comment">     * ensemble report the same vote to new servers that start up and</span></div><div class="line"><span class="comment">     * send leader election notifications to the ensemble.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    self.updateElectionVote(getEpoch());</div><div class="line"></div><div class="line">    zk.getZKDatabase().setlastProcessedZxid(zk.getZxid());</div><div class="line">&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) &#123;</div><div class="line">            createSessionTracker();</div><div class="line">        &#125;</div><div class="line">        startSessionTracker();</div><div class="line">        setupRequestProcessors();<span class="comment">//关键初始化处理链中的三个处理器</span></div><div class="line">        registerJMX();</div><div class="line">        setState(State.RUNNING);<span class="comment">//关键，设置服务状态为运行状态，开始受理client业务</span></div><div class="line">        notifyAll();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>那么在learner中呢？</strong></p>
<p>逻辑也是如此。    follower.followLeader() – &gt; syncWithLeader（）</p>
<p>同步完leader数据后，马上启动。关键代码在syncWithLeader方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    zk.startup();<span class="comment">//跟leader一样，最终也是会调用</span></div><div class="line">    </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) &#123;</div><div class="line">        createSessionTracker();</div><div class="line">    &#125;</div><div class="line">    startSessionTracker();</div><div class="line">    setupRequestProcessors();</div><div class="line"></div><div class="line">    registerJMX();</div><div class="line"></div><div class="line">    setState(State.RUNNING);</div><div class="line">    notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    <strong>所以，确保了，在leader跟learner同步数据完成后，整个集群才能够启动使用，否则在这期间是不会客户端业务的。保证了数据一致性。（而且只有这个时候，才能够初始化处理链，处理请求并把服务器状态标志位RUNning）</strong></p>
<blockquote>
<p><strong>集群的处理链跟单机模式的处理链有何不同</strong></p>
</blockquote>
<p>​    我们知道单机模式下，server端是通过PrepRequestProcessor -》SyncRequestProcessor-》FinalRequestProcessor 这三个处理链进行处理客户端请求的。</p>
<p>​    那么集群模式下，也是这三个处理器么？答案：<strong>不是一样的，有些许区别。</strong></p>
<p>​    因为leader、follower、observer对服务端（ZooKeeperServer）的实现都是不一样的，分别是LeaderZooKeeperServer，FollowerZooKeeperServer、ObserverZooKeeperServer，他们对 setupRequestProcessors()初始化处理链的实现都不同。</p>
<p><strong>原生ZooKeeperServer的setupRequestProcessors（）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line">    RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</div><div class="line">            finalProcessor);</div><div class="line">    ((SyncRequestProcessor)syncProcessor).start();</div><div class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);</div><div class="line">    ((PrepRequestProcessor)firstProcessor).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>LeaderZooKeeperServer的setupRequestProcessors（）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line">    RequestProcessor toBeAppliedProcessor = <span class="keyword">new</span> Leader.ToBeAppliedRequestProcessor(</div><div class="line">            finalProcessor, getLeader().toBeApplied);</div><div class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(toBeAppliedProcessor,</div><div class="line">            Long.toString(getServerId()), <span class="keyword">false</span>,</div><div class="line">            getZooKeeperServerListener());</div><div class="line">    commitProcessor.start();</div><div class="line">    ProposalRequestProcessor proposalProcessor = <span class="keyword">new</span> ProposalRequestProcessor(<span class="keyword">this</span>,</div><div class="line">            commitProcessor);</div><div class="line">    proposalProcessor.initialize();</div><div class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, proposalProcessor);</div><div class="line">    ((PrepRequestProcessor)firstProcessor).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proposalProcessor：作用是发起投票请求的。因为集群模式下，更新操作需要投票。</p>
<p>​    prep处理收到请求，然后使用proposal处理器，向learner发送操作提议，如果learner半数相应，那么说明可以提交数据，那么接着执行commit处理器，向learner发送提交数据请求。</p>
<p>​    执行commit处理器时，<strong>会阻塞</strong>，等待learner的ack确认（learner在自己服务器持久化成功后，发送ack请求），learner发送ack确认后，leader被唤醒，表示本次更新操作半数learner已经更新成功，继续执行接下来的处理器，leader最后执行final处理器持久化数据。</p>
<p><strong>FollowerZooKeeperServer的setupRequestProcessors（）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(finalProcessor,</div><div class="line">            Long.toString(getServerId()), <span class="keyword">true</span>,</div><div class="line">            getZooKeeperServerListener());</div><div class="line">    commitProcessor.start();</div><div class="line">    firstProcessor = <span class="keyword">new</span> FollowerRequestProcessor(<span class="keyword">this</span>, commitProcessor);</div><div class="line">    ((FollowerRequestProcessor) firstProcessor).start();</div><div class="line">    syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</div><div class="line">            <span class="keyword">new</span> SendAckRequestProcessor((Learner)getFollower()));</div><div class="line">    syncProcessor.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>ObserverZooKeeperServer的setupRequestProcessors（）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;      </div><div class="line">    <span class="comment">// We might consider changing the processor behaviour of </span></div><div class="line">    <span class="comment">// Observers to, for example, remove the disk sync requirements.</span></div><div class="line">    <span class="comment">// Currently, they behave almost exactly the same as followers.</span></div><div class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</div><div class="line">    commitProcessor = <span class="keyword">new</span> CommitProcessor(finalProcessor,</div><div class="line">            Long.toString(getServerId()), <span class="keyword">true</span>,</div><div class="line">            getZooKeeperServerListener());</div><div class="line">    commitProcessor.start();</div><div class="line">    firstProcessor = <span class="keyword">new</span> ObserverRequestProcessor(<span class="keyword">this</span>, commitProcessor);</div><div class="line">    ((ObserverRequestProcessor) firstProcessor).start();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Observer should write to disk, so that the it won't request</span></div><div class="line"><span class="comment">     * too old txn from the leader which may lead to getting an entire</span></div><div class="line"><span class="comment">     * snapshot.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * However, this may degrade performance as it has to write to disk</span></div><div class="line"><span class="comment">     * and do periodic snapshot which may double the memory requirements</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">if</span> (syncRequestProcessorEnabled) &#123;</div><div class="line">        syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>, <span class="keyword">null</span>);</div><div class="line">        syncProcessor.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>压测一下zk的常用接口</strong></p>
</blockquote>
<p>例如压测一下新增节点操作，看是否存在相同节点创建等等问题。</p>
<h1 id="zk的zxid"><a href="#zk的zxid" class="headerlink" title="zk的zxid"></a>zk的zxid</h1><p>   zxid：事务id。</p>
<p>​    我们知道在数据同步和leader选举中，server的zxid是至关重要的，因为他表示这当前数据提交事务id，那么也就意味着， 他越大数据就越新，那么他成为leader的机会应该更大。</p>
<p>​    <strong>zxid是一个64位的数字，高32位表示epoch（也就是，当前是第几轮的投票，每次有新的leader都会加1），低32位表示递增的序号（日志文件序号）。</strong></p>
<p>​    我们在zk的存储目录中可以看到，生成的日志文件1000000001就是递增的序号，表示这是第一轮中产生的1号日志文件。其中currentEpoch表示当前是第几轮（<strong>新增一轮就表示有新的leader产生</strong>）。acceptedEpoch表示已经接受过的第几轮，一般而言，currentEpoch和acceptedEpoch是一样的。</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200413110859408.png" alt="image-20200413110859408"></p>
<p>​    既然每一轮都表示新的leader选出，那么就会对应着新的日志文件，然后根据低32位递增该轮的日志文件。保证了每轮都会有相应的日志（这样数据看起来就很清晰，知道这个日志文件是那一轮产生的，也方便数据同步的时候leader和learner的数据同步。leader只需要发送learner缺少的第几轮的日志即可，不需要发送之前旧轮数的数据。）</p>
<p>总而言之，<strong>新的leader会创建新的epoch（表示这是属于我的领导）</strong>。</p>
<h1 id="zk保证了高并发的安全性"><a href="#zk保证了高并发的安全性" class="headerlink" title="zk保证了高并发的安全性"></a>zk保证了高并发的安全性</h1><p>​    </p>
<p>​    我们知道，客户端的所有更新请求（cud，增删改），都是转发到leader服务器（无论单机模式还是集群模式），leader服务器对于请求，都会 放到一个队列中，逐个进行处理。</p>
<p>​    </p>
<h1 id="zk是不是强一致性？是顺序一致性"><a href="#zk是不是强一致性？是顺序一致性" class="headerlink" title="zk是不是强一致性？是顺序一致性"></a>zk是不是强一致性？是顺序一致性</h1><p>​    首先理解一下强一致性的概念：要成功就一起成功，不允许存在不成功，数据必须是一致的。</p>
<p>​    很明显zk不是强一致性。zk的机制是过半提交成功，那么就认为整个更新请求是成功，此时其他没有成功ack的server是存在数据不一致的。（<strong>如果上面阐述了zk是强一致性，那么是有歧义的，望周知</strong>）</p>
<p>​    </p>
<p>那么zk是不是最终一致性呢？也不是。</p>
<p>zookeeper是<strong>顺序一致性</strong>。</p>
<h2 id="什么叫顺序一致性："><a href="#什么叫顺序一致性：" class="headerlink" title="什么叫顺序一致性："></a>什么叫顺序一致性：</h2><p>假设有一个Zookeeper集群（N&gt;=3，N为奇数），那么只有一个Leader（通过FastLeaderElection选主策略选取），所有的写操作（客户端请求Leader或Follower的写操作）都由Leader统一处理，Follower虽然对外提供读写，但写操作会提交到Leader，由Leader和Follower共同保证同一个Follower请求的顺序性，Leader会为每个请求生成一个zxid（高32位是epoch，用来标识leader选举周期，每次一个leader被选出来，都会有一个新的epoch，标识当前属于哪个leader的统治时期，低32位用于递增计数）</p>
<p>针对同一个Follower A提交的写请求request1、request2，某些Follower虽然可能不能在请求提交成功后立即看到（也就是强一致性），但经过自身与Leader之间的同步后，这些Follower在看到这两个请求时，一定是先看到request1，然后再看到request2，两个请求之间不会乱序，即顺序一致性。</p>
<p>画个图</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200413115911137.png" alt="image-20200413115911137"></p>
<p>​    也就是说，如果在B1读到的x是1，那么C0读到肯定也是1，那么B2肯定也是1。不会存在说，B1读到的是1，然后之后发生了回滚C0读到的x变成了0，那么这样就不满足顺序一致性。</p>
<p>​    也就是说在，时间轴上的操作，都是有顺序的。数据都是一致的，不会存在朝令夕改。</p>
<p><strong>那么在zk中，使用队列和zxid保证了顺序一致性。</strong></p>
<p>​    但是说是这么说，zk真的能够保证顺序一致性么？<strong>并不能！！！在多台客户端请求的时候并不能保证顺序一致性（也就是说可能在同步数据过程中，B1读到的x是1，但是C0读到的是0。因为存在网络延迟的原因，可能C0读到的是某一台learner还没有执行leader的commit操作，数据不是最新的）</strong></p>
<p>​    <strong>但是同一台客户端发出的请求读取到的数据肯定是一直的。例如客户端B，B2请求leader获取x数据这个时候，因为leader已经持久化诗句完毕，返回x是1。但是接着客户端B发出B3请求再次获取x数据的时候，请求到的是集群集群中的learner，那么因为这个时候这台learner还未完成数据的同步，那么此时B3请求获取到的x是0。但是客户端拿到x=0时会直接丢弃，因为他发现这个数据的zxid比上次最近获取的zxid还小，他认为不是最新的。</strong></p>
<p>我们可以看官方的解释：</p>
<p><img src="/2020/02/02/zookeeper源码解析/image-20200413143508887.png" alt="image-20200413143508887"></p>
<p>​    <strong>他自己说了，zk无法保证在某个时刻，每一台zk服务，在两台客户端去连接的时候，能够获取到相同的数据。那么如果想让两个客户端读到相同的值，他提供了sync()函数帮助我们实现这个功能</strong></p>
<p>也就是说，客户端B在获取某个节点数据之前，先调用sync方法，然后再去获取数据。这样就能够保证客户端B跟客户端A读到的值是一样的。</p>
<p>官方文档：<a href="http://zookeeper.apache.org/doc/r3.5.5/zookeeperProgrammers.html#ch_zkGuarantees" target="_blank" rel="external">http://zookeeper.apache.org/doc/r3.5.5/zookeeperProgrammers.html#ch_zkGuarantees</a></p>
<h1 id="zk涉及到的java基础知识"><a href="#zk涉及到的java基础知识" class="headerlink" title="zk涉及到的java基础知识"></a>zk涉及到的java基础知识</h1><blockquote>
<p><strong>首先并发编程的wait和notify</strong></p>
</blockquote>
<p>在客户端发送请求给服务端后，会监听packet的请求是否处理完成，调用wait()阻塞等待返回。直到服务端处理完成，唤醒notify</p>
<blockquote>
<p><strong>队列相关知识</strong></p>
</blockquote>
<p>你会发现zk的客户端还是服务端，都充斥着各种队列，例如客户端发送的请求，都会封装到outgoingqueue队列中逐个处理。</p>
<p>服务端在处理请求的时候，会从队列中逐个拿出，然后传递给处理链，每个处理链中的处理器，都会有自己的队列，处理完成后，都会放到自己的队列中，然后交给下一个处理器处理（一共三个处理器，pre、sync、final）</p>
<blockquote>
<p><strong>juc的countdownlatch</strong></p>
</blockquote>
<p>​    服务端在启动的时候，就是利用了countdownlatch的机制，通过cd.await()实现了服务的挂起，直到cd.countdown()，那就说明server需要退出，然后才能继续处理cd.await()之后的代码，完成关闭server的后继工作。</p>
<blockquote>
<p><strong>生产者和消费者</strong></p>
<p><strong>责任链模式</strong></p>
</blockquote>
<p>我们知道不管是单机版本server还是集群版本，他们最终处理请求都是会经过一条处理链进行处理请求。</p>
<h1 id="zk源码构建"><a href="#zk源码构建" class="headerlink" title="zk源码构建"></a><strong>zk源码构建</strong></h1><h2 id="安装ANT"><a href="#安装ANT" class="headerlink" title="安装ANT"></a><strong>安装ANT</strong></h2><ul>
<li><strong><a href="https://link.jianshu.com?t=https%3A%2F%2Fant.apache.org%2Fbindownload.cgi" target="_blank" rel="external">下载ant</a>,地址：<a href="https://link.jianshu.com?t=https%3A%2F%2Fant.apache.org%2Fbindownload.cgi" target="_blank" rel="external">https://ant.apache.org/bindownload.cgi</a></strong></li>
<li><strong>下载后解压ant到硬盘目录，设置环境变量：</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>变量</strong></th>
<th style="text-align:center"><strong>值</strong></th>
<th style="text-align:center"><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ANT_HOME</strong></td>
<td style="text-align:center"><strong>D:\apache-ant-1.10.2</strong></td>
<td style="text-align:center"><strong>新建变量</strong></td>
</tr>
<tr>
<td><strong>Path</strong></td>
<td style="text-align:center"><strong>;%ANT_HOME%\bin</strong></td>
<td style="text-align:center"><strong>没有就新建变量，有则在内容后追加</strong></td>
</tr>
<tr>
<td><strong>CLASSPATH</strong></td>
<td style="text-align:center"><strong>;%ANT_HOME%\lib</strong></td>
<td style="text-align:center"><strong>没有就新建变量，有则在内容后追加</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>验证ant是否安装成功</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">H:\zookeeper-vip1&gt;ant  -version</div><div class="line">Apache Ant(TM) version 1.10.7 compiled on September 1 2019</div></pre></td></tr></table></figure>
<h2 id="下载zk源码"><a href="#下载zk源码" class="headerlink" title="下载zk源码"></a><strong>下载zk源码</strong></h2><p> <strong>3.下载Zookeeper源码</strong></p>
<p>   <strong>下载地址： <a href="https://github.com/apache/zookeeper" target="_blank" rel="external">https://github.com/apache/zookeeper</a></strong></p>
<p><strong>本次选用的是Zookeeper 3.4.14版本。</strong></p>
<p><strong><img src="/2020/02/02/zookeeper源码解析/image-20200408115045686.png" alt="image-20200408115045686"></strong></p>
<p><strong>下载zip，然后解压</strong></p>
<h2 id="使用ant将Zookeeper源码编译成Eclipse工程"><a href="#使用ant将Zookeeper源码编译成Eclipse工程" class="headerlink" title="使用ant将Zookeeper源码编译成Eclipse工程"></a><strong>使用ant将Zookeeper源码编译成Eclipse工程</strong></h2><ul>
<li><strong>使用：ant eclipse命令</strong></li>
</ul>
<p><strong>进入解压zk的根目录，使用ant eclipse 命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ ant eclipse</div><div class="line">Buildfile: E:\workspace\git\zookeeper\build.xml</div><div class="line"></div><div class="line">ant-eclipse-download:</div><div class="line">      [get] Getting: http://downloads.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2</div><div class="line">      [get] To: E:\workspace\git\zookeeper\src\java\ant-eclipse-1.0.bin.tar.bz2</div><div class="line">      [get] http://downloads.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2 moved to https://nchc.dl.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2</div><div class="line"></div><div class="line">BUILD FAILED</div><div class="line">E:\workspace\git\zookeeper\build.xml:1730: Redirection detected from http to https. Protocol switch unsafe, not allowed.</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>1.下载ant-eclipse-1.0.bin.tar.bz2失败，将源码build.xml中的</strong><br> <strong>get src=”[<a href="http://downloads.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2" target="_blank" rel="external">http://downloads.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2</a>]” 替换成如下地址</strong><br> <strong>get src=”[<a href="http://ufpr.dl.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2" target="_blank" rel="external">http://ufpr.dl.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2</a>]”</strong><br> <strong>2.再次执行ant eclipse命令，等待时间有点长，等编译结束后即可导入eclipse中</strong></p>
</blockquote>
<p><strong>如果再次执行ant eclipse命令，还是报上面的错误，那么需要把ant-eclipse-1.0.bin.tar.bz2单独下载下来</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">解决方案：</div><div class="line">　　1、在浏览器中打开http://ufpr.dl.sourceforge.net/project/ant-eclipse/ant-eclipse/1.0/ant-eclipse-1.0.bin.tar.bz2，并下载对应的文件</div><div class="line">　　2、将文件copy 到 zookeeper源目录zookeeper-server/src/main/resources中</div><div class="line">　　3、打开build.xml文件，找到需要下载的地方注释掉即可</div></pre></td></tr></table></figure>
<p><strong><img src="/2020/02/02/zookeeper源码解析/image-20200408115408050.png" alt="image-20200408115408050"></strong></p>
<p><strong>再次输入命令ant eclipse，看到如下图所示，表示编译成功：</strong></p>
<p><strong><img src="/2020/02/02/zookeeper源码解析/image-20200408141112408.png" alt="image-20200408141112408"></strong></p>
<h2 id="导入到eclipse中"><a href="#导入到eclipse中" class="headerlink" title="导入到eclipse中"></a>导入到eclipse中</h2><p>可能会提示Version类实现的Info接口不存在：<a href="https://www.dazhuanlan.com/2019/12/24/5e01b9f7e4fe0/" target="_blank" rel="external">https://www.dazhuanlan.com/2019/12/24/5e01b9f7e4fe0/</a></p>
<h2 id="启动server或client"><a href="#启动server或client" class="headerlink" title="启动server或client"></a>启动server或client</h2><p><a href="https://blog.csdn.net/chinaCsdnV2/article/details/81049686" target="_blank" rel="external">https://blog.csdn.net/chinaCsdnV2/article/details/81049686</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>如果你感觉文章对你又些许感悟，你可以支持我！！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/wechatpay.png" alt="Jeremy Kinge WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/uploads/alipay.png" alt="Jeremy Kinge Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
	
	<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/zookeeper/" rel="tag"><i class="fa fa-tag"></i> zookeeper</a>
          
            <a href="/tags/zk源码，顺序一致性/" rel="tag"><i class="fa fa-tag"></i> zk源码，顺序一致性</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/03/RocketMQ-深入理解/" rel="next" title="RocketMQ深入理解-源码分析">
                <i class="fa fa-chevron-left"></i> RocketMQ深入理解-源码分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/05/jmeter使用总结/" rel="prev" title="jmeter压测工具使用总结">
                jmeter压测工具使用总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微薄</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDUxMS83MDY1"></div>
    
  </div>


      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDUxMS83MDY1"></div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Jeremy Kinge" />
          <p class="site-author-name" itemprop="name">Jeremy Kinge</p>
           
              <p class="site-description motion-element" itemprop="description">To know everything, no words don't talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">97</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JeremyKinge" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/LJBANANABLUE?s=09" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://m.weibo.cn/u/3991058874?from=1078095010&wm=20005_0002&sourceType=qq&uid=3991058874" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/profile.php?id=100010100689349" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="StackOverflow">
                  
                    <i class="fa fa-fw fa-stack-overflow"></i>
                  
                    
                      StackOverflow
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://xiezejingzhazha.blog.163.com/" target="_blank" title="网易博客">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                    
                      网易博客
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

		<div id="music163player">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=451768026&auto=0&height=66"></iframe>
</div>
		
        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#zk集群角色"><span class="nav-number">1.</span> <span class="nav-text">zk集群角色</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要observer"><span class="nav-number">1.1.</span> <span class="nav-text">为什么需要observer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么保证一致性"><span class="nav-number">1.2.</span> <span class="nav-text">怎么保证一致性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk的ACL节点权限"><span class="nav-number">2.</span> <span class="nav-text">zk的ACL节点权限</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查看权限"><span class="nav-number">2.1.</span> <span class="nav-text">查看权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#好的文档"><span class="nav-number">2.2.</span> <span class="nav-text">好的文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk客户端创建的三种方式"><span class="nav-number">3.</span> <span class="nav-text">zk客户端创建的三种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原生方式"><span class="nav-number">3.1.</span> <span class="nav-text">原生方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用zkClient"><span class="nav-number">3.2.</span> <span class="nav-text">使用zkClient</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#curator客户端"><span class="nav-number">3.3.</span> <span class="nav-text">curator客户端</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zookeeper中zoo-cfg详解"><span class="nav-number">4.</span> <span class="nav-text">zookeeper中zoo.cfg详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单机模式"><span class="nav-number">5.</span> <span class="nav-text">########单机模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk客户端源码解析"><span class="nav-number">6.</span> <span class="nav-text">zk客户端源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用zkCli-sh起送客户端"><span class="nav-number">6.1.</span> <span class="nav-text">使用zkCli.sh起送客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeperMain源码-初始化zk客户端"><span class="nav-number">6.2.</span> <span class="nav-text">ZooKeeperMain源码 - 初始化zk客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper构建连接源码"><span class="nav-number">6.2.1.</span> <span class="nav-text">zookeeper构建连接源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SendThread初始化NIO进行与server端的通信-负责发送请求给服务端"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">SendThread初始化NIO进行与server端的通信 - 负责发送请求给服务端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eventThread-处理watcher事件"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">eventThread 处理watcher事件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeperMain-run-解析命令行，处理请求"><span class="nav-number">6.3.</span> <span class="nav-text">ZooKeeperMain.run() - 解析命令行，处理请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构建请求到请求队列中"><span class="nav-number">6.3.1.</span> <span class="nav-text">构建请求到请求队列中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SendThread的run方法循环处理客户端请求和服务端响应"><span class="nav-number">6.3.2.</span> <span class="nav-text">SendThread的run方法循环处理客户端请求和服务端响应</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发送客户端请求给服务端"><span class="nav-number">6.3.2.1.</span> <span class="nav-text">发送客户端请求给服务端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理服务端返回的响应数据"><span class="nav-number">6.3.2.2.</span> <span class="nav-text">处理服务端返回的响应数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sendThread-readResponse-读取服务端返回的信息"><span class="nav-number">6.3.2.2.1.</span> <span class="nav-text">sendThread.readResponse() - 读取服务端返回的信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最后处理finishPacket-请求"><span class="nav-number">6.3.2.2.2.</span> <span class="nav-text">最后处理finishPacket()请求</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eventThread处理监听事件"><span class="nav-number">6.3.2.3.</span> <span class="nav-text">eventThread处理监听事件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">6.3.2.3.1.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#！！为什么监听的事件只处理一次-watcher机制源码！！"><span class="nav-number">6.4.</span> <span class="nav-text">！！为什么监听的事件只处理一次 - watcher机制源码！！</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端执行quit退出命令行操作会发生什么"><span class="nav-number">6.5.</span> <span class="nav-text">客户端执行quit退出命令行操作会发生什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zookeeper集群优先选择连接节点改造"><span class="nav-number">6.6.</span> <span class="nav-text">zookeeper集群优先选择连接节点改造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">6.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk客户端连接服务端超时源码解析"><span class="nav-number">7.</span> <span class="nav-text">zk客户端连接服务端超时源码解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk服务端源码解析-单机模式"><span class="nav-number">8.</span> <span class="nav-text">zk服务端源码解析 - 单机模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#QuorumPeerMain类源码"><span class="nav-number">8.1.</span> <span class="nav-text">QuorumPeerMain类源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析zoo-cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略"><span class="nav-number">8.1.1.</span> <span class="nav-text">解析zoo.cfg配置信息到QuorumPeerConfig并识别是否是集群模式，确定半数选举策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断启动的是单机版server还是集群模式"><span class="nav-number">8.1.2.</span> <span class="nav-text">判断启动的是单机版server还是集群模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动单机版server"><span class="nav-number">8.1.3.</span> <span class="nav-text">启动单机版server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据NIOServerCnxnFactory建立socket，监听客户端连接"><span class="nav-number">8.1.3.1.</span> <span class="nav-text">根据NIOServerCnxnFactory建立socket，监听客户端连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动NIOServerCnxnFactory线程，接受客户端的请求"><span class="nav-number">8.1.3.2.</span> <span class="nav-text">启动NIOServerCnxnFactory线程，接受客户端的请求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-doIO-k-处理客户端请求"><span class="nav-number">8.2.</span> <span class="nav-text">c.doIO(k)处理客户端请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用ZooKeeperServer的processPacket处理请求"><span class="nav-number">8.2.1.</span> <span class="nav-text">使用ZooKeeperServer的processPacket处理请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据请求处理链，处理请求"><span class="nav-number">8.2.2.</span> <span class="nav-text">根据请求处理链，处理请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#请求处理器PrepRequestProcessor"><span class="nav-number">8.2.2.1.</span> <span class="nav-text">请求处理器PrepRequestProcessor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理器SyncRequestProcessor持久化（快照）操作"><span class="nav-number">8.2.2.2.</span> <span class="nav-text">处理器SyncRequestProcessor持久化（快照）操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理器FinalRequestProcessor从队列中拿出数据进行内存操作"><span class="nav-number">8.2.2.3.</span> <span class="nav-text">处理器FinalRequestProcessor从队列中拿出数据进行内存操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#watcher监听事件机制"><span class="nav-number">8.2.2.3.1.</span> <span class="nav-text">watcher监听事件机制</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-2"><span class="nav-number">8.3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#好的文档-1"><span class="nav-number">8.4.</span> <span class="nav-text">好的文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单机模式-end"><span class="nav-number">9.</span> <span class="nav-text">########单机模式 end</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集群模式"><span class="nav-number">10.</span> <span class="nav-text">########集群模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集群模式下的服务端启动源码解析（如何保证数据一致性）"><span class="nav-number">11.</span> <span class="nav-text">集群模式下的服务端启动源码解析（如何保证数据一致性）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#知识储备"><span class="nav-number">11.1.</span> <span class="nav-text">知识储备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化集群配置信息"><span class="nav-number">11.2.</span> <span class="nav-text">初始化集群配置信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runFromConfig-config-启动服务器"><span class="nav-number">11.3.</span> <span class="nav-text">runFromConfig(config)启动服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#loadDataBase-重放数据到服务器内存"><span class="nav-number">11.3.1.</span> <span class="nav-text">loadDataBase()重放数据到服务器内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cnxnFactory-start-初始化启动NIOServerCnxnFactory线程"><span class="nav-number">11.3.2.</span> <span class="nav-text">cnxnFactory.start()初始化启动NIOServerCnxnFactory线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#startLeaderElection（）确定选举策略和先投自己一票"><span class="nav-number">11.3.3.</span> <span class="nav-text">startLeaderElection（）确定选举策略和先投自己一票</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-3"><span class="nav-number">11.3.3.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super-start-–-根据选定策略执行leader选举-投票代码"><span class="nav-number">11.3.4.</span> <span class="nav-text">super.start() – 根据选定策略执行leader选举-投票代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1sendNotifications自己的投票提议给其他server-保存需要投票的数据到sendqueue中"><span class="nav-number">11.3.4.1.</span> <span class="nav-text">1.1sendNotifications自己的投票提议给其他server - 保存需要投票的数据到sendqueue中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2处理接受到其他服务端的投票数据-确定最终leader"><span class="nav-number">11.3.4.2.</span> <span class="nav-text">1.2处理接受到其他服务端的投票数据 - 确定最终leader</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果集群中，某台server挂掉，那么怎么重新进行选举？"><span class="nav-number">11.3.5.</span> <span class="nav-text">如果集群中，某台server挂掉，那么怎么重新进行选举？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新加入的服务器怎么进行选举？怎么知道哪台是leader"><span class="nav-number">11.3.6.</span> <span class="nav-text">新加入的服务器怎么进行选举？怎么知道哪台是leader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leader选举总结"><span class="nav-number">11.3.7.</span> <span class="nav-text">leader选举总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么保证数据一致性（已经确定leader）"><span class="nav-number">11.4.</span> <span class="nav-text">怎么保证数据一致性（已经确定leader）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#执行loadDataBase加载本地快照数据到内存"><span class="nav-number">11.4.1.</span> <span class="nav-text">执行loadDataBase加载本地快照数据到内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动quorumPeer线程执行run方法"><span class="nav-number">11.4.2.</span> <span class="nav-text">启动quorumPeer线程执行run方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#leader为每一个learner开启线程接受请求。"><span class="nav-number">11.4.2.1.</span> <span class="nav-text">leader为每一个learner开启线程接受请求。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#learner请求leader"><span class="nav-number">11.4.2.2.</span> <span class="nav-text">learner请求leader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开始同步数据"><span class="nav-number">11.4.2.3.</span> <span class="nav-text">开始同步数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#leader怎么处理"><span class="nav-number">11.4.2.3.1.</span> <span class="nav-text">leader怎么处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#learner怎么处理"><span class="nav-number">11.4.2.3.2.</span> <span class="nav-text">learner怎么处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#leader在哪里处理learner转发client的写请求？"><span class="nav-number">11.4.2.3.3.</span> <span class="nav-text">leader在哪里处理learner转发client的写请求？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集群模式-end"><span class="nav-number">12.</span> <span class="nav-text">########集群模式 end</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk实现分布式锁和分布式配置中心"><span class="nav-number">13.</span> <span class="nav-text">zk实现分布式锁和分布式配置中心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现分布式锁"><span class="nav-number">13.1.</span> <span class="nav-text">实现分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式配置中心"><span class="nav-number">13.2.</span> <span class="nav-text">分布式配置中心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#负载均衡"><span class="nav-number">13.3.</span> <span class="nav-text">负载均衡</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#！！！！！疑问！！！！！！！！！！！"><span class="nav-number">14.</span> <span class="nav-text">！！！！！疑问！！！！！！！！！！！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk的zxid"><span class="nav-number">15.</span> <span class="nav-text">zk的zxid</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk保证了高并发的安全性"><span class="nav-number">16.</span> <span class="nav-text">zk保证了高并发的安全性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk是不是强一致性？是顺序一致性"><span class="nav-number">17.</span> <span class="nav-text">zk是不是强一致性？是顺序一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么叫顺序一致性："><span class="nav-number">17.1.</span> <span class="nav-text">什么叫顺序一致性：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk涉及到的java基础知识"><span class="nav-number">18.</span> <span class="nav-text">zk涉及到的java基础知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zk源码构建"><span class="nav-number">19.</span> <span class="nav-text">zk源码构建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装ANT"><span class="nav-number">19.1.</span> <span class="nav-text">安装ANT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下载zk源码"><span class="nav-number">19.2.</span> <span class="nav-text">下载zk源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用ant将Zookeeper源码编译成Eclipse工程"><span class="nav-number">19.3.</span> <span class="nav-text">使用ant将Zookeeper源码编译成Eclipse工程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导入到eclipse中"><span class="nav-number">19.4.</span> <span class="nav-text">导入到eclipse中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动server或client"><span class="nav-number">19.5.</span> <span class="nav-text">启动server或client</span></a></li></ol></li></ol></div>
            

          </div>
		  

		  
        </section>
      <!--/noindex-->
      

      

    </div>
	

	
  </aside>
  

  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2022 &mdash; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeremy Kinge</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">
      406.9k
    </span>
  
</div>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">
  
</div>



  <span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span class="post-meta-divider">|</span>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共406.9k字</span>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  




  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
