<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[聊聊分布式事务，再说说解决方案-cap]]></title>
    <url>%2F2017%2F10%2F18%2F%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%86%8D%E8%AF%B4%E8%AF%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-cap%2F</url>
    <content type="text"><![CDATA[数据库事务 在说分布式事务之前，我们先从数据库事务说起。 数据库事务可能大家都很熟悉，在开发过程中也会经常使用到。但是即使如此，可能对于一些细节问题，很多人仍然不清楚。比如很多人都知道数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation)和持久性(Durabilily)，简称就是ACID。但是再往下比如问到隔离性指的是什么的时候可能就不知道了，或者是知道隔离性是什么但是再问到数据库实现隔离的都有哪些级别，或者是每个级别他们有什么区别的时候可能就不知道了。 本文并不打算介绍这些数据库事务的这些东西，有兴趣可以搜索一下相关资料。不过有一个知识点我们需要了解，就是假如数据库在提交事务的时候突然断电，那么它是怎么样恢复的呢？ 为什么要提到这个知识点呢？ 因为分布式系统的核心就是处理各种异常情况，这也是分布式系统复杂的地方，因为分布式的网络环境很复杂，这种“断电”故障要比单机多很多，所以我们在做分布式系统的时候，最先考虑的就是这种情况。这些异常可能有 机器宕机、网络异常、消息丢失、消息乱序、数据错误、不可靠的TCP、存储数据丢失、其他异常等等… 我们接着说本地事务数据库断电的这种情况，它是怎么保证数据一致性的呢？我们使用SQL Server来举例，我们知道我们在使用 SQL Server 数据库是由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。 接着，我们就说一下分布式事务。 分布式理论 当我们的单个数据库的性能产生瓶颈的时候，我们可能会对数据库进行分区，这里所说的分区指的是物理分区，分区之后可能不同的库就处于不同的服务器上了，这个时候单个数据库的ACID已经不能适应这种情况了，而在这种ACID的集群环境下，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，最为关键的是再很难扩展新的分区了，这个时候如果再追求集群的ACID会导致我们的系统变得很差，这时我们就需要引入一个新的理论原则来适应这种集群的情况，就是 CAP 原则或者叫CAP定理，那么CAP定理指的是什么呢？ CAP定理 CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性： 一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效) 可用性(Availability) ： 每个操作都必须以可预期的响应结束 分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成 具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。 这个定理在迄今为止的分布式系统中都是适用的！ 为什么这么说呢？ 转载链接描述的很到位：http://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库中的undo和redo日志]]></title>
    <url>%2F2017%2F10%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84undo%E5%92%8Credo%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[转载好的博客解释1： http://blog.csdn.net/kobejayandy/article/details/50885693 转载好的博客解释2： http://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vSphere与Workstation虚拟机交互的几种方法]]></title>
    <url>%2F2017%2F10%2F18%2FvSphere%E4%B8%8EWorkstation%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[参见转载链接： http://wangchunhai.blog.51cto.com/225186/1884052]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看虚拟机里的Centos7的IP]]></title>
    <url>%2F2017%2F10%2F18%2F%E6%9F%A5%E7%9C%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%87%8C%E7%9A%84Centos7%E7%9A%84IP%2F</url>
    <content type="text"><![CDATA[登录虚拟机 输入用户名和密码（用户名一般是root） 查看ip 指令 ip addr 指令： 查看当前虚拟机ip 我们发现ens32 没有 inet 这个属性，没有出现ip，那么说明在设置的时候没有开启，需要先去设置。 当前位置：[root@localhost ~]# pwd/root[root@localhost ~]# 接着来查看ens32网卡的配置： vi /etc/sysconfig/network-scripts/ifcfg-ens32 注意vi后面加空格. etc 文件夹的位置在于 [root@localhost ~]# cd ..[root@localhost /]# lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usr 查看 ifcfg-ens32 的内容 从配置清单中可以发现 CentOS 7 默认是不启动网卡的（ONBOOT=no）。 把这一项改为YES（ONBOOT=yes） – (按 i 进入编辑模式 ，修改完，按 esc退出编辑模式，然后 按 ctrl + shift + : 输入 wq 完成编辑) 然后重启网络服务： sudo service network restart 然后我们再输入 ip addr 命令 使用第三方工具登录 这里是用的是 xshell，你也可以用winscp（这个一般是用来传文件的） 然后点击连接，输入用户名和密码，便可以进入命令界面]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[activity工作流框架——数据库表结构说明]]></title>
    <url>%2F2017%2F10%2F12%2Factivity%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[本文转载于： http://www.jianshu.com/p/f9fd1cc02eae activity一共23张表 表的命名第一部分都是以 ACT_开头的。 表的命名第二部分是一个两个字符用例表的标识 act_ge_*： ‘ge’代表general（一般）。普通数据，各种情况都使用的数据。 act_gebytearray：二进制数据表，用来保存部署文件的大文本数据1.ID:资源文件编号，自增长2.REVINT:版本号3.NAME:资源文件名称4.DEPLOYMENTID:来自于父表act_redeployment的主键5.BYTES:大文本类型，存储文本字节流 act_geproperty：属性数据表，存储这整个流程引擎级别的数据。在初始化表结构时，会默认插入三条记录。1.NAME:属性名称2.VALUE_:属性值3.REV_INT:版本号 act_hi_*： hi’代表 history（历史）。就是这些表包含着历史的相关数据，如结束的流程实例、变量、任务、等等。 act_hiactinst：历史节点表1.ID : 标识2.PROC_DEFID :流程定义id3.PROC_INSTID : 流程实例id4.EXECUTIONID : 执行实例5.ACTID : 节点id6.ACTNAME : 节点名称7.ACTTYPE : 节点类型8.ASSIGNEE_ : 节点任务分配人9.STARTTIME : 开始时间10.ENDTIME : 结束时间11.DURATION : 经过时长 act_hi_attachment：历史附件表 act_hicomment：历史意见表1.ID :标识2.TYPE : 意见记录类型 为comment 时 为处理意见3.TIME : 记录时间4.USERID :5.TASKID ： 对应任务的id6.PROC_INSTID : 对应的流程实例的id7.ACTION ： 为AddComment 时为处理意见8.MESSAGE : 处理意见9.FULLMSG : act_hidetail：历史详情表，启动流程或者在任务complete之后,记录历史流程变量1.ID : 标识2.TYPE_ : variableUpdate 和 formProperty 两种值3.PROC_INSTID : 对应流程实例id4.EXECUTIONID : 对应执行实例id5.TASKID : 对应任务id6.ACT_INSTID : 对应节点id7.NAME : 历史流程变量名称，或者表单属性的名称8.VARTYPE : 定义类型9.REV : 版本10.TIME : 导入时间11.BYTEARRAYID12.DOUBLE : 如果定义的变量或者表单属性的类型为double，他的值存在这里13.LONG : 如果定义的变量或者表单属性的类型为LONG ,他的值存在这里14.TEXT : 如果定义的变量或者表单属性的类型为string，值存在这里15.TEXT2: act_hi_identitylink：历史流程人员表 act_hiprocinst： 历史流程实例表1.ID : 唯一标识2.PROC_INSTID : 流程ＩＤ3.BUSINESSKEY : 业务编号4.PROC_DEFID ： 流程定义id5.STARTTIME : 流程开始时间6.ENT_TIME : 结束时间7.DURATION : 流程经过时间8.START_USERID : 开启流程用户id9.START_ACTID : 开始节点10.END_ACTID： 结束节点11.SUPER_PROCESS_INSTANCEID : 父流程流程id12.DELETEREASON : 从运行中任务表中删除原因 act_hitaskinst： 历史任务实例表1.ID ： 标识2.PROC_DEFID ： 流程定义id3.TASK_DEFKEY : 任务定义id4.PROC_INSTID : 流程实例ｉｄ5.EXECUTIONID : 执行实例id6.PARENT_TASKID : 父任务id7.NAME : 任务名称8.DESCRIPTION : 说明9.OWNER : 拥有人（发起人）10.ASSIGNEE : 分配到任务的人11.START_TIME : 开始任务时间12.ENDTIME : 结束任务时间13.DURATION_ : 时长14.DELETEREASON :从运行时任务表中删除的原因15.PRIORITY_ : 紧急程度16.DUEDATE : act_hi_varinst：历史变量表 act_id_*： id’代表 identity（身份）。这些表包含着标识的信息，如用户、用户组、等等。 act_idgroup:用户组信息表，用来存储用户组信息。1.ID：用户组名2.REVINT:版本号3.NAME:用户组描述信息4.TYPE_:用户组类型 act_id_info：用户扩展信息表 act_id_membership：用户与用户组对应信息表，用来保存用户的分组信息1.USERID:用户名2.GROUPID:用户组名 act_iduser：用户信息表1.ID:用户名2.REVINT:版本号3.FIRST:用户名称4.LAST:用户姓氏5.EMAIL:邮箱6.PWD_:密码 act_re_*： ’re’代表 repository（仓库）。带此前缀的表包含的是静态信息，如，流程定义、流程的资源（图片、规则，等）。 act_redeployment:部署信息表,用来存储部署时需要持久化保存下来的信息1.ID:部署编号，自增长2.NAME_:部署包的名称3.DEPLOYTIME:部署时间 act_re_model 流程设计模型部署表 act_reprocdef:业务流程定义数据表1.ID:流程ID，由“流程编号：流程版本号：自增长ID”组成2.CATEGORY:流程命名空间（该编号就是流程文件targetNamespace的属性值）3.NAME:流程名称（该编号就是流程文件process元素的name属性值）4.KEY:流程编号（该编号就是流程文件process元素的id属性值）5.VERSION:流程版本号（由程序控制，新增即为1，修改后依次加1来完成的）6.DEPLOYMENTID:部署编号7.RESOURCENAME:资源文件名称8.DGRM_RESOURCENAME:图片资源文件名称9.HAS_START_FROMKEY:是否有Start From Key 注：此表和ACT_RE_DEPLOYMENT是多对一的关系，即，一个部署的bar包里可能包含多个流程定义文件，每个流程定义文件都会有一条记录在ACT_REPROCDEF表内，每个流程定义的数据，都会对于ACT_GE_BYTEARRAY表内的一个资源文件和PNG图片文件。和ACT_GE_BYTEARRAY的关联是通过程序用ACT_GE_BYTEARRAY.NAME与ACT_REPROCDEF.NAME完成的，在数据库表结构中没有体现。 act_ru_*： ’ru’代表 runtime（运行时）。就是这个运行时的表存储着流程变量、用户任务、变量、作业，等中的运行时的数据。 activiti 只存储流程实例执行期间的运行时数据，当流程实例结束时，将删除这些记录。这就使这些运行时的表保持 的小且快。 act_ru_event_subscr act_ruexecution：运行时流程执行实例表1.ID：主键，这个主键有可能和PROC_INSTID相同，相同的情况表示这条记录为主实例记录。2.REV_：版本，表示数据库表更新次数。3.PROC_INSTID：流程实例编号，一个流程实例不管有多少条分支实例，这个ID都是一致的。4.BUSINESSKEY：业务编号，业务主键，主流程才会使用业务主键，另外这个业务主键字段在表中有唯一约束。5.PARENTID：找到该执行实例的父级，最终会找到整个流程的执行实例6.PROC_DEFID：流程定义ID7.SUPEREXEC： 引用的执行模板，这个如果存在表示这个实例记录为一个外部子流程记录，对应主流程的主键ID。8.ACTID： 节点id，表示流程运行到哪个节点9.ISACTIVE： 是否活动流程实例10.ISCONCURRENT：是否并发。上图同步节点后为并发，如果是并发多实例也是为1。11.ISSCOPE： 主实例为1，子实例为0。12.TENANTID : 这个字段表示租户ID。可以应对多租户的设计。13.IS_EVENT_SCOPE: 没有使用到事件的情况下，一般都为0。14.SUSPENSIONSTATE：是否暂停。 act_ruidentitylink：运行时流程人员表，主要存储任务节点与参与者的相关信息1.ID： 标识2.REV_： 版本3.GROUPID： 组织id4.TYPE_： 类型5.USERID： 用户id6.TASKID： 任务id act_ru_job act_rutask：运行时任务节点表1.ID：2.REV_：3.EXECUTIONID： 执行实例的id4.PROC_INSTID： 流程实例的id5.PROC_DEFID： 流程定义的id,对应act_reprocdef 的id6.NAME_： 任务名称，对应 task 的name7.PARENT_TASKID : 对应父任务8.DESCRIPTION_：9.TASK_DEFKEY： task 的id10.OWNER : 发起人11.ASSIGNEE： 分配到任务的人12.DELEGATION : 委托人13.PRIORITY： 紧急程度14.CREATETIME： 发起时间15.DUETIME：审批时长 act_ruvariable：运行时流程变量数据表1.ID：标识2.REV：版本号3.TYPE：数据类型4.NAME_：变量名5.EXECUTIONID： 执行实例id6.PROC_INSTID： 流程实例id7.TASKID： 任务id8.BYTEARRAYID：9.DOUBLE：若数据类型为double ,保存数据在此列10.LONG： 若数据类型为Long保存数据到此列11.TEXT： string 保存到此列12.TEXT2： 结论及总结: 流程文件部署主要涉及到3个表，分别是：ACT_GE_BYTEARRAY、ACT_RE_DEPLOYMENT、ACT_RE_PROCDEF。主要完成“部署包”–&gt;“流程定义文件”–&gt;“所有包内文件”的解析部署关系。从表结构中可以看出，流程定义的元素需要每次从数据库加载并解析，因为流程定义的元素没有转化成数据库表来完成，当然流程元素解析后是放在缓存中的，具体的还需要后面详细研究。 流程定义中的java类文件不保存在数据库里 。 组织机构的管理相对较弱，如果要纳入单点登录体系内还需要改造完成，具体改造方法有待研究。 运行时对象的执行与数据库记录之间的关系需要继续研究 历史数据的保存及作用需要继续研究。]]></content>
      <categories>
        <category>activity</category>
      </categories>
      <tags>
        <tag>activity</tag>
        <tag>工作流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于web.xml中ServletContext、ServletContextListener、Filter、Servlet的执行顺序]]></title>
    <url>%2F2017%2F10%2F10%2F%E5%85%B3%E4%BA%8Eweb-xml%E4%B8%ADServletContext%E3%80%81ServletContextListener%E3%80%81Filter%E3%80%81Servlet%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言 今天跑一个web项目，想做一些初始化工作，于是使用Filter来实现，但是发现ServletContextListener，Servlet也是能够实现的。但是肯定会有先后顺序执行的问题，那么接下来探讨这个问题。 作者规则：为了节省部分人的时间，先说结论。结论就是标题的顺序：ServletContext - ServletContextListener- Filter、Servlet web加载 启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml。 加载产生Servlet上下文实例，ServletContext 这个web项目的所有部分都将共享这个上下文。容器将转换为键值对，并交给servletContext。L例如我们在使用spring的时候，会配置applicationContext.xml &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 依次加载Servlet的事件监听器 - ServletContextListener 并依次调用public void contextInitialized(ServletContextEvent sce)方法。加载和调用多个Listener的顺序由在web.xml中配置的依次顺序决定的。 &lt;listener&gt; &lt;listener-class&gt;com.wlx.core.application.ApplicaltionListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;listener&gt; &lt;listener-class&gt;com.wlx.core.application.ApplicaltionListener2&lt;/listener-class&gt;&lt;/listener&gt;先执行 ApplicaltionListener的contextInitialized方法后执行ApplicaltionListener2的contextInitialized方法 我们可以通过这个方法做一些初始化工作：例如初始化数据库连接池，初始化redis，启动定时器服务，启动线程池做一些socket通讯服务等等工作。 然后在contextDestroyed方法关闭这些服务即可。 .依次加载Servlet的过滤器-Filter 并依次调用public void init(FilterConfig filterConfig) throws ServletException;方法加载和调用多个filter的顺序由在web.xml中配置的依次顺序决定的。 &lt;filter&gt; &lt;filter-name&gt;appFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.wlx.core.application.AppFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;appFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 依次加载Servlet Load-on-startup元素在web应用启动的时候指定了servlet被加载的顺序，它的值必须是一个整数。如果它的值是一个负整数或是这个元素不存在，那么容器会在该servlet被调用的时候(例如下面代码访问-/servlet/UploadFile 为后缀的时候才会去初始化init，并不会在项目启动时候访问init)，加载这个servlet。如果值是正整数或零，容器在配置的时候就加载并初始化这个servlet，容器必须保证值小的先被加载。如果值相等，容器可以自动选择先加载谁。 在servlet的配置当中，&lt;load-on-startup&gt;5&lt;/load-on-startup&gt;的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。 项目启动时会去调用 UploadFile的init方法&lt;servlet&gt; &lt;servlet-name&gt;UploadFile&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wlx.core.application.servlet.UploadFile&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;UploadFile&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/UploadFile&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 项目启动时不会去调用 EServlet的init方法，访问匹配规则的网址时才会去调用init，而且只调用一次 &lt;servlet&gt; &lt;servlet-name&gt;EServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wlx.core.application.servlet.EServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;EServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/EServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 总结 以上是Web容器在启动时加载的顺序，启动加载只会加载一次。web.xml 的加载顺序是：ServletContext-&gt; context-param -&gt;listener -&gt; filter -&gt; servlet. 扩展知识-请求执行循序 在上面中我们总结web加载的执行顺序，那么一个请求的执行循序呢？实际上就是一个责任链模式的问题 依次执行过滤器filter的方法public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain)，这个方法应用了责任链模式，当在该方法中使用chain.doFilter(request, response);则这个过滤器就调用下一个过滤器，直到过滤器链条完成调用，进入Servlet处理，这个时候doFilter并未执行完成，仅仅在servlet之前进行一连串的过滤处理。 进入相应Servlet并调用public void service(ServletRequest req, ServletResponse res)方法，或者说是GET和POST方法。public void doGet(HttpServletRequest request, HttpServletResponse respose)进行请求响应的业务处理。 Servlet处理完成后，执行chain.doFilter(request, response);执行其他过滤器链条的后置过滤处理，然后执行自己的后置处理。 以上Filter和Servlet的执行顺序有点像Spring AOP 的前置通知和后置通知与业务方法关系。在Filter的doFilter方法中的chain.doFilter(request, response);之前做的业务逻辑就像前置通知，之后的逻辑像后置通知。业务方法是Sevlet中的public void service(ServletRequest req, ServletResponse res)方法。并且可以由多个有序的过滤链条进行Servlet的过滤。 Filter的过滤请求的Servlet的范围与配置有关,Filter在每次访问Servlet时都会拦截过滤。 代码例子： public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;执行MyFilter init&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;执行MyFilter doFilter&quot;); System.out.println(&quot;执行MyFilter doFilter before&quot;); chain.doFilter(request, response); System.out.println(&quot;执行MyFilter doFilter after&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;执行MyFilter destroy&quot;); &#125;&#125;-------------------------------------------------------------public class MyFilter1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;执行MyFilter1 init&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;执行MyFilter1 doFilter &quot;); System.out.println(&quot;执行MyFilter1 doFilter before&quot;); chain.doFilter(request, response); System.out.println(&quot;执行MyFilter1 doFilter after&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;执行MyFilter1 destroy&quot;); &#125;&#125;------------------------------------------------------------------------public class MyServlet1 extends HttpServlet &#123; private static final long serialVersionUID = 1L; public void init() throws ServletException &#123; System.out.println(&quot;执行Servlet1 init()&quot;); &#125; public void destroy() &#123; System.out.println(&quot;执行Servlet1 destroy()&quot;); &#125; public void doGet(HttpServletRequest request, HttpServletResponse respose) throws ServletException, IOException &#123; System.out.println(&quot;执行Servlet1 service&quot;); &#125;&#125; 省略在web.xml中的配置 输出： 执行MyFilter doFilter执行MyFilter doFilter before执行MyFilter1 doFilter执行MyFilter1 doFilter before执行Servlet service执行MyFilter1 doFilter after执行MyFilter doFilter after]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
        <tag>web.xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软技能-代码之外的生存指南-把自己当做一个企业去思考]]></title>
    <url>%2F2017%2F10%2F09%2F%E8%BD%AF%E6%8A%80%E8%83%BD-%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97-%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%BD%93%E5%81%9A%E4%B8%80%E4%B8%AA%E4%BC%81%E4%B8%9A%E5%8E%BB%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[《软技能》—— 把自己当做一个企业去思考]]></content>
      <categories>
        <category>读书系统</category>
      </categories>
      <tags>
        <tag>软技能</tag>
        <tag>代码之外的生存指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java到底是值传递还是引用传递]]></title>
    <url>%2F2017%2F09%2F26%2Fjava%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[引言 我们先给本文定下基调，java是值传递 有一种说法，引用传递实际上也就是值传递。这个说法很有意思，实际上这种说法也是有道理的，传递引用，这个引用实际上就是一个地址，也即是一个值。 什么是值传递和引用传递 首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用含义。 一：搞清楚 基本类型 和 引用类型的不同之处 int num = 10;String str = &quot;hello&quot;; num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。 二：搞清楚赋值运算符（=）的作用 num = 20;str = &quot;java&quot;; 对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变（重要）。 例子 参数传递基本上就是赋值操作 第一个例子：基本类型void foo(int value) &#123; value = 100;&#125;foo(num); // num 没有被改变第二个例子：没有提供改变自身方法的引用类型void foo(String text) &#123; text = &quot;windows&quot;;&#125;foo(str); // str 也没有被改变第三个例子：提供了改变自身方法的引用类型StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder.append(&quot;4&quot;);&#125;foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder = new StringBuilder(&quot;ipad&quot;);&#125;foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。 重点理解为什么，第三个例子和第四个例子结果不同？ 例子5 public class Employee &#123; public int age;&#125;public class Main &#123; public static void changeEmployee(Employee employee3) &#123; employee3 = new Employee(); // flag 1 employee3.age = 1000; &#125; public static void main(String[] args) &#123; Employee employee = new Employee(); employee.age = 100; changeEmployee(employee); System.out.println(employee.age); &#125;&#125;输出： 100如果把 flag 1 位置代码注释，那么程序结果输出1000---原因同上 总结 = 号的理解是最重要的，他是一个动词，可能会引起左边变量值的改变 java中方法参数传递方式是按值传递。 如果参数是基本类型，传递的是基本类型的字面量值的拷贝。也就是你我没有半毛钱关系 如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。你我可能存在关系 = 是赋值操作（任何包含=的如+=、-=、 /=等等，都内含了赋值操作）。不再是你以前理解的数学含义了，而+ - /和 = 在java中更不是一个级别，换句话说， = 是一个动作，一个可以改变内存状态的操作，一个可以改变变量的符号，而+ - /却不会。这里的赋值操作其实是包含了两个意思：1、放弃了原有的值或引用；2、得到了 = 右侧变量的值或引用。Java中对 = 的理解很重要啊！！可惜好多人忽略了，或者理解了却没深思过。 对于基本数据类型变量，= 操作是完整地复制了变量的值。换句话说，“=之后，你我已无关联”；至于基本数据类型，就不在这科普了。 对于非基本数据类型变量，= 操作是复制了变量的引用。换句话说，“嘿，= 左侧的变量，你丫别给我瞎动！咱俩现在是一根绳上的蚂蚱，除非你再被 = 一次放弃现有的引用！！上面说了 = 是一个动作，所以我把 = 当作动词用啦！！”。而非基本数据类型变量你基本上可以参数本身是变量 参数传递本质就是一种 = 操作。参数是变量，所有我们对变量的操作、变量能有的行为，参数都有。所以把C语言里参数是传值啊、传指针啊的那套理论全忘掉，参数传递就是 = 操作。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java深入理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承之上溯造型和下溯造型]]></title>
    <url>%2F2017%2F09%2F12%2F%E7%BB%A7%E6%89%BF%E4%B9%8B%E4%B8%8A%E6%BA%AF%E9%80%A0%E5%9E%8B%E5%92%8C%E4%B8%8B%E6%BA%AF%E9%80%A0%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言 我们在平时的开发编码中，都会用到上溯造型和下溯造型，只是我们并不知道他的官方叫法而已， 上溯造型跟继承和多态，以及动态绑定的关系很密切 ，关于这几个概念后面会有涉及到他们的概念。 继承和合成 继承：它的本质就是为了使得代码复用（可以基于已经存在的类构造一个新类。继承已经存在的类就可以复用这些类的方法和域。在此基础上，可以添加新的方法和域，从而扩充了类的功能。） 合成：在新类里创建原有的对象称为合成。这种方式可以重复利用现有的代码而不更改它的形式。 -----继承关键字extends表明新类派生于一个已经存在的类。已存在的类称为父类或基类，新类称为子类或派生类。例如:class Dog extends Animal &#123;&#125;类Dog继承了Animal，Animal类称为父类或基类，Dog类称为子类或派生类。---合成合成比较简单，就是在一个类中创建一个已经存在的类。class Dog &#123; Animal animal;&#125; 上溯造型 这个术语缘于继承关系图的传统画法：将基类至于顶部，而向下发展的就是派生类(子类)，发送给父类的消息亦可发给衍生类，父类包含子类。假设把子类赋值给父类，这个过程就称之为上溯造型— 这个时候只能够调用父类父类的方法，子类特有的方法不能够调用，子类变窄 //父类abstract class Animal &#123; public abstract void speak(); public void eat()&#123; &#125; &#125;//子类特有方法interface DoorGod &#123; void guard(); &#125; //Dog 子类和 Cat 子类class Cat extends Animal &#123; @Override public void eat() &#123; try &#123; Thread.sleep( 1000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // super .eat(); System.out.println(&quot;cat eat&quot;); &#125; @Override public void speak() &#123; System.out.println( &quot; 喵喵 &quot; ); &#125; &#125; class Dog extends Animal implements DoorGod&#123; @Override public void speak() &#123; System.out.println( &quot; 汪汪 &quot; ); &#125; public void guard() &#123; while ( true )&#123; System.out.println( &quot; 汪汪 &quot; ); &#125; &#125; &#125; //测试方法public class TestShangSu&#123; public static void upcasting(Animal animal)&#123; animal.speak(); animal.eat(); &#125; @Test public void test1()&#123; Animal dog1 = new Dog(); upcasting(dog1); Animal cat = new Cat(); upcasting(cat); &#125; &#125;//输出 汪汪 喵喵 cat eat 这个时候为什么输出是：子类覆盖父类的方法，而不是父类的方法，这个涉及到动态绑定。后面再讲 由于upcasting(Animal animal)方法的参数是 Animal类型的，因此如果传入的参数是 Animal的子类，传入的参数就会被转换成父类Animal类型，这样你创建的Dog对象能使用的方法只是Animal中的签名方法；也就是说，在上溯的过程中，Dog的接口变窄了，它本身的一些方法（例如实现了 DoorGod的guard方法）就不可见了。如果你想使用Dog中存在而Animal中不存在的方法（比如guard方法），编译时不能通过的。由此可见，上溯造型是安全的类型转换。 如果Dog在上溯造型过程中想使用 DoorGod的guard方法，那么需要配合下溯造型和安全检查，来进行强制转换，讲Animal 下溯为 Dog类型。 注意的是：下溯是不安全的，由父类转化为子类，所以需要加上判断。 下溯造型 将基类转化为衍生类，不安全的操作，可能会引发ClassCastException。 上面的例子只需要加上这一层判断即可 public static void upcasting(Animal animal)&#123; if( animal instanceof Dog )&#123;//下溯造型判断 Dog dog = (Dog) animal; dog.guard(); &#125; animal.speak(); animal.eat(); &#125; 我们在使用注解实现请求方法的登录控制 登录拦截器里面有段关键代码使用的就是下溯造型 为什么使用上溯和下溯造型 上面的例子我们发现，关键的代码是upcasting方法，为什么在调用upcasting方法时要有意忽略调用它的对象类型呢？如果让upcasting方法简单地获取Dog句柄似乎更加直观易懂，但是那样会使衍生自Animal类的每一个新类都要实现专属自己的upcasting方法：例如Cat会实现一个重复的upcasting(Cat cat )这样的方法。 实现多态的好处和代码复利用。 动态绑定 在上面的upcasting方法，测试例子输出的是子类的方法，而非是父类的方法，但是我们使用的是父类去调用这些方法，为什么输出不是父类的呢？ upcasting它接收的是Animal句柄，当执行speak和eat方法时时，它是如何知道Animal句柄指向的是一个Dog对象而不是Cat对象呢？编译器是无从得知的，这涉及到接下来要说明的绑定问题。 Java实现了一种方法调用机制，可在运行期间判断对象的类型，然后调用相应的方法，这种在运行期间进行，以对象的类型为基础的绑定称为动态绑定。除非一个方法被声明为final，Java中的所有方法都是动态绑定的。 静态方法的绑定 他跟普通的方法不同，子类和父类方法都是静态的，子类如果去掉父类编译会错误 package Test;class Person &#123; static void eat() &#123; System.out.println(&quot;Person.eat()&quot;); &#125; static void speak() &#123; System.out.println(&quot;Person.speak()&quot;); &#125;&#125;class Boy extends Person &#123; static void eat() &#123; System.out.println(&quot;Boy.eat()&quot;); &#125; static void speak() &#123; System.out.println(&quot;Boy.speak()&quot;); &#125;&#125;class Girl extends Person &#123; static void eat() &#123; System.out.println(&quot;Girl.eat()&quot;); &#125; static void speak() &#123; System.out.println(&quot;Girl.speak()&quot;); &#125;&#125;public class Persons &#123; public static Person randPerson() &#123; switch ((int)(Math.random() * 2)) &#123; default: case 0: return new Boy(); case 1: return new Girl(); &#125; &#125; public static void main(String[] args) &#123; Person[] p = new Person[4]; for (int i = 0; i &lt; p.length; i++) &#123; p[i] = randPerson(); // 随机生成Boy或Girl &#125; for (int i = 0; i &lt; p.length; i++) &#123; p[i].eat(); &#125; &#125;&#125;//输出Person.eat()Person.eat()Person.eat()Person.eat() 对于静态方法而言，不管父类引用指向的什么子类对象，调用的都是父类的方法。 总结 上溯造型和动态绑定实际上就是多态的体现，下溯造型是为了解决因为上溯而导致衍生类功能变小的问题，继承则是上溯和下溯以及动态编译的基础。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解实现请求方法的登录控制]]></title>
    <url>%2F2017%2F09%2F06%2F%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%9A%84%E7%99%BB%E5%BD%95%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 之前一直使用的是，拦截器来统一验证当前用户是否登录，通过验证cookie或者session里面的是否存在已经登录标识来完成登录逻辑判断。但是会发现，这个很麻烦，而且有很多配置需要配置，例如免验证URL等等配置，无法实现可拔插式方法级别的控制。 public class RequestInterceptor extends HandlerInterceptorAdapter &#123; public String[] allowUrls;//配置不拦截的资源，所以在代码里面来排除. public void setAllowUrls(String[] allowUrls) &#123; this.allowUrls = allowUrls; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // TODO Auto-generated method stub &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO Auto-generated method stub request.setCharacterEncoding(&quot;UTF8&quot;); HttpSession session=request.getSession();//获取登录的SESSION String sessionid=request.getSession().getId();//获取登录的SESSIONID String requestPath=request.getServletPath();//获取客户请求页面 //先过滤掉不需要判断SESSION的请求 for(String url : allowUrls) &#123; if(requestPath.contains(url)) &#123; return true; &#125; &#125; Object attribute = request.getSession().getAttribute(&quot;sys_user&quot;); if( attribute == null )&#123; response.sendRedirect(&quot;/index.jsp&quot;); &#125; return true; &#125; 大体上是这样的，通过allowUrls来控制免登录url（上面的代码其实可以使用配置文件的方式来配置allowUrls的值，可以不通过setAllowUrls的方式来赋值，但是为了方面扩展就加入了。） 这里会面临一个问题，那就是如果网站网页多的话，那么allowUrls的值会变得很庞大，可能会缺漏。所以下面讲解本人用到的解决方式—-注解 和 spring配置方式（跟数组形式没有什么区别） spring 配置方式path 对所有的请求拦截使用/**，对某个模块下的请求拦截使用：/myPath/*&lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot; /&gt; &lt;bean class=&quot;com.kingge.oa.user.LoginInterceptor&quot; /&gt;&lt;/mvc:interceptor&gt; 或者 &lt;!-- 拦截是否登录 &lt;mvc:interceptor&gt; 需拦截的地址 二级目录 &lt;mvc:mapping path=&quot;/*/*&quot;/&gt; &lt;bean class=&quot;com.jk.ssm.interceptor.RequestInterceptor&quot; &gt; &lt;property name=&quot;allowUrls&quot;&gt; //回去调用拦截器的 setAllowUrls 方法 &lt;list&gt; 如果请求中包含以下路径，则不进行拦截 &lt;value&gt;/account/login.html&lt;/value&gt; &lt;value&gt;/captcha/image.html&lt;/value&gt; &lt;value&gt;/register/register.html&lt;/value&gt; &lt;value&gt;/error/400.html&lt;/value&gt; &lt;value&gt;/error/404.html&lt;/value&gt; &lt;value&gt;/error/500.html&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/mvc:interceptor&gt; 使用注解关于注解 官方说辞：JDK5开始，java增加了对元数据(MetaData)的支持，怎么支持？答：通过Annotation(注解）来实现。Annotation提供了为程序元素设置元数据的方法。元数据：描述数据的数据。 个人理解：首先什么是元数据，元数据就是对一类事物的统称，他不仅限于某个事物的描述。例如我们有ABC三个系统，分别使用oracle，mysql，db2，都有登录功能，他们的用户表字段名称是不一样的。那么有个需求，我想把A系统的用户数据pour到B系统中，那么进行映射操作？这个时候就需要一个描述用户数据的一个统一标识（元数据）这样我们就可以先把，A系统数据映射到元数据，然后再从元数据取数据映射到B系统中。 粗俗的理解，元数据就是一个类的属性，但是他所具备的职能的而应用范围，跟真正意义上类的属性数不一样的。传统的类的属性他只描述这个类，元数据可以描述多个具有共性的类。 再举个例子，我们现在常用的数据中心（DC）就是使用了元数据来作为数据传输的媒介。 元数据作用：：Annotation就像代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。读取到了程序元素的元数据，就可以执行相应的处理。通过注解，程序开发人员可以在不改变原有逻辑的情况下，在源代码文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过解析这些注解获取到这些补充信息，从而进行验证或者进行部署等。 到java8为止一共提供了五个 注解 unchecked异常：运行时异常。是RuntimeException的子类，不需要在代码中显式地捕获unchecked异常做处理。Java异常 @SafeVarargs (java7新增）：java7的“堆污染”警告与@SafeVarargs堆污染：把一个不带泛型的对象赋给一个带泛型的变量是，就会发生堆污染。例如：下面代码引起堆污染，会给出警告List l2 = new ArrayList&lt;Number&gt;();List&lt;String&gt; ls = l2;3中方式去掉这个警告 3种方式去掉这个警告：使用注解@SafeVarargs修饰引发该警告的方法或构造器。使用@SuppressWarnings(“unchecked”) 修饰。使用编译器参数命令：-Xlint:varargs @Functionlnterface （java8新增）：修饰函数式接口使用该注解修饰的接口必须是函数式接口，不然编译会出错。那么什么是函数式接口？答：如果接口中只有一个抽象方法（可以包含多个默认方法或static方法），就是函数式接口。 五个基本元注解 元注解：描述注解的注解（概念跟元数据类似）。 java提供了6个元注解（Meta Annotation)，在java.lang.annotation中。其中5个用于修饰其他的Annonation定义。而@Repeatable专门用于定义Java8新增的重复注解。所以要定义注解必须使用到5个元注解来定义( 五个注解用法 详情百度 ) @Inherited @Documented @Retention（英文：保留） @Target ( 目标) 自定义注解 参见下面，例子或者白度，具体就不阐述了。 使用注解解决登录问题定义一个枚举类 作用： 是否进行验证权限（因为后期可能会增加权限判断注解，而且是否登录也可以说是权限判断的一种，所以这里的枚举类的作用就是保存是否进行权限判断信息） public enum Action&#123; Normal(&quot;0&quot;,&quot;执行权限验证&quot;), Skip(&quot;1&quot;, &quot;跳过权限验证&quot;); private final String key; private final String desc; private Action(String key, String desc) &#123; this.key = key; this.desc = desc; &#125; //省略get set方法 定义登录和权限注解 Login属性是action ，属性类型是Action（上面的枚举类） @Target(ElementType.METHOD)@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Login&#123; Action action() default Action.Normal;&#125; @Target(&#123;java.lang.annotation.ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Permission&#123; String value() default &quot;&quot;; // 这里我是保存一个权限代码，例如赋值为4000，表示当前用户的必须具备4000的权限才能够访问方法 Action action() default Action.Normal;&#125; 拦截器public class LoginInterceptor extends HandlerInterceptorAdapter&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception&#123; if(handler instanceof HandlerMethod)&#123; //是否为请求方法 HandlerMethod handlerMethod = (HandlerMethod) handler; Login login = handlerMethod.getMethodAnnotation(Login.class);//当前请求方法是否添加了Login注解 if( login != null &amp;&amp; &quot;0&quot;.equals(login.action().getKey()) )&#123;//判断属性的值是否是0-表示需要进行登录验证 Object attribute = request.getSession().getAttribute(&quot;sys_user&quot;); if( attribute == null )&#123; response.sendRedirect(&quot;/index.jsp&quot;); &#125; &#125; return true; &#125; return true; &#125;&#125; 在spring中配置拦截器&lt;mvc:interceptors&gt;&lt;bean class=&quot;com.kingge.oa.user.LoginInterceptor&quot;&gt;&lt;/bean&gt;&lt;/mvc:interceptors&gt; 给请求方法添加权限控制 @Login(action=Action.Skip) //不需要进行登录校验 @Permission(value=&quot;4000&quot;,action=Action.normal)//需要进行权限号为4000的权限校验 @RequestMapping(&quot;/list&quot;) public String list(Model model,HttpServletRequest request) &#123; request.getSession().setAttribute(&quot;sys_user&quot;, &quot;denglule&quot;); List&lt;User&gt; userList = userService.findAllObjects(); System.out.println( userList ); model.addAttribute(&quot;userList&quot;,userList ); return &quot;list&quot;; &#125; @Login(action=Action.Normal)//添加操作，需要校验是否登录 @RequestMapping(value=&quot;/add&quot;, method=RequestMethod.POST) public String add( User user ) &#123; System.out.println( user ); userService.insert(user); return &quot;forward:/user/list&quot;; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java注解</tag>
        <tag>登录控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8新特性]]></title>
    <url>%2F2017%2F08%2F29%2Fjava8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Java 8可谓是自Java 5以来最具革命性的版本了，她在语言、编译器、类库、开发工具以及Java虚拟机等方面都带来了不少新特性。我们来一一回顾一下这些特性。 一、Lambda表达式 Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。Lambda 是一个匿名函数。 一个Lambda表达式可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。例如： 例子1 需求： 比较TreeSet中数据，按小到大输出 使用匿名内部类实现一个排序功能 //采用匿名内部类的方式-实现比较器 Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1, o2);//关键代码 &#125; &#125;;//传入比较器 TreeSet&lt;Integer&gt; tree2 = new TreeSet&lt;&gt;(comparator ); tree2.add(12); tree2.add(-12); tree2.add(100);System.out.println(tree2) //输出 -12 12 100 我们不难发现上面的代码存在一个问题：其实关键代码只有第七行，其他代码都是冗余的 使用Lambda表达式实现同样功能 //使用Lambda表达式，抽取关键代码，减少代码量Comparator&lt;Integer&gt; comparator2 = (x, y) -&gt; Integer.compare(x, y); //关键代码 TreeSet&lt;Integer&gt; tree = new TreeSet&lt;&gt;(comparator2 ); tree.add(12); tree.add(-12); tree.add(100); tree.forEach(System.out::println);//代替System.out.println 代码瞬间就变得很简短，你可能觉得这个有什么，没什么感觉。那么我们在进入第二个例子 例子2 需求：1.获取公司中年龄小于 35 的员工信息2.获取公司中工资大于 5000 的员工信息。。。。。。 前期准备实现一个Employee类,有四个属性 private int id;private String name;private int age;private double salary;忽略get/set方法和构造器 初始化一个List： List&lt;Employee&gt; emps = Arrays.asList( new Employee(101, &quot;张三&quot;, 18, 9999.99), new Employee(102, &quot;李四&quot;, 59, 6666.66), new Employee(103, &quot;王五&quot;, 28, 3333.33), new Employee(104, &quot;赵六&quot;, 8, 7777.77), new Employee(105, &quot;田七&quot;, 38, 5555.55)); 常规方法实现实现两个方法，然后传入需要过滤的源数据，返回过滤后的结果集 //需求：获取公司中年龄小于 35 的员工信息public List&lt;Employee&gt; filterEmployeeAge(List&lt;Employee&gt; emps)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee emp : emps) &#123; if(emp.getAge() &lt;= 35)&#123;//比较代码 list.add(emp); &#125; &#125; return list;&#125;//需求：获取公司中工资大于 5000 的员工信息public List&lt;Employee&gt; filterEmployeeSalary(List&lt;Employee&gt; emps)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee emp : emps) &#123; if(emp.getSalary() &gt;= 5000)&#123;//比较代码 list.add(emp); &#125; &#125; return list;&#125; 我们不难发现上面的代码存在一个问题：那就是两个方法除了比较部分不同，其他逻辑是一样的，存在大量冗余，假设有新的需求（例如求得求得名字姓王的员工）那么就需要再创建一个 filterEmployee**方法对应新的需求。 使用策略设计模式实现 提供父借口 和 两个 实现类（两个需求对应的逻辑实现类） // 父接口 @FunctionalInterfacepublic interface MyPredicate&lt;T&gt; &#123; public boolean test(T t); &#125;//需求1 实现类-年龄小于35public class FilterEmployeeForAge implements MyPredicate&lt;Employee&gt;&#123; @Override public boolean test(Employee t) &#123; return t.getAge() &lt;= 35; &#125;&#125;//需求1 实现类-工资大于5000public class FilterEmployeeForSalary implements MyPredicate&lt;Employee&gt; &#123; @Override public boolean test(Employee t) &#123; return t.getSalary() &gt;= 5000; &#125;&#125; 测试代码 // 通用过滤方法 public List&lt;Employee&gt; filterEmployee(List&lt;Employee&gt; emps, MyPredicate&lt;Employee&gt; mp)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee employee : emps) &#123; if(mp.test(employee))&#123; list.add(employee); &#125; &#125; return list; &#125; @Test public void test4()&#123; //传入实现年龄过滤的实现类 List&lt;Employee&gt; list = filterEmployee(emps, new FilterEmployeeForAge()); for (Employee employee : list) &#123; System.out.println(employee); &#125; System.out.println(&quot;------------------------------------------&quot;); List&lt;Employee&gt; list2 = filterEmployee(emps, new FilterEmployeeForSalary()); for (Employee employee : list2) &#123; System.out.println(employee); &#125; &#125; 使用策略模式比上一个的好处是：代码很清晰，便于维护，新的需求我们只需要再实现对应的需求实现类即可，然后传入MyPredicate```接口即可。缺点是：需要实现对应的需求类然后实现``` MyPredicate&lt;T&gt;```接口### **匿名内部类**这种方法类似于例子1中的 Comparator这个接口的实现```JAVA//直接使用 MyPredicate&lt;Employee&gt;接口，不去实现对应的需求类（上面的FilterEmployeeForSalary 和 FilterEmployeeForAge ） @Test public void test5()&#123; List&lt;Employee&gt; list = filterEmployee(emps, new MyPredicate&lt;Employee&gt;() &#123; @Override public boolean test(Employee t) &#123; return t.getId() &lt;= 103; &#125; &#125;); for (Employee employee : list) &#123; System.out.println(employee); &#125; &#125; 我们不难发现上面的代码存在一个问题：跟例子1一样，存在大量的冗余。 Lambda 表达式实现前期准备public List&lt;Employee&gt; filterEmployee(List&lt;Employee&gt; emps, MyPredicate&lt;Employee&gt; mp)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee employee : emps) &#123; if(mp.test(employee))&#123; list.add(employee); &#125; &#125; return list;&#125; @Testpublic void test6()&#123; List&lt;Employee&gt; list = filterEmployee(emps, (e) -&gt; e.getAge() &lt;= 35); list.forEach(System.out::println); System.out.println("------------------------------------------"); List&lt;Employee&gt; list2 = filterEmployee(emps, (e) -&gt; e.getSalary() &gt;= 5000); list2.forEach(System.out::println);&#125; 我们不难发现上面的代码存在一个问题：这个代码，是不是已经非常简短了，感觉已经是终极的最简代码。但是实际上还有更简短的代码（使用stream api）缺点：太过依赖 MyPredicate 这个接口，假设这个接口不存在，该怎么办呢？（我们这里仅仅是做个假设） 终极实现方式：Stream API@Testpublic void test7()&#123; emps.stream() .filter((e) -&gt; e.getAge() &lt;= 35) .forEach(System.out::println); System.out.println(&quot;----------------------------------------------&quot;); emps.stream() .filter((e) -&gt; e.getSalary() &gt;= 5000) .forEach(System.out::println); System.out.println(&quot;----------------------------------------------&quot;); // 可以使用map 指定输出那个属性的值，代替普通的便利输出 emps.stream() .map(Employee::getName) .limit(3)// 输出前三个 .sorted()//排序 .forEach(System.out::println); &#125; 输出 Employee [id=101, name=张三, age=18, salary=9999.99]Employee [id=103, name=王五, age=28, salary=3333.33]Employee [id=104, name=赵六, age=8, salary=7777.77]----------------------------------------------Employee [id=101, name=张三, age=18, salary=9999.99]Employee [id=102, name=李四, age=59, salary=6666.66]Employee [id=104, name=赵六, age=8, salary=7777.77]Employee [id=105, name=田七, age=38, salary=5555.55]----------------------------------------------张三李四王五 我们不难发现上面的代码存在一个问题：这个代码，是非常潇洒，舒服的，不依赖我们上面所说的接口。 函数式接口 为了使现有函数更好的支持Lambda表达式，Java 8引入了函数式接口的概念。函数式接口就是只有一个方法的普通接口。java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的例子。为此，Java 8增加了一种特殊的注解@FunctionalInterface： –也就是说：这个接口里面只能够存在一个接口方法，多个就会报错 例子：@FunctionalInterfacepublic interface Functional &#123; void method();&#125; 认识Lambda表达式概念 一、Lambda 表达式的基础语法：Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符 箭头操作符将 Lambda 表达式拆分成两部分： 左侧：Lambda 表达式的参数列表 右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体 上面的例子：List list = filterEmployee(emps, (e) -&gt; e.getAge() &lt;= 35); 第二个参数他会去找 MyPredicate&lt;T&gt; 接口里面的 public boolean test(T t);test方法，lambda表达式左边的(e) 对应的是test方法的入参, ambda表达式右边的e.getAge() &lt;= 35 对应得是test方法的实现 那么你可能会有疑问，假设MyPredicate接口里面有很多个接口方法，那么他会去调用那个呢？他怎么知道去找test方法呢？ 引入了：@FunctionalInterface这个函数式接口的概念，解决了这个问题。 * 语法格式一：无参数，无返回值 * () -&gt; System.out.println(&quot;Hello Lambda!&quot;); &gt; 例如 Runnable接口的 run方法就是无参数无返回值： @Test public void test1()&#123; int num = 0;//jdk 1.7 前，我们知道匿名内部引用局部变量必须声明为final //但jdk1.8，它默认给我们添加了final，不用显示声明。 Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Hello World!&quot; + num); //这里如果改为 num++是会报错的，因为他本质上是一个final &#125; &#125;; r.run(); System.out.println(&quot;-------------------------------&quot;); Runnable r1 = () -&gt; System.out.println(&quot;Hello Lambda!&quot;); r1.run(); &#125;这两个是等效的 * * 语法格式二：有一个参数，并且无返回值* (x) -&gt; System.out.println(x)* 例子：Consumer这个类jdk自带--有参数无返回值@Testpublic void test2()&#123; Consumer&lt;String&gt; con = x -&gt; System.out.println(x); con.accept(&quot;我是你泽精哥！&quot;);&#125; * 语法格式三：若只有一个参数，小括号可以省略不写* x -&gt; System.out.println(x)* * 语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句* Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;* System.out.println(&quot;函数式接口&quot;);* return Integer.compare(x, y);* &#125;; * 语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写* Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);* * 语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”* (Integer x, Integer y) -&gt; Integer.compare(x, y); 类型推断 : jdk1.8后，添加了这个功能String[] strs = {“aaa”, “bbb”, “ccc”} ; 它自动会转换里面的数据为String类型的数据改为： String[] strs;strs = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;//会报错--因为这样无法进行类型推断 类型推断例子2 public void show(Map&lt;String, Integer&gt; map)&#123;&#125;//方法 show(new HashMap&lt;&gt;());//调用方法我们发现在调用方法的时候入参我们并没有明确声明类型，但是在jdk1.8中是可以编译通过的。这里也是运用了类型推断（注意：jdk1.7中编译会失败） 热身例子一 //函数是接口@FunctionalInterfacepublic interface MyFun &#123; public Integer getValue(Integer num);&#125;//测试 //需求：对一个数进行运算 @Test public void test6()&#123; Integer num = operation(100, (x) -&gt; x * x); System.out.println(num); System.out.println(operation(200, (y) -&gt; y + 200)); &#125; public Integer operation(Integer num, MyFun mf)&#123; return mf.getValue(num); &#125; 热身例子二//函数接口 @FunctionalInterface //约束当前接口只能有一个方法public interface CalcLong&lt;K,T&gt;&#123; // public K getMultiply(T t, T tt); K getMultiply(T t, T tt);&#125;//需求：求得两个数的和 String result = getMuyl(10L,10L,(e,ee)-&gt;&#123; System.out.println(e+ &quot; &quot; + ee); return e+ee+&quot;&quot;; &#125;); System.out.println(result); public String getMuyl(Long l,Long ll,CalcLong&lt;String,Long&gt; mf)&#123; return mf.getMultiply(l, ll); &#125; 看到这里可能会有疑惑？我靠，使用lambda表达式还得声明一个函数接口，这么麻烦。实际上，java内部已经帮我们实现了很多个接口供我们使用，不需要重新自己定义，除非有特别操作。 java8内置四大函数式接口 为了解决接口需要自定义问题 /* * Java8 内置的四大核心函数式接口 * * Consumer&lt;T&gt; : 消费型接口 * void accept(T t); * * Supplier&lt;T&gt; : 供给型接口 * T get(); * * Function&lt;T, R&gt; : 函数型接口 * R apply(T t); * * Predicate&lt;T&gt; : 断言型接口 * boolean test(T t); * */ 例子消费型接口//Consumer&lt;T&gt; 消费型接口 :@Testpublic void test1()&#123; String p; happy(10000, (m) -&gt; System.out.println(&quot;桑拿，每次消费：&quot; + m + &quot;元&quot;));&#125; public void happy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money);&#125; Supplier 供给型接口 //Supplier&lt;T&gt; 供给型接口 :@Testpublic void test2()&#123; List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100)); for (Integer num : numList) &#123; System.out.println(num); &#125;&#125;//需求：产生指定个数的整数，并放入集合中public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer n = sup.get(); list.add(n); &#125; return list;&#125; Function 函数型接口 //Function&lt;T, R&gt; 函数型接口：@Testpublic void test3()&#123; String newStr = strHandler(&quot;\t\t\t 去除前后空格 &quot;, (str) -&gt; str.trim()); System.out.println(newStr); String subStr = strHandler(&quot;截取字符串你知不知道&quot;, (str) -&gt; str.substring(2, 5)); System.out.println(subStr);&#125;//需求：用于处理字符串public String strHandler(String str, Function&lt;String, String&gt; fun)&#123; return fun.apply(str);&#125; Predicate 断言型接口 //Predicate&lt;T&gt; 断言型接口：@Testpublic void test4()&#123; List&lt;String&gt; list = Arrays.asList(&quot;Hello&quot;, &quot;atguigu&quot;, &quot;Lambda&quot;, &quot;www&quot;, &quot;ok&quot;); List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; 3); for (String str : strList) &#123; System.out.println(str); &#125;&#125;//需求：将满足条件的字符串，放入集合中public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str : list) &#123; if(pre.test(str))&#123; strList.add(str); &#125; &#125; return strList;&#125; 四大内置函数衍生的子函数 二、接口的默认方法与静态方法 我们可以在接口中定义默认方法，使用default关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。例如：public interface DefaultFunctionInterface &#123; default String defaultFunction() &#123; return &quot;default function&quot;; &#125;&#125; 我们还可以在接口中定义静态方法，使用static关键字，也可以提供实现。例如：public interface StaticFunctionInterface &#123; static String staticFunction() &#123; return &quot;static function&quot;; &#125;&#125; 接口的默认方法和静态方法的引入，其实可以认为引入了C＋＋中抽象类的理念，以后我们再也不用在每个实现类中都写重复的代码了。 三、方法引用 通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。一般有四种不同的方法引用： 构造器引用 构造器引用。语法是Class::new，构造器的参数列表，需要与函数式接口中参数列表保持一致！也就是说，决定Class::new调用那一个构造器得是：接口函数的方法的参数 //构造器引用@Testpublic void test7()&#123; // Supplier 的接口方法 T get(); --所以调用无参构造器 Supplier&lt;Employee&gt; fun0 = Employee::new; //Function 的接口方法 R apply(T t);-调用一个参数构造器 Function&lt;String, Employee&gt; fun = Employee::new; //BiFunction 的接口方法 R apply(T t, U u); -调用二参构造器 BiFunction&lt;String, Integer, Employee&gt; fun2 = Employee::new;&#125; 对象静态方法引用（类名::静态方法） 静态方法引用。语法是Class::static_method，要求接受一个Class类型的参数； //类名 :: 静态方法名//max和compare 都是静态方法@Testpublic void test4()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y); System.out.println(&quot;-------------------------------------&quot;); Comparator&lt;Integer&gt; com2 = Integer::compare; BiFunction&lt;Double, Double, Double&gt; fun = (x, y) -&gt; Math.max(x, y); System.out.println(fun.apply(1.5, 22.2)); System.out.println(&quot;------------------------------------&quot;); BiFunction&lt;Double, Double, Double&gt; fun2 = Math::max; System.out.println(fun2.apply(1.2, 1.5));&#125; 对象实例方法引用（对象引用::实例方法名） 特定类的任意对象方法引用。它的语法是Class::method。要求方法是没有参数的； //对象的引用 :: 实例方法名@Testpublic void test2()&#123; Employee emp = new Employee(101, &quot;张三&quot;, 18, 9999.99); Supplier&lt;String&gt; sup = () -&gt; emp.getName(); System.out.println(sup.get()); System.out.println(&quot;----------------------------------&quot;); Supplier&lt;String&gt; sup2 = emp::getName; System.out.println(sup2.get());&#125; 类名实例方法引用(类名::实例方法名) 我们知道一般是有对象才能够引用实例方法，但是有种特殊情况是可以直接使用类名引用实例方法若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName //类名 :: 实例方法名//按照常规是String st = new String(&quot;123&quot;); st::equals,//对象调用实例方法，但是下面因为符合第四种引用的规则，//所以可以使用类名调用实例方法@Testpublic void test5()&#123;//第一个参数为实例方法调用者，第二个参数为为实例方法参数 BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y); System.out.println(bp.test(&quot;abcde&quot;, &quot;abcde&quot;)); System.out.println(&quot;-------------------------------------&quot;); BiPredicate&lt;String, String&gt; bp2 = String::equals;System.out.println(bp2.test(&quot;abc&quot;, &quot;abc&quot;)); System.out.println(&quot;---------------------------------------&quot;); //第一个参数为实例方法调用者，第二个参数为空Function&lt;Employee, String&gt; fun = (e) -&gt; e.show();System.out.println(fun.apply(new Employee()));System.out.println(&quot;--------------------------------------&quot;); Function&lt;Employee, String&gt; fun2 = Employee::show; System.out.println(fun2.apply(new Employee())); &#125; 注意： ①方法体所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！ ②若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式：ClassName::MethodName (针对于第四种方法引用) 数组引用（类型[] :: new）//数组引用@Testpublic void test8()&#123; Function&lt;Integer, String[]&gt; fun = (args) -&gt; new String[args]; String[] strs = fun.apply(10); System.out.println(strs.length); System.out.println(&quot;--------------------------&quot;); Function&lt;Integer, Employee[]&gt; fun2 = Employee[] :: new; Employee[] emps = fun2.apply(20); System.out.println(emps.length);&#125; 四、重复注解在Java 5中使用注解有一个限制，即相同的注解在同一位置只能声明一次。Java 8引入重复注解，这样相同的注解在同一地方也可以声明多次。重复注解机制本身需要用@Repeatable注解。Java 8在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。 五、扩展注解的支持Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。 六、OptionalJava 8引入Optional类来防止空指针异常，Optional类最先是由Google的Guava项目引入的。Optional类实际上是个容器：它可以保存类型T的值，或者保存null。使用Optional类我们就不用显式进行空指针检查了。 七、Stream前言 Stream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce，当然Google的MapReduce的灵感也是来自函数式编程。她其实是一连串支持连续、并行聚集操作的元素。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！ 八、Date/Time API (JSR 310)Java 8新的Date-Time API (JSR 310)受Joda-Time的影响，提供了新的java.time包，可以用来替代 java.util.Date和java.util.Calendar。一般会用到Clock、LocaleDate、LocalTime、LocaleDateTime、ZonedDateTime、Duration这些类，对于时间日期的改进还是非常不错的。 九、JavaScript引擎NashornNashorn允许在JVM上开发运行JavaScript应用，允许Java与JavaScript相互调用。 十、Base64在Java 8中，Base64编码成为了Java类库的标准。Base64类同时还提供了对URL、MIME友好的编码器与解码器。 除了这十大新特性之外，还有另外的一些新特性： 更好的类型推测机制：Java 8在类型推测方面有了很大的提高，这就使代码更整洁，不需要太多的强制类型转换了。 编译器优化：Java 8将方法的参数名加入了字节码中，这样在运行时通过反射就能获取到参数名，只需要在编译时使用-parameters参数。 并行（parallel）数组：支持对数组进行并行处理，主要是parallelSort()方法，它可以在多核机器上极大提高数组排序的速度。 并发（Concurrency）：在新增Stream机制与Lambda的基础之上，加入了一些新方法来支持聚集操作。 Nashorn引擎jjs：基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。 类依赖分析器jdeps：可以显示Java类的包级别或类级别的依赖。 JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122），元空间直接采用的是物理空间，也即是我们电脑的内存，电脑内存多大，元空间就有多大。]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
        <tag>java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表冲突解决方式之开放地址法和链地址法]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%93%88%E5%B8%8C%E8%A1%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E5%92%8C%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本定义 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字key对应一个存储位置f(key)。 这种对应关系f称为散列或哈希函数 采用上述思想将数据存储在一块连续的存储空间中，这块连续的存储空间称为散列或哈希表 关键字对应的存储位置称为散列地址 如果碰到两个不同的关键字key1≠key2，但却有相同的f(key1)=f(key2)，这种现象称为冲突， 并把key1和key2 称为这个散列函数的同义词（synonym） 散列函数构造方法好的散列函数参考如下两个原则： 计算简单 散列地址分布均匀 最常用的方法是除留余数法，对于散列表长度为m的散列函数是 f(key)=key mod p (p≤m) 处理散列冲突 开放地址法 开放地址法就是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列表总能找到，并存入。开放地址法又分为线性探测法，二次探测法和随机探测法。 链地址法 将所有同义词的关键字存储在同一个单链表中，称这个单链表为同义词子表，在散列表中只存储同义词子表的头指针。只要有冲突，就在同义词的子表中增加结点。(java中的HashMap就是采用这种方法) 开放地址法]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
        <tag>哈希解决冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8之Hashmap]]></title>
    <url>%2F2017%2F08%2F28%2Fjava8%E4%B9%8BHashmap%2F</url>
    <content type="text"><![CDATA[Java8-HashMap变化 数据的存储结构从：数组+链表 演变为了 数组+链表+红黑树 Map 家庭族谱 HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 总结对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 HashMap简介 Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示： 我们知道HashMap的数据存储结构就是：数组加上链表。通过对于key的值做hash运算，获得对应的值找到对应的数组下标，然后再存储值。存储值的过程中可能当前数组已经存在值（这个称之为冲突） 然后再生成一个链表存储冲突的值。 HashCode() 和 Hash() 方法实现得足够好，能够尽可能地减少冲突的产生，那么对 HashMap 的操作几乎等价于对数组的随机访问操作，具有很好的性能。但是，如果 HashCode() 或者 Hash() 方法实现较差，在大量冲突产生的情况下，HashMap 事实上就退化为几个链表，对 HashMap 的操作等价于遍历链表，此时性能很差。 解决冲突的方法：开放地址法和链地址法 HashMap特点 允许null为key 输出无序 如果想要输出有序，那以使用继承他的LinkedHashMap，元素输出顺序跟输入顺序一致,他提供了一个节点保存输入的元素的顺序。想要对元素的值进行排序 推荐TreeMap（因为他继承了SortedMap) 非线程安全 数组+链表存储方式 Java8特性 HashMap是数组+链表+红黑树 存储算法： map.put(&quot;kingge&quot;,&quot;shuai&quot;)系统将调用kingge”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 好的hash算法和扩容机制是解决冲突和高效存取的命题 HashMap 重要的几个属性int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子int modCount; int size; Node[] table(Hash桶)始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 分析HashMap的put方法put方法图解，详情可以去看源码 public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 步骤①：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 步骤③：节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 步骤④：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 步骤⑥：超过最大容量 就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 为什么说HashMap是线程不安全的 个人觉得有两个表现，如果还有其他的希望大家补充，或者以后等楼主源码研究透了再补充 表现一 我们知道当插入数据超过了threshold(threshold=length * Load factor),那么就会扩容，扩容会去调用resize和transfer方法，这个时候原先hash桶里面的所有数据都会重新计算，对应的位置–称之为rehash，这个成本很大 最根本的原因是出现时死循环-也就是在死锁问题出现在了transfer方法上面,而且是因为在扩容转换的过程中采用的是链表的头插法的形式进行插入数据。例如原来在数组arr[0]的位置又链表1–&gt;2–&gt;3 那么扩容后，采用头插法就变成了arr[0]：3–&gt;2–&gt;1 为什么采用头插法，因为时间复杂度为O(1)，想象一下尾插法，那么需要遍历找到最尾元素然后插入时间复杂度是O(n) 具体源码分析参见：http://www.importnew.com/22011.html 表现二多个线程同时操作一个hashmap就可能出现不安全的情况：比如A B两个线程(A线程获数据 B线程存数据) 同时操作myHashMap1.B线程执行存放数据modelHashMap.put(“1”,”2”);2.A线程执行get获取数据modelHashMap.get(“1”)A线程获取的值本来应该是2，但是如果A线程在刚到达获取的动作还没执行的时候，线程执行的机会又跳到线程B，此时线程B又对modelHashMap赋值 如：modelHashMap.put(“1”,”3”);然后线程虚拟机又执行线程A，A取到的值为3，这样map中第一个存放的值 就会丢失。。。。。—原子性 解决HashMap非线程安全其实上面我已经有提过了： 三个方法： Hashtable替换HashMap Collections.synchronizedMap将HashMap包装起来 private Map map = Collections.synchronizedMap(new HashMap());替换private HashMap map = new HashMap(); ConcurrentHashMap替换HashMap private ConcurrentHashMap map = new ConcurrentHashMap();替换private HashMap map = new HashMap(); 好的博文http://blog.csdn.net/lyg468088/article/details/49464121]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java8</tag>
        <tag>java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员未来规划]]></title>
    <url>%2F2017%2F08%2F28%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[http://www.jianshu.com/p/9d29a441ee17?utm_source=desktop&amp;utm_medium=timeline]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>大龄程序员</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java之ClassLoader源码分析]]></title>
    <url>%2F2017%2F08%2F24%2Fjava%E4%B9%8BClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[类加载器ClassLoader的含义 不论多么简单的java程序，都是由一个或者多个java文件组成，java内部实现了程序所需要的功能逻辑，类之间可能还存在着依赖关系。当程序运行的时候，类加载器会把一部分类编译为class后加载到内存中，这样程序才能够调用里面的方法并运行。 类之间如果存在依赖关系，那么类加载会去帮你加载相关的类到内存中，这样才能够完成调用。如果找不到相关的类，那么他就会抛出我们在开发经常见到的异常：ClassNotFoundException Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，JVM在加载类的时候，都是通过ClassLoader的loadClass（）方法来加载class的,与此同时在loadClass中存在着三种加载策略，loadClass使用双亲委派模式。 所以Classloader就是用来动态加载Class文件到内存当中用的。 Java默认提供的三个ClassLoader1.Bootstrap ClassLoader 称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，预设上它负责搜寻JRE所在目录的classes或lib目录下（实际上是由系统参数sun.boot.class.path指定）。如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件： URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for (int i = 0; i &lt; urls.length; i++) &#123; System.out.println(urls[i].toExternalForm()); &#125; &gt; 这两种输出的内容都是一样的。 System.out.println(System.getProperty("sun.boot.class.path")); 输出 file:/F:/JDK/jdk1.8/jre/lib/resources.jarfile:/F:/JDK/jdk1.8/jre/lib/rt.jarfile:/F:/JDK/jdk1.8/jre/lib/sunrsasign.jarfile:/F:/JDK/jdk1.8/jre/lib/jsse.jarfile:/F:/JDK/jdk1.8/jre/lib/jce.jarfile:/F:/JDK/jdk1.8/jre/lib/charsets.jarfile:/F:/JDK/jdk1.8/jre/lib/jfr.jarfile:/F:/JDK/jdk1.8/jre/classesF:\JDK\jdk1.8\jre\lib\resources.jar;F:\JDK\jdk1.8\jre\lib\rt.jar;F:\JDK\jdk1.8\jre\lib\sunrsasign.jar;F:\JDK\jdk1.8\jre\lib\jsse.jar;F:\JDK\jdk1.8\jre\lib\jce.jar;F:\JDK\jdk1.8\jre\lib\charsets.jar;F:\JDK\jdk1.8\jre\lib\jfr.jar;F:\JDK\jdk1.8\jre\classes 2.Extension ClassLoader 称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar（实际上是由系统参数java.ext.dirs指定） 3.App ClassLoader 称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件（由系统参数java.class.path指定） 总结 Extension ClassLoader和App ClassLoader 这两个类加载器实际上都是继承了ClassLoader类，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器，也就是说： Bootstrap Loader会在JVM启动之后载入，之后它会载入ExtClassLoader并将ExtClassLoader的parent设为Bootstrap Loader，然后BootstrapLoader再加载AppClassLoader，并将AppClassLoader的parent设定为 ExtClassLoader。 ClassLoader加载类的原理双亲委托加载模式 我们知道除了顶级的 Bootstrap Loader他的parent属性为null之外，其他的两个或者自定义的类加载器都是存在parent 的。 当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象 为什么要使用双亲委托这种模型呢 java是一门具有很高的安全性的语言，使用这种加载策略的目的是为了：防止重载，父类如果已经找到了需要的类并加载到了内存，那么子类加载器就不需要再去加载该类。安全性问题。两个原因 JVM在搜索类的时候，又是如何判定两个class是相同的 类名是否相同 否由同一个类加载器实例加载 看一个例子public class TestClassLoader&#123; public static void main(String[] args) &#123; ClassLoader loader = TestClassLoader.class.getClassLoader(); //获得加载ClassLoaderTest.class这个类的类加载器 while(loader != null) &#123; System.out.println(loader); loader = loader.getParent(); //获得父类加载器的引用 &#125; System.out.println(loader); &#125;&#125; 输出 sun.misc.Launcher$AppClassLoader@2a139a55sun.misc.Launcher$ExtClassLoader@7852e922null 结论 第一行结果说明：ClassLoaderTest的类加载器是AppClassLoader。 第二行结果说明：AppClassLoader的类加器是ExtClassLoader，即parent=ExtClassLoader。 第三行结果说明：ExtClassLoader的类加器是Bootstrap ClassLoader，因为Bootstrap ClassLoader不是一个普通的Java类，所以ExtClassLoader的parent=null，所以第三行的打印结果为null就是这个原因。 测试2 将ClassLoaderTest.class打包成ClassLoaderTest.jar，放到Extension ClassLoader的加载目录下（JAVA_HOME/jre/lib/ext），然后重新运行这个程序，得到的结果会是什么样呢？ 输出 sun.misc.Launcher$ExtClassLoader@7852e922null 结果分析： 为什么第一行的结果是ExtClassLoader呢？ 因为ClassLoader的委托模型机制，当我们要用ClassLoaderTest.class这个类的时候，AppClassLoader在试图加载之前，先委托给Bootstrcp ClassLoader，Bootstracp ClassLoader发现自己没找到，它就告诉ExtClassLoader，兄弟，我这里没有这个类，你去加载看看，然后Extension ClassLoader拿着这个类去它指定的类路径（JAVA_HOME/jre/lib/ext）试图加载，唉，它发现在ClassLoaderTest.jar这样一个文件中包含ClassLoaderTest.class这样的一个文件，然后它把找到的这个类加载到内存当中，并生成这个类的Class实例对象，最后把这个实例返回。所以ClassLoaderTest.class的类加载器是ExtClassLoader。 第二行的结果为null，是因为ExtClassLoader的父类加载器是Bootstrap ClassLoader。 测试3: 用Bootstrcp ClassLoader来加载ClassLoaderTest.class，有两种方式：1、在jvm中添加-Xbootclasspath参数，指定Bootstrcp ClassLoader加载类的路径，并追加我们自已的jar（ClassTestLoader.jar）2、将class文件放到JAVA_HOME/jre/classes/目录下（上面有提到）(将ClassLoaderTest.jar解压后，放到JAVA_HOME/jre/classes目录下，如下图所示：)提示：jre目录下默认没有classes目录，需要自己手动创建一个提供者：Java团长 自定义ClassLoader前言 实现自定义类加载的目的是，假设我们的类他不是存在特定的位置，可能是某个磁盘或者某个远程服务器上面，那么我们就需要自定义类加载器去加载这些类。 继承继承java.lang.ClassLoader 重写父类的findClass方法 在findClass()方法中调用defineClass()。 这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常 注意： 一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 为什么不去重定义loadClass方法呢？其实也可以，但是loadClass方法内部已经实现了搜索类的策略。除非你是非常熟悉否则还是不建议这样去做。这里建议重载findClass方法，因为在loadClass中最后会去调用findClass方法去加载类。而且这个方法内部默认是空的。 分析loadClass方法源码/*** A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &quot;class file&quot; of that name from a file system.**/ 大致意思如下：class loader是一个负责加载classes的对象，ClassLoader类是一个抽象类，需要给出类的二进制名称，class loader尝试定位或者产生一个class的数据，一个典型的策略是把二进制名字转换成文件名然后到文件系统中找到该文件。 protected synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // 首先检查该name指定的class是否有被加载 Class c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; //如果parent不为null，则调用parent的loadClass进行加载 c = parent.loadClass(name, false); &#125;else&#123; //parent为null，则调用BootstrapClassLoader进行加载 c = findBootstrapClass0(name); &#125; &#125;catch(ClassNotFoundException e) &#123; //如果仍然无法加载成功，则调用自身的findClass进行加载 c = findClass(name); // &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; 自定义类加载器package com.kingge.com;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.URL;public class PersonalClassLoader extends ClassLoader&#123; private String rootUrl; public PersonalClassLoader(String rootUrl) &#123; this.rootUrl = rootUrl; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class clazz = null;//this.findLoadedClass(name); // 父类已加载 //if (clazz == null) &#123; //检查该类是否已被加载过 byte[] classData = getClassData(name); //根据类的二进制名称,获得该class文件的字节码数组 if (classData == null) &#123; throw new ClassNotFoundException(); &#125; clazz = defineClass(name, classData, 0, classData.length); //将class的字节码数组转换成Class类的实例 //ClassLoader内置方法 /* * Converts an array of bytes into an instance of class * Before the &lt;tt&gt;Class&lt;/tt&gt; can be used it must be resolved.*/ //&#125; return clazz; &#125; private byte[] getClassData(String name) &#123; InputStream is = null; try &#123; String path = classNameToPath(name); URL url = new URL(path); byte[] buff = new byte[1024*4]; int len = -1; is = url.openStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); while((len = is.read(buff)) != -1) &#123; baos.write(buff,0,len); &#125; return baos.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (is != null) &#123; try &#123; is.close(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125; private String classNameToPath(String name) &#123; return rootUrl + &quot;/&quot; + name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;; &#125;&#125; 测试类： package com.kingge.com;public class ClassLoaderTest&#123; public static void main(String[] args) &#123; try &#123; /*ClassLoader loader = ClassLoaderTest.class.getClassLoader(); //获得ClassLoaderTest这个类的类加载器 while(loader != null) &#123; System.out.println(loader); loader = loader.getParent(); //获得父加载器的引用 &#125; System.out.println(loader);*/ String rootUrl = &quot;http://localhost:8080/console/res&quot;; PersonalClassLoader networkClassLoader = new PersonalClassLoader(rootUrl); String classname = &quot;HelloWorld&quot;; Class clazz = networkClassLoader.loadClass(classname); System.out.println(clazz.getClassLoader()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出： com.kingge.com.PersonalClassLoader@65b54208 其中HelloWorld.class文件的位置在于： 其实很多服务器都自定义了类加载器 用于加载web应用指定目录下的类库（jar或class），如：Weblogic、Jboss、tomcat等，下面我以Tomcat为例，展示该web容器都定义了哪些个类加载器： 下面以tomcat为例子 1、新建一个web工程httpweb 2、新建一个ClassLoaderServletTest，用于打印web容器中的ClassLoader层次结构 一下代码来自网上：import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ClassLoaderServletTest extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); ClassLoader loader = this.getClass().getClassLoader(); while(loader != null) &#123; out.write(loader.getClass().getName()+&quot;&lt;br/&gt;&quot;); loader = loader.getParent(); &#125; out.write(String.valueOf(loader)); out.flush(); out.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125; &#125; 3、配置Servlet，并启动服务 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app version=&quot;2.4&quot; xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;ClassLoaderServletTest&lt;/servlet-name&gt; &lt;servlet-class&gt;ClassLoaderServletTest&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ClassLoaderServletTest&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ClassLoaderServletTest&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 运行截图： 总结 这种自定义的方式目的就是为了，能够控制类的加载流程，那么这种远程加载类的方式类似于我们常用的Hessian 来访问多个系统获取类 好的网站http://blog.csdn.net/briblue/article/details/54973413]]></content>
      <categories>
        <category>java深入理解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ClassLoader</tag>
        <tag>类加载器</tag>
        <tag>自定义类加载器</tag>
        <tag>类加载器源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么毕业后选择留在小城市]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%95%E4%B8%9A%E5%90%8E%E9%80%89%E6%8B%A9%E7%95%99%E5%9C%A8%E5%B0%8F%E5%9F%8E%E5%B8%82%2F</url>
    <content type="text"><![CDATA[前言经常看到大学要毕业的学生，会有一种纠结感。越是临近毕业，这种感觉就越是强烈这种感觉实际上就是一种选择恐惧症，又或者说是小城综合征。他们对于毕业后究竟是选择去一线城市就业还是去二三线城市就业，产生了很大的选择恐惧。 为什么会产生这种心理大致的原因有那么几个： 身边的认识的人，都是选择回到自己的家乡进行就业，自己收到了影响。 大城市的生活节奏会比小城市更加的紧凑，你会很忙。 父母希望自己回去，离家近的地方工作。 恋人不跟随自己，她或他选择了回到了故乡就业，自己左右为难。 有些人已经在大城市实习过，对于大城市已经厌倦。 作者的选择 本人就是属于最后一种，大三的时候去的深圳实习，在一家IT互联网公司上班，加班很多，虽然加班这种现象在深圳是一种常态。但是每天加班到晚上一点多，也是很累，所以毕业后也就选择回到了自己的家乡就业。 回到了]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>总结</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[max-allowed-packet的问题]]></title>
    <url>%2F2017%2F08%2F17%2Fmax-allowed-packet%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 近期，因启动项目有个批量插入的sql结果太大，超过了mysql自带的缓存，报了这个错误 修改： 定位到mysql的安装目录下面，然后修改my.ini 的max_allowed_packet = 8M默认是1M]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>异常</tag>
        <tag>sql异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客迁移]]></title>
    <url>%2F2017%2F08%2F14%2F%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[今天周一，天气炎热，调开空调。噼里啪啦的敲完今天的工作，因为今天本人决定再次迁移自己的PersonalBlog。个人一共换过很多个博客，前期使用过网易博客，后来访问量上不去(网易博客他并不是一个IT社区)，后来换到了博客园，感觉还行，但是好景不长，感觉本人有处女座的完美主义，很纠结，总感觉这个博客园UI设计不行。 最后又换到了CSDN，今天又临时决定迁移到了本人的服务器上面，自由管理。 我的性格知道的人应该知道，我是知无不言言无不尽，只要我会的有所感悟的都会分享出来。以后每天心情一更，工作方面一周一更。 最后：人生需要面对,搞笑我是认真的。]]></content>
      <categories>
        <category>心情</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hessian 多系统访问]]></title>
    <url>%2F2017%2F08%2F14%2FHessian%20%E5%A4%9A%E7%B3%BB%E7%BB%9F%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[实现多数据量的导入数据库]]></title>
    <url>%2F2017%2F08%2F01%2F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[引言 在做一个项目的时候，涉及到需要从一个表格中获取百万条数据然后插入到数据库中，最后采用JDBC的executeBantch方法实现这个功能。 采取的策略 尽量关闭字段索引（因为再插入数据的时候还是需要维护索引的，在创建索引和维护索引 会耗费时间,随着数据量的增加而增加，可以在插入数据后再去为字段创建索引） 虽然索引可以提高查询速度但是，插入数据的时候会导致索性的更新。索性越多，插入会越慢。可以看文档描述:Although it can be tempting to create an indexes for every possible column used in a query, unnecessary indexes waste space and waste time for MySQL to determine which indexes to use. Indexes also add to the cost of inserts, updates, and deletes because each index must be updated. You must find the right balance to achieve fast queries using the optimal set of indexes. 分批次提交数据 在分布式条件下，还可以考虑在不同的数据库结点提交，有底层的消息系统完成数据扩展 过滤预处理数据 预处理数据的场景：为了避免插入的数据（假设ListA）跟数据库中某些数据重复，那么我们会把要插入的数据去数据库中查询是否已经存在，获得返回的已经存在数据（ListB）。然后在插入数据的时候判断当前数据是否在ListB中，那么当前数据不能够插入数据库。过滤出来，最后得到一个可以插入数据库的ListC 代码关键代码/*数据分析结束*/ /*往数据库写数据开始*/ Connection conn=null; PreparedStatement idsUserAdd=null; try &#123; Class.forName("com.mysql.jdbc.Driver") ; conn = DriverManager.getConnection(ConfigTool.getProperty("jdbc.url").toString() , ConfigTool.getProperty("jdbc.username").toString() , ConfigTool.getProperty("jdbc.password").toString()); conn.setAutoCommit(false); //构造预处理statement idsUserAdd = conn.prepareStatement("INSERT INTO dc_matedata ("+ " ID,`NAME`, DATATYPE,`CODE`,TYPE_ID,`LENGTH`, "+ " DATANAME, VALUEAREA,`RESTRICT`, REMARK,MD_DATE)"+ " values(?,?,?,?,?,?,?,?,?,?,now())"); //最大列表的数目当做循环次数 int xhcs=addMetadataList.size();//addMetadataList需要插入的数据 for(int i=0;i&lt;xhcs;i++)&#123; idsUserAdd.setString(1,addMetadataList.get(i).get("id").toString()); idsUserAdd.setString(2,addMetadataList.get(i).get("name").toString()); idsUserAdd.setString(3,addMetadataList.get(i).get("dataType").toString()); idsUserAdd.setString(4,addMetadataList.get(i).get("code").toString()); idsUserAdd.setString(5,addMetadataList.get(i).get("typeId").toString()); idsUserAdd.setString(6,addMetadataList.get(i).get("dataLength").toString()); idsUserAdd.setString(7,addMetadataList.get(i).get("dataName").toString()); idsUserAdd.setString(8,addMetadataList.get(i).get("valueArea").toString()); idsUserAdd.setString(9,addMetadataList.get(i).get("dataRestrict").toString()); idsUserAdd.setString(10,addMetadataList.get(i).get("dataRemark").toString()); idsUserAdd.addBatch(); //每10000次提交一次 if(i%10000==0||i==xhcs-1)&#123;//可以设置不同的大小；如50，100，500，1000等等 i==xhcs-1（最后一次） idsUserAdd.executeBatch(); conn.commit(); idsUserAdd.clearBatch(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw e; &#125;finally &#123; try &#123; if(idsUserAdd!=null) idsUserAdd.close(); if(conn!=null) conn.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); throw e; &#125; &#125; /*往数据库写数据结束*/ 完整代码/** * 校验需要导入的元数据信息，封装错误信息并批量插入数据库 */ @Override public List&lt;Map&lt;String, Object&gt;&gt; saveDCMetadataBatch(List&lt;Map&lt;String, Object&gt;&gt; list, boolean valid, boolean addError) throws Exception&#123; List&lt;Map&lt;String,Object&gt;&gt; errorList=new ArrayList&lt;Map&lt;String,Object&gt;&gt;();//获得不能够添加成功的数据 Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;();//查询条件 Map&lt;String,String&gt; codeMap=new HashMap&lt;String,String&gt;();//每个分类对应的元数据的编号最大值 Map&lt;String,Object&gt; metaName=new HashMap&lt;String,Object&gt;();//查询数据库中是否存在相同的数据（这里校验的是：元数据的中文简称） Map&lt;String,Object&gt; metaDataName=new HashMap&lt;String,Object&gt;();//查询数据库中是否存在相同的数据（这里校验的是：元数据的数据项名称） map.put("metaName",list);//需要查询的元数据中文名称 map.put("metaDataTypeId",list);//导入的元数据的编号 List&lt;Map&lt;String, Object&gt;&gt; metaExistList = dCMatedataDao.getDCMetadata(map);//根据元数据名称查询当前分类下是否存在同样元数据 map.put("metaName",null);//置空 map.put("metaDataName",list); List&lt;Map&lt;String, Object&gt;&gt; metaExistListTwo = dCMatedataDao.getDCMetadata(map);//根据元数据数据项名称查询存在的元数据 //保存重复的信息 for(int i=0;i&lt;metaExistList.size();i++) metaName.put(metaExistList.get(i).get("name").toString()+metaExistList.get(i).get("code").toString() ,metaExistList.get(i).get("id"));//添加父类的编号为后缀-唯一性保证 for(int i=0;i&lt;metaExistListTwo.size();i++) metaDataName.put(metaExistListTwo.get(i).get("dataname").toString()+metaExistListTwo.get(i).get("code").toString(), metaExistListTwo.get(i).get("id")); /*整理出来的数据-开始*/ List&lt;Map&lt;String,Object&gt;&gt; addMetadataList=new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); /*整理出来的数据-结束*/ for (int i = 0; i &lt; list.size(); i++) &#123; Map&lt;String, Object&gt; MetadataObj = list.get(i); try &#123; String metadatId = StringUtil.getUUID();//元数据id /*校验开始*/ if (valid)&#123; if(validUser(MetadataObj,"name",addError)!=null)&#123;//验证输入的数据是否符合格式和必填。 errorList.add(MetadataObj); continue; &#125; &#125; /*前端校验结束*/ /*校验是否存在同名的元数据*/ String dataCodeCheck = MetadataObj.get("dataCode").toString().trim(); //元数据父分类编号 String name = MetadataObj.get("name").toString().trim();//元数据中文简称 if (metaName.containsKey(name+dataCodeCheck)) &#123; if (addError) &#123; MetadataObj.put("errInfo", "中文简称已存在"); &#125; errorList.add(MetadataObj); continue; &#125; /*校验是否存在相同数据项的元数据*/ String dataName = MetadataObj.get("dataName").toString().trim();//数据项名 if (metaDataName.containsKey(dataName+dataCodeCheck)) &#123; if (addError) &#123; MetadataObj.put("errInfo", "数据项名已存在"); &#125; errorList.add(MetadataObj); continue; &#125; String dataCode = MetadataObj.get("dataCode").toString().trim(); //元数据父分类编号 List&lt;Map&lt;String, Object&gt;&gt; footCount = dCMatedataDao.getFootCount(dataCode); if( footCount.size() &gt; 0)&#123; if (addError) &#123; MetadataObj.put("errInfo", "分类编码不是最后一级分类"); &#125; errorList.add(MetadataObj); continue; &#125; Map&lt;String, Object&gt; typeByCode = dCMatedataDao.getMetadataTypeByCode(dataCode); if( typeByCode == null || typeByCode.size() &lt; 1)&#123; if (addError) &#123; MetadataObj.put("errInfo", "分类编码不存在，请先添加分类"); &#125; errorList.add(MetadataObj); continue; &#125; //校验是在添加的List中是否存在相同的数据项名或者中文简称 //校验导入文件中是否存在一样的中文简称或者数据项名 boolean nameExist = false; boolean dataNameExist = false; for (int j = 0; j &lt; addMetadataList.size(); j++)&#123; Map&lt;String, Object&gt; map2 = addMetadataList.get(j); String typeId = map2.get("typeId").toString(); String nameE = map2.get("name").toString(); String dataNameE = map2.get("dataName").toString(); if( typeId.equals(typeByCode.get("id").toString()) &amp;&amp; nameE.equals(name))&#123; nameExist=true; break; &#125; if( typeId.equals(typeByCode.get("id").toString()) &amp;&amp; dataNameE.equals(dataName))&#123; dataNameExist=true; break; &#125; &#125; if( nameExist )&#123; if (addError) &#123; MetadataObj.put("errInfo", "中文简称已存在"); &#125; errorList.add(MetadataObj); continue; &#125; if( dataNameExist )&#123; if (addError) &#123; MetadataObj.put("errInfo", "数据项名已存在"); &#125; errorList.add(MetadataObj); continue; &#125; //进入这里说明校验结束，开始填充添加的数据 String type_id = typeByCode.get("id").toString();//元数据所属分类id String dataType = MetadataObj.get("dataType").toString().trim(); //元数据类型 String dataLength = MetadataObj.get("dataLength").toString().trim(); //元数据长度 String code = ""; //// if( codeMap.get(dataCode) == null||StringUtil.isEmpty(codeMap.get(dataCode)) )&#123;//表示当前分类不存在已经添加的元数据--因为编码map中不存在对应分类的最大编码 Map maxCodeByPid = this.selectMetadataMaxCode(type_id); if( maxCodeByPid == null )&#123;//表示当前分类下不存在任何子分类 code = StringUtil.getCode("0", dataCode);//则从01开始编号 codeMap.put(dataCode, "01");//保存当前分类下元数据编号最大值 &#125;else&#123; String object = (String) maxCodeByPid.get("codeNum");//当前分类节点下的元数据的编号最大值。 int pSituation = object.indexOf(dataCode); int pLength = pSituation+dataCode.length() ; String substring = object.substring(pLength); //截取出最大编号值得最大值 code = StringUtil.getCode(substring, dataCode); int temp = Integer.parseInt(substring);//保存当前分类下元数据编号最大值 temp+=1; codeMap.put(dataCode, temp+""); &#125; &#125;else&#123; String maxCode = codeMap.get(dataCode); code = StringUtil.getCode(maxCode, dataCode); //保存当前分类下元数据编号最大值 int temp = Integer.parseInt(maxCode); temp+=1; codeMap.put(dataCode, temp+""); &#125; /// Map&lt;String, Object&gt; metadatList = new LinkedHashMap&lt;String, Object&gt;(); metadatList.put("id", metadatId); metadatList.put("name",name); metadatList.put("dataType",dataType); metadatList.put("code",code); metadatList.put("typeId",type_id); metadatList.put("dataLength",dataLength); metadatList.put("dataName",dataName); metadatList.put("valueArea", MetadataObj.get("valueArea")==null?"":MetadataObj.get("valueArea") ); metadatList.put("dataRestrict",MetadataObj.get("dataRestrict")==null?"":MetadataObj.get("dataRestrict")); metadatList.put("dataRemark",MetadataObj.get("dataRemark")==null?"":MetadataObj.get("dataRemark")); metadatList.put("mdDate",new Date()); addMetadataList.add(metadatList); &#125; catch (Exception e)&#123; if(addError) &#123; MetadataObj.put("errInfo", e.getMessage()); &#125; errorList.add(MetadataObj); &#125; &#125; /*数据分析结束*/ /*往数据库写数据开始*/ Connection conn=null; PreparedStatement idsUserAdd=null; try &#123; Class.forName("com.mysql.jdbc.Driver") ; conn = DriverManager.getConnection(ConfigTool.getProperty("jdbc.url").toString() , ConfigTool.getProperty("jdbc.username").toString() , ConfigTool.getProperty("jdbc.password").toString()); conn.setAutoCommit(false); //构造预处理statement idsUserAdd = conn.prepareStatement("INSERT INTO dc_matedata ("+ " ID,`NAME`, DATATYPE,`CODE`,TYPE_ID,`LENGTH`, "+ " DATANAME, VALUEAREA,`RESTRICT`, REMARK,MD_DATE)"+ " values(?,?,?,?,?,?,?,?,?,?,now())"); //最大列表的数目当做循环次数 int xhcs=addMetadataList.size(); for(int i=0;i&lt;xhcs;i++)&#123; idsUserAdd.setString(1,addMetadataList.get(i).get("id").toString()); idsUserAdd.setString(2,addMetadataList.get(i).get("name").toString()); idsUserAdd.setString(3,addMetadataList.get(i).get("dataType").toString()); idsUserAdd.setString(4,addMetadataList.get(i).get("code").toString()); idsUserAdd.setString(5,addMetadataList.get(i).get("typeId").toString()); idsUserAdd.setString(6,addMetadataList.get(i).get("dataLength").toString()); idsUserAdd.setString(7,addMetadataList.get(i).get("dataName").toString()); idsUserAdd.setString(8,addMetadataList.get(i).get("valueArea").toString()); idsUserAdd.setString(9,addMetadataList.get(i).get("dataRestrict").toString()); idsUserAdd.setString(10,addMetadataList.get(i).get("dataRemark").toString()); idsUserAdd.addBatch(); //每10000次提交一次 if(i%10000==0||i==xhcs-1)&#123;//可以设置不同的大小；如50，100，500，1000等等 idsUserAdd.executeBatch(); conn.commit(); idsUserAdd.clearBatch(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw e; &#125;finally &#123; try &#123; if(idsUserAdd!=null) idsUserAdd.close(); if(conn!=null) conn.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); throw e; &#125; &#125; /*往数据库写数据结束*/ return errorList; &#125; 总结 有些网友发现使用StringBuffer 来拼接入参，不通过prepareStatement的预处理，虽然前者速度很快，但是使用prepareStatement可以防止SQL注入 有的好的建议大家都可以提出来]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>JDBC</tag>
        <tag>批量导入</tag>
        <tag>SSM</tag>
        <tag>项目经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工程师书单（初级、中级、高级）]]></title>
    <url>%2F2017%2F06%2F21%2FJava%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B9%A6%E5%8D%95%EF%BC%88%E5%88%9D%E7%BA%A7%E3%80%81%E4%B8%AD%E7%BA%A7%E3%80%81%E9%AB%98%E7%BA%A7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[当你的能力承受不住你的欲望，你就应该静下心来读书 初级书籍《编写高质量代码——改善Java程序的151个建议》 这是一本值得入门java的人放在床头的书。此书内容广泛、要点翔实。大多数优秀程序设计书籍都需要看老外写的，但是这本讲述提高java编程水平的书还是不错的，适合具有基本java编程能力的人。对于程序猿而言，工作久了，就感觉编程习惯对一个人很重要。习惯好，不仅工作效率告，而且bug少。这本书对提高个人的好的编程习惯很有帮助。 《Java程序员修炼之道》 此书涵盖了Java7的新特性和Java开发的关键技术，对当前大量开源技术并存，多核处理器、并发以及海量数据给Java开发带来的挑战作出了精辟的分析，提供了实践前沿的深刻洞见，涉及依赖注入、现代并发、类与字节码、性能调优等底层概念的剖析。**书中的道理很浅显，可是对于菜鸟却是至理名言。基本为你勾勒了一个成熟软件程序员专家所需要的所有特性。。 《Java8实战》 没看过。嘻嘻嘻 《有效的单元测试》 此书由敏捷技术实践专家撰写，系统且深入地阐释单元测试用于软件设计的工具、方法、原则和佳实践；深入剖析各种测试常见问题，包含大量实践案例，可操作性强，能为用户高效编写测试提供系统实践指南。**介绍了单元测试的各个方面，TDD、test double、测试的坏味道、可测试的设计等等，每个主题需要深入的话，还需要配合其它书籍和实践，非常适合入门单元测试。书中例子非常全面，看完对使用 Junit 进行单元测试会有一个大的长进，而且用java语言编写，内容很新 《Java核心技术：卷1》 不推荐卷2，因为这个作为初级书单来讲，太难了。 《代码整洁之道》 没看过 《数据结构与算法分析-Java语言描述》 本书是java数据结构与算法方面的三宝之一，除了这三本其他的已经没有意义了。这三宝分别是:**黑宝书《数据结构与算法分析java语言描述》mark allen weiss蓝宝书《java数据结构和算法》robert lafore红宝书《算法》robert sedgewick黑宝书胜在公式推理和证明以及算法的简洁和精炼，此外习题较多。蓝宝书胜在对算法的深入浅出的讲解，演示和举例，让艰涩的理论变得很容易理解。红宝书胜在系出名门斯坦福，演示通俗易懂，内容丰富。有了这三宝，算法不用愁，学完以后再看《算法导论》就容易多了。本书从讲解什么是数据结构开始，延伸至高级数据结构和算法分析，强调数据结构和问题求解技术。本书的目的是从抽象思维和问题求解的观点提供对数据结构的实用介绍，试图包含有关数据结构、算法分析及其Java实现的所有重要的细节 中级书单《重构：改善既有代码的设计》 重构，绝对是写程序过程中最重要的事之一。在写程序之前我们不可能事先了解所有的需求，设计肯定会有考虑不周的地方，而且随着项目需求的修改，也有可能原来的设计已经被改得面目全非了。更何况，我们很少有机会从头到尾完成一个项目，基本上都是接手别人的代码，我们要做的是重构，从小范围的重构开始。**重构是设计,设计是art,重构也是art. 一个函数三行只是语不惊人死不休的说法,是对成百上千行代码的矫枉过正。 更一个般的看法是一个函数应该写在一页纸内。 《Effective Java》 必读 《Java并发编程实战》 没看过： 本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量。**java进阶必看，多线程的最佳书籍。 实战Java高并发程序设计》 没看过 《算法》 没看过 《Head First 设计模式》 这是我看过最幽默最搞笑最亲切同时又让我收获巨大的技术书籍！ 森森的膜拜Freeman(s)！Amen！ 深入浅出，娓娓道来，有的地方能笑死你！写得很有趣，图文并茂，比起四人帮的那本，好懂了不知道多少倍。计算机世界的head first系列基本都是经典。不过只看书学明白设计模式是不可能的，这些只是前人的总结，我们唯有实践实践再实践了。**读这本书不仅仅是学习知识，而是在学习一种思考的方法，学习一种认知的技巧，学习一种成长的阶梯。 总之，用你闲暇的时间来读这本书，并不亚于你专注的工作或学习。笔者强烈推荐此书，要成长为一名高级程序员，设计模式已经是必备技能了。 《Java编程思想》 没看过 高级书单 《深入理解Java虚拟机》 没看过 《Java性能权威指南》 没看过 《深入分析Java Web技术内幕》 没看过 《大型网站系统与Java中间件实践》 没看过 《大型网站技术架构：核心原理与案例分析》 没看过 《企业应用架构模式》 没看过 Spring3.x企业应用开发实战 这本书适合初学者看或者当做一本参考书。对于提高者而言，略看就行 Spring揭秘 没看过 Java程序性能优化:让你的Java程序更快、更稳定 没看过 总结talk is less show me your code，希望大家有好的书籍也可以推荐]]></content>
      <categories>
        <category>读书系统</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>书籍推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql索引详解]]></title>
    <url>%2F2016%2F08%2F01%2FMysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。考虑如下情况，假设数据库中一个表有10^6条记录，DBMS的页面大小为4K，并存储100条记录。如果没有索引，查询将对整个表进行扫描，最坏的情况下，如果所有数据页都不在内存，需要读取10^4个页面，如果这10^4个页面在磁盘上随机分布，需要进行10^4次I/O，假设磁盘每次I/O时间为10ms(忽略数据传输时间)，则总共需要100s(但实际上要好很多很多)。如果对之建立B-Tree索引，则只需要进行log100(10^6)=3次页面读取，最坏情况下耗时30ms。这就是索引带来的效果，很多时候，当你的应用程序进行SQL查询速度很慢时，应该想想是否可以建索引。进入正题： 有些硬啃的干货还是得了解的，下面先了解索引的基本知识 索引分类 单列索引 主键索引 唯一索引 普通索引 组合索引用到的表CREATE TABLE `award` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id', `aty_id` varchar(100) NOT NULL DEFAULT '' COMMENT '活动场景id', `nickname` varchar(12) NOT NULL DEFAULT '' COMMENT '用户昵称', `is_awarded` tinyint(1) NOT NULL DEFAULT 0 COMMENT '用户是否领奖', `award_time` int(11) NOT NULL DEFAULT 0 COMMENT '领奖时间', `account` varchar(12) NOT NULL DEFAULT '' COMMENT '帐号', `password` char(32) NOT NULL DEFAULT '' COMMENT '密码', `message` varchar(255) NOT NULL DEFAULT '' COMMENT '获奖信息', `created_time` int(11) NOT NULL DEFAULT 0 COMMENT '创建时间', `updated_time` int(11) NOT NULL DEFAULT 0 COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='获奖信息表'; 单列索引普通索引 这个是最基本的索引 创建语法：其sql格式是： 第一种方式 : CREATE INDEX IndexName ON `TableName`(`字段名`(length)) 第二种方式 : ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length)) 创建例子：第一种方式 : CREATE INDEX account_Index ON `award`(`account`);第二种方式: ALTER TABLE award ADD INDEX account_Index(`account`) 唯一索引 与普通索引类似,但是不同的是唯一索引要求所有的类的值是唯一的,这一点和主键索引一样.但是他允许有空值 创建语法：其sql格式是： 第一种方式 : CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length)); 第二种方式 : ALTER TABLE TableName ADD UNIQUE (column_list) 创建例子：CREATE UNIQUE INDEX account_UNIQUE_Index ON `award`(`account`); 主键索引 他与唯一索引的不同在于不允许有空值(在B+TREE中的InnoDB引擎中,主键索引起到了至关重要的地位) 创建语法：其sql格式是： 第一种方式 : CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length)); 第二种方式 : ALTER TABLE TableName ADD UNIQUE (column_list) 创建例子：CREATE UNIQUE INDEX account_UNIQUE_Index ON `award`(`account`); 单列索引的总结mysql&gt;SELECT ｀uid｀ FROM people WHERE lname｀='Liu' AND ｀fname｀='Zhiqun' AND ｀age｀=26因为我们不想扫描整表，故考虑用索引。单列索引：ALTER TABLE people ADD INDEX lname (lname);将lname列建索引，这样就把范围限制在lname='Liu'的结果集1上，之后扫描结果集1，产生满足fname='Zhiqun'的结果集2，再扫描结果集2，找到 age=26的结果集3，即最终结果。由 于建立了lname列的索引，与执行表的完全扫描相比，效率提高了很多，但我们要求扫描的记录数量仍旧远远超过了实际所需 要的。虽然我们可以删除lname列上的索引，再创建fname或者age 列的索引，但是，不论在哪个列上创建索引搜索效率仍旧相似。&gt; 所以就需要组合索引 组合索引 一个表中含有多个单列索引不代表是组合索引,通俗一点讲 组合索引是:包含多个字段但是只有索引名称 创建语法：其sql格式是： CREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...); 创建例子：CREATE INDEX nickname_account_createdTime_Index ON `award`(`nickname`, `account`, `created_time`); 如果你建立了 组合索引(nickname_account_createdTime_Index) 那么他实际包含的是3个索引 (nickname) (nickname,account)(nickname,account,created_time) 组合索引的最左前缀 上面的例子中给nickname,account,created_time 这三个字段建立索引他会去创建三个索引，但是在执行查询的时候只会用其中一个索引去查询，mysql会选择一个最严格(获得结果集记录数最少)的索引，所以where子句中使用最频繁的一列放在最左边。所谓最左前缀原则就是先要看第一列，在第一列满足的条件下再看左边第二列 全文索引 文本字段上(text)如果建立的是普通索引,那么只有对文本的字段内容前面的字符进行索引,其字符大小根据索引建立索引时申明的大小来规定.如果文本中出现多个一样的字符,而且需要查找的话,那么其条件只能是 where column lick &apos;%xxxx%&apos; 这样做会让索引失效.这个时候全文索引就祈祷了作用了ALTER TABLE tablename ADD FULLTEXT(column1, column2)有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。ELECT * FROM tablenameWHERE MATCH(column1, column2) AGAINST(‘xxx′, ‘sss′, ‘ddd′)这条命令将把column1和column2字段里有xxx、sss和ddd的数据记录全部查询出来。 总结使用索引的优点 可以通过建立唯一索引或者主键索引,保证数据库表中每一行数据的唯一性. 建立索引可以大大提高检索的数据,以及减少表的检索行数 在表连接的连接条件 可以加速表与表直接的相连 在分组和排序字句进行数据检索,可以减少查询时间中 分组 和 排序时所消耗的时间(数据库的记录会重新排序) 建立索引,在查询中使用索引 可以提高性能 使用索引的缺点 在创建索引和维护索引 会耗费时间,随着数据量的增加而增加 索引文件会占用物理空间,除了数据表需要占用物理空间之外,每一个索引还会占用一定的物理空间 当对表的数据进行 INSERT,UPDATE,DELETE 的时候,索引也要动态的维护,这样就会降低数据的维护速度,(建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)。 使用索引需要注意的地方 在经常需要搜索的列上,可以加快索引的速度 主键列上可以确保列的唯一性 在表与表的而连接条件上加上索引,可以加快连接查询的速度 在经常需要排序(order by),分组(group by)和的distinct 列上加索引 可以加快排序查询的时间, (单独order by 用不了索引，索引考虑加where 或加limit) 在一些where 之后的 &lt; &lt;= &gt; &gt;= BETWEEN IN 以及某个情况下的like 建立字段的索引(B-TREE) like语句的 如果你对nickname字段建立了一个索引.当查询的时候的语句是 nickname lick ‘%ABC%’ 那么这个索引讲不会起到作用.而nickname lick ‘ABC%’ 那么将可以用到索引 索引不会包含NULL列,如果列中包含NULL值都将不会被包含在索引中,复合索引中如果有一列含有NULL值那么这个组合索引都将失效,一般需要给默认值0或者 ‘ ‘字符串 使用短索引,如果你的一个字段是Char(32)或者int(32),在创建索引的时候指定前缀长度 比如前10个字符 (前提是多数值是唯一的..)那么短索引可以提高查询速度,并且可以减少磁盘的空间,也可以减少I/0操作. 不要在列上进行运算,这样会使得mysql索引失效,也会进行全表扫描 选择越小的数据类型越好,因为通常越小的数据类型通常在磁盘,内存,cpu,缓存中 占用的空间很少,处理起来更快 什么情况下不建立索引 查询中很少使用到的列 不应该创建索引,如果建立了索引然而还会降低mysql的性能和增大了空间需求. 很少数据的列也不应该建立索引,比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql需要扫描的行数很多,增加索引,并不能提高效率 定义为text和image和bit数据类型的列不应该增加索引 当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系 好的文章转：SQL优化转：MySQL索引原理及慢查询优化]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++文件流操作的读与写]]></title>
    <url>%2F2014%2F11%2F08%2FC-%E6%96%87%E4%BB%B6%E6%B5%81%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%BB%E4%B8%8E%E5%86%99%2F</url>
    <content type="text"><![CDATA[对文件的写入put和&lt;&lt; 写入方式 put的操作：是对文件进行写入的操作，写入一个字符（可以使字母也可以是asci码值） file.put(' A');file.put('\n');file &lt;&lt; "xiezejing1994"; 输出： &nbsp;&nbsp;&nbsp;&nbsp;A// 注意到A这里有几个空格 但是不影响左对齐xiezejing1994// 也就是说A的前面不会有空格 ##操作和&lt;&lt; 读写方式区别 put操作和 file &lt;&lt;‘A’这个基本上是一样的，但是有个区别就是他不可以这样file &lt;&lt;’ A’;（A的前面有空格）因为他是格式化输入 所以中间不能有”空格“但是这样file &lt;&lt;”‘ A”;（也就是以字符串的格式输入则会有空格） 文件的读操作1.getline（） getline（ cin ，string类型 ） getline( cin, z ); file1 &lt;&lt; z; （file1 为文件流对象） 例子： char c[100]; while ( !file.eof() ) &#123; file.getline( c,100 ); cout &lt;&lt; c; &#125; 假设文件1.txt内有' A xiezejing1994 这样文本它的输出：' Axiezejing1994 也就是说他没有读到换行的功能 不会输出' A xiezejing1994（原因就是getlibe其实里面有三个参数，第三个参数默认为'\n'） 2.getline（ fstream，string ）while ( getline( file,z ) )&#123; cout &lt;&lt; z;&#125; 3.get（） char c[100]; while ( !file.eof() ) &#123; //file.getline( c,100 ,'\0'); file.get( c,100 ,'\0'); cout &lt;&lt; c; &#125;输出同getline一样----必须要写三个参数 否则只会输出一行（第三个参数为'\n'也是只会输出一行）。非常严格的输出。 4.get操作 char c; file.get(c); while ( !file.eof() ) &#123; cout &lt;&lt; c; file.get(c); &#125;-----和getline的区别在于 他是读取单个字符的，所以会读取到结束符号故会输出' Axiezejing1994 对文件是否读到末尾的判断1.feof（） 该函数只有“已经读取了”结束标志时 feof（）才会返回非零值 也就是说当文件读取到文件结束标志位时他的返回值不是非零还是零 故还要在进行一次读. 例子 假设在1.txt中只有abc三个字符在进行 while（！feof(fp)） &#123; ch = getc(fp); putchar(ch); &#125;//实际上输出的是四个字符改为ch = getc（fp）；while （ ！feof（fp））&#123; putchar（ch）； ch = getc（fp）；&#125;// 这样就可以正常运行3. 可以不调用函数eof 直接就是 while （ file ） // file 就是文件流的对象&#123; 。。。。操作&#125;4.char c[100]; while ( !file.eof() ) &#123; file.getline( c,100 ,'\0'); cout &lt;&lt; c; &#125;这个 和char c[100]; while ( !file.eof() ) &#123; file.getline( c,100 ,'\n'); cout &lt;&lt; c; &#125;假设文本为上面的。输出分别为' A xiezejing1994' Axiezejing1994 读写1.read( 数组名，接收的个数 )2.write( 数组名，gcount函数 )#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;int main()&#123; ifstream file( "D:\\jjj.txt"); ofstream file1( "D:\\j.txt" , ios::app); string z; if ( !file ) &#123; cout &lt;&lt; " 无法打开\n "; return 1; &#125; char c[100]; while ( !file.eof() ) &#123; file.read( c,100 ); file1.write( c, file.gcount() ); &#125; file.close(); file.close(); return 0;&#125; **判断打开是否正确** 1. if( !file )2.if ( !file.good() ) &#123; cout &lt;&lt; " 无法打开\n "; return 1; &#125;3. if ( !file.is_open() ) &#123; cout &lt;&lt; " 无法打开\n "; return 1; &#125;4. if ( file.fail() ) &#123; cout &lt;&lt; " 无法打开\n "; return 1; &#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>C++</tag>
        <tag>文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章例子]]></title>
    <url>%2F2013%2F12%2F02%2Fceshi%2F</url>
    <content type="text"><![CDATA[前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等；]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>tag1</tag>
        <tag>tag2</tag>
        <tag>tag3</tag>
      </tags>
  </entry>
</search>
