<!DOCTYPE html>



  




<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('OOPS, 主人请输入文章密码才能够观看哟') !== ''){
                alert('哎呀，密码错误哟！');
                history.back();
            }
        }
    })();
</script>


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|40:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="hive,数据仓库工具," />





  <link rel="alternate" href="/atom.xml" title="King哥" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="一 Hive基本概念1.1 什么是HiveHive：由Facebook开源用于解决海量结构化日志的数据统计。 Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能。 本质是：将HQL转化成MapReduce程序（所说他是基于Hadoop） 1）Hive处理的数据存储在HDFS（hive元数据存储在用户配置的数据库里面） 2）Hive分析数据底层的">
<meta name="keywords" content="hive,数据仓库工具">
<meta property="og:type" content="article">
<meta property="og:title" content="hive总结">
<meta property="og:url" content="http://kingge.top/2018/05/16/hive总结/index.html">
<meta property="og:site_name" content="King哥">
<meta property="og:description" content="一 Hive基本概念1.1 什么是HiveHive：由Facebook开源用于解决海量结构化日志的数据统计。 Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能。 本质是：将HQL转化成MapReduce程序（所说他是基于Hadoop） 1）Hive处理的数据存储在HDFS（hive元数据存储在用户配置的数据库里面） 2）Hive分析数据底层的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509172339054.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509172559212.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509172636573.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509172852105.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509172928250.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509172937505.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509173442759.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509173508986.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509173552490.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509173610908.png">
<meta property="og:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509173744714.png">
<meta property="og:updated_time" content="2020-05-09T09:39:59.207Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hive总结">
<meta name="twitter:description" content="一 Hive基本概念1.1 什么是HiveHive：由Facebook开源用于解决海量结构化日志的数据统计。 Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能。 本质是：将HQL转化成MapReduce程序（所说他是基于Hadoop） 1）Hive处理的数据存储在HDFS（hive元数据存储在用户配置的数据库里面） 2）Hive分析数据底层的">
<meta name="twitter:image" content="http://kingge.top/2018/05/16/hive总结/image-20200509172339054.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://kingge.top/2018/05/16/hive总结/"/>





  <title>hive总结 | King哥</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">King哥</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">To know everything, no words don't talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-picture">
          <a href="/picture/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            照片
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kingge.top/2018/05/16/hive总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeremy Kinge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">hive总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-16T00:00:00+08:00">
                2018-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">hadoop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  32,034
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  134
                </span>
              
            </div>
          

          

		  
		  
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一-Hive基本概念"><a href="#一-Hive基本概念" class="headerlink" title="一 Hive基本概念"></a>一 Hive基本概念</h1><h2 id="1-1-什么是Hive"><a href="#1-1-什么是Hive" class="headerlink" title="1.1 什么是Hive"></a>1.1 什么是Hive</h2><p>Hive：由Facebook开源<strong>用于解决海量结构化日志的数据统计</strong>。</p>
<p>Hive是基于Hadoop的一个<strong>数据仓库工具</strong>，可以将<strong>结构化的数据文件映射为一张表</strong>，并提供类SQL查询功能。</p>
<p>本质是：<strong>将HQL转化成MapReduce程序（所说他是基于Hadoop）</strong></p>
<p>1）Hive处理的数据存储在HDFS（hive元数据存储在用户配置的数据库里面）</p>
<p>2）Hive分析数据底层的实现是MapReduce</p>
<p>3）执行程序运行在Yarn上</p>
<h2 id="1-2-Hive的优缺点"><a href="#1-2-Hive的优缺点" class="headerlink" title="1.2 Hive的优缺点"></a>1.2 Hive的优缺点</h2><h3 id="1-2-1-优点"><a href="#1-2-1-优点" class="headerlink" title="1.2.1 优点"></a>1.2.1 优点</h3><p>1）操作接口采用类SQL语法，提供快速开发的能力（简单、容易上手）</p>
<p>2）避免了去写MapReduce，减少开发人员的学习成本。</p>
<p>3）Hive的执行延迟比较高，<strong>因此Hive常用于数据分析，对实时性要求不高的场合；（mysql实时性就比较快，但是如果数据量很大-上亿，那么mysql就会崩溃-所以一般业务场景是hive和mysql 配合使用）</strong></p>
<p>4）Hive优势在于处理大数据，<strong>对于处理小数据没有优势，因为Hive的执行延迟比较高。</strong></p>
<p>5）Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。</p>
<h3 id="1-2-2-缺点"><a href="#1-2-2-缺点" class="headerlink" title="1.2.2 缺点"></a>1.2.2 缺点</h3><p>1）Hive的HQL表达能力有限（<strong><em>也就是说，部分复杂的业务场景，需要用户自己实现***</em></strong>MapReduce***）</p>
<p>（1）迭代式算法无法表达</p>
<p>（2）数据挖掘方面不擅长</p>
<p>2）Hive的效率比较低</p>
<p>（1）Hive自动生成的MapReduce作业，通常情况下不够智能化</p>
<p>（2）Hive调优比较困难，粒度较粗</p>
<h2 id="1-3-Hive架构原理（图要记住）"><a href="#1-3-Hive架构原理（图要记住）" class="headerlink" title="1.3 Hive架构原理（图要记住）"></a>1.3 Hive架构原理（图要记住）</h2><p>​         <img src="/2018/05/16/hive总结/image-20200509172339054.png" alt="image-20200509172339054">       </p>
<p>​    如图中所示，Hive通过给用户提供的一系列交互接口，接收到用户的指令(SQL)，使用自己的Driver，结合元数据(MetaStore)，将这些指令翻译成MapReduce，提交到Hadoop中执行，最后，将执行返回的结果输出到用户交互接口。</p>
<p>1）用户接口：Client</p>
<p>CLI（hive shell）、JDBC/ODBC(java访问hive)、WEBUI（浏览器访问hive）</p>
<p>2）元数据：Metastore</p>
<p>元数据包括：表名、表所属的数据库（默认是default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等；</p>
<p><strong>默认存储在自带的derby数据库中，推荐使用MySQL存储Metastore</strong></p>
<p>3）Hadoop</p>
<p>使用HDFS进行存储，使用MapReduce进行计算。</p>
<p>4）驱动器：Driver</p>
<p>（1）解析器（SQL Parser）：将SQL字符串转换成抽象语法树AST，这一步一般都用第三方工具库完成，比如antlr；对AST进行语法分析，比如表是否存在、字段是否存在、SQL语义是否有误。</p>
<p>（2）编译器（Physical Plan）：将AST编译生成逻辑执行计划。</p>
<p>（3）优化器（Query Optimizer）：对逻辑执行计划进行优化。</p>
<p>（4）执行器（Execution）：把逻辑执行计划转换成可以运行的物理计划。对于Hive来说，就是MR/Spark。</p>
<h2 id="1-4-Hive和数据库比较"><a href="#1-4-Hive和数据库比较" class="headerlink" title="1.4 Hive和数据库比较"></a>1.4 Hive和数据库比较</h2><p>由于 Hive 采用了类似SQL 的查询语言 HQL(Hive Query Language)，因此很容易将 Hive 理解为数据库。其实从结构上来看，Hive 和数据库除了拥有类似的查询语言，再无类似之处。本文将从多个方面来阐述 Hive 和数据库的差异。数据库可以用在 Online 的应用中，但是Hive 是为数据仓库而设计的，清楚这一点，有助于从应用角度理解 Hive 的特性。</p>
<h3 id="1-4-1-查询语言"><a href="#1-4-1-查询语言" class="headerlink" title="1.4.1 查询语言"></a>1.4.1 查询语言</h3><p>由于SQL被广泛的应用在数据仓库中，因此，专门针对Hive的特性设计了类SQL的查询语言HQL。熟悉SQL开发的开发者可以很方便的使用Hive进行开发。</p>
<h3 id="1-4-2-数据存储位置"><a href="#1-4-2-数据存储位置" class="headerlink" title="1.4.2 数据存储位置"></a>1.4.2 数据存储位置</h3><p>Hive 是建立在 Hadoop 之上的，所有 Hive 的数据都是存储在 HDFS 中的。而数据库则可以将数据保存在块设备或者本地文件系统中。</p>
<h3 id="1-4-3-数据更新"><a href="#1-4-3-数据更新" class="headerlink" title="1.4.3 数据更新"></a>1.4.3 数据更新</h3><p>由于Hive是针对数据仓库应用设计的，而<strong>数据仓库的内容是读多写少的</strong>。因此，<strong>Hive中不支持对数据的改写和添加，所有的数据都是在加载的时候确定好的</strong>。而数据库中的数据通常是需要经常进行修改的，因此可以使用 INSERT INTO … VALUES 添加数据，使用 UPDATE … SET修改数据。</p>
<h3 id="1-4-4-索引"><a href="#1-4-4-索引" class="headerlink" title="1.4.4 索引"></a>1.4.4 索引</h3><p>Hive在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此也没有对数据中的某些Key建立索引。<strong><em>Hive***</em></strong>要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高*<strong>。由于 MapReduce 的引入， Hive 可以并行访问数据，因此即使没有索引，对于<a href="http://lib.csdn.net/base/hadoop" target="_blank" rel="external">大数据</a>量的访问，Hive 仍然可以体现出优势。数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。*</strong>由于数据的访问延迟较高，决定了*<strong> *</strong>Hive*<strong> *</strong>不适合在线数据查询。***</p>
<h3 id="1-4-5-执行"><a href="#1-4-5-执行" class="headerlink" title="1.4.5 执行"></a>1.4.5 执行</h3><p>Hive中大多数查询的执行是通过 Hadoop 提供的 MapReduce 来实现的。而数据库通常有自己的执行引擎。</p>
<h3 id="1-4-6-执行延迟"><a href="#1-4-6-执行延迟" class="headerlink" title="1.4.6 执行延迟"></a>1.4.6 执行延迟</h3><p>Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致 Hive 执行延迟高的因素是 MapReduce框架。由于MapReduce 本身具有较高的延迟，因此在利用MapReduce 执行Hive查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。</p>
<h3 id="1-4-7-可扩展性"><a href="#1-4-7-可扩展性" class="headerlink" title="1.4.7 可扩展性"></a>1.4.7 可扩展性</h3><p>由于Hive是建立在Hadoop之上的，因此Hive的可扩展性是和Hadoop的可扩展性是一致的（世界上最大的Hadoop 集群在 Yahoo!，2009年的规模在4000 台节点左右）。而数据库由于 ACID 语义的严格限制，扩展行非常有限。目前最先进的并行数据库 <a href="http://lib.csdn.net/base/oracle" target="_blank" rel="external">Oracle</a> 在理论上的扩展能力也只有100台左右。</p>
<h3 id="1-4-8-数据规模"><a href="#1-4-8-数据规模" class="headerlink" title="1.4.8 数据规模"></a>1.4.8 数据规模</h3><p>由于Hive建立在集群上并可以利用MapReduce进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。</p>
<h3 id="1-4-9-hive元数据"><a href="#1-4-9-hive元数据" class="headerlink" title="1.4.9 hive元数据"></a>1.4.9 hive元数据</h3><p><a href="https://blog.csdn.net/xjp8587/article/details/81411879" target="_blank" rel="external">https://blog.csdn.net/xjp8587/article/details/81411879</a></p>
<p><a href="https://www.cnblogs.com/qingyunzong/p/8710356.html" target="_blank" rel="external">https://www.cnblogs.com/qingyunzong/p/8710356.html</a></p>
<p>Hive 的元数据信息通常存储在关系型数据库中，常用MySQL数据库作为元数据库管理（因为使用默认的derby数据库，只能提供给一个client使用-参见2.4）</p>
<p>里面存储了，hive数据库仓库相关的信息，例如，hive版本信息，创建了那些表，数据库或者表数据在hdfs存储的位置等等。</p>
<h1 id="二-Hive安装环境准备"><a href="#二-Hive安装环境准备" class="headerlink" title="二 Hive安装环境准备"></a>二 Hive安装环境准备</h1><h2 id="2-1-Hive安装地址"><a href="#2-1-Hive安装地址" class="headerlink" title="2.1 Hive安装地址"></a>2.1 Hive安装地址</h2><p>1）Hive官网地址：</p>
<p><a href="http://hive.apache.org/" target="_blank" rel="external">http://hive.apache.org/</a></p>
<p>2）文档查看地址：</p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/GettingStarted</a></p>
<p>3）下载地址：</p>
<p><a href="http://archive.apache.org/dist/hive/" target="_blank" rel="external">http://archive.apache.org/dist/hive/</a></p>
<p>4）github地址：</p>
<p><a href="https://github.com/apache/hive" target="_blank" rel="external">https://github.com/apache/hive</a></p>
<h2 id="2-2-Hive安装部署"><a href="#2-2-Hive安装部署" class="headerlink" title="2.2 Hive安装部署"></a>2.2 Hive安装部署</h2><p>1）Hive安装及配置</p>
<p>（1）把apache-hive-1.2.1-bin.tar.gz上传到linux的/opt/software目录下</p>
<p>（2）解压apache-hive-1.2.1-bin.tar.gz到/opt/module/目录下面</p>
<p>[kingge@hadoop102 software]$ tar -zxvf apache-hive-1.2.1-bin.tar.gz -C /opt/module/</p>
<p>（3）修改apache-hive-1.2.1-bin.tar.gz的名称为hive</p>
<p>[kingge@hadoop102 module]$ mv apache-hive-1.2.1-bin/ hive</p>
<p>（4）修改/opt/module/hive/conf目录下的hive-env.sh.template名称为hive-env.sh</p>
<p>[kingge@hadoop102 conf]$ mv hive-env.sh.template hive-env.sh</p>
<p>​    （5）配置hive-env.sh文件</p>
<p>​    （a）配置HADOOP_HOME路径</p>
<p>export HADOOP_HOME=/opt/module/hadoop-2.7.2</p>
<p>​    （b）配置HIVE_CONF_DIR路径</p>
<p>export HIVE_CONF_DIR=/opt/module/hive/conf</p>
<p>2）Hadoop集群配置</p>
<p>（1）必须启动hdfs和yarn</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ sbin/start-dfs.sh</p>
<p>[kingge@hadoop103 hadoop-2.7.2]$ sbin/start-yarn.sh</p>
<p>（2）在HDFS上创建/tmp和/user/hive/warehouse两个目录并修改他们的同组权限可写</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -mkdir /tmp</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -mkdir -p /user/hive/warehouse</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -chmod g+w /tmp</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ bin/hadoop fs -chmod g+w /user/hive/warehouse</p>
<p>3）Hive基本操作（<strong><em>默认操作***</em></strong>hive*<strong>*</strong>创建的default*<strong>*</strong>数据库***）</p>
<p>（1）启动hive</p>
<p>​    [kingge@hadoop102 hive]$ bin/hive</p>
<p>​    （2）查看数据库</p>
<p>​    hive&gt;show databases;</p>
<p>（3）打开默认数据库</p>
<p>​    hive&gt;use default;</p>
<p>（4）显示default数据库中的表</p>
<p>​    hive&gt;show tables;</p>
<p>（5）创建一张表</p>
<p>​    hive&gt; create table student(id int, name string) ;</p>
<p>（6）显示数据库中有几张表</p>
<p>​    hive&gt;show tables;</p>
<p>（7）查看表的结构</p>
<p>​    hive&gt;desc student;</p>
<p>（8）向表中插入数据</p>
<p>hive&gt; insert into student values(1000,”ss”);</p>
<p>（9）查询表中数据</p>
<p>​    hive&gt; select * from student;</p>
<p>（10）退出hive</p>
<p>​    hive&gt; quit;</p>
<p>你会发现，执行inset操作的时候实际上他是启动了一个mr程序-<strong><em>任何sql***</em></strong>操作都会转化成MapReduce*<strong>*</strong>来进行。***</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172559212.png" alt="image-20200509172559212"></p>
<h2 id="2-3-将本地文件导入Hive案例"><a href="#2-3-将本地文件导入Hive案例" class="headerlink" title="2.3 将本地文件导入Hive案例"></a>2.3 将本地文件导入Hive案例</h2><p><strong>需求</strong>：将本地/opt/module/datas/student.txt这个目录下的数据导入到hive的student(id int, name string)表中。</p>
<p>1）数据准备：在/opt/module/datas/student.txt这个目录下准备数据</p>
<p>（1）在/opt/module/目录下创建datas</p>
<p>​    [kingge@hadoop102 module]$ mkdir datas</p>
<p>（2）在/opt/module/datas/目录下创建student.txt文件并添加数据</p>
<p>​    [kingge@hadoop102 datas]$ touch student.txt</p>
<p>[kingge@hadoop102 datas]$ vi student.txt</p>
<p>1001    zhangshan</p>
<p>1002    lishi</p>
<p>1003    zhaoliu</p>
<p>注意以tab键间隔。</p>
<p>2）Hive实际操作</p>
<p>（1）启动hive</p>
<p>​    [kingge@hadoop102 hive]$ bin/hive</p>
<p>（2）显示数据库</p>
<p>hive&gt;show databases;</p>
<p>（3）使用default数据库</p>
<p>​    hive&gt;use default;</p>
<p>（4）显示default数据库中的表</p>
<p>​    hive&gt;show tables;</p>
<p>（5）删除已创建的student表</p>
<p>hive&gt; drop table student;</p>
<p>（6）创建student表, 并声明文件分隔符’\t’</p>
<p>​    hive&gt; create table student(id int, name string) ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘\t’;</p>
<p>（7）加载/opt/module/datas/student.txt 文件到student数据库表中。</p>
<p>​    hive&gt; load data local inpath ‘/opt/module/datas/student.txt’ into table student;</p>
<p>（8）Hive查询结果</p>
<p>hive&gt; select * from student;</p>
<p>OK</p>
<p>1001    zhangshan</p>
<p>1002    lishi</p>
<p>1003    zhaoliu</p>
<p>Time taken: 0.266 seconds, Fetched: 3 row(s)</p>
<h2 id="2-4-遇到的问题（默认Derby数据库）"><a href="#2-4-遇到的问题（默认Derby数据库）" class="headerlink" title="2.4 遇到的问题（默认Derby数据库）"></a>2.4 遇到的问题（默认Derby数据库）</h2><p>再打开一个客户端窗口启动hive，会产生java.sql.SQLException异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</div><div class="line">        at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:522)</div><div class="line">        at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:677)</div><div class="line">        at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:621)</div><div class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</div><div class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">        at java.lang.reflect.Method.invoke(Method.java:606)</div><div class="line">        at org.apache.hadoop.util.RunJar.run(RunJar.java:221)</div><div class="line">        at org.apache.hadoop.util.RunJar.main(RunJar.java:136)</div><div class="line">Caused by: java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</div><div class="line">        at org.apache.hadoop.hive.metastore.MetaStoreUtils.newInstance(MetaStoreUtils.java:1523)</div><div class="line">        at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.&lt;init&gt;(RetryingMetaStoreClient.java:86)</div><div class="line">        at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.getProxy(RetryingMetaStoreClient.java:132)</div><div class="line">        at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.getProxy(RetryingMetaStoreClient.java:104)</div><div class="line">        at org.apache.hadoop.hive.ql.metadata.Hive.createMetaStoreClient(Hive.java:3005)</div><div class="line">        at org.apache.hadoop.hive.ql.metadata.Hive.getMSC(Hive.java:3024)</div><div class="line">        at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:503)</div><div class="line">        ... 8 more</div></pre></td></tr></table></figure>
<p>原因是，Metastore默认存储在自带的derby数据库中，推荐使用MySQL存储Metastore;</p>
<p>官方文档已经说明，这个默认数据库仅限于测试使用，而且只能够允许一个客户端访问</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172636573.png" alt="image-20200509172636573"></p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+Metastore+3.0+Administration#AdminManualMetastore3.0Administration-Option2:ExternalRDBMS" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/AdminManual+Metastore+3.0+Administration#AdminManualMetastore3.0Administration-Option2:ExternalRDBMS</a></p>
<h2 id="2-4-MySql安装"><a href="#2-4-MySql安装" class="headerlink" title="2.4 MySql安装"></a>2.4 MySql安装</h2><h3 id="2-4-1-安装包准备"><a href="#2-4-1-安装包准备" class="headerlink" title="2.4.1 安装包准备"></a>2.4.1 安装包准备</h3><p>1）查看mysql是否安装，如果安装了，卸载mysql</p>
<p>​    （1）查看</p>
<p>​    [root@hadoop102 桌面]# rpm -qa|grep mysql</p>
<p>mysql-libs-5.1.73-7.el6.x86_64</p>
<p>​    （2）卸载</p>
<p>​    [root@hadoop102 桌面]# rpm -e –nodeps mysql-libs-5.1.73-7.el6.x86_64</p>
<p>2）解压mysql-libs.zip文件到当前目录</p>
<p>[root@hadoop102 software]# unzip mysql-libs.zip</p>
<p>​    [root@hadoop102 software]# ls</p>
<p>mysql-libs.zip</p>
<p>mysql-libs         </p>
<p>3）进入到mysql-libs文件夹下，并设置当前用户执行权限</p>
<p>[root@hadoop102 mysql-libs]# ll</p>
<p>总用量 76048</p>
<p>-rw-r–r–. 1 root root 18509960 3月 26 2015 MySQL-client-5.6.24-1.el6.x86_64.rpm</p>
<p>-rw-r–r–. 1 root root 3575135 12月 1 2013 mysql-connector-java-5.1.27.tar.gz</p>
<p>-rw-r–r–. 1 root root 55782196 3月 26 2015 MySQL-server-5.6.24-1.el6.x86_64.rpm</p>
<p>[root@hadoop102 mysql-libs]# chmod u+x ./*</p>
<p>[root@hadoop102 mysql-libs]# ll</p>
<p>总用量 76048</p>
<p>-rwxr–r–. 1 root root 18509960 3月 26 2015 MySQL-client-5.6.24-1.el6.x86_64.rpm</p>
<p>-rwxr–r–. 1 root root 3575135 12月 1 2013 mysql-connector-java-5.1.27.tar.gz</p>
<p>-rwxr–r–. 1 root root 55782196 3月 26 2015 MySQL-server-5.6.24-1.el6.x86_64.rpm</p>
<h3 id="2-4-2-安装MySql服务器（建议使用root用户进行操作-涉及到某些目录）"><a href="#2-4-2-安装MySql服务器（建议使用root用户进行操作-涉及到某些目录）" class="headerlink" title="2.4.2 安装MySql服务器（建议使用root用户进行操作-涉及到某些目录）"></a>2.4.2 安装MySql服务器（<em>建议使用<strong>root</strong>用户进行操作<strong>-</strong>涉及到某些目录</em>）</h3><p>1）安装mysql服务端</p>
<p>[<strong><em>root\</em></strong>@hadoop102 mysql-libs]# rpm -ivh MySQL-server-5.6.24-1.el6.x86_64.rpm</p>
<p>2）查看产生的随机密码</p>
<p>[<strong><em>root\</em></strong>@hadoop102 mysql-libs]# cat /root/.mysql_secret</p>
<p>​    OEXaQuS8IWkG19Xs</p>
<p>3）查看mysql状态</p>
<p>​    [root@hadoop102 mysql-libs]# service mysql status</p>
<p>4）启动mysql</p>
<p>​    [root@hadoop102 mysql-libs]# service mysql start</p>
<h3 id="2-4-3-安装MySql客户端"><a href="#2-4-3-安装MySql客户端" class="headerlink" title="2.4.3 安装MySql客户端"></a>2.4.3 安装MySql客户端</h3><p>1）安装mysql客户端</p>
<p>​    [root@hadoop102 mysql-libs]# rpm -ivh MySQL-client-5.6.24-1.el6.x86_64.rpm</p>
<p>2）链接mysql</p>
<p>​    [root@hadoop102 mysql-libs]# mysql -uroot -pOEXaQuS8IWkG19Xs</p>
<p>3）修改密码</p>
<p>​    mysql&gt;SET PASSWORD=PASSWORD(‘000000’);</p>
<p>4）退出mysql</p>
<p>mysql&gt;exit</p>
<h3 id="2-4-4-MySql中user表中主机配置"><a href="#2-4-4-MySql中user表中主机配置" class="headerlink" title="2.4.4 MySql中user表中主机配置"></a>2.4.4 MySql中user表中主机配置</h3><p><strong><em>配置只要是root***</em></strong>用户+*<strong>*</strong>密码，在任何主机上都能登录MySQL*<strong>*</strong>数据库。***</p>
<p><strong><em>详情参见这个网址： <a href="https://blog.csdn.net/lthirdonel/article/details/79011033\" target="_blank" rel="external">https://blog.csdn.net/lthirdonel/article/details/79011033\</a></em></strong></p>
<p>1）进入mysql</p>
<p>[root@hadoop102 mysql-libs]# mysql -uroot -p000000</p>
<p>2）显示数据库</p>
<p>mysql&gt;show databases;</p>
<p>3）使用mysql数据库</p>
<p>mysql&gt;use mysql;</p>
<p>4）展示mysql数据库中的所有表</p>
<p>mysql&gt;show tables;</p>
<p>5）展示user表的结构</p>
<p>​    mysql&gt;desc user;</p>
<p>6）查询user表</p>
<p>mysql&gt;select User, Host, Password from user;</p>
<p>7）修改user表，把Host表内容修改为%</p>
<p>​    mysql&gt;update user set host=’%’ where host=’localhost’;</p>
<p>8）删除root用户的其他host</p>
<p>mysql&gt;delete from user where Host=’hadoop102 ‘;</p>
<p>mysql&gt;delete from user where Host=’127.0.0.1’;</p>
<p>mysql&gt;delete from user where Host=’::1’;</p>
<p>9）刷新</p>
<p>​    mysql&gt;flush privileges;</p>
<p>10）退出</p>
<p>mysql&gt; quit;</p>
<h2 id="2-5-Hive元数据配置到MySql"><a href="#2-5-Hive元数据配置到MySql" class="headerlink" title="2.5 Hive元数据配置到MySql"></a>2.5 Hive元数据配置到MySql</h2><h3 id="2-5-1-驱动拷贝"><a href="#2-5-1-驱动拷贝" class="headerlink" title="2.5.1 驱动拷贝"></a>2.5.1 驱动拷贝</h3><p>1）在/opt/software/mysql-libs目录下解压mysql-connector-java-5.1.27.tar.gz驱动包</p>
<p>​    [root@hadoop102 mysql-libs]# tar -zxvf mysql-connector-java-5.1.27.tar.gz</p>
<p>2）拷贝/opt/software/mysql-libs/mysql-connector-java-5.1.27目录下的</p>
<p>mysql-connector-java-5.1.27-bin.jar到/opt/module/hive/lib/</p>
<p>[root@hadoop102 mysql-connector-java-5.1.27]# cp mysql-connector-java-5.1.27-bin.jar /opt/module/hive/lib/</p>
<h3 id="2-5-2-配置Metastore到MySql"><a href="#2-5-2-配置Metastore到MySql" class="headerlink" title="2.5.2 配置Metastore到MySql"></a>2.5.2 配置Metastore到MySql</h3><p>1）在/opt/module/hive/conf目录下创建一个hive-site.xml</p>
<p>[kingge@hadoop102 conf]$ touch hive-site.xml</p>
<p>[kingge@hadoop102 conf]$ vi hive-site.xml</p>
<p>2）根据官方文档配置参数，拷贝数据到hive-site.xml文件中。</p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/AdminManual+MetastoreAdmin" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/AdminManual+MetastoreAdmin</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">	  &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</div><div class="line">	  &lt;value&gt;jdbc:mysql://hadoop102:3306/metastore?createDatabaseIfNotExist=true&lt;/value&gt;</div><div class="line">	  &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line"></div><div class="line">	&lt;property&gt;</div><div class="line">	  &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</div><div class="line">	  &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</div><div class="line">	  &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line"></div><div class="line">	&lt;property&gt;</div><div class="line">	  &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</div><div class="line">	  &lt;value&gt;root&lt;/value&gt;</div><div class="line">	  &lt;description&gt;username to use against metastore database&lt;/description&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line"></div><div class="line">	&lt;property&gt;</div><div class="line">	  &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</div><div class="line">	  &lt;value&gt;000000&lt;/value&gt;</div><div class="line">	  &lt;description&gt;password to use against metastore database&lt;/description&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<p>3）配置完毕后，如果启动hive异常，可以重新启动虚拟机。（重启后，别忘了启动hadoop集群）</p>
<h3 id="2-5-3-多窗口启动Hive测试"><a href="#2-5-3-多窗口启动Hive测试" class="headerlink" title="2.5.3 多窗口启动Hive测试"></a>2.5.3 多窗口启动Hive测试</h3><p>1）先启动MySQL</p>
<p>[kingge@hadoop102 mysql-libs]$ mysql -uroot -p000000</p>
<p>​    查看有几个数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; show databases;</div><div class="line"></div><div class="line">+--------------------+</div><div class="line"></div><div class="line">| Database      |</div><div class="line"></div><div class="line">+--------------------+</div><div class="line"></div><div class="line">| information_schema |</div><div class="line"></div><div class="line">| mysql       |</div><div class="line"></div><div class="line">| performance_schema |</div><div class="line"></div><div class="line">| test        |</div><div class="line"></div><div class="line">+-----------</div><div class="line">---------+</div></pre></td></tr></table></figure>
<p>2）再次打开多个窗口，分别启动hive</p>
<p>[kingge@hadoop102 hive]$ bin/hive</p>
<p>3）启动hive后，回到MySQL窗口查看数据库，显示增加了metastore数据库</p>
<p>​    mysql&gt; show databases;</p>
<p>+——————–+</p>
<p>| Database      |</p>
<p>+——————–+</p>
<p>| information_schema |</p>
<p>| metastore     |</p>
<p>| mysql       |</p>
<p>| performance_schema |</p>
<p>| test        |</p>
<p>+——————–+</p>
<h2 id="2-6-Hive常用交互命令"><a href="#2-6-Hive常用交互命令" class="headerlink" title="2.6 Hive常用交互命令"></a>2.6 Hive常用交互命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[kingge@hadoop102 hive]$ bin/hive -help</div><div class="line">usage: hive</div><div class="line"> -d,--define &lt;key=value&gt;          Variable subsitution to apply to hive</div><div class="line">                                  commands. e.g. -d A=B or --define A=B</div><div class="line">    --database &lt;databasename&gt;     Specify the database to use</div><div class="line"> -e &lt;quoted-query-string&gt;         SQL from command line</div><div class="line"> -f &lt;filename&gt;                    SQL from files</div><div class="line"> -H,--help                        Print help information</div><div class="line">    --hiveconf &lt;property=value&gt;   Use value for given property</div><div class="line">    --hivevar &lt;key=value&gt;         Variable subsitution to apply to hive</div><div class="line">                                  commands. e.g. --hivevar A=B</div><div class="line"> -i &lt;filename&gt;                    Initialization SQL file</div><div class="line"> -S,--silent                      Silent mode in interactive shell</div><div class="line"> -v,--verbose                     Verbose mode (echo executed SQL to the console)</div></pre></td></tr></table></figure>
<p>1）“-e”不进入hive的交互窗口执行sql语句</p>
<p>[kingge@hadoop102 hive]$ bin/hive -e “select id from student;”</p>
<p>2）“-f”执行脚本中sql语句</p>
<p>​    （1）在/opt/module/datas目录下创建hivef.sql文件</p>
<p>​       [kingge@hadoop102 datas]$ touch hivef.sql</p>
<p>​       文件中写入正确的sql语句</p>
<p>​       select *from student;</p>
<p>​    （2）执行文件中的sql语句</p>
<p>[kingge@hadoop102 hive]$ bin/hive -f /opt/module/datas/hivef.sql</p>
<p>（3）执行文件中的sql语句并将结果写入文件中</p>
<p>[kingge@hadoop102 hive]$ bin/hive -f /opt/module/datas/hivef.sql &gt; /opt/module/datas/hive_result.txt</p>
<h2 id="2-7-Hive其他命令操作"><a href="#2-7-Hive其他命令操作" class="headerlink" title="2.7 Hive其他命令操作"></a>2.7 Hive其他命令操作</h2><p>1）退出hive窗口：   </p>
<p>hive(default)&gt;exit;</p>
<p>hive(default)&gt;quit;</p>
<p>在新版的oracle中没区别了，在以前的版本是有的：</p>
<p>exit:先隐性提交数据，再退出；</p>
<p>quit:不提交数据，退出；</p>
<p>2）在hive cli命令窗口中如何查看hdfs文件系统</p>
<p>​    hive(default)&gt;dfs -ls /;</p>
<p>3）在hive cli命令窗口中如何查看hdfs本地系统</p>
<p>hive(default)&gt;! ls /opt/module/datas;</p>
<p>4）查看在hive中输入的所有历史命令</p>
<p>​    （1）进入到当前用户的根目录/root或/home/kingge</p>
<p>​    （2）查看. hivehistory文件</p>
<p>[kingge@hadoop102 ~]$ cat .hivehistory</p>
<h2 id="2-8-Hive常见属性配置（重要）"><a href="#2-8-Hive常见属性配置（重要）" class="headerlink" title="2.8 Hive常见属性配置（重要）"></a>2.8 Hive常见属性配置（<em>重要</em>）</h2><h3 id="2-8-1-Hive数据仓库位置配置"><a href="#2-8-1-Hive数据仓库位置配置" class="headerlink" title="2.8.1 Hive数据仓库位置配置"></a>2.8.1 Hive数据仓库位置配置</h3><p>​    1）Default数据仓库的最原始位置是在hdfs上的：/user/hive/warehouse路径下</p>
<p>​     <strong><em>Hive***</em></strong>默认创建了一个名字为“default*<strong>*</strong>”的数据库，如果没有指明具体操作那个数据库，那么所有的操作针对的都是Default*<strong>*</strong>。所以我们在操作书写sql*<strong>*</strong>时，最好使用 use*<strong> *</strong>命令指明操作那个数据库。***</p>
<p>​    2）在仓库目录下，没有对默认的数据库default创建文件夹。如果某张表属于default数据库，直接在数据仓库目录下创建一个文件夹。</p>
<p>   这句话的意思是：</p>
<p>\1.    我们如果在default数据库创建了一张表，那么实际上就是在/user/hive/warehouse路径下，创建了一个以<strong><em>表名为名称的文件\</em></strong>。 <strong><em>Insert***</em></strong>如数据库表的数据会在该文件夹下面生成一个文件存储。每insert*<strong>*</strong>一次就会生成一个（名字一般是000000_0*<strong>*</strong>）,*<strong>*</strong>如果通过load*<strong>*</strong>的方式导入数据，那么存储数据文件就是load*<strong>*</strong>数据的那个文件名。***</p>
<p>例如 load data local inpath ‘/opt/module/datas/studentnto table default.student</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172852105.png" alt="image-20200509172852105"></p>
<p>\2.    如果我们创建了一个数据库，那么就会在 /user/hive/warehouse路径下创建</p>
<p>一个名字为数据库在HDFS上的默认存储路径是/user/hive/warehouse/数据库名.db。 的文件夹。</p>
<p>​    3）修改default数据仓库原始位置（将hive-default.xml.template如下配置信息拷贝到hive-site.xml文件中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">&lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;</div><div class="line">&lt;value&gt;/user/hive/warehouse&lt;/value&gt;</div><div class="line">&lt;description&gt;location of default database for the warehouse&lt;/description&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>配置同组用户有执行权限</p>
<p>bin/hdfs dfs -chmod g+w /user/hive/warehouse</p>
<h3 id="2-8-2-查询后信息显示配置"><a href="#2-8-2-查询后信息显示配置" class="headerlink" title="2.8.2 查询后信息显示配置"></a>2.8.2 查询后信息显示配置</h3><p>1）在hive-site.xml文件中添加如下配置信息，就可以实现显示当前数据库，以及查询表的头信息配置。（<strong><em>通过这项配置我们一颗额外的指导，启动***</em></strong>hive*<strong>*</strong>后默认*<strong>*</strong>use default*<strong> *</strong>数据库***）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">	&lt;name&gt;hive.cli.print.header&lt;/name&gt;</div><div class="line">	&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;property&gt;</div><div class="line">	&lt;name&gt;hive.cli.print.current.db&lt;/name&gt;</div><div class="line">	&lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
<p>​    2）重新启动hive，对比配置前后差异</p>
<p>（1）配置前</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172928250.png" alt="image-20200509172928250"></p>
<p>（2）配置后</p>
<p> <img src="/2018/05/16/hive总结/image-20200509172937505.png" alt="image-20200509172937505"></p>
<h3 id="2-8-3-Hive运行日志信息配置"><a href="#2-8-3-Hive运行日志信息配置" class="headerlink" title="2.8.3 Hive运行日志信息配置"></a>2.8.3 Hive运行日志信息配置</h3><p>1）Hive的log默认存放在/tmp/kingge/hive.log目录下（当前用户名下）。</p>
<p>2）修改hive的log存放日志到/opt/module/hive/logs</p>
<p>​    （1）修改/opt/module/hive/conf/hive-log4j.properties.template文件名称为</p>
<p>hive-log4j.properties</p>
<p>[kingge@hadoop102 conf]$ pwd</p>
<p>/opt/module/hive/conf</p>
<p>​       [kingge@hadoop102 conf]$ mv hive-log4j.properties.template hive-log4j.properties</p>
<p>​    （2）在hive-log4j.properties文件中修改log存放位置</p>
<p>hive.log.dir=/opt/module/hive/logs</p>
<h3 id="2-8-4-参数配置方式"><a href="#2-8-4-参数配置方式" class="headerlink" title="2.8.4 参数配置方式"></a>2.8.4 参数配置方式</h3><p>1）查看当前所有的配置信息</p>
<p>​    hive&gt;set;</p>
<p>2）参数的配置三种方式</p>
<p>​    （1）配置文件方式</p>
<p>默认配置文件：hive-default.xml</p>
<p>用户自定义配置文件：hive-site.xml</p>
<p>​    注意：用户自定义配置会覆盖默认配置。另外，Hive也会读入Hadoop的配置，因为Hive是作为Hadoop的客户端启动的，Hive的配置会覆盖Hadoop的配置。配置文件的设定<strong><em>对本机启动\</em></strong>的所有Hive进程都有效。</p>
<p>（2）命令行参数方式</p>
<p>启动Hive时，可以在命令行添加-hiveconf param=value来设定参数。</p>
<p>例如：</p>
<p>[kingge@hadoop103 hive]$ bin/hive -hiveconf mapred.reduce.tasks=10;</p>
<p>注意：仅对本次hive启动有效（退出当前hive client客户端，失效并恢复默认值）</p>
<p>查看参数设置：</p>
<p>hive (default)&gt; set mapred.reduce.tasks;</p>
<p>（3）参数声明方式</p>
<p>可以在HQL中使用SET关键字设定参数</p>
<p>例如：</p>
<p>hive (default)&gt; set mapred.reduce.tasks=100;</p>
<p>注意：仅对本次hive启动有效。（退出当前hive client客户端，失效并恢复默认值）</p>
<p>查看参数设置</p>
<p>hive (default)&gt; set mapred.reduce.tasks;</p>
<p>上述三种设定方式的优先级依次递增。即<strong><em>配置文件***</em></strong>&lt;*<strong>*</strong>命令行参数*<strong>*</strong>&lt;*<strong>*</strong>参数声明*<strong>。*</strong>注意某些系统级的参数，例如*<strong>*</strong>log4j*<strong>*</strong>相关的设定，必须用前两种方式设定，因为那些参数的读取在会话建立以前已经完成了。***</p>
<h1 id="三-Hive数据类型"><a href="#三-Hive数据类型" class="headerlink" title="三 Hive数据类型"></a>三 Hive数据类型</h1><h2 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h2><table>
<thead>
<tr>
<th>Hive数据类型</th>
<th>Java数据类型</th>
<th>长度</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>byte</td>
<td>1byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>SMALINT</td>
<td>short</td>
<td>2byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>INT</td>
<td>int</td>
<td>4byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BIGINT</td>
<td>long</td>
<td>8byte有符号整数</td>
<td>20</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>boolean</td>
<td>布尔类型，true或者false</td>
<td>TRUE FALSE</td>
</tr>
<tr>
<td>FLOAT</td>
<td>float</td>
<td>单精度浮点数</td>
<td>3.14159</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>double</td>
<td>双精度浮点数</td>
<td>3.14159</td>
</tr>
<tr>
<td>STRING</td>
<td>string</td>
<td>字符系列。可以指定字符集。可以使用单引号或者双引号。</td>
<td>‘now is the  time’ “for all good men”</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td></td>
<td>时间类型</td>
<td></td>
</tr>
<tr>
<td>BINARY</td>
<td></td>
<td>字节数组</td>
</tr>
</tbody>
</table>
<p>​      对于Hive的String类型相当于数据库的varchar类型，该类型是一个可变的字符串，不过它不能声明其中最多能存储多少个字符，理论上它可以存储2GB的字符数。</p>
<h2 id="3-2-集合数据类型"><a href="#3-2-集合数据类型" class="headerlink" title="3.2 集合数据类型"></a>3.2 集合数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>语法示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRUCT</td>
<td>和c语言中的struct类似，都可以通过“点”符号访问元素内容。例如，如果某个列的数据类型是STRUCT{first STRING, last STRING},那么第1个元素可以通过字段.first来引用。</td>
<td>struct()</td>
</tr>
<tr>
<td>MAP</td>
<td>MAP是一组键-值对元组集合，使用数组表示法可以访问数据。例如，如果某个列的数据类型是MAP，其中键-&gt;值对是’first’-&gt;’John’和’last’-&gt;’Doe’，那么可以通过字段名[‘last’]获取最后一个元素</td>
<td>map()</td>
</tr>
<tr>
<td>ARRAY</td>
<td>数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素，每个数组元素都有一个编号，编号从零开始。例如，数组值为[‘John’, ‘Doe’]，那么第2个元素可以通过数组名[1]进行引用。</td>
<td>Array()</td>
</tr>
</tbody>
</table>
<p>Hive有三种复杂数据类型ARRAY、MAP 和 STRUCT。ARRAY和MAP与Java中的Array和Map类似，而STRUCT与C语言中的Struct类似，它封装了一个命名字段集合，复杂数据类型允许任意层次的嵌套。</p>
<p>案例实操</p>
<p>1）假设某表有如下一行，我们用JSON格式来表示其数据结构。在Hive下访问的格式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;songsong&quot;,</div><div class="line">    &quot;friends&quot;: [&quot;bingbing&quot; , &quot;lili&quot;] ,       //列表Array, </div><div class="line">    &quot;children&quot;: &#123;                      //键值Map,</div><div class="line">        &quot;xiao song&quot;: 18 ,</div><div class="line">        &quot;xiaoxiao song&quot;: 19</div><div class="line">    &#125;</div><div class="line">    &quot;address&quot;: &#123;                      //结构Struct,</div><div class="line">        &quot;street&quot;: &quot;hui long guan&quot; ,</div><div class="line">        &quot;city&quot;: &quot;beijing&quot; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2）基于上述数据结构，我们在Hive里创建对应的表，并导入数据。 </p>
<p>创建本地测试文件test.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">songsong,bingbing_lili,xiao song:18_xiaoxiao song:19,hui long guan_beijing</div><div class="line">yangyang,caicai_susu,xiao yang:18_xiaoxiao yang:19,chao yang_beijing</div></pre></td></tr></table></figure>
<p>注意，MAP，STRUCT和ARRAY里的元素间关系都可以用同一个字符表示，这里用“_”。</p>
<p>3）Hive上创建测试表test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create table test(</div><div class="line">name string,</div><div class="line">friends array&lt;string&gt;,</div><div class="line">children map&lt;string, int&gt;,</div><div class="line">address struct&lt;street:string, city:string&gt;</div><div class="line">)</div><div class="line">row format delimited fields terminated by &apos;,&apos;</div><div class="line">collection items terminated by &apos;_&apos;</div><div class="line">map keys terminated by &apos;:&apos;</div><div class="line">lines terminated by &apos;\n&apos;;</div></pre></td></tr></table></figure>
<p>字段解释：</p>
<p>row format delimited fields terminated by ‘,’ – 列分隔符</p>
<p>collection items terminated by ‘_’    –MAP STRUCT 和 ARRAY 的分隔符(数据分割符号)</p>
<p>map keys terminated by ‘:’             – MAP中的key与value的分隔符</p>
<p>lines terminated by ‘\n’;               – 行分隔符</p>
<p>4）导入文本数据到测试表</p>
<p>  hive  (default)&gt; load data local inpath ‘/opt/module/datas/test.txt’ into table  test;  </p>
<p>5）访问三种集合列里的数据，以下分别是ARRAY，MAP，STRUCT的访问方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive (default)&gt; select friends[1],children[&apos;xiao song&apos;],address.city from test where name=&quot;songsong&quot;;</div><div class="line">OK</div><div class="line">_c0     _c1     city</div><div class="line">lili    18      beijing</div><div class="line">Time taken: 0.076 seconds, Fetched: 1 row(s)</div></pre></td></tr></table></figure>
<h2 id="3-3-类型转化"><a href="#3-3-类型转化" class="headerlink" title="3.3 类型转化"></a>3.3 类型转化</h2><p>Hive的原子数据类型是可以进行隐式转换的，类似于Java的类型转换，例如某表达式使用INT类型，TINYINT会自动转换为INT类型，但是Hive不会进行反向转化，例如，某表达式使用TINYINT类型，INT不会自动转换为TINYINT类型，它会返回错误，除非使用CAST操作。</p>
<p>1）隐式类型转换规则如下。</p>
<p>（1）任何整数类型都可以隐式地转换为一个范围更广的类型，如TINYINT可以转换成INT，INT可以转换成BIGINT。</p>
<p>（2）所有整数类型、FLOAT和STRING类型都可以隐式地转换成DOUBLE。</p>
<p>（3）TINYINT、SMALLINT、INT都可以转换为FLOAT。</p>
<p>（4）BOOLEAN类型不可以转换为任何其它的类型。</p>
<p>2）可以使用CAST操作显示进行数据类型转换，例如CAST(‘1’ AS INT)将把字符串’1’ 转换成整数1；如果强制类型转换失败，如执行CAST(‘X’ AS INT)，表达式返回空值 NULL。</p>
<h1 id="四-DDL数据定义"><a href="#四-DDL数据定义" class="headerlink" title="四 DDL数据定义"></a>四 DDL数据定义</h1><h2 id="4-1-创建数据库"><a href="#4-1-创建数据库" class="headerlink" title="4.1 创建数据库"></a>4.1 创建数据库</h2><p>1）创建一个数据库，数据库在HDFS上的默认存储路径是/user/hive/warehouse/*.db。</p>
<p>hive (default)&gt; create database db_hive;   //最终在HDFS中是/user/hive/warehouse/ db_hive.db。</p>
<p>2）避免要创建的数据库已经存在错误，增加if not exists判断。（标准写法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive&gt; create database db_hive;</div><div class="line">FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. Database db_hive already exi</div><div class="line">Sts</div><div class="line">hive (default)&gt; create database if not exists db_hive;</div></pre></td></tr></table></figure>
<p>3）创建一个数据库，指定数据库在HDFS上存放的位置</p>
<p>hive (default)&gt; create database db_hive2 location ‘/db_hive2.db’;</p>
<p>create database db_hive2 location ‘/ ‘; 不指明生成的文件夹名称，那么也会创建成功，只不过他没有像上面那样生成了一个文件夹（也就是访问HDFS根目录时，发现是空的），但是数据库已经创建成功。当你使用该数据库创建一张表的时候。会在根目录下直接生成以表名为名称的文件夹。保存表的数据（跟之前的一样）–<strong><em>所以推荐还是指明创建的数据库名称\</em></strong></p>
<h2 id="4-2-修改数据库（只能修改数据库描述信息，其他数据不能修改）"><a href="#4-2-修改数据库（只能修改数据库描述信息，其他数据不能修改）" class="headerlink" title="4.2 修改数据库（只能修改数据库描述信息，其他数据不能修改）"></a>4.2 修改数据库（只能修改数据库描述信息，其他数据不能修改）</h2><p>用户可以使用ALTER DATABASE命令为某个数据库的DBPROPERTIES设置键-值对属性值，来描述这个数据库的属性信息。数据库的其他元数据信息都是不可更改的，包括数据库名和数据库所在的目录位置。（<strong><em>跟***</em></strong>mysql*<strong>*</strong>的差别***）</p>
<p>hive (default)&gt; alter database db_hive set dbproperties(‘createtime’=’20170830’);</p>
<p>在mysql中查看修改结果</p>
<p>hive&gt; desc database extended db_hive;</p>
<p>db_name comment location    owner_name   owner_type   parameters</p>
<p>db_hive     hdfs://hadoop102:8020/user/hive/warehouse/db_hive.db  kingge USER  {createtime=20170830}</p>
<h2 id="4-3-查询数据库"><a href="#4-3-查询数据库" class="headerlink" title="4.3 查询数据库"></a>4.3 查询数据库</h2><h3 id="4-3-1-显示数据库"><a href="#4-3-1-显示数据库" class="headerlink" title="4.3.1 显示数据库"></a>4.3.1 显示数据库</h3><p>1）显示数据库</p>
<p>hive&gt; show databases;</p>
<p>2）过滤显示查询的数据库</p>
<p>​    hive&gt; show databases like ‘db_hive*’;</p>
<p>OK</p>
<p>db_hive</p>
<p>db_hive_1</p>
<h3 id="4-3-2-查看数据库详情"><a href="#4-3-2-查看数据库详情" class="headerlink" title="4.3.2 查看数据库详情"></a>4.3.2 查看数据库详情</h3><p>1）显示数据库信息</p>
<p>hive&gt; desc database db_hive;</p>
<p>OK</p>
<p>db_hive     hdfs://hadoop102:8020/user/hive/warehouse/db_hive.db   kinggeUSER </p>
<p>2）显示数据库详细信息，extended</p>
<p>hive&gt; desc database extended db_hive;</p>
<p>OK</p>
<p>db_hive     hdfs://hadoop102:8020/user/hive/warehouse/db_hive.db   kinggeUSER </p>
<h3 id="4-3-3-切换当前数据库"><a href="#4-3-3-切换当前数据库" class="headerlink" title="4.3.3 切换当前数据库"></a>4.3.3 切换当前数据库</h3><p>hive (default)&gt; use db_hive;</p>
<h2 id="4-4-删除数据库"><a href="#4-4-删除数据库" class="headerlink" title="4.4 删除数据库"></a>4.4 删除数据库</h2><p>1）删除空数据库</p>
<p>hive&gt;drop database db_hive2;</p>
<p>2）如果删除的数据库不存在，最好采用 if exists判断数据库是否存在</p>
<p>  hive&gt; drop  database db_hive2;  FAILED:  SemanticException [Error 10072]: Database does not exist: db_hive  </p>
<p>hive&gt; drop database if exists db_hive2;</p>
<p>3）如果数据库不为空，可以采用cascade命令，强制删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive&gt; drop database db_hive;</div><div class="line">FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. InvalidOperationException(message:Database db_hive is not empty. One or more tables exist.)</div></pre></td></tr></table></figure>
<p>hive&gt; drop database db_hive cascade;</p>
<h2 id="4-5-创建表"><a href="#4-5-创建表" class="headerlink" title="4.5 创建表"></a>4.5 创建表</h2><p>1）建表语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name </div><div class="line">[(col_name data_type [COMMENT col_comment], ...)] </div><div class="line">[COMMENT table_comment] </div><div class="line">[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] </div><div class="line">[CLUSTERED BY (col_name, col_name, ...) </div><div class="line">[SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] </div><div class="line">[ROW FORMAT row_format] </div><div class="line">[STORED AS file_format] </div><div class="line">[LOCATION hdfs_path]</div></pre></td></tr></table></figure>
<p>2）字段解释说明：</p>
<p>（1）CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXISTS 选项来忽略这个异常。</p>
<p>（2）EXTERNAL关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION），Hive创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</p>
<p>（3）COMMENT：为表和列添加注释。</p>
<p>（4）PARTITIONED BY创建分区表</p>
<p>（5）CLUSTERED BY创建分桶表</p>
<p>（6）SORTED BY不常用</p>
<p>（7）ROW FORMAT </p>
<p>DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char] </p>
<p>​    [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] </p>
<p>  | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, …)]</p>
<p>用户在建表的时候可以自定义SerDe或者使用自带的SerDe。如果没有指定ROW FORMAT 或者ROW FORMAT DELIMITED，将会使用自带的SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的SerDe，Hive通过SerDe确定表的具体的列的数据。</p>
<p>（8）<strong><em>STORED AS***</em></strong>指定存储文件类型（默认是txt*<strong>*</strong>）***</p>
<p>常用的存储文件类型：SEQUENCEFILE（二进制序列文件）、TEXTFILE（文本）、RCFILE（列式存储格式文件）</p>
<p>如果文件数据是纯文本，可以使用STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p>
<p>（9）LOCATION ：指定表在HDFS上的存储位置。</p>
<p>（10）LIKE允许用户复制现有的表结构，但是不复制数据。</p>
<h3 id="4-5-1-管理表"><a href="#4-5-1-管理表" class="headerlink" title="4.5.1 管理表"></a>4.5.1 管理表</h3><p>1）理论</p>
<p><strong><em>默认创建的表都是所谓的管理表，有时也被称为内部表\</em></strong>。因为这种表，Hive会（或多或少地）控制着数据的生命周期。Hive默认情况下会将这些表的数据存储在由配置项hive.metastore.warehouse.dir(例如，/user/hive/warehouse)所定义的目录的子目录下。    当我们删除一个管理表时，Hive也会删除这个表中数据（删除HDFS存储的目录和数据）。管理表不适合和其他工具共享数据。</p>
<p><strong>2**</strong>）案例实操**</p>
<p>（1）普通创建表</p>
<p>  create table if not  exists student2(  id int, name string  )  row format  delimited fields terminated by ‘\t’  stored as textfile  location  ‘/user/hive/warehouse/student2’;  </p>
<p>（2）根据查询结果创建表（查询的结果会添加到新创建的表中）</p>
<p>  create table if not exists student3  as select id, name from student;  </p>
<p>（3）根据已经存在的表结构创建表（只拷贝student结构，没有获取student数据）</p>
<p>  create table if not exists student4 like student;  </p>
<p>（4）查询表的类型</p>
<p>hive (default)&gt; desc formatted student2;</p>
<p>Table Type:       MANAGED_TABLE </p>
<h3 id="4-5-2-外部表"><a href="#4-5-2-外部表" class="headerlink" title="4.5.2 外部表"></a>4.5.2 外部表</h3><p>1）理论</p>
<p>因为表是外部表，所以Hive并非认为其完全拥有这份数据。删除该表并不会删除掉这份数据（即在hdfs中还保存着数据库的数据），不过描述表的元数据信息会被删除掉。（mysql中关于该表的元数据信息就会被删除）</p>
<p>2）管理表和外部表的使用场景：</p>
<p>每天将收集到的网站日志定期流入HDFS文本文件。在外部表（原始日志表）的基础上做大量的统计分析，用到的中间表、结果表使用内部表存储，数据通过SELECT+INSERT进入内部表。</p>
<p>3）案例实操</p>
<p>分别创建部门和员工外部表，并向表中导入数据。</p>
<p>（1）原始数据</p>
<p>​             </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dept.txt </div><div class="line">10	ACCOUNTING	1700</div><div class="line">20	RESEARCH	1800</div><div class="line">30	SALES	1900</div><div class="line">40	OPERATIONS	1700</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">emp.txt</div><div class="line"></div><div class="line">7369	SMITH	CLERK	7902	1980-12-17	800.00		20</div><div class="line">7499	ALLEN	SALESMAN	7698	1981-2-20	1600.00	300.00	30</div><div class="line">7521	WARD	SALESMAN	7698	1981-2-22	1250.00	500.00	30</div><div class="line">7566	JONES	MANAGER	7839	1981-4-2	2975.00		20</div><div class="line">7654	MARTIN	SALESMAN	7698	1981-9-28	1250.00	1400.00	30</div><div class="line">7698	BLAKE	MANAGER	7839	1981-5-1	2850.00		30</div><div class="line">7782	CLARK	MANAGER	7839	1981-6-9	2450.00		10</div><div class="line">7788	SCOTT	ANALYST	7566	1987-4-19	3000.00		20</div><div class="line">7839	KING	PRESIDENT		1981-11-17	5000.00		10</div><div class="line">7844	TURNER	SALESMAN	7698	1981-9-8	1500.00	0.00	30</div><div class="line">7876	ADAMS	CLERK	7788	1987-5-23	1100.00		20</div><div class="line">7900	JAMES	CLERK	7698	1981-12-3	950.00		30</div><div class="line">7902	FORD	ANALYST	7566	1981-12-3	3000.00		20</div><div class="line">7934	MILLER	CLERK	7782	1982-1-23	1300.00		10</div></pre></td></tr></table></figure>
<p>​    （2）建表语句</p>
<p>​       创建部门表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create external table if not exists default.dept(</div><div class="line">deptno int,</div><div class="line">dname string,</div><div class="line">loc int</div><div class="line">)</div><div class="line">row format delimited fields terminated by &apos;\t&apos;;</div></pre></td></tr></table></figure>
<p>​       创建员工表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create external table if not exists default.emp(</div><div class="line">empno int,</div><div class="line">ename string,</div><div class="line">job string,</div><div class="line">mgr int,</div><div class="line">hiredate string, </div><div class="line">sal double, </div><div class="line">comm double,</div><div class="line">deptno int)</div><div class="line">row format delimited fields terminated by &apos;\t&apos;;</div></pre></td></tr></table></figure>
<p>（3）查看创建的表</p>
<p>hive (default)&gt; show tables;</p>
<p>OK</p>
<p>tab_name</p>
<p>dept</p>
<p>emp</p>
<p>​    （4）向外部表中导入数据</p>
<p>​       导入数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept;</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/emp.txt’ into table default.emp;</p>
<p>查询结果</p>
<p>hive (default)&gt; select * from emp;</p>
<p>hive (default)&gt; select * from dept;</p>
<p>​    （5）查看表格式化数据</p>
<p>hive (default)&gt; desc formatted dept;</p>
<p>Table Type:       EXTERNAL_TABLE</p>
<h2 id="4-6-分区表"><a href="#4-6-分区表" class="headerlink" title="4.6 分区表"></a>4.6 分区表</h2><p>分区表实际上就是<strong><em>对应一个***</em></strong>HDFS*<strong>*</strong>文件系统上的独立的文件夹***，该文件夹下是该分区所有的数据文件。Hive中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过WHERE子句中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。</p>
<p>举个例子：我们知道项目日志框架会根据日期每天生成一个日志文件，这样方便我们查看，也方便存储的打开。因为如果把所有的日志信息都输入到一个文件中，那么查阅的时候就很不方便。所以分区表的含义也是如此，根据某些关键字把数据库表的数据拆分成多个文件夹存储。</p>
<p><strong><em>需要注意，假设创建的是分区表，那么插入数据的时候（insert***</em></strong>或者load*<strong>*</strong>的方式），都需要指明partition*<strong>*</strong>字段的值，否则会报错。***</p>
<p><strong><em>如果某张表是分区表。那么每个分区的定义，其实就表现为了这张表的数据存储目录下的一个子目录，如果是分区表。那么数据文件一定要存储在某个分区中，而不能直接存储在表中。\</em></strong></p>
<h3 id="4-6-1-分区表基本操作"><a href="#4-6-1-分区表基本操作" class="headerlink" title="4.6.1 分区表基本操作"></a>4.6.1 分区表基本操作</h3><p>1）引入分区表（需要根据日期对日志进行管理）</p>
<p>​    /user/hive/warehouse/log_partition/20170702/20170702.log</p>
<p>​    /user/hive/warehouse/log_partition/20170703/20170703.log</p>
<p>/user/hive/warehouse/log_partition/20170704/20170704.log</p>
<p>2）创建分区表语法<strong><em>（注意如果在创建表时不指定分区，那么后面就不能够使用分区相关特性，例如\</em></strong> <strong><em>load***</em></strong>数据时不能够指定load*<strong>*</strong>到哪个分区）***</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive (default)&gt; create table dept_partition(</div><div class="line">               deptno int, dname string, loc string</div><div class="line">               )</div><div class="line">               partitioned by (month string)</div><div class="line">               row format delimited fields terminated by &apos;\t&apos;;</div></pre></td></tr></table></figure>
<p>3）加载数据到分区表中</p>
<p>测试直接导入dep数据：发现报错</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173442759.png" alt="image-20200509173442759"></p>
<p>必须指明partition 字段</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept_partition partition(month=’201709’);</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept_partition partition(month=’201708’);</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept_partition partition(month=’201707’);</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173508986.png" alt="image-20200509173508986"></p>
<p>4）查询分区表中数据</p>
<p>查询所有分区</p>
<p>select * from dept_partition</p>
<p>​    单分区查询</p>
<p>hive (default)&gt; select * from dept_partition where month=’201709’;</p>
<p>多分区联合查询</p>
<p>hive (default)&gt; select * from dept_partition where month=’201709’</p>
<p>​       union</p>
<p>​       select * from dept_partition where month=’201708’</p>
<p>​       union</p>
<p>​       select * from dept_partition where month=’201707’;</p>
<p>_u3.deptno   _u3.dname    _u3.loc _u3.month</p>
<p>10   ACCOUNTING   NEW YORK    201707</p>
<p>10   ACCOUNTING   NEW YORK    201708</p>
<p>10   ACCOUNTING   NEW YORK    201709</p>
<p>20   RESEARCH    DALLAS 201707</p>
<p>20   RESEARCH    DALLAS 201708</p>
<p>20   RESEARCH    DALLAS 201709</p>
<p>30   SALES  CHICAGO 201707</p>
<p>30   SALES  CHICAGO 201708</p>
<p>30   SALES  CHICAGO 201709</p>
<p>40   OPERATIONS   BOSTON 201707</p>
<p>40   OPERATIONS   BOSTON 201708</p>
<p>40   OPERATIONS   BOSTON 201709</p>
<p>5）增加分区</p>
<p>​    创建单个分区（也就是在hdfs中创建文件夹month=201706）</p>
<p>hive (default)&gt; alter table dept_partition add partition(month=’201706’) ;</p>
<p>​    同时创建多个分区</p>
<p>hive (default)&gt; alter table dept_partition add partition(month=’201705’) partition(month=’201704’);</p>
<p>6）删除分区</p>
<p>​    删除单个分区</p>
<p>hive (default)&gt; alter table dept_partition drop partition (month=’201704’);</p>
<p>同时删除多个分区</p>
<p>hive (default)&gt; alter table dept_partition drop partition (month=’201705’)<strong>,</strong> partition (month=’201706’);</p>
<p>7）查看分区表有多少分区</p>
<p>hive&gt;show partitions dept_partition;</p>
<p>8）查看分区表结构</p>
<p>​    hive&gt;desc formatted dept_partition;</p>
<p># Partition Information     </p>
<p># col_name       data_type        comment       </p>
<p>month          string  </p>
<h3 id="4-6-2-分区表注意事项"><a href="#4-6-2-分区表注意事项" class="headerlink" title="4.6.2 分区表注意事项"></a>4.6.2 分区表注意事项</h3><p>1）创建二级分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hive (default)&gt; create table dept_partition2(</div><div class="line">               deptno int, dname string, loc string</div><div class="line">               )</div><div class="line">               partitioned by (month string, day string)</div><div class="line">               row format delimited fields terminated by &apos;\t&apos;;</div></pre></td></tr></table></figure>
<p>2）正常的加载数据</p>
<p>（1）加载数据到二级分区表中</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table default.dept_partition2 partition(month=’201709’, day=’13’);</p>
<p>（2）查询分区数据</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’13’;</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173552490.png" alt="image-20200509173552490"></p>
<p>3）把数据直接上传到分区目录上，让分区表和数据产生关联的两种方式</p>
<p>​    （1）方式一：上传数据后修复</p>
<p>​    上传数据</p>
<p>hive (default)&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=12;</p>
<p>​    查询数据（查询不到刚上传的数据）</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’12’;</p>
<p>执行修复命令</p>
<p>​    hive&gt;msck repair table dept_partition2;</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173610908.png" alt="image-20200509173610908"></p>
<p>添加数据的元数据信息到mysql中，关联表</p>
<p>再次查询数据</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’12’;</p>
<p>​    （2）方式二：上传数据后添加分区</p>
<p>​    上传数据</p>
<p>hive (default)&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=11;</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=11;</p>
<p>​    执行添加分区</p>
<p>​    hive (default)&gt; alter table dept_partition2 add partition(month=’201709’, day=’11’);</p>
<p>​    查询数据</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’11’;</p>
<p>​    （3）方式三：上传数据后load数据到分区</p>
<p>​       创建目录</p>
<p>hive (default)&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=10;</p>
<p>上传数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/dept.txt’ into table dept_partition2 partition(month=’201709’,day=’10’);</p>
<p>查询数据</p>
<p>hive (default)&gt; select * from dept_partition2 where month=’201709’ and day=’10’;</p>
<h2 id="4-7-修改表（不支持删除某个字段）"><a href="#4-7-修改表（不支持删除某个字段）" class="headerlink" title="4.7 修改表（不支持删除某个字段）"></a>4.7 修改表（不支持删除某个字段）</h2><h3 id="4-7-1-重命名表"><a href="#4-7-1-重命名表" class="headerlink" title="4.7.1 重命名表"></a>4.7.1 重命名表</h3><p>​    （1）语法</p>
<p>  ALTER TABLE  table_name RENAME TO new_table_name  </p>
<p>​    （2）实操案例</p>
<p>hive (default)&gt; alter table dept_partition2 rename to dept_partition3;</p>
<h3 id="4-7-2-增加、修改和删除表分区"><a href="#4-7-2-增加、修改和删除表分区" class="headerlink" title="4.7.2 增加、修改和删除表分区"></a>4.7.2 增加、修改和删除表分区</h3><p>详见4.6.1分区表基本操作。</p>
<h3 id="4-7-3-增加-修改-替换列信息"><a href="#4-7-3-增加-修改-替换列信息" class="headerlink" title="4.7.3 增加/修改/替换列信息"></a>4.7.3 增加/修改/替换列信息</h3><p>1）语法</p>
<p>​    更新列</p>
<p>  ALTER TABLE table_name CHANGE [COLUMN]  col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER  column_name]  </p>
<p>增加和替换列</p>
<p>  ALTER TABLE table_name ADD|REPLACE  COLUMNS (col_name data_type [COMMENT col_comment], …)   </p>
<p>注：ADD是代表新增一字段，字段位置在所有列后面(partition列前)，REPLACE则是表示替换表中所有字段。</p>
<p>2）实操案例</p>
<p>（1）查询表结构</p>
<p>hive&gt;desc dept_partition;</p>
<p>（2）添加列</p>
<p>hive (default)&gt; alter table dept_partition add columns(deptdesc string);</p>
<p>（3）查询表结构</p>
<p>hive&gt;desc dept_partition;</p>
<p>（4）更新列</p>
<p>hive (default)&gt; alter table dept_partition change column deptdesc desc int;</p>
<p>（5）查询表结构</p>
<p>hive&gt;desc dept_partition;</p>
<p>（6）替换列</p>
<p>hive (default)&gt; alter table dept_partition replace columns(deptno string, dname string, loc string); （全局改变表的列，只保留指定的列）</p>
<p>（7）查询表结构</p>
<p>hive&gt;desc dept_partition;</p>
<h2 id="4-8-删除表"><a href="#4-8-删除表" class="headerlink" title="4.8 删除表"></a>4.8 删除表</h2><p>hive (default)&gt; drop table dept_partition;</p>
<h1 id="五-DML数据操作"><a href="#五-DML数据操作" class="headerlink" title="五 DML数据操作"></a>五 DML数据操作</h1><h2 id="5-1-数据导入"><a href="#5-1-数据导入" class="headerlink" title="5.1 数据导入"></a>5.1 数据导入</h2><h3 id="5-1-1-向表中装载数据（Load）"><a href="#5-1-1-向表中装载数据（Load）" class="headerlink" title="5.1.1 向表中装载数据（Load）"></a>5.1.1 向表中装载数据（Load）</h3><p>1）语法</p>
<p>hive&gt;load data [local] inpath ‘/opt/module/datas/student.txt’ [overwrite] into table student [partition (partcol1=val1,…)];</p>
<p>（1）load data:表示加载数据</p>
<p>（2）local:表示从本地加载数据到hive表；否则从HDFS加载数据到hive表</p>
<p>（3）inpath:表示加载数据的路径</p>
<p>（4）overwrite:表示覆盖表中已有数据，否则表示追加</p>
<p>（5）into table:表示加载到哪张表</p>
<p>（6）student:表示具体的表</p>
<p>（7）partition:表示上传到指定分区</p>
<p>2）实操案例</p>
<p>​    （0）创建一张表</p>
<p>hive (default)&gt; create table student(id string, name string) row format delimited fields terminated by ‘\t’;</p>
<p>（1）加载本地文件到hive</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/student.txt’ into table default.student;</p>
<p>​    （2）加载HDFS文件到hive中</p>
<p>​    上传文件到HDFS</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/student.txt /user/kingge/hive;</p>
<p>加载HDFS上数据</p>
<p>hive (default)&gt;load data inpath ‘/user/kingge/hive/student.txt’ into table default.student;</p>
<p><strong><em>需要注意的是：/user/kingge/hive/student.txt\</em></strong> <strong><em>这个文件就不存在的，因为他是通过剪切的方式把数据 load***</em></strong>到了 /user/kingge/hive/student*<strong> *</strong>目录下***</p>
<p>​    （3）加载数据覆盖表中已有的数据</p>
<p>​    上传文件到HDFS</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/student.txt /user/kingge/hive;</p>
<p>加载数据覆盖表中已有的数据</p>
<p>hive (default)&gt;load data inpath ‘/user/kingge/hive/student.txt’ overwrite into table default.student;</p>
<h3 id="5-1-2-通过查询语句向表中插入数据（Insert）"><a href="#5-1-2-通过查询语句向表中插入数据（Insert）" class="headerlink" title="5.1.2 通过查询语句向表中插入数据（Insert）"></a>5.1.2 通过查询语句向表中插入数据（Insert）</h3><p>1）创建一张分区表</p>
<p>hive (default)&gt; create table student(id int, name string) partitioned by (month string) row format delimited fields terminated by ‘\t’;</p>
<p>2）基本插入数据</p>
<p>  hive (default)&gt; insert  into table student partition(month=’201709’)  values(1,’wangwu’);  </p>
<p>3）基本模式插入（根据单张表查询结果）</p>
<p>hive (default)&gt; insert overwrite table student partition(month=’201708’)</p>
<p>​       select id, name from student where month=’201709’;</p>
<p>4）多插入模式（根据多张表查询结果）</p>
<p>hive (default)&gt; from student</p>
<p>​       insert overwrite table student partition(month=’201707’)</p>
<p>​       select id, name where month=’201709’</p>
<p>​       insert overwrite table student partition(month=’201706’)</p>
<p>​       select id, name where month=’201709’;</p>
<h3 id="5-1-3-查询语句中创建表并加载数据（As-Select）"><a href="#5-1-3-查询语句中创建表并加载数据（As-Select）" class="headerlink" title="5.1.3 查询语句中创建表并加载数据（As Select）"></a>5.1.3 查询语句中创建表并加载数据（As Select）</h3><p>详见4.5.1章创建表。</p>
<p>根据查询结果创建表（查询的结果会添加到新创建的表中）</p>
<p>  create table if not exists student3  as select id,  name from student;  </p>
<h3 id="5-1-4-创建表时通过Location指定加载数据路径"><a href="#5-1-4-创建表时通过Location指定加载数据路径" class="headerlink" title="5.1.4 创建表时通过Location指定加载数据路径"></a>5.1.4 创建表时通过Location指定加载数据路径</h3><p>1）创建表，并指定在<strong><em>hdfs\</em></strong>上的位置</p>
<p>hive (default)&gt; create table if not exists student5(</p>
<p>​       id int, name string</p>
<p>​       )</p>
<p>​       row format delimited fields terminated by ‘\t’</p>
<p>​       location ‘/user/hive/warehouse/student5’;</p>
<p>2）上传数据到hdfs上</p>
<p>hive (default)&gt; dfs -put /opt/module/datas/student.txt /user/hive/warehouse/student5;</p>
<p>3）查询数据</p>
<p>hive (default)&gt; select * from student5;</p>
<h3 id="5-1-5-Import数据到指定Hive表中"><a href="#5-1-5-Import数据到指定Hive表中" class="headerlink" title="5.1.5 Import数据到指定Hive表中"></a>5.1.5 Import数据到指定Hive表中</h3><p>注意：先用export导出后，再将数据导入。（数据来源hdfs）</p>
<p>  hive (default)&gt; import table  student2 partition(month=’201709’) from ‘/user/hive/warehouse/export/student’;  </p>
<h2 id="5-2-数据导出"><a href="#5-2-数据导出" class="headerlink" title="5.2 数据导出"></a>5.2 数据导出</h2><h3 id="5-2-1-Insert导出"><a href="#5-2-1-Insert导出" class="headerlink" title="5.2.1 Insert导出"></a>5.2.1 Insert导出</h3><p>1）将查询的结果导出到本地</p>
<p>  hive (default)&gt; insert  overwrite local directory ‘/opt/module/datas/export/student’         </p>
<p> select * from student;  </p>
<p>2）将查询的结果格式化导出到本地</p>
<p>  hive (default)&gt; insert  overwrite local directory ‘/opt/module/datas/export/student1’         ROW  FORMAT DELIMITED FIELDS TERMINATED BY ‘\t’       </p>
<p>select * from student;  </p>
<p>3）将查询的结果导出到HDFS上(没有local)</p>
<p>  hive (default)&gt; insert  overwrite directory ‘/user/kingge/student2’         ROW  FORMAT DELIMITED FIELDS TERMINATED BY ‘\t’          </p>
<p> select * from student;  </p>
<h3 id="5-2-2-Hadoop命令导出到本地"><a href="#5-2-2-Hadoop命令导出到本地" class="headerlink" title="5.2.2 Hadoop命令导出到本地"></a>5.2.2 Hadoop命令导出到本地</h3><p>  hive  (default)&gt; dfs -get /user/hive/warehouse/student/month=201709/000000_0   /opt/module/datas/export/student3.txt;  </p>
<h3 id="5-2-3-Hive-Shell-命令导出"><a href="#5-2-3-Hive-Shell-命令导出" class="headerlink" title="5.2.3 Hive Shell 命令导出"></a>5.2.3 Hive Shell 命令导出</h3><p>基本语法：（hive -f/-e 执行语句或者脚本 &gt; file）</p>
<p>  [kingge@hadoop102 hive]$ bin/hive -e  ‘select * from default.student;’ &gt; /opt/module/datas/export/student4.txt;  </p>
<h3 id="5-2-4-Export导出到HDFS上"><a href="#5-2-4-Export导出到HDFS上" class="headerlink" title="5.2.4 Export导出到HDFS上"></a>5.2.4 Export导出到HDFS上</h3><p>  hive (default)&gt; export table  default.student to ‘/user/hive/warehouse/export/student’;  </p>
<h3 id="5-2-5-Sqoop导出"><a href="#5-2-5-Sqoop导出" class="headerlink" title="5.2.5 Sqoop导出"></a>5.2.5 Sqoop导出</h3><p>后续课程专门讲。</p>
<h2 id="5-3-清除表中数据（Truncate）"><a href="#5-3-清除表中数据（Truncate）" class="headerlink" title="5.3 清除表中数据（Truncate）"></a>5.3 清除表中数据（Truncate）</h2><p>注意：Truncate只能删除管理表，不能删除外部表中数据</p>
<p>hive (default)&gt; truncate table student;</p>
<h1 id="六-查询"><a href="#六-查询" class="headerlink" title="六 查询"></a>六 查询</h1><p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[WITH CommonTableExpression (, CommonTableExpression)*]    (Note: Only available starting with Hive 0.13.0)</div><div class="line">SELECT [ALL | DISTINCT] select_expr, select_expr, ...</div><div class="line">  FROM table_reference</div><div class="line">  [WHERE where_condition]</div><div class="line">  [GROUP BY col_list]</div><div class="line">  [ORDER BY col_list]</div><div class="line">  [CLUSTER BY col_list</div><div class="line">    | [DISTRIBUTE BY col_list] [SORT BY col_list]</div><div class="line">  ]</div><div class="line"> [LIMIT number]</div></pre></td></tr></table></figure>
<h2 id="6-1-基本查询（Select…From）"><a href="#6-1-基本查询（Select…From）" class="headerlink" title="6.1 基本查询（Select…From）"></a>6.1 基本查询（Select…From）</h2><h3 id="6-1-1-全表和特定列查询"><a href="#6-1-1-全表和特定列查询" class="headerlink" title="6.1.1 全表和特定列查询"></a>6.1.1 全表和特定列查询</h3><p>1）全表查询</p>
<p>hive (default)&gt; select * from emp;</p>
<p>2）选择特定列查询</p>
<p>hive (default)&gt; select empno, ename from emp;</p>
<p>注意：</p>
<p>（1）SQL 语言大小写不敏感。</p>
<p>（2）SQL 可以写在一行或者多行</p>
<p>（3）关键字不能被缩写也不能分行</p>
<p>（4）各子句一般要分行写。</p>
<p>（5）使用缩进提高语句的可读性。</p>
<h3 id="6-1-2-列别名"><a href="#6-1-2-列别名" class="headerlink" title="6.1.2 列别名"></a>6.1.2 列别名</h3><p>1）重命名一个列。</p>
<p>2）便于计算。</p>
<p>3）紧跟列名，也可以在列名和别名之间加入关键字‘AS’ </p>
<p>4）案例实操</p>
<p>​    （1）查询名称和部门</p>
<p>​    hive (default)&gt; select ename AS name, deptno dn from emp;</p>
<h3 id="6-1-3-算术运算符"><a href="#6-1-3-算术运算符" class="headerlink" title="6.1.3 算术运算符"></a>6.1.3 算术运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>A+B</td>
<td>A和B 相加</td>
</tr>
<tr>
<td>A-B</td>
<td>A减去B</td>
</tr>
<tr>
<td>A*B</td>
<td>A和B 相乘</td>
</tr>
<tr>
<td>A/B</td>
<td>A除以B</td>
</tr>
<tr>
<td>A%B</td>
<td>A对B取余</td>
</tr>
<tr>
<td>A&amp;B</td>
<td>A和B按位取与</td>
</tr>
<tr>
<td>A\</td>
<td>B</td>
<td>A和B按位取或</td>
</tr>
<tr>
<td>A^B</td>
<td>A和B按位取异或</td>
</tr>
<tr>
<td>~A</td>
<td>A按位取反</td>
</tr>
</tbody>
</table>
<p>案例实操</p>
<p>​    查询出所有员工的薪水后加1显示。</p>
<p>hive (default)&gt; select sal +1 from emp;</p>
<h3 id="6-1-4-常用函数"><a href="#6-1-4-常用函数" class="headerlink" title="6.1.4 常用函数"></a>6.1.4 常用函数</h3><p>1）求总行数（count）</p>
<p>hive (default)&gt; select count(*) cnt from emp;</p>
<p>2）求工资的最大值（max）</p>
<p>hive (default)&gt; select max(sal) max_sal from emp;</p>
<p>3）求工资的最小值（min）</p>
<p>hive (default)&gt; select min(sal) min_sal from emp;</p>
<p>4）求工资的总和（sum）</p>
<p>hive (default)&gt; select sum(sal) sum_sal from emp; </p>
<p>5）求工资的平均值（avg）</p>
<p>​    hive (default)&gt; select avg(sal) avg_sal from emp;</p>
<h3 id="6-1-5-Limit语句"><a href="#6-1-5-Limit语句" class="headerlink" title="6.1.5 Limit语句"></a>6.1.5 Limit语句</h3><p>典型的查询会返回多行数据。LIMIT子句用于限制返回的行数。</p>
<p>hive (default)&gt; select * from emp limit 5;</p>
<h2 id="6-2-Where语句"><a href="#6-2-Where语句" class="headerlink" title="6.2 Where语句"></a>6.2 Where语句</h2><p>1）使用WHERE子句，将不满足条件的行过滤掉。</p>
<p>2）WHERE子句紧随FROM子句。</p>
<p>3）案例实操</p>
<p>查询出薪水大于1000的所有员工</p>
<p>hive (default)&gt; select * from emp where sal &gt;1000;</p>
<h3 id="6-2-1-比较运算符（Between-In-Is-Null）"><a href="#6-2-1-比较运算符（Between-In-Is-Null）" class="headerlink" title="6.2.1 比较运算符（Between/In/ Is Null）"></a>6.2.1 比较运算符（Between/In/ Is Null）</h3><p>1）下面表中描述了谓词操作符，这些操作符同样可以用于JOIN…ON和HAVING语句中。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>支持的数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>A=B</td>
<td>基本数据类型</td>
<td>如果A等于B则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;=&gt;B</td>
<td>基本数据类型</td>
<td>如果A和B都为NULL，则返回TRUE，其他的和等号（=）操作符的结果一致，如果任一为NULL则结果为NULL</td>
</tr>
<tr>
<td>A&lt;&gt;B, A!=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL则返回NULL；如果A不等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A小于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&lt;=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A小于等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&gt;B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A大于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A&gt;=B</td>
<td>基本数据类型</td>
<td>A或者B为NULL，则返回NULL；如果A大于等于B，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A [NOT] BETWEEN B AND C</td>
<td>基本数据类型</td>
<td>如果A，B或者C任一为NULL，则结果为NULL。如果A的值大于等于B而且小于或等于C，则结果为TRUE，反之为FALSE。如果使用NOT关键字则可达到相反的效果。</td>
</tr>
<tr>
<td>A IS NULL</td>
<td>所有数据类型</td>
<td>如果A等于NULL，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A IS NOT NULL</td>
<td>所有数据类型</td>
<td>如果A不等于NULL，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>IN(数值1, 数值2)</td>
<td>所有数据类型</td>
<td>使用 IN运算显示列表中的值</td>
</tr>
<tr>
<td>A [NOT] LIKE B</td>
<td>STRING 类型</td>
<td>B是一个SQL下的简单正则表达式，如果A与其匹配的话，则返回TRUE；反之返回FALSE。B的表达式说明如下：‘x%’表示A必须以字母‘x’开头，‘%x’表示A必须以字母’x’结尾，而‘%x%’表示A包含有字母’x’,可以位于开头，结尾或者字符串中间。如果使用NOT关键字则可达到相反的效果。</td>
</tr>
<tr>
<td>A RLIKE B, A REGEXP B</td>
<td>STRING 类型</td>
<td>B是一个正则表达式，如果A与其匹配，则返回TRUE；反之返回FALSE。匹配使用的是JDK中的正则表达式接口实现的，因为正则也依据其中的规则。例如，正则表达式必须和整个字符串A相匹配，而不是只需与其字符串匹配。</td>
</tr>
</tbody>
</table>
<p>2）案例实操</p>
<p>（1）查询出薪水等于5000的所有员工</p>
<p>hive (default)&gt; select * from emp where sal =5000;</p>
<p>​    （2）查询工资在500到1000的员工信息</p>
<p>hive (default)&gt; select * from emp where sal between 500 and 1000;</p>
<p>​    （3）查询comm为空的所有员工信息</p>
<p>hive (default)&gt; select * from emp where comm is null;</p>
<p>​    （4）查询工资是1500和5000的员工信息</p>
<p>hive (default)&gt; select * from emp where sal IN (1500, 5000);</p>
<h3 id="6-2-2-Like和RLike"><a href="#6-2-2-Like和RLike" class="headerlink" title="6.2.2 Like和RLike"></a>6.2.2 Like和RLike</h3><p>1）使用LIKE运算选择类似的值</p>
<p>2）选择条件可以包含字符或数字:</p>
<p>% 代表零个或多个字符(任意个字符)。</p>
<p>_ 代表一个字符。</p>
<p>3）RLIKE子句是Hive中这个功能的一个扩展，其可以通过Java的正则表达式这个更强大的语言来指定匹配条件。</p>
<p>4）案例实操</p>
<p>​    （1）查找以2开头薪水的员工信息</p>
<p>​    hive (default)&gt; select * from emp where sal LIKE ‘2%’;</p>
<p>​    （2）查找第二个数值为2的薪水的员工信息</p>
<p>hive (default)&gt; select * from emp where sal LIKE ‘_2%’;</p>
<p>​    （3）查找薪水中含有2的员工信息</p>
<p>hive (default)&gt; select * from emp where sal RLIKE ‘[2]’;</p>
<h3 id="6-2-3-逻辑运算符（And-Or-Not）"><a href="#6-2-3-逻辑运算符（And-Or-Not）" class="headerlink" title="6.2.3 逻辑运算符（And/Or/Not）"></a>6.2.3 逻辑运算符（And/Or/Not）</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND</td>
<td>逻辑并</td>
</tr>
<tr>
<td>OR</td>
<td>逻辑或</td>
</tr>
<tr>
<td>NOT</td>
<td>逻辑否</td>
</tr>
</tbody>
</table>
<p>案例实操</p>
<p>​    （1）查询薪水大于1000，部门是30</p>
<p>hive (default)&gt; select * from emp where sal&gt;1000 and deptno=30;</p>
<p>​    （2）查询薪水大于1000，或者部门是30</p>
<p>hive (default)&gt; select * from emp where sal&gt;1000 or deptno=30;</p>
<p>​    （3）查询除了20部门和30部门以外的员工信息</p>
<p>hive (default)&gt; select * from emp where deptno not IN(30, 20);</p>
<h2 id="6-3-分组"><a href="#6-3-分组" class="headerlink" title="6.3 分组"></a>6.3 分组</h2><h3 id="6-3-1-Group-By语句"><a href="#6-3-1-Group-By语句" class="headerlink" title="6.3.1 Group By语句"></a>6.3.1 Group By语句</h3><p>GROUP BY语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，然后对每个组执行聚合操作。</p>
<p>案例实操：</p>
<p>​    （1）计算emp表每个部门的平均工资</p>
<p>hive (default)&gt; select t.deptno, avg(t.sal) avg_sal from emp t group by t.deptno;</p>
<p>​    （2）计算emp每个部门中每个岗位的最高薪水</p>
<p>hive (default)&gt; select t.deptno, t.job, max(t.sal) max_sal from emp t group by t.deptno, t.job;</p>
<h3 id="6-3-2-Having语句"><a href="#6-3-2-Having语句" class="headerlink" title="6.3.2 Having语句"></a>6.3.2 Having语句</h3><p>1）having与where不同点</p>
<p>（1）where针对表中的列发挥作用，查询数据；having针对查询结果中的列发挥作用，筛选数据。<strong><em>（也就是说在***</em></strong>select*<strong> *</strong>查询结果完后，having*<strong>*</strong>里面的语句才会执行。***</p>
<p><strong><em>Where***</em></strong>是在select*<strong>*</strong>结果时立即生效，参与过滤。）***</p>
<p>（2）where后面不能写分组函数，而having后面可以使用分组函数。</p>
<p>（3）having只用于group by分组统计语句。</p>
<p>2）案例实操：</p>
<p>（1）求每个部门的平均薪水大于2000的部门</p>
<p>​    求每个部门的平均工资</p>
<p>​    hive (default)&gt; select deptno, avg(sal) from emp group by deptno;</p>
<p>​    求每个部门的平均薪水大于2000的部门</p>
<p>hive (default)&gt; select deptno, avg(sal) avg_sal from emp group by deptno having avg_sal &gt; 2000;</p>
<h2 id="6-4-Join语句"><a href="#6-4-Join语句" class="headerlink" title="6.4 Join语句"></a>6.4 Join语句</h2><h3 id="6-4-1-等值Join"><a href="#6-4-1-等值Join" class="headerlink" title="6.4.1 等值Join"></a>6.4.1 等值Join</h3><p>Hive支持通常的SQL JOIN语句，但是只支持等值连接，不支持非等值连接。</p>
<p>何为非等值连接</p>
<p> <img src="/2018/05/16/hive总结/image-20200509173744714.png" alt="image-20200509173744714"></p>
<p>案例实操</p>
<p>（1）根据员工表和部门表中的部门编号相等，查询员工编号、员工名称和部门编号；</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno, d.dname from emp e join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-2-表的别名"><a href="#6-4-2-表的别名" class="headerlink" title="6.4.2 表的别名"></a>6.4.2 表的别名</h3><p>1）好处</p>
<p>（1）使用别名可以简化查询。</p>
<p>（2）使用表名前缀可以提高执行效率。</p>
<p>2）案例实操</p>
<p>合并员工表和部门表</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-3-内连接"><a href="#6-4-3-内连接" class="headerlink" title="6.4.3 内连接"></a>6.4.3 内连接</h3><p>内连接：只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-4-左外连接"><a href="#6-4-4-左外连接" class="headerlink" title="6.4.4 左外连接"></a>6.4.4 左外连接</h3><p>​    左外连接：JOIN操作符左边表中符合WHERE子句的所有记录将会被返回。</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e left join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-5-右外连接"><a href="#6-4-5-右外连接" class="headerlink" title="6.4.5 右外连接"></a>6.4.5 右外连接</h3><p>右外连接：JOIN操作符右边表中符合WHERE子句的所有记录将会被返回。</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e right join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-6-满外连接（oracle支持fulljoin语法，mysql没有该语法）"><a href="#6-4-6-满外连接（oracle支持fulljoin语法，mysql没有该语法）" class="headerlink" title="6.4.6 满外连接（oracle支持fulljoin语法，mysql没有该语法）"></a>6.4.6 满外连接（oracle支持fulljoin语法，mysql没有该语法）</h3><p>​    满外连接：将会返回所有表中符合WHERE语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用NULL值替代。</p>
<p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e full join dept d on e.deptno = d.deptno;</p>
<h3 id="6-4-7-多表连接"><a href="#6-4-7-多表连接" class="headerlink" title="6.4.7 多表连接"></a>6.4.7 多表连接</h3><p>注意：连接 n个表，至少需要n-1个连接条件。例如：连接三个表，至少需要两个连接条件。</p>
<p>0）数据准备</p>
<p> 1700    Beijing<br>1800    London<br>1900    Tokyo</p>
<p>1）创建位置表</p>
<p>  create table if not  exists default.location(  loc int,  loc_name string  )  row format  delimited fields terminated by ‘\t’;  </p>
<p>2）导入数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/location.txt’ into table default.location;</p>
<p>3）多表连接查询</p>
<p>hive (default)&gt;SELECT e.ename, d.deptno, l. loc_name</p>
<p>FROM  emp e </p>
<p>JOIN  dept d</p>
<p>ON   d.deptno = e.deptno</p>
<p>JOIN  location l</p>
<p>ON   d.loc = l.loc;</p>
<p>大多数情况下，Hive会对每对JOIN连接对象启动一个MapReduce任务。本例中会首先启动一个MapReduce job对表e和表d进行连接操作，然后会再启动一个MapReduce job将第一个MapReduce job的输出和表l;进行连接操作。</p>
<p>注意：为什么不是表d和表l先进行连接操作呢？这是因为Hive总是按照从左到右的顺序执行的。</p>
<h3 id="6-4-8-笛卡尔积"><a href="#6-4-8-笛卡尔积" class="headerlink" title="6.4.8 笛卡尔积"></a>6.4.8 笛卡尔积</h3><p>1）笛卡尔集会在下面条件下产生:</p>
<p>（1）省略连接条件</p>
<p>（2）连接条件无效</p>
<p>（3）所有表中的所有行互相连接</p>
<p>2）案例实操</p>
<p>hive (default)&gt; select empno, deptno from emp, dept;</p>
<p>FAILED: SemanticException Column deptno Found in more than One Tables/Subqueries</p>
<h3 id="6-4-9-连接谓词中不支持or"><a href="#6-4-9-连接谓词中不支持or" class="headerlink" title="6.4.9 连接谓词中不支持or"></a>6.4.9 连接谓词中不支持or</h3><p>hive (default)&gt; select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno = d.deptno or e.ename=d.ename;  错误的</p>
<h2 id="6-5-排序"><a href="#6-5-排序" class="headerlink" title="6.5 排序"></a>6.5 排序</h2><h3 id="6-5-1-全局排序（Order-By）"><a href="#6-5-1-全局排序（Order-By）" class="headerlink" title="6.5.1 全局排序（Order By）"></a>6.5.1 全局排序（Order By）</h3><p>Order By：全局排序，一个MapReduce</p>
<p>1）使用 ORDER BY 子句排序</p>
<p>ASC（ascend）: 升序（默认）</p>
<p>DESC（descend）: 降序</p>
<p>2）ORDER BY 子句在SELECT语句的结尾。</p>
<p>3）案例实操</p>
<p>​    （1）查询员工信息按工资升序排列</p>
<p>hive (default)&gt; select * from emp order by sal;</p>
<p>​    （2）查询员工信息按工资降序排列</p>
<p>hive (default)&gt; select * from emp order by sal desc;</p>
<h3 id="6-5-2-按照别名排序"><a href="#6-5-2-按照别名排序" class="headerlink" title="6.5.2 按照别名排序"></a>6.5.2 按照别名排序</h3><p>按照员工薪水的2倍排序</p>
<p>hive (default)&gt; select ename, sal*2 twosal from emp order by twosal;</p>
<h3 id="6-5-3-多个列排序"><a href="#6-5-3-多个列排序" class="headerlink" title="6.5.3 多个列排序"></a>6.5.3 多个列排序</h3><p>按照部门和工资升序排序</p>
<p>hive (default)&gt; select ename, deptno, sal from emp order by deptno, sal ;</p>
<h3 id="6-5-4-每个MapReduce内部排序（Sort-By）"><a href="#6-5-4-每个MapReduce内部排序（Sort-By）" class="headerlink" title="6.5.4 每个MapReduce内部排序（Sort By）"></a>6.5.4 每个MapReduce内部排序（Sort By）</h3><p>Sort By：每个MapReduce内部进行排序，对全局结果集来说不是排序。</p>
<p>​    1）设置reduce个数</p>
<p>hive (default)&gt; set mapreduce.job.reduces=3;</p>
<p>2）查看设置reduce个数</p>
<p>hive (default)&gt; set mapreduce.job.reduces;</p>
<p>3）根据部门编号降序查看员工信息</p>
<p>hive (default)&gt; select * from emp sort by empno desc;</p>
<p>​    4）将查询结果导入到文件中（按照部门编号降序排序）</p>
<p>hive (default)&gt; insert overwrite local directory ‘/opt/module/datas/sortby-result’ select * from emp sort by deptno desc;</p>
<h3 id="6-5-5-分区排序（Distribute-By）"><a href="#6-5-5-分区排序（Distribute-By）" class="headerlink" title="6.5.5 分区排序（Distribute By）"></a>6.5.5 分区排序（Distribute By）</h3><p>Distribute By：类似MR中partition，进行分区，结合sort by使用。</p>
<p>​    注意，Hive要求DISTRIBUTE BY语句要写在SORT BY语句之前。</p>
<p>对于distribute by进行测试，一定要分配多reduce进行处理，否则无法看到distribute by的效果。</p>
<p>案例实操：</p>
<p>​    （1）先按照部门编号分区，再按照员工编号降序排序。</p>
<p>hive (default)&gt; set mapreduce.job.reduces=3;</p>
<p>​    hive (default)&gt; insert overwrite local directory ‘/opt/module/datas/distribute-result’ select * from emp distribute by deptno sort by empno desc;</p>
<h3 id="6-5-6-Cluster-By"><a href="#6-5-6-Cluster-By" class="headerlink" title="6.5.6 Cluster By"></a>6.5.6 Cluster By</h3><p>当distribute by和sorts by字段相同时，可以使用cluster by方式。</p>
<p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是倒序排序，不能指定排序规则为ASC或者DESC。</p>
<p>1）以下两种写法等价</p>
<p>hive (default)&gt; select * from emp cluster by deptno;</p>
<p>hive (default)&gt; select * from emp distribute by deptno sort by deptno;</p>
<p>注意：按照部门编号分区，不一定就是固定死的数值，可以是20号和30号部门分到一个分区里面去。</p>
<h2 id="6-6-分桶及抽样查询"><a href="#6-6-分桶及抽样查询" class="headerlink" title="6.6 分桶及抽样查询"></a>6.6 分桶及抽样查询</h2><h3 id="6-6-1-分桶表数据存储"><a href="#6-6-1-分桶表数据存储" class="headerlink" title="6.6.1 分桶表数据存储"></a>6.6.1 分桶表数据存储</h3><p>​    分区针对的是数据的存储路径（通过分文件夹的方式存储数据）；分桶针对的是数据文件。（通过把一份数据分为几分去存储）</p>
<p>分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可形成合理的分区，特别是之前所提到过的要确定合适的划分大小这个疑虑。</p>
<p>​    分桶是将数据集分解成更容易管理的若干部分的另一个技术。</p>
<p>1）先创建分桶表，通过直接导入数据文件的方式</p>
<p>（0）数据准备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1001	ss1</div><div class="line">1002	ss2</div><div class="line">1003	ss3</div><div class="line">1004	ss4</div><div class="line">1005	ss5</div><div class="line">1006	ss6</div><div class="line">1007	ss7</div><div class="line">1008	ss8</div><div class="line">1009	ss9</div><div class="line">1010	ss10</div><div class="line">1011	ss11</div><div class="line">1012	ss12</div><div class="line">1013	ss13</div><div class="line">1014	ss14</div><div class="line">1015	ss15</div><div class="line">1016	ss16</div></pre></td></tr></table></figure>
<p>（1）创建分桶表</p>
<p>  create table  stu_buck(id int, name string)  clustered by(id)   into 4 buckets  row format  delimited fields terminated by ‘\t’;  </p>
<p>（2）查看表结构</p>
<p>hive (default)&gt; desc formatted stu_buck;</p>
<p>Num Buckets:      4   </p>
<p>（3）导入数据到分桶表中</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/student.txt’ into table stu_buck;</p>
<p>（4）查看创建的分桶表中是否分成4个桶</p>
<p>发现并没有分成4个桶。是什么原因呢？</p>
<p>2）创建分桶表时，数据通过子查询的方式导入</p>
<p>​    （1）先建一个普通的stu表</p>
<p>  create table stu(id  int, name string)  row format  delimited fields terminated by ‘\t’;  </p>
<p>​    （2）向普通的stu表中导入数据</p>
<p>  load data local inpath ‘/opt/module/datas/student.txt’  into table stu;  </p>
<p>​    （3）清空stu_buck表中数据</p>
<p>  truncate table  stu_buck;  select * from  stu_buck;  </p>
<p>​    （4）导入数据到分桶表，通过子查询的方式</p>
<p>  insert into table  stu_buck  select id, name  from stu;  </p>
<p>（5）发现还是只有一个分桶</p>
<p>（6）需要设置一个属性</p>
<p>  hive (default)&gt; set hive.enforce.bucketing=true;  hive (default)&gt; set mapreduce.job.reduces=-1;  hive (default)&gt; insert into table stu_buck  select id, name from  stu;  </p>
<p>l <strong><em>可以看到，把student***</em></strong>的数据分为了四份存储。***</p>
<p>（7）查询分桶的数据</p>
<p>  hive  (default)&gt; select * from stu_buck;  OK  stu_buck.id   stu_buck.name  1001  ss1  1005  ss5  1009  ss9  1012  ss12  1016  ss16  1002  ss2  1006  ss6  1013  ss13  1003  ss3  1007  ss7  1010  ss10  1014  ss14  1004  ss4  1008  ss8  1011  ss11  1015  ss15  </p>
<h3 id="6-6-2-分桶抽样查询"><a href="#6-6-2-分桶抽样查询" class="headerlink" title="6.6.2 分桶抽样查询"></a>6.6.2 分桶抽样查询</h3><p>对于非常大的数据集，有时用户需要使用的是一个具有代表性的查询结果而不是全部结果。Hive可以通过对表进行抽样来满足这个需求。</p>
<p>查询表stu_buck中的数据。</p>
<p>  hive (default)&gt; select * from stu_buck tablesample(bucket 1 out of 4 on id);  </p>
<p>注：tablesample是抽样语句，语法：TABLESAMPLE(BUCKET x OUT OF y) 。</p>
<p>y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽样的比例。例如，table总共分了4份，当y=2时，抽取(4/2=)2个bucket的数据，当y=8时，抽取(4/8=)1/2个bucket的数据。</p>
<p>x表示从哪个bucket开始抽取。例如，table总bucket数为4，tablesample(bucket 4 out of 4)，表示总共抽取（4/4=）1个bucket的数据，抽取第4个bucket的数据。</p>
<p>注意：x的值必须小于等于y的值，否则</p>
<p>FAILED: SemanticException [Error 10061]: Numerator should not be bigger than denominator in sample clause for table stu_buck</p>
<h3 id="6-6-3-数据块抽样"><a href="#6-6-3-数据块抽样" class="headerlink" title="6.6.3 数据块抽样"></a>6.6.3 数据块抽样</h3><p>Hive提供了另外一种按照百分比进行抽样的方式，这种是基于行数的，按照输入路径下的数据块百分比进行的抽样。</p>
<p>  hive (default)&gt; select * from stu tablesample(0.1 percent) ;  </p>
<p>提示：这种抽样方式不一定适用于所有的文件格式。另外，这种抽样的最小抽样单元是一个HDFS数据块。因此，如果表的数据大小小于普通的块大小128M的话，那么将会返回所有行。</p>
<h1 id="七-函数"><a href="#七-函数" class="headerlink" title="七 函数"></a>七 函数</h1><h2 id="7-1-系统自带的函数"><a href="#7-1-系统自带的函数" class="headerlink" title="7.1 系统自带的函数"></a>7.1 系统自带的函数</h2><p>1）查看系统自带的函数</p>
<p>hive&gt; show functions;</p>
<p>2）显示自带的函数的用法</p>
<p>hive&gt; desc function upper;</p>
<p>3）详细显示自带的函数的用法</p>
<p>hive&gt; desc function extended upper;</p>
<h2 id="7-2-自定义函数"><a href="#7-2-自定义函数" class="headerlink" title="7.2 自定义函数"></a>7.2 自定义函数</h2><p>1）Hive 自带了一些函数，比如：max/min等，但是数量有限，自己可以通过自定义UDF来方便的扩展。</p>
<p>2）当Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。</p>
<p>3）根据用户自定义函数类别分为以下三种：</p>
<p>​    （1）UDF（User-Defined-Function）</p>
<p>​       一进一出</p>
<p>​    （2）UDAF（User-Defined Aggregation Function）</p>
<p>​       聚集函数，多进一出</p>
<p>​       类似于：count/max/min</p>
<p>​    （3）UDTF（User-Defined Table-Generating Functions）</p>
<p>​       一进多出</p>
<p>​       如lateral view explore()</p>
<p>4）官方文档地址</p>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/HivePlugins</a></p>
<p>5）编程步骤：</p>
<p>​    （1）继承org.apache.hadoop.hive.ql.UDF</p>
<p>​    （2）需要实现evaluate函数；evaluate函数支持重载；</p>
<p>​    （3）在hive的命令行窗口创建函数</p>
<p>​       a）添加jar</p>
<p>​           add jar linux_jar_path</p>
<p>​       b）创建function，</p>
<p>​           create [temporary] function [dbname.]function_name AS class_name;</p>
<p>​    （4）在hive的命令行窗口删除函数</p>
<p>​       Drop [temporary] function [if exists] [dbname.]function_name;</p>
<p>6）注意事项</p>
<p>​    （1）UDF必须要有返回类型，可以返回null，但是返回类型不能为void；</p>
<h2 id="7-3-自定义UDF函数开发案例"><a href="#7-3-自定义UDF函数开发案例" class="headerlink" title="7.3 自定义UDF函数开发案例"></a>7.3 自定义UDF函数开发案例</h2><p>1）创建一个java工程，并创建一个lib文件夹</p>
<p>2）将hive的jar包解压后，将apache-hive-1.2.1-bin\lib文件下的jar包都拷贝到java工程中。</p>
<p>3）创建一个类</p>
<p>  package  com.kingge.hive;  import org.apache.hadoop.hive.ql.exec.UDF;     public  class Lower extends UDF {         public String evaluate  (final String s) {                  if (s == null) {             return null;         }                  return  s.toString().toLowerCase();      }  }  </p>
<p>4）打成jar包上传到服务器/opt/module/jars/udf.jar</p>
<p>5）将jar包添加到hive的classpath</p>
<p>hive (default)&gt; add jar /opt/module/datas/udf.jar;</p>
<p>6）创建<strong><em>临时函数\</em></strong>与开发好的java class关联（<strong><em>临时函数***</em></strong>hive*<strong>*</strong>命令窗口一关闭马上销毁，本质是没有注册到元数据中***）</p>
<p>hive (default)&gt; create temporary function udf_lower as “com.kingge.hive.Lower”;</p>
<p>7）即可在hql中使用自定义的函数strip </p>
<p>hive (default)&gt; select ename, udf_lower(ename) lowername from emp;</p>
<h1 id="八-压缩和存储"><a href="#八-压缩和存储" class="headerlink" title="八 压缩和存储"></a>八 压缩和存储</h1><h2 id="8-1-Hadoop源码编译支持Snappy压缩"><a href="#8-1-Hadoop源码编译支持Snappy压缩" class="headerlink" title="8.1 Hadoop源码编译支持Snappy压缩"></a>8.1 Hadoop源码编译支持Snappy压缩</h2><h3 id="8-1-1-资源准备"><a href="#8-1-1-资源准备" class="headerlink" title="8.1.1 资源准备"></a>8.1.1 资源准备</h3><p>1）CentOS联网 </p>
<p>配置CentOS能连接外网。Linux虚拟机ping <a href="http://www.baidu.com" target="_blank" rel="external">www.baidu.com</a> 是畅通的</p>
<p>注意：采用root角色编译，减少文件夹权限出现问题</p>
<p>2）jar包准备(hadoop源码、JDK8 、maven、protobuf)</p>
<p>（1）hadoop-2.7.2-src.tar.gz</p>
<p>（2）jdk-8u144-linux-x64.tar.gz</p>
<p>（3）snappy-1.1.3.tar.gz</p>
<p>（4）apache-maven-3.0.5-bin.tar.gz</p>
<p>（5）protobuf-2.5.0.tar.gz</p>
<h3 id="8-1-2-jar包安装"><a href="#8-1-2-jar包安装" class="headerlink" title="8.1.2 jar包安装"></a>8.1.2 jar包安装</h3><p>0）注意：所有操作必须在root用户下完成</p>
<p>1）JDK解压、配置环境变量JAVA_HOME和PATH，验证<a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">java</a>-version(如下都需要验证是否配置成功)</p>
<p>[root@hadoop101 software] # tar -zxf jdk-8u144-linux-x64.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 software]# vi /etc/profile</p>
<p>  #JAVA_HOME  export JAVA_HOME=/opt/module/jdk1.8.0_144  export PATH=$PATH:$JAVA_HOME/bin  </p>
<p>[root@hadoop101 software]#source /etc/profile</p>
<p>验证命令：java -version</p>
<p>2）Maven解压、配置 MAVEN_HOME和PATH。</p>
<p>[root@hadoop101 software]# tar -zxvf apache-maven-3.0.5-bin.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 apache-maven-3.0.5]# vi /etc/profile</p>
<p>  #MAVEN_HOME  export  MAVEN_HOME=/opt/module/apache-maven-3.0.5  export PATH=$PATH:$MAVEN_HOME/bin  </p>
<p>[root@hadoop101 software]#source /etc/profile</p>
<p>验证命令：mvn -version</p>
<h3 id="8-1-3-编译源码"><a href="#8-1-3-编译源码" class="headerlink" title="8.1.3 编译源码"></a>8.1.3 编译源码</h3><p>1）准备编译环境</p>
<p>[root@hadoop101 software]# yum install svn</p>
<p>[root@hadoop101 software]# yum install autoconf automake libtool cmake</p>
<p>[root@hadoop101 software]# yum install ncurses-devel</p>
<p>[root@hadoop101 software]# yum install openssl-devel</p>
<p>[root@hadoop101 software]# yum install gcc*</p>
<p>2）编译安装snappy</p>
<p>[root@hadoop101 software]# tar -zxvf snappy-1.1.3.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 module]# cd snappy-1.1.3/</p>
<p>[root@hadoop101 snappy-1.1.3]# ./configure</p>
<p>[root@hadoop101 snappy-1.1.3]# make</p>
<p>[root@hadoop101 snappy-1.1.3]# make install</p>
<p># 查看snappy库文件</p>
<p>[root@hadoop101 snappy-1.1.3]# ls -lh /usr/local/lib |grep snappy</p>
<p>3）编译安装protobuf</p>
<p>[root@hadoop101 software]# tar -zxvf protobuf-2.5.0.tar.gz -C /opt/module/</p>
<p>[root@hadoop101 module]# cd protobuf-2.5.0/</p>
<p>[root@hadoop101 protobuf-2.5.0]# ./configure </p>
<p>[root@hadoop101 protobuf-2.5.0]# make </p>
<p>[root@hadoop101 protobuf-2.5.0]# make install</p>
<p># 查看protobuf版本以测试是否安装成功<br> [root@hadoop101 protobuf-2.5.0]# protoc –version</p>
<p>4）编译hadoop native</p>
<p>[root@hadoop101 software]# tar -zxvf hadoop-2.7.2-src.tar.gz</p>
<p>[root@hadoop101 software]# cd hadoop-2.7.2-src/</p>
<p>[root@hadoop101 software]# mvn clean package -DskipTests -Pdist,native -Dtar -Dsnappy.lib=/usr/local/lib -Dbundle.snappy</p>
<p>执行成功后，/opt/software/hadoop-2.7.2-src/hadoop-dist/target/<a href="http://lib.csdn.net/base/hadoop" target="_blank" rel="external">hadoop</a>-2.7.2.tar.gz即为新生成的支持snappy压缩的二进制安装包。</p>
<h2 id="8-2-Hadoop压缩配置"><a href="#8-2-Hadoop压缩配置" class="headerlink" title="8.2 Hadoop压缩配置"></a>8.2 Hadoop压缩配置</h2><h3 id="8-2-1-MR支持的压缩编码"><a href="#8-2-1-MR支持的压缩编码" class="headerlink" title="8.2.1 MR支持的压缩编码"></a>8.2.1 MR支持的压缩编码</h3><table>
<thead>
<tr>
<th>压缩格式</th>
<th>工具</th>
<th>算法</th>
<th>文件扩展名</th>
<th>是否可切分</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFAULT</td>
<td>无</td>
<td>DEFAULT</td>
<td>.deflate</td>
<td>否</td>
</tr>
<tr>
<td>Gzip</td>
<td>gzip</td>
<td>DEFAULT</td>
<td>.gz</td>
<td>否</td>
</tr>
<tr>
<td>bzip2</td>
<td>bzip2</td>
<td>bzip2</td>
<td>.bz2</td>
<td>是</td>
</tr>
<tr>
<td>LZO</td>
<td>lzop</td>
<td>LZO</td>
<td>.lzo</td>
<td>是</td>
</tr>
<tr>
<td>Snappy</td>
<td>无</td>
<td>Snappy</td>
<td>.snappy</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>为了支持多种压缩/解压缩算法，Hadoop引入了编码/解码器，如下表所示</p>
<table>
<thead>
<tr>
<th>压缩格式</th>
<th>对应的编码/解码器</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFLATE</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
</tr>
<tr>
<td>gzip</td>
<td>org.apache.hadoop.io.compress.GzipCodec</td>
</tr>
<tr>
<td>bzip2</td>
<td>org.apache.hadoop.io.compress.BZip2Codec</td>
</tr>
<tr>
<td>LZO</td>
<td>com.hadoop.compression.lzo.LzopCodec</td>
</tr>
<tr>
<td>Snappy</td>
<td>org.apache.hadoop.io.compress.SnappyCodec</td>
</tr>
</tbody>
</table>
<p>压缩性能的比较</p>
<table>
<thead>
<tr>
<th>压缩算法</th>
<th>原始文件大小</th>
<th>压缩文件大小</th>
<th>压缩速度</th>
<th>解压速度</th>
</tr>
</thead>
<tbody>
<tr>
<td>gzip</td>
<td>8.3GB</td>
<td>1.8GB</td>
<td>17.5MB/s</td>
<td>58MB/s</td>
</tr>
<tr>
<td>bzip2</td>
<td>8.3GB</td>
<td>1.1GB</td>
<td>2.4MB/s</td>
<td>9.5MB/s</td>
</tr>
<tr>
<td>LZO</td>
<td>8.3GB</td>
<td>2.9GB</td>
<td>49.3MB/s</td>
<td>74.6MB/s</td>
</tr>
</tbody>
</table>
<p><a href="http://google.github.io/snappy/" target="_blank" rel="external">http://google.github.io/snappy/</a></p>
<p>On a single core of a Core i7 processor in 64-bit mode, Snappy compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more.</p>
<h3 id="8-2-2-压缩参数配置"><a href="#8-2-2-压缩参数配置" class="headerlink" title="8.2.2 压缩参数配置"></a>8.2.2 压缩参数配置</h3><p>要在Hadoop中启用压缩，可以配置如下参数（mapred-site.xml文件中）：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>阶段</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>io.compression.codecs    （在core-site.xml中配置）</td>
<td>org.apache.hadoop.io.compress.DefaultCodec,  org.apache.hadoop.io.compress.GzipCodec,  org.apache.hadoop.io.compress.BZip2Codec,  org.apache.hadoop.io.compress.Lz4Codec</td>
<td>输入压缩</td>
<td>Hadoop使用文件扩展名判断是否支持某种编解码器</td>
</tr>
<tr>
<td>mapreduce.map.output.compress</td>
<td>false</td>
<td>mapper输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.map.output.compress.codec</td>
<td>org.apache.hadoop.io.compress.DefaultCodec</td>
<td>mapper输出</td>
<td>使用LZO、LZ4或snappy编解码器在此阶段压缩数据</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress</td>
<td>false</td>
<td>reducer输出</td>
<td>这个参数设为true启用压缩</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.codec</td>
<td>org.apache.hadoop.io.compress.  DefaultCodec</td>
<td>reducer输出</td>
<td>使用标准工具或者编解码器，如gzip和bzip2</td>
</tr>
<tr>
<td>mapreduce.output.fileoutputformat.compress.type</td>
<td>RECORD</td>
<td>reducer输出</td>
<td>SequenceFile输出使用的压缩类型：NONE和BLOCK</td>
</tr>
</tbody>
</table>
<h2 id="8-3-开启Map输出阶段压缩"><a href="#8-3-开启Map输出阶段压缩" class="headerlink" title="8.3 开启Map输出阶段压缩"></a>8.3 开启Map输出阶段压缩</h2><p>开启map输出阶段压缩可以减少job中map和Reduce task间数据传输量。具体配置如下：</p>
<p><strong>案例实操：</strong></p>
<p>​    1）开启hive中间传输数据压缩功能</p>
<p>hive (default)&gt;set hive.exec.compress.intermediate=true;</p>
<p>2）开启mapreduce中map输出压缩功能</p>
<p>hive (default)&gt;set mapreduce.map.output.compress=true;</p>
<p>3）设置mapreduce中map输出数据的压缩方式</p>
<p>hive (default)&gt;set mapreduce.map.output.compress.codec= org.apache.hadoop.io.compress.SnappyCodec;</p>
<p>4）执行查询语句</p>
<p>​    hive (default)&gt; select count(ename) name from emp;</p>
<h2 id="8-4-开启Reduce输出阶段压缩"><a href="#8-4-开启Reduce输出阶段压缩" class="headerlink" title="8.4 开启Reduce输出阶段压缩"></a>8.4 开启Reduce输出阶段压缩</h2><p>当Hive将输出写入到表中时，输出内容同样可以进行压缩。属性hive.exec.compress.output控制着这个功能。用户可能需要保持默认设置文件中的默认值false，这样默认的输出就是非压缩的纯文本文件了。用户可以通过在查询语句或执行脚本中设置这个值为true，来开启输出结果压缩功能。</p>
<p><strong>案例实操：</strong></p>
<p>1）开启hive最终输出数据压缩功能</p>
<p>hive (default)&gt;set hive.exec.compress.output=true;</p>
<p>2）开启mapreduce最终输出数据压缩</p>
<p>hive (default)&gt;set mapreduce.output.fileoutputformat.compress=true;</p>
<p>3）设置mapreduce最终数据输出压缩方式</p>
<p>hive (default)&gt; set mapreduce.output.fileoutputformat.compress.codec = org.apache.hadoop.io.compress.SnappyCodec;</p>
<p>4）设置mapreduce最终数据输出压缩为块压缩</p>
<p>hive (default)&gt; set mapreduce.output.fileoutputformat.compress.type=BLOCK;</p>
<p>5）测试一下输出结果是否是压缩文件</p>
<p>hive (default)&gt; insert overwrite local directory ‘/opt/module/datas/distribute-result’ select * from emp distribute by deptno sort by empno desc;</p>
<h2 id="8-5-文件存储格式"><a href="#8-5-文件存储格式" class="headerlink" title="8.5 文件存储格式"></a>8.5 文件存储格式</h2><p>Hive支持的存储数的格式主要有：TEXTFILE 、SEQUENCEFILE、ORC、PARQUET。</p>
<h3 id="8-5-1-列式存储和行式存储"><a href="#8-5-1-列式存储和行式存储" class="headerlink" title="8.5.1 列式存储和行式存储"></a>8.5.1 列式存储和行式存储</h3><p>上图左边为逻辑表，右边第一个为行式存储，第二个为列式存储。</p>
<p><strong>行存储的特点：</strong> 查询满足条件的一整行数据的时候，列存储则需要去每个聚集的字段找到对应的每个列的值，行存储只需要找到其中一个值，其余的值都在相邻地方，所以此时行存储查询的速度更快。</p>
<p><strong>列存储的特点：</strong> 因为每个字段的数据聚集存储，在查询只需要少数几个字段的时候，能大大减少读取的数据量；每个字段的数据类型一定是相同的，列式存储可以针对性的设计更好的设计压缩算法。</p>
<p>TEXTFILE和SEQUENCEFILE的存储格式都是基于行存储的；</p>
<p>ORC和PARQUET是基于列式存储的。</p>
<h3 id="8-5-2-TextFile格式"><a href="#8-5-2-TextFile格式" class="headerlink" title="8.5.2 TextFile格式"></a>8.5.2 TextFile格式</h3><p>默认格式，数据不做压缩，磁盘开销大，数据解析开销大。可结合Gzip、Bzip2使用，但使用Gzip这种方式，hive不会对数据进行切分，从而无法对数据进行并行操作。</p>
<h3 id="8-5-3-Orc格式"><a href="#8-5-3-Orc格式" class="headerlink" title="8.5.3 Orc格式"></a>8.5.3 Orc格式</h3><p>Orc (Optimized Row Columnar)是Hive 0.11版里引入的新的存储格式。</p>
<p>可以看到每个Orc文件由1个或多个stripe组成，每个stripe250MB大小，这个Stripe实际相当于RowGroup概念，不过大小由4MB-&gt;250MB，这样应该能提升顺序读的吞吐率。每个Stripe里有三部分组成，分别是Index Data，Row Data，Stripe Footer：</p>
<p>  1）Index Data：一个轻量级的index，默认是每隔1W行做一个索引。这里做的索引应该只是记录某行的各字段在Row Data中的offset。</p>
<p>  2）Row Data：存的是具体的数据，先取部分行，然后对这些行按列进行存储。对每个列进行了编码，分成多个Stream来存储。</p>
<p>  3）Stripe Footer：存的是各个Stream的类型，长度等信息。</p>
<p>每个文件有一个File Footer，这里面存的是每个Stripe的行数，每个Column的数据类型信息等；每个文件的尾部是一个PostScript，这里面记录了整个文件的压缩类型以及FileFooter的长度信息等。在读取文件时，会seek到文件尾部读PostScript，从里面解析到File Footer长度，再读FileFooter，从里面解析到各个Stripe信息，再读各个Stripe，即从后往前读。</p>
<h3 id="8-5-4-Parquet格式"><a href="#8-5-4-Parquet格式" class="headerlink" title="8.5.4 Parquet格式"></a>8.5.4 Parquet格式</h3><p>Parquet是面向分析型业务的列式存储格式，由Twitter和Cloudera合作开发，2015年5月从Apache的孵化器里毕业成为Apache顶级项目。</p>
<p>Parquet文件是以二进制方式存储的，所以是不可以直接读取的，文件中包括该文件的数据和元数据，因此Parquet格式文件是自解析的。</p>
<p>通常情况下，在存储Parquet数据的时候会按照Block大小设置行组的大小，由于一般情况下每一个Mapper任务处理数据的最小单位是一个Block，这样可以把每一个行组由一个Mapper任务处理，增大任务执行并行度。Parquet文件的格式如下图所示。</p>
<p>上图展示了一个Parquet文件的内容，一个文件中可以存储多个行组，文件的首位都是该文件的Magic Code，用于校验它是否是一个Parquet文件，Footer length记录了文件元数据的大小，通过该值和文件长度可以计算出元数据的偏移量，文件的元数据中包括每一个行组的元数据信息和该文件存储数据的Schema信息。除了文件中每一个行组的元数据，每一页的开始都会存储该页的元数据，在Parquet中，有三种类型的页：数据页、字典页和索引页。数据页用于存储当前行组中该列的值，字典页存储该列值的编码字典，每一个列块中最多包含一个字典页，索引页用来存储当前行组下该列的索引，目前Parquet中还不支持索引页。</p>
<h3 id="8-5-5-主流文件存储格式对比实验"><a href="#8-5-5-主流文件存储格式对比实验" class="headerlink" title="8.5.5 主流文件存储格式对比实验"></a>8.5.5 主流文件存储格式对比实验</h3><p>从存储文件的压缩比和查询速度两个角度对比。</p>
<p><strong>存储文件的压缩比测试：</strong></p>
<p>0）测试数据</p>
<p>1）TextFile</p>
<p>（1）创建表，存储数据格式为TEXTFILE</p>
<p>  create table log_text (  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as textfile ;  </p>
<p>（2）向表中加载数据</p>
<p>  hive  (default)&gt; load data local inpath ‘/opt/module/datas/log.data’ into table  log_text ;  </p>
<p>（3）查看表中数据大小</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_text;  </p>
<p>18.1 M /user/hive/warehouse/log_text/log.data</p>
<p>2）ORC</p>
<p>​    （1）创建表，存储数据格式为ORC</p>
<p>  create table log_orc(  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as orc ;  </p>
<p>（2）向表中加载数据</p>
<p>  hive  (default)&gt; insert into table log_orc select * from log_text ;  </p>
<p>（3）查看表中数据大小</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_orc/ ;  </p>
<p>2.8 M /user/hive/warehouse/log_orc/000000_0</p>
<p>3）Parquet</p>
<p>​    （1）创建表，存储数据格式为parquet</p>
<p>  create table log_parquet(  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as parquet ;                 </p>
<p>（2）向表中加载数据</p>
<p>  hive  (default)&gt; insert into table log_parquet select * from log_text ;  </p>
<p>（3）查看表中数据大小</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_parquet/ ;  </p>
<p>13.1 M  /user/hive/warehouse/log_parquet/000000_0</p>
<p>存储文件的压缩比总结：</p>
<p>ORC &gt; Parquet &gt; textFile</p>
<p><strong>存储文件的查询速度测试：</strong></p>
<p>1）TextFile</p>
<p>hive (default)&gt; select count(*) from log_text;</p>
<p>_c0</p>
<p>100000</p>
<p>Time taken: 21.54 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 21.08 seconds, Fetched: 1 row(s)</p>
<p>2）ORC</p>
<p>hive (default)&gt; select count(*) from log_orc;</p>
<p>_c0</p>
<p>100000</p>
<p>Time taken: 20.867 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 22.667 seconds, Fetched: 1 row(s)</p>
<p>3）Parquet</p>
<p>hive (default)&gt; select count(*) from log_parquet;</p>
<p>_c0</p>
<p>100000</p>
<p>Time taken: 22.922 seconds, Fetched: 1 row(s)</p>
<p>Time taken: 21.074 seconds, Fetched: 1 row(s)</p>
<p>存储文件的查询速度总结：查询速度相近。</p>
<h2 id="8-6-存储和压缩结合"><a href="#8-6-存储和压缩结合" class="headerlink" title="8.6 存储和压缩结合"></a>8.6 存储和压缩结合</h2><h3 id="8-6-1-修改Hadoop集群具有Snappy压缩方式"><a href="#8-6-1-修改Hadoop集群具有Snappy压缩方式" class="headerlink" title="8.6.1 修改Hadoop集群具有Snappy压缩方式"></a>8.6.1 修改Hadoop集群具有Snappy压缩方式</h3><p>1）查看hadoop checknative命令使用</p>
<p>[kingge@hadoop104 hadoop-2.7.2]$ hadoop</p>
<p>​       checknative [-a|-h] check native hadoop and compression libraries availability</p>
<p>2）查看hadoop支持的压缩方式</p>
<p>​    [kingge@hadoop104 hadoop-2.7.2]$ hadoop checknative</p>
<p>17/12/24 20:32:52 WARN bzip2.Bzip2Factory: Failed to load/initialize native-bzip2 library system-native, will use pure-Java version</p>
<p>17/12/24 20:32:52 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</p>
<p>Native library checking:</p>
<p>hadoop: true /opt/module/hadoop-2.7.2/lib/native/libhadoop.so</p>
<p>zlib:  true /lib64/libz.so.1</p>
<p>snappy: false </p>
<p>lz4:   true revision:99</p>
<p>bzip2:  false</p>
<p>3）将编译好的支持Snappy压缩的hadoop-2.7.2.tar.gz包导入到hadoop102的/opt/software中</p>
<p>4）解压hadoop-2.7.2.tar.gz到当前路径</p>
<p>[kingge@hadoop102 software]$ tar -zxvf hadoop-2.7.2.tar.gz</p>
<p>5）进入到/opt/software/hadoop-2.7.2/lib/native路径可以看到支持Snappy压缩的动态链接库</p>
<p>[kingge@hadoop102 native]$ pwd</p>
<p>/opt/software/hadoop-2.7.2/lib/native</p>
<p>[kingge@hadoop102 native]$ ll</p>
<p>-rw-r–r–. 1 kingge kingge 472950 9月  1 10:19 libsnappy.a</p>
<p>-rwxr-xr-x. 1 kingge kingge   955 9月  1 10:19 libsnappy.la</p>
<p>lrwxrwxrwx. 1 kingge kingge   18 12月 24 20:39 libsnappy.so -&gt; libsnappy.so.1.3.0</p>
<p>lrwxrwxrwx. 1 kingge kingge   18 12月 24 20:39 libsnappy.so.1 -&gt; libsnappy.so.1.3.0</p>
<p>-rwxr-xr-x. 1 kingge kingge 228177 9月  1 10:19 libsnappy.so.1.3.0</p>
<p>6）拷贝/opt/software/hadoop-2.7.2/lib/native里面的所有内容到开发集群的/opt/module/hadoop-2.7.2/lib/native路径上</p>
<p>​    [kingge@hadoop102 native]$ cp ../native/* /opt/module/hadoop-2.7.2/lib/native/</p>
<p>7）分发集群</p>
<p>​    [kingge@hadoop102 lib]$ xsync native/</p>
<p>8）再次查看hadoop支持的压缩类型</p>
<p>[kingge@hadoop102 hadoop-2.7.2]$ hadoop checknative</p>
<p>17/12/24 20:45:02 WARN bzip2.Bzip2Factory: Failed to load/initialize native-bzip2 library system-native, will use pure-Java version</p>
<p>17/12/24 20:45:02 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</p>
<p>Native library checking:</p>
<p>hadoop: true /opt/module/hadoop-2.7.2/lib/native/libhadoop.so</p>
<p>zlib:  true /lib64/libz.so.1</p>
<p>snappy: true /opt/module/hadoop-2.7.2/lib/native/libsnappy.so.1</p>
<p>lz4:   true revision:99</p>
<p>bzip2:  false</p>
<p>9）重新启动hadoop集群和hive</p>
<h3 id="8-6-2-测试存储和压缩"><a href="#8-6-2-测试存储和压缩" class="headerlink" title="8.6.2 测试存储和压缩"></a>8.6.2 测试存储和压缩</h3><p>官网：<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC</a></p>
<p>ORC存储方式的压缩：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Default</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>orc.compress</td>
<td>ZLIB</td>
<td>high level  compression (one of NONE, ZLIB, SNAPPY)</td>
</tr>
<tr>
<td>orc.compress.size</td>
<td>262,144</td>
<td>number of  bytes in each compression chunk</td>
</tr>
<tr>
<td>orc.stripe.size</td>
<td>67,108,864</td>
<td>number of  bytes in each stripe</td>
</tr>
<tr>
<td>orc.row.index.stride</td>
<td>10,000</td>
<td>number of  rows between index entries (must be &gt;= 1000)</td>
</tr>
<tr>
<td>orc.create.index</td>
<td>true</td>
<td>whether to  create row indexes</td>
</tr>
<tr>
<td>orc.bloom.filter.columns</td>
<td>“”</td>
<td>comma  separated list of column names for which bloom filter should be created</td>
</tr>
<tr>
<td>orc.bloom.filter.fpp</td>
<td>0.05</td>
<td>false  positive probability for bloom filter (must &gt;0.0 and &lt;1.0)</td>
</tr>
</tbody>
</table>
<p>1）创建一个非压缩的的ORC存储方式</p>
<p>​    （1）建表语句</p>
<p>  create table log_orc_none(  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as orc tblproperties  (“orc.compress”=”NONE”);  </p>
<p>​    （2）插入数据</p>
<p>  hive  (default)&gt; insert into table log_orc_none select * from log_text ;  </p>
<p>​    （3）查看插入后数据</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_orc_none/ ;  </p>
<p>7.7 M /user/hive/warehouse/log_orc_none/000000_0</p>
<p>2）创建一个SNAPPY压缩的ORC存储方式</p>
<p>​    （1）建表语句</p>
<p>  create table log_orc_snappy(  track_time string,  url string,  session_id string,  referer string,  ip string,  end_user_id string,  city_id string  )  row format delimited fields terminated  by ‘\t’  stored as orc tblproperties (“orc.compress”=”SNAPPY”);  </p>
<p>​    （2）插入数据</p>
<p>  hive  (default)&gt; insert into table log_orc_snappy select * from log_text ;  </p>
<p>​    （3）查看插入后数据</p>
<p>  hive  (default)&gt; dfs -du -h /user/hive/warehouse/log_orc_snappy/ ;  </p>
<p>3.8 M  /user/hive/warehouse/log_orc_snappy/000000_0</p>
<p>3）上一节中默认创建的ORC存储方式，导入数据后的大小为</p>
<p>2.8 M /user/hive/warehouse/log_orc/000000_0</p>
<p>比Snappy压缩的还小。原因是orc存储文件默认采用ZLIB压缩。比snappy压缩的小。</p>
<p><strong>4**</strong>）存储方式和压缩总结：**</p>
<p>​    在实际的项目开发当中，hive表的数据存储格式一般选择：orc或parquet。压缩方式一般选择snappy，lzo。</p>
<h1 id="九-企业级调优"><a href="#九-企业级调优" class="headerlink" title="九 企业级调优"></a>九 企业级调优</h1><h2 id="9-1-Fetch抓取"><a href="#9-1-Fetch抓取" class="headerlink" title="9.1 Fetch抓取"></a>9.1 Fetch抓取</h2><p>Fetch抓取是指，Hive中对某些情况的查询可以不必使用MapReduce计算。例如：SELECT * FROM employees;在这种情况下，Hive可以简单地读取employee对应的存储目录下的文件，然后输出查询结果到控制台。</p>
<p>在hive-default.xml.template文件中hive.fetch.task.conversion默认是more，老版本hive默认是minimal，该属性修改为more以后，在全局查找、字段查找、limit查找等都不走mapreduce。</p>
  <property>      <name>hive.fetch.task.conversion</name>      <value>more</value>      <description>       Expects one of [none, minimal, more].       Some select queries can be converted to single FETCH task minimizing  latency.       Currently the query should be single sourced not having any subquery  and should not have       any aggregations or distincts (which incurs RS), lateral views and  joins.       0. none : disable hive.fetch.task.conversion       1.  minimal : SELECT STAR, FILTER on partition columns, LIMIT only     2. more   : SELECT, FILTER, LIMIT only (support TABLESAMPLE and virtual columns)      </description>     </property>  

<p>案例实操：</p>
<p>​    1）把hive.fetch.task.conversion设置成none，然后执行查询语句，都会执行mapreduce程序。</p>
<p>hive (default)&gt; set hive.fetch.task.conversion=none;</p>
<p>hive (default)&gt; select * from emp;</p>
<p>hive (default)&gt; select ename from emp;</p>
<p>hive (default)&gt; select ename from emp limit 3;</p>
<p>​    2）把hive.fetch.task.conversion设置成more，然后执行查询语句，如下查询方式都不会执行mapreduce程序。</p>
<p>hive (default)&gt; set hive.fetch.task.conversion=more;</p>
<p>hive (default)&gt; select * from emp;</p>
<p>hive (default)&gt; select ename from emp;</p>
<p>hive (default)&gt; select ename from emp limit 3;</p>
<h2 id="9-2-本地模式"><a href="#9-2-本地模式" class="headerlink" title="9.2 本地模式"></a>9.2 本地模式</h2><p>大多数的Hadoop Job是需要Hadoop提供的完整的可扩展性来处理大数据集的（<strong><em>意思就是需要搭建完整的***</em></strong>hadoop*<strong>*</strong>分布式集群*<strong>）。不过，有时Hive的*</strong>输入数据量是非常小*的**。在这种情况下，为查询触发执行任务消耗的时间可能会比实际job的执行时间要多的多。对于大多数这种情况，Hive可以通过本地模式在单台机器上处理所有的任务。对于小数据集，执行时间可以明显被缩短。</p>
<p>用户可以通过设置hive.exec.mode.local.auto的值为true，来让Hive在适当的时候自动启动这个优化。</p>
<p>  set hive.exec.mode.local.auto=true; //开启本地mr  //设置local mr的最大输入数据量，当输入数据量小于这个值时采用local   mr的方式，默认为134217728，即128M  set hive.exec.mode.local.auto.inputbytes.max=50000000;  //设置local mr的最大输入文件个数，当输入文件个数小于这个值时采用local mr的方式，默认为4  set hive.exec.mode.local.auto.input.files.max=10;  </p>
<p>案例实操：</p>
<p>1）开启本地模式，并执行查询语句</p>
<p>hive (default)&gt; set hive.exec.mode.local.auto=true; </p>
<p>hive (default)&gt; select * from emp cluster by deptno;</p>
<p>Time taken: 1.328 seconds, Fetched: 14 row(s)</p>
<p>2）关闭本地模式，并执行查询语句</p>
<p>hive (default)&gt; set hive.exec.mode.local.auto=false; </p>
<p>hive (default)&gt; select * from emp cluster by deptno;</p>
<p>Time taken: 20.09 seconds, Fetched: 14 row(s)</p>
<h2 id="9-3-表的优化（重要）"><a href="#9-3-表的优化（重要）" class="headerlink" title="9.3 表的优化（重要）"></a>9.3 表的优化（重要）</h2><h3 id="9-3-1-小表、大表Join"><a href="#9-3-1-小表、大表Join" class="headerlink" title="9.3.1 小表、大表Join"></a>9.3.1 小表、大表Join</h3><p>将key相对分散，并且数据量小的表放在join的左边，这样可以有效减少内存溢出错误发生的几率；再进一步，可以使用Group让小的维度表（1000条以下的记录条数）先进内存。在map端完成reduce。</p>
<p>实际测试发现：新版的hive已经对小表JOIN大表和大表JOIN小表进行了优化。小表放在左边和右边已经没有明显区别。</p>
<p><strong>案例实操</strong></p>
<p>（0）需求：测试大表JOIN小表和小表JOIN大表的效率</p>
<p>（1）建大表、小表和JOIN后表的语句</p>
<p>  // 创建大表  create table bigtable(id bigint, time bigint, uid string, keyword  string, url_rank int, click_num int, click_url string) row format delimited  fields terminated by ‘\t’;  // 创建小表  create table smalltable(id bigint, time bigint, uid string, keyword  string, url_rank int, click_num int, click_url string) row format delimited  fields terminated by ‘\t’;  // 创建join后表的语句  create table jointable(id bigint, time bigint, uid string, keyword  string, url_rank int, click_num int, click_url string) row format delimited  fields terminated by ‘\t’;  </p>
<p>（2）分别向大表和小表中导入数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/bigtable’ into table bigtable;</p>
<p>hive (default)&gt;load data local inpath ‘/opt/module/datas/smalltable’ into table smalltable;</p>
<p>（3）关闭mapjoin功能（默认是打开的-这里为了测试先把他关闭）</p>
<p>set hive.auto.convert.join = false;</p>
<p>（4）执行小表JOIN大表语句</p>
<p>  insert overwrite table jointable  select b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,  b.click_url  from smalltable s  left join bigtable b  on b.id = s.id;  </p>
<p>Time taken: 35.921 seconds</p>
<p>（5）执行大表JOIN小表语句</p>
<p>  insert overwrite table jointable  select b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,  b.click_url  from bigtable b  left join smalltable s  on s.id = b.id;  </p>
<p>Time taken: 34.196 seconds</p>
<h3 id="9-3-2-大表Join大表"><a href="#9-3-2-大表Join大表" class="headerlink" title="9.3.2 大表Join大表"></a>9.3.2 大表Join大表</h3><p>1）空KEY过滤</p>
<p>有时join超时是因为某些key对应的数据太多，而相同key对应的数据都会发送到相同的reducer上，从而导致内存不够。此时我们应该仔细分析这些异常的key，很多情况下，这些key对应的数据是异常数据，我们需要在SQL语句中进行过滤。例如key对应的字段为空，操作如下：</p>
<p>案例实操</p>
<p>（1）配置历史服务器</p>
<p>​    配置mapred-site.xml</p>
  <property>  <name>mapreduce.jobhistory.address</name>  <value>hadoop102:10020</value>  </property>  <property>      <name>mapreduce.jobhistory.webapp.address</name>      <value>hadoop102:19888</value>  </property>  

<p>​    启动历史服务器</p>
<p>sbin/mr-jobhistory-daemon.sh start historyserver</p>
<p>​    查看jobhistory</p>
<p><a href="http://192.168.1.102:19888/jobhistory" target="_blank" rel="external">http://192.168.1.102:19888/jobhistory</a></p>
<p>（2）创建原始数据表、空id表、合并后数据表</p>
<p>  // 创建原始表  create table ori(id  bigint, time bigint, uid string, keyword string, url_rank int, click_num int,  click_url string) row format delimited fields terminated by ‘\t’;  // 创建空id表  create table  nullidtable(id bigint, time bigint, uid string, keyword string, url_rank int,  click_num int, click_url string) row format delimited fields terminated by  ‘\t’;  // 创建join后表的语句  create table  jointable(id bigint, time bigint, uid string, keyword string, url_rank int,  click_num int, click_url string) row format delimited fields terminated by  ‘\t’;  </p>
<p>（3）分别加载原始数据和空id数据到对应表中</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/ori’ into table ori;</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/nullid’ into table nullidtable;</p>
<p>（4）测试不过滤空id</p>
<p>hive (default)&gt; insert overwrite table jointable </p>
<p>select n.* from nullidtable n left join ori o on n.id = o.id;</p>
<p>Time taken: 42.038 seconds</p>
<p>（5）测试过滤空id</p>
<p>hive (default)&gt; insert overwrite table jointable </p>
<p>select n.<em> from (select </em> from nullidtable where id is not null ) n left join ori o on n.id = o.id;</p>
<p>Time taken: 31.725 seconds</p>
<p>2）空key转换</p>
<p>有时虽然某个key为空对应的数据很多，但是相应的数据不是异常数据，必须要包含在join的结果中，此时我们可以表a中key为空的字段赋一个随机的值，使得数据随机均匀地分不到不同的reducer上。例如：</p>
<p><strong>案例实操：</strong></p>
<p><strong>不随机分布空**</strong>null<strong>**值：</strong></p>
<p>（1）设置5个reduce个数</p>
<p>set mapreduce.job.reduces = 5;</p>
<p>（2）JOIN两张表</p>
<p>  insert overwrite table jointable  select n.* from nullidtable n left join ori b on n.id = b.id;  </p>
<p><strong>结果：可以看出来，出现了数据倾斜，某些**</strong>reducer<strong><strong>的资源消耗远大于其他</strong></strong>reducer<strong>**。</strong></p>
<p>  <strong>打开历史服务器查看</strong></p>
<p>随机分布空null值</p>
<p>（1）设置5个reduce个数</p>
<p>set mapreduce.job.reduces = 5;</p>
<p>（2）JOIN两张表</p>
<p>  insert overwrite table  jointable  select n.* from  nullidtable n full join ori o on   case when n.id is null  then concat(‘hive’, rand()) else n.id end = o.id;  </p>
<p><strong>结果：可以看出来，消除了数据倾斜，负载均衡**</strong>reducer<strong>**的资源消耗</strong></p>
<h3 id="9-3-3-MapJoin"><a href="#9-3-3-MapJoin" class="headerlink" title="9.3.3 MapJoin"></a>9.3.3 MapJoin</h3><p>如果不指定MapJoin或者不符合MapJoin的条件，那么Hive解析器会将Join操作转换成Common Join，即：在Reduce阶段完成join。容易发生数据倾斜。可以用MapJoin把小表全部加载到内存在map端进行join，避免reducer处理。</p>
<p>1）开启MapJoin参数设置：</p>
<p>（1）设置自动选择Mapjoin</p>
<p>set hive.auto.convert.join = true; 默认为true</p>
<p>（2）大表小表的阈值设置（默认25M一下认为是小表）：</p>
<p>set hive.mapjoin.smalltable.filesize=25000000;</p>
<p>2）MapJoin工作机制</p>
<p><strong>案例实操：</strong></p>
<p>（1）开启Mapjoin功能</p>
<p>set hive.auto.convert.join = true; 默认为true</p>
<p>（2）执行小表JOIN大表语句</p>
<p>  insert overwrite table jointable  select b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,  b.click_url  from smalltable s  join bigtable b  on s.id = b.id;  </p>
<p>Time taken: 24.594 seconds</p>
<p>（3）执行大表JOIN小表语句</p>
<p>  insert overwrite table jointable  select b.id, b.time, b.uid, b.keyword, b.url_rank, b.click_num,  b.click_url  from bigtable b  join smalltable s  on s.id = b.id;  </p>
<p>Time taken: 24.315 seconds</p>
<h3 id="9-3-4-Group-By"><a href="#9-3-4-Group-By" class="headerlink" title="9.3.4 Group By"></a>9.3.4 Group By</h3><p>默认情况下，Map阶段同一Key数据分发给一个reduce，当一个key数据过大时就倾斜了。</p>
<p>  并不是所有的聚合操作都需要在Reduce端完成，很多聚合操作都可以先在Map端进行部分聚合，最后在Reduce端得出最终结果。</p>
<p>1）开启Map端聚合参数设置</p>
<p>​    （1）是否在Map端进行聚合，默认为True</p>
<p>hive.map.aggr = true</p>
<p>（2）在Map端进行聚合操作的条目数目</p>
<p>  hive.groupby.mapaggr.checkinterval = 100000</p>
<p>（3）有数据倾斜的时候进行负载均衡（默认是false）</p>
<p>  hive.groupby.skewindata = true</p>
<p>  当选项设定为 true，生成的查询计划会有两个MR Job。第一个MR Job中，Map的输出结果会随机分布到Reduce中，每个Reduce做部分聚合操作，并输出结果，这样处理的结果是相同的Group By Key有可能被分发到不同的Reduce中，从而达到负载均衡的目的；第二个MR Job再根据预处理的数据结果按照Group By Key分布到Reduce中（这个过程可以保证相同的Group By Key被分布到同一个Reduce中），最后完成最终的聚合操作。</p>
<h3 id="9-3-5-Count-Distinct-去重统计"><a href="#9-3-5-Count-Distinct-去重统计" class="headerlink" title="9.3.5 Count(Distinct) 去重统计"></a>9.3.5 Count(Distinct) 去重统计</h3><p>数据量小的时候无所谓，数据量大的情况下，由于COUNT DISTINCT操作需要用一个Reduce Task来完成，这一个Reduce需要处理的数据量太大，就会导致整个Job很难完成，一般COUNT DISTINCT使用先GROUP BY再COUNT的方式替换：</p>
<p><strong>案例实操</strong></p>
<p>​    （1）创建一张大表</p>
<p>  hive (default)&gt; create table bigtable(id bigint,  time bigint, uid string, keyword string, url_rank int, click_num int,  click_url string) row format delimited fields terminated by ‘\t’;  </p>
<p>​    （2）加载数据</p>
<p>hive (default)&gt; load data local inpath ‘/opt/module/datas/bigtable’ into table bigtable;</p>
<p>（3）设置5个reduce个数</p>
<p>set mapreduce.job.reduces = 5;</p>
<p>（4）执行去重id查询</p>
<p>hive (default)&gt; select count(distinct id) from bigtable;</p>
<p>Stage-Stage-1: Map: 1 Reduce: 1  Cumulative CPU: 7.12 sec  HDFS Read: 120741990 HDFS Write: 7 SUCCESS</p>
<p>Total MapReduce CPU Time Spent: 7 seconds 120 msec</p>
<p>OK</p>
<p>c0</p>
<p>100001</p>
<p>Time taken: 23.607 seconds, Fetched: 1 row(s)</p>
<p>​    （5）采用GROUP by去重id</p>
<p>hive (default)&gt; select count(id) from (select id from bigtable group by id) a;</p>
<p>Stage-Stage-1: Map: 1 Reduce: 5  Cumulative CPU: 17.53 sec  HDFS Read: 120752703 HDFS Write: 580 SUCCESS</p>
<p>Stage-Stage-2: Map: 1 Reduce: 1  Cumulative CPU: 4.29 sec  HDFS Read: 9409 HDFS Write: 7 SUCCESS</p>
<p>Total MapReduce CPU Time Spent: 21 seconds 820 msec</p>
<p>OK</p>
<p>_c0</p>
<p>100001</p>
<p>Time taken: 50.795 seconds, Fetched: 1 row(s)</p>
<p>虽然会多用一个Job来完成，但在数据量大的情况下，这个绝对是值得的。</p>
<h3 id="9-3-6-笛卡尔积"><a href="#9-3-6-笛卡尔积" class="headerlink" title="9.3.6 笛卡尔积"></a>9.3.6 笛卡尔积</h3><p>尽量避免笛卡尔积，join的时候不加on条件，或者无效的on条件，Hive只能使用1个reducer来完成笛卡尔积。</p>
<h3 id="9-3-7-行列过滤"><a href="#9-3-7-行列过滤" class="headerlink" title="9.3.7 行列过滤"></a>9.3.7 行列过滤</h3><p>列处理：在SELECT中，只拿需要的列，如果有，尽量使用分区过滤，少用SELECT <em>。（**</em>select*<strong> *</strong>具体的列名，非必要时不要使用*<strong>*</strong>select *<strong><em> </em></strong>取全列***）</p>
<p>行处理：在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在Where后面，那么就会先全表关联，之后再过滤。（<strong><em>两个表关联，那么应该先使用***</em></strong>where*<strong>*</strong>过滤自身的数据，然后再*<strong>*</strong>join*<strong>*</strong>两张表，这样数据的操作会更快***）</p>
<p>比如：</p>
<p><strong>案例实操：</strong></p>
<p>​    （1）测试先关联两张表，再用where条件过滤</p>
<p>hive (default)&gt; select o.id from bigtable b</p>
<p>join ori o on o.id = b.id</p>
<p>where o.id &lt;= 10;</p>
<p>Time taken: 34.406 seconds, Fetched: 100 row(s)</p>
<p>（2）通过子查询后，再关联表</p>
<p>hive (default)&gt; select b.id from bigtable b</p>
<p>join (select id from ori where id &lt;= 10 ) o on b.id = o.id;</p>
<p>Time taken: 30.058 seconds, Fetched: 100 row(s)</p>
<h3 id="9-3-8-动态分区调整"><a href="#9-3-8-动态分区调整" class="headerlink" title="9.3.8 动态分区调整"></a>9.3.8 动态分区调整</h3><p>关系型数据库中，对分区表Insert数据时候，数据库自动会根据分区字段的值，将数据插入到相应的分区中，Hive中也提供了类似的机制，即动态分区(Dynamic Partition)，只不过，使用Hive的动态分区，需要进行相应的配置。</p>
<p>1）开启动态分区参数设置</p>
<p>（1）开启动态分区功能（默认true，开启）</p>
<p>hive.exec.dynamic.partition=true</p>
<p>（2）设置为非严格模式（动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。）</p>
<p>hive.exec.dynamic.partition.mode=nonstrict</p>
<p>（3）在所有执行MR的节点上，最大一共可以创建多少个动态分区。</p>
<p>hive.exec.max.dynamic.partitions=1000</p>
<p>​    （4）在每个执行MR的节点上，最大可以创建多少个动态分区。该参数需要根据实际的数据来设定。比如：源数据中包含了一年的数据，即day字段有365个值，那么该参数就需要设置成大于365，如果使用默认值100，则会报错。</p>
<p>hive.exec.max.dynamic.partitions.pernode=100</p>
<p>（5）整个MR Job中，最大可以创建多少个HDFS文件。</p>
<p>hive.exec.max.created.files=100000</p>
<p>（6）当有空分区生成时，是否抛出异常。一般不需要设置。</p>
<p>hive.error.on.empty.partition=false</p>
<p>2）案例实操</p>
<p>需求：将ori中的数据按照时间(如：20111230000008)，插入到目标表ori_partitioned_target的相应分区中。</p>
<p>（1）创建分区表</p>
<p>  create table  ori_partitioned(id bigint, time bigint, uid string, keyword string, url_rank  int, click_num int, click_url string)   partitioned by (p_time  bigint)   row format delimited  fields terminated by ‘\t’;  </p>
<p>（2）加载数据到分区表中</p>
<p>  hive  (default)&gt; load data local inpath ‘/opt/module/datas/ds1’ into table  ori_partitioned partition(p_time=’20111230000010’) ;  hive  (default)&gt; load data local inpath ‘/opt/module/datas/ds2’ into table  ori_partitioned partition(p_time=’20111230000011’) ;  </p>
<p>（3）创建目标分区表</p>
<p>  create  table ori_partitioned_target(id bigint, time bigint, uid string, keyword  string, url_rank int, click_num int, click_url string) PARTITIONED BY (p_time  STRING) row format delimited fields terminated by ‘\t’;  </p>
<p>（4）设置动态分区</p>
<p>  set hive.exec.dynamic.partition = true;  set hive.exec.dynamic.partition.mode = nonstrict;  set hive.exec.max.dynamic.partitions = 1000;  set hive.exec.max.dynamic.partitions.pernode = 100;  set hive.exec.max.created.files = 100000;  set hive.error.on.empty.partition = false;     hive (default)&gt; insert overwrite table  ori_partitioned_target partition (p_time)   select id, time, uid, keyword, url_rank, click_num, click_url, p_time  from ori_partitioned;  </p>
<p>（5）查看目标分区表的分区情况</p>
<p>hive (default)&gt; show partitions ori_partitioned_target;</p>
<h3 id="9-3-9-分桶"><a href="#9-3-9-分桶" class="headerlink" title="9.3.9 分桶"></a>9.3.9 分桶</h3><p>详见6.6章。</p>
<h3 id="9-3-10-分区"><a href="#9-3-10-分区" class="headerlink" title="9.3.10 分区"></a>9.3.10 分区</h3><p>详见4.6章。</p>
<h2 id="9-4-数据倾斜"><a href="#9-4-数据倾斜" class="headerlink" title="9.4 数据倾斜"></a>9.4 数据倾斜</h2><h3 id="9-4-1-合理设置Map数"><a href="#9-4-1-合理设置Map数" class="headerlink" title="9.4.1 合理设置Map数"></a>9.4.1 合理设置Map数</h3><p><strong>1**</strong>）通常情况下，作业会通过input<strong><strong>的目录产生一个或者多个map</strong></strong>任务。**</p>
<p>主要的决定因素有：input的文件总个数，input的文件大小，集群设置的文件块大小。</p>
<p><strong>2**</strong>）是不是map<strong>**数越多越好？</strong></p>
<p>答案是否定的。如果一个任务有很多小文件（远远小于块大小128m），则每个小文件也会被当做一个块，用一个map任务来完成，而一个map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。而且，同时可执行的map数是受限的。</p>
<p><strong>3**</strong>）是不是保证每个map<strong><strong>处理接近128m</strong></strong>的文件块，就高枕无忧了？**</p>
<p>答案也是不一定。比如有一个127m的文件，正常会用一个map去完成，但这个文件只有一个或者两个小字段，却有几千万的记录，如果map处理的逻辑比较复杂，用一个map任务去做，肯定也比较耗时。</p>
<p>针对上面的问题2和3，我们需要采取两种方式来解决：即减少map数和增加map数；</p>
<h3 id="9-4-2-小文件进行合并"><a href="#9-4-2-小文件进行合并" class="headerlink" title="9.4.2 小文件进行合并"></a>9.4.2 小文件进行合并</h3><p>在map执行前合并小文件，减少map数：CombineHiveInputFormat具有对小文件进行合并的功能（系统默认的格式）。HiveInputFormat没有对小文件合并功能。</p>
<p>set hive.input.format= org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;</p>
<h3 id="9-4-3-复杂文件增加Map数"><a href="#9-4-3-复杂文件增加Map数" class="headerlink" title="9.4.3 复杂文件增加Map数"></a>9.4.3 复杂文件增加Map数</h3><p>当input的文件都很大，任务逻辑复杂，map执行非常慢的时候，可以考虑增加Map数，来使得每个map处理的数据量减少，从而提高任务的执行效率。</p>
<p>增加map的方法为：根据computeSliteSize(Math.max(minSize,Math.min(maxSize,blocksize)))=blocksize=128M公式，调整maxSize最大值。让maxSize最大值低于blocksize就可以增加map的个数。</p>
<p><strong>案例实操：</strong></p>
<p>（1）执行查询</p>
<p>hive (default)&gt; select count(*) from emp;</p>
<p>Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 1</p>
<p>​    （2）设置最大切片值为100个字节 默认256M</p>
<p>hive (default)&gt; set mapreduce.input.fileinputformat.split.maxsize=100;</p>
<p>hive (default)&gt; select count(*) from emp;</p>
<p>Hadoop job information for Stage-1: number of mappers: 6; number of reducers: 1</p>
<h3 id="9-4-4-合理设置Reduce数"><a href="#9-4-4-合理设置Reduce数" class="headerlink" title="9.4.4 合理设置Reduce数"></a>9.4.4 合理设置Reduce数</h3><p><strong>1**</strong>）调整reduce<strong>**个数方法一</strong></p>
<p>（1）每个Reduce处理的数据量默认是256MB</p>
<p>hive.exec.reducers.bytes.per.reducer=256000000</p>
<p>​    （2）每个任务最大的reduce数，默认为1009</p>
<p>hive.exec.reducers.max=1009</p>
<p>（3）计算reducer数的公式</p>
<p>N=min(参数2，总输入数据量/参数1)</p>
<p><strong>2**</strong>）调整reduce<strong>**个数方法二</strong></p>
<p>在hadoop的mapred-default.xml文件中修改</p>
<p>设置每个job的Reduce个数</p>
<p>set mapreduce.job.reduces = 15;</p>
<p><strong>3**</strong>）reduce<strong>**个数并不是越多越好</strong></p>
<p>1）过多的启动和初始化reduce也会消耗时间和资源；</p>
<p>2）另外，有多少个reduce，就会有多少个输出文件，如果生成了很多个小文件，那么如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题；</p>
<p>在设置reduce个数的时候也需要考虑这两个原则：处理大数据量利用合适的reduce数；使单个reduce任务处理数据量大小要合适；</p>
<h2 id="9-5-并行执行"><a href="#9-5-并行执行" class="headerlink" title="9.5 并行执行"></a>9.5 并行执行</h2><p>Hive会将一个查询转化成一个或者多个阶段。这样的阶段可以是MapReduce阶段、抽样阶段、合并阶段、limit阶段。或者Hive执行过程中可能需要的其他阶段。默认情况下，Hive一次只会执行一个阶段。不过，某个特定的job可能包含众多的阶段，而这些阶段可能并非完全互相依赖的，也就是说有些阶段是可以并行执行的，这样可能使得整个job的执行时间缩短。不过，如果有更多的阶段可以并行执行，那么job可能就越快完成。</p>
<p>​    通过设置参数hive.exec.parallel值为true（默认是false），就可以开启并发执行。不过，在共享集群中，需要注意下，如果job中并行阶段增多，那么集群利用率就会增加。</p>
<p>  set hive.exec.parallel=true;       //打开任务并行执行  set hive.exec.parallel.thread.number=16; //同一个sql允许最大并行度，默认为8。  </p>
<p>当然，得是在系统资源比较空闲的时候才有优势，否则，没资源，并行也起不来。</p>
<h2 id="9-6-严格模式"><a href="#9-6-严格模式" class="headerlink" title="9.6 严格模式"></a>9.6 严格模式</h2><p>Hive提供了一个严格模式，可以防止用户执行那些可能意向不到的不好的影响的查询。</p>
<p>​    通过设置属性hive.mapred.mode值为默认是非严格模式nonstrict 。开启严格模式需要修改hive.mapred.mode值为strict，开启严格模式可以禁止3种类型的查询。</p>
  <property>      <name>hive.mapred.mode</name>      <value>strict</value>      <description>       The mode in which the Hive operations are being performed.        In strict mode, some risky queries are not allowed to run. They  include:        Cartesian Product.        No partition being picked up for a query.        Comparing bigints and strings.        Comparing bigints and doubles.        Orderby without limit.      </description>     </property>  

<p>1）对于分区表，除非where语句中含有分区字段过滤条件来限制范围，否则不允许执行。换句话说，就是用户不允许扫描所有分区。进行这个限制的原因是，通常分区表都拥有非常大的数据集，而且数据增加迅速。没有进行分区限制的查询可能会消耗令人不可接受的巨大资源来处理这个表。</p>
<p>2）对于使用了order by语句的查询，要求必须使用limit语句。因为order by为了执行排序过程会将所有的结果数据分发到同一个Reducer中进行处理，强制要求用户增加这个LIMIT语句可以防止Reducer额外执行很长一段时间。</p>
<p>3）限制笛卡尔积的查询。对关系型数据库非常了解的用户可能期望在执行JOIN查询的时候不使用ON语句而是使用where语句，这样关系数据库的执行优化器就可以高效地将WHERE语句转化成那个ON语句。不幸的是，Hive并不会执行这种优化，因此，如果表足够大，那么这个查询就会出现不可控的情况。</p>
<h2 id="9-7-JVM重用-重要"><a href="#9-7-JVM重用-重要" class="headerlink" title="9.7 JVM重用(重要)"></a>9.7 JVM重用(重要)</h2><p>JVM重用是Hadoop调优参数的内容，其对Hive的性能具有非常大的影响，特别是对于很难避免小文件的场景或task特别多的场景，这类场景大多数执行时间都很短。</p>
<p>Hadoop的默认配置通常是使用派生JVM来执行map和Reduce任务的。这时JVM的启动过程可能会造成相当大的开销，尤其是执行的job包含有成百上千task任务的情况。JVM重用可以使得JVM实例在同一个job中重新使用N次。N的值可以在Hadoop的mapred-site.xml文件中进行配置。通常在10-20之间，具体多少需要根据具体业务场景测试得出。</p>
  <property>     <name>mapreduce.job.jvm.numtasks</name>     <value>10</value>     <description>How many tasks to run per jvm. If set to -1, there  is     no limit.      </description>  </property>  

<p>这个功能的缺点是，开启JVM重用将一直占用使用到的task插槽，以便进行重用，直到任务完成后才能释放。如果某个“不平衡的”job中有某几个reduce task执行的时间要比其他Reduce task消耗的时间多的多的话，那么保留的插槽就会一直空闲着却无法被其他的job使用，直到所有的task都结束了才会释放。</p>
<h2 id="9-8-推测执行"><a href="#9-8-推测执行" class="headerlink" title="9.8 推测执行"></a>9.8 推测执行</h2><p>在分布式集群环境下，因为程序Bug（包括Hadoop本身的bug），负载不均衡或者资源分布不均等原因，会造成同一个作业的多个任务之间运行速度不一致，有些任务的运行速度可能明显慢于其他任务（比如一个作业的某个任务进度只有50%，而其他所有任务已经运行完毕），则这些任务会拖慢作业的整体执行进度。为了避免这种情况发生，Hadoop采用了推测执行（Speculative Execution）机制，它根据一定的法则推测出“拖后腿”的任务，并为这样的任务启动一个备份任务，让该任务与原始任务同时处理同一份数据，并最终选用最先成功运行完成任务的计算结果作为最终结果。</p>
<p>设置开启推测执行参数：Hadoop的mapred-site.xml文件中进行配置</p>
  <property>     <name>mapreduce.map.speculative</name>     <value>true</value>     <description>If true, then multiple instances of some map tasks           may be executed in  parallel.</description>  </property>     <property>     <name>mapreduce.reduce.speculative</name>     <value>true</value>     <description>If true, then multiple instances of some reduce  tasks           may be executed in  parallel.</description>  </property>  

<p>不过hive本身也提供了配置项来控制reduce-side的推测执行：</p>
<p>​     <property>      <name>hive.mapred.reduce.tasks.speculative.execution</name>      <value>true</value>      <description>Whether speculative execution for reducers should  be turned on. </description>     </property>  </p>
<p>关于调优这些推测执行变量，还很难给一个具体的建议。如果用户对于运行时的偏差非常敏感的话，那么可以将这些功能关闭掉。如果用户因为输入数据量很大而需要执行长时间的map或者Reduce task的话，那么启动推测执行造成的浪费是非常巨大大。</p>
<h2 id="9-9-压缩"><a href="#9-9-压缩" class="headerlink" title="9.9 压缩"></a>9.9 压缩</h2><p>详见第8章。</p>
<h2 id="9-10-执行计划（Explain）"><a href="#9-10-执行计划（Explain）" class="headerlink" title="9.10 执行计划（Explain）"></a>9.10 执行计划（Explain）</h2><p>1）基本语法</p>
<p>EXPLAIN [EXTENDED | DEPENDENCY | AUTHORIZATION] query</p>
<p>2）案例实操</p>
<p>（1）查看下面这条语句的执行计划</p>
<p>hive (default)&gt; explain select * from emp;</p>
<p>hive (default)&gt; explain select deptno, avg(sal) avg_sal from emp group by deptno;</p>
<p>（2）查看详细执行计划</p>
<p>hive (default)&gt; explain extended select * from emp;</p>
<p>hive (default)&gt; explain extended select deptno, avg(sal) avg_sal from emp group by deptno;</p>
<h1 id="十-Hive实战"><a href="#十-Hive实战" class="headerlink" title="十 Hive实战"></a>十 Hive实战</h1><p>敬请期待</p>
<h1 id="十一-数据仓库"><a href="#十一-数据仓库" class="headerlink" title="十一 数据仓库"></a>十一 数据仓库</h1><h2 id="11-1-什么是数据仓库"><a href="#11-1-什么是数据仓库" class="headerlink" title="11.1 什么是数据仓库"></a>11.1 什么是数据仓库</h2><p>数据仓库，英文名称为Data Warehouse，可简写为DW或DWH。数据仓库，是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。它出于分析性报告和决策支持目的而创建。为需要业务智能的企业，提供指导业务流程改进、监视时间、成本、质量以及控制。</p>
<h2 id="11-2-数据仓库能干什么？"><a href="#11-2-数据仓库能干什么？" class="headerlink" title="11.2 数据仓库能干什么？"></a>11.2 数据仓库能干什么？</h2><p>1）年度销售目标的指定，需要根据以往的历史报表进行决策，不能拍脑袋。</p>
<p>2）如何优化业务流程</p>
<p>​    例如：一个电商网站订单的完成包括：浏览、下单、支付、物流，其中物流环节可能和中通、申通、韵达等快递公司合作。快递公司每派送一个订单，都会有订单派送的确认时间，可以根据订单派送时间来分析哪个快递公司比较快捷高效，从而选择与哪些快递公司合作，剔除哪些快递公司，增加用户友好型。</p>
<h2 id="11-3-数据仓库的特点"><a href="#11-3-数据仓库的特点" class="headerlink" title="11.3 数据仓库的特点"></a>11.3 数据仓库的特点</h2><p><strong>1**</strong>）数据仓库的数据是面向主题的**</p>
<p>与传统数据库面向应用进行数据组织的特点相对应，数据仓库中的数据是面向主题进行组织的。什么是主题呢？首先，主题是一个抽象的概念，是较高层次上企业信息系统中的数据综合、归类并进行分析利用的抽象。在逻辑意义上，它是对应企业中某一宏观分析领域所涉及的分析对象。面向主题的数据组织方式，就是在较高层次上对分析对象的数据的一个完整、一致的描述，能完整、统一地刻划各个分析对象所涉及的企业的各项数据，以及数据之间的联系。所谓较高层次是相对面向应用的数据组织方式而言的，是指按照主题进行数据组织的方式具有更高的数据抽象级别。</p>
<p><strong>2**</strong>）数据仓库的数据是集成的**</p>
<p>数据仓库的数据是从原有的分散的数据库数据抽取来的。操作型数据与DSS分析型数据之间差别甚大。第一，数据仓库的每一个主题所对应的源数据在原有的各分散数据库中有许多重复和不一致的地方，且来源于不同的联机系统的数据都和不同的应用逻辑捆绑在一起；第二，数据仓库中的综合数据不能从原有的数据库系统直接得到。因此在数据进入数据仓库之前，必然要经过统一与综合，这一步是数据仓库建设中最关键、最复杂的一步，所要完成的工作有：</p>
<p>（1）要统一源数据中所有矛盾之处，如字段的同名异义、异名同义、单位不统一、字长不一致等。</p>
<p>（2）进行数据综合和计算。数据仓库中的数据综合工作可以在从原有数据库抽取 数据时生成，但许多是在数据仓库内部生成的，即进入数据仓库以后进行综合生成的。</p>
<p><strong>3**</strong>）数据仓库的数据是不可更新的**</p>
<p>数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，一般情况下并不进行修改操作。数据仓库的数据反映的是一段相当长的时间内历史数据的内容，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据，而不是联机处理的数据。数据库中进行联机处理的数据经过集成输入到数据仓库中，一旦数据仓库存放的数据已经超过数据仓库的数据存储期限，这些数据将从当前的数据仓库中删去。因为数据仓库只进行数据查询操作，所以数据仓库管理系统相比数据库管理系统而言要简单得多。数据库管理系统中许多技术难点，如完整性保护、并发控制等等，在数据仓库的管理中几乎可以省去。但是由于数据仓库的查询数据量往往很大，所以就对数据查询提出了更高的要求，它要求采用各种复杂的索引技术；同时由于数据仓库面向的是商业企业的高层管理者，他们会对数据查询的界面友好性和数据表示提出更高的要求。</p>
<p><strong>4**</strong>）数据仓库的数据是随时间不断变化的**</p>
<p>数据仓库中的数据不可更新是针对应用来说的，也就是说，数据仓库的用户进行分析处理时是不进行数据更新操作的。但并不是说，在从数据集成输入数据仓库开始到最终被删除的整个数据生存周期中，所有的数据仓库数据都是永远不变的。</p>
<p>数据仓库的数据是随时间的变化而不断变化的，这是数据仓库数据的第四个特征。这一特征表现在以下3方面：</p>
<p>（1）数据仓库随时间变化不断增加新的数据内容。数据仓库系统必须不断捕捉OLTP数据库中变化的数据，追加到数据仓库中去，也就是要不断地生成OLTP数据库的快照，经统一集成后增加到数据仓库中去；但对于确实不再变化的数据库快照，如果捕捉到新的变化数据，则只生成一个新的数据库快照增加进去，而不会对原有的数据库快照进行修改。</p>
<p>（2）数据仓库随时间变化不断删去旧的数据内容。数据仓库的数据也有存储期限，一旦超过了这一期限，过期数据就要被删除。只是数据仓库内的数据时限要远远长于操作型环境中的数据时限。在操作型环境中一般只保存有60~90天的数据，而在数据仓库中则需要保存较长时限的数据（如5~10年），以适应DSS进行趋势分析的要求。</p>
<p>（3）数据仓库中包含有大量的综合数据，这些综合数据中很多跟时间有关，如数据经常按照时间段进行综合，或隔一定的时间片进行抽样等等。这些数据要随着时间的变化不断地进行重新综合。因此，数据仓库的数据特征都包含时间项，以标明数据的历史时期。</p>
<h2 id="11-4-数据仓库发展历程"><a href="#11-4-数据仓库发展历程" class="headerlink" title="11.4 数据仓库发展历程"></a>11.4 数据仓库发展历程</h2><p><strong>数据仓库的发展大致经历了这样的三个过程：</strong></p>
<p><strong>1**</strong>）简单报表阶段：**这个阶段，系统的主要目标是解决一些日常的工作中业务人员需要的报表，以及生成一些简单的能够帮助领导进行决策所需要的汇总数据。这个阶段的大部分表现形式为数据库和前端报表工具。</p>
<p><strong>2**</strong>）数据集市阶段：**这个阶段，主要是根据某个业务部门的需要，进行一定的数据的采集，整理，按照业务人员的需要，进行多维报表的展现，能够提供对特定业务指导的数据，并且能够提供特定的领导决策数据。</p>
<p><strong>3**</strong>）数据仓库阶段：**这个阶段，主要是按照一定的数据模型，对整个企业的数据进行采集，整理，并且能够按照各个业务部门的需要，提供跨部门的，完全一致的业务报表数据，能够通过数据仓库生成对对业务具有指导性的数据，同时，为领导决策提供全面的数据支持。</p>
<p>通过数据仓库建设的发展阶段，我们能够看出，数据仓库的建设和数据集市的建设的重要区别就在于数据模型的支持。因此，数据模型的建设，对于我们数据仓库的建设，有着决定性的意义。</p>
<h2 id="11-5-数据库与数据仓库的区别"><a href="#11-5-数据库与数据仓库的区别" class="headerlink" title="11.5 数据库与数据仓库的区别"></a>11.5 数据库与数据仓库的区别</h2><p>了解数据库与数据仓库的区别之前，首先掌握三个概念。数据库软件、数据库、数据仓库。</p>
<p><strong>数据库软件：</strong>是一种软件，可以看得见，可以操作。用来实现数据库逻辑功能。属于物理层。</p>
<p><strong>数据库：</strong>是一种逻辑概念，用来存放数据的仓库。通过数据库软件来实现。数据库由很多表组成，表是二维的，一张表里可以有很多字段。字段一字排开，对应的数据就一行一行写入表中。数据库的表，在于能够用二维表现多维关系。目前市面上流行的数据库都是二维数据库。如：Oracle、DB2、MySQL、Sybase、MS SQL Server等。</p>
<p><strong>数据仓库：</strong>是数据库概念的升级。从逻辑上理解，数据库和数据仓库没有区别，都是通过数据库软件实现的存放数据的地方，只不过从数据量来说，数据仓库要比数据库更庞大得多。数据仓库主要用于数据挖掘和数据分析，辅助领导做决策。</p>
<p>在IT的架构体系中，数据库是必须存在的。必须要有地方存放数据。比如现在的网购，淘宝，京东等等。物品的存货数量，货品的价格，用户的账户余额之类的。这些数据都是存放在后台数据库中。或者最简单理解，我们现在微博，QQ等账户的用户名和密码。在后台数据库必然有一张user表，字段起码有两个，即用户名和密码，然后我们的数据就一行一行的存在表上面。当我们登录的时候，我们填写了用户名和密码，这些数据就会被传回到后台去，去跟表上面的数据匹配，匹配成功了，你就能登录了。匹配不成功就会报错说密码错误或者没有此用户名等。这个就是数据库，数据库在生产环境就是用来干活的。凡是跟业务应用挂钩的，我们都使用数据库。</p>
<p>数据仓库则是BI下的其中一种技术。由于数据库是跟业务应用挂钩的，所以一个数据库不可能装下一家公司的所有数据。数据库的表设计往往是针对某一个应用进行设计的。比如刚才那个登录的功能，这张user表上就只有这两个字段，没有别的字段了。但是这张表符合应用，没有问题。但是这张表不符合分析。比如我想知道在哪个时间段，用户登录的量最多？哪个用户一年购物最多？诸如此类的指标。那就要重新设计数据库的表结构了。对于数据分析和数据挖掘，我们引入数据仓库概念。数据仓库的表结构是依照分析需求，分析维度，分析指标进行设计的。</p>
<p>数据库与数据仓库的区别实际讲的是OLTP与OLAP的区别。</p>
<p>操作型处理，叫联机事务处理OLTP（On-Line Transaction Processing），也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询、修改。用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。</p>
<p>分析型处理，叫联机分析处理OLAP（On-Line Analytical Processing）一般针对某些主题的历史数据进行分析，支持管理决策。</p>
<p>表 操作型处理与分析型处理的比较</p>
<table>
<thead>
<tr>
<th>操作型处理</th>
<th>分析型处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>细节的</td>
<td>综合的或提炼的</td>
</tr>
<tr>
<td>实体——关系（E-R）模型</td>
<td>星型模型或雪花模型</td>
</tr>
<tr>
<td>存取瞬间数据</td>
<td>存储历史数据，不包含最近的数据</td>
</tr>
<tr>
<td>可更新的</td>
<td>只读、只追加</td>
</tr>
<tr>
<td>一次操作一个单元</td>
<td>一次操作一个集合</td>
</tr>
<tr>
<td>性能要求高，响应时间短</td>
<td>性能要求宽松</td>
</tr>
<tr>
<td>面向事务</td>
<td>面向分析</td>
</tr>
<tr>
<td>一次操作数据量小</td>
<td>一次操作数据量大</td>
</tr>
<tr>
<td>支持日常操作</td>
<td>支持决策需求</td>
</tr>
<tr>
<td>数据量小</td>
<td>数据量大</td>
</tr>
<tr>
<td>客户订单、库存水平和银行账户查询等</td>
<td>客户收益分析、市场细分等</td>
</tr>
</tbody>
</table>
<h2 id="11-6-数据仓库架构分层"><a href="#11-6-数据仓库架构分层" class="headerlink" title="11.6 数据仓库架构分层"></a>11.6 数据仓库架构分层</h2><h3 id="11-6-1-数据仓库架构"><a href="#11-6-1-数据仓库架构" class="headerlink" title="11.6.1 数据仓库架构"></a>11.6.1 数据仓库架构</h3><p>数据仓库标准上可以分为四层：ODS（临时存储层）、PDW（数据仓库层）、DM（数据集市层）、APP（应用层）。</p>
<p>1）ODS层：</p>
<p>为临时存储层，是接口数据的临时存储区域，为后一步的数据处理做准备。一般来说ODS层的数据和源系统的数据是同构的，主要目的是简化后续数据加工处理的工作。从数据粒度上来说ODS层的数据粒度是最细的。ODS层的表通常包括两类，一个用于存储当前需要加载的数据，一个用于存储处理完后的历史数据。历史数据一般保存3-6个月后需要清除，以节省空间。但不同的项目要区别对待，如果源系统的数据量不大，可以保留更长的时间，甚至全量保存；</p>
<p>2）PDW层：</p>
<p>为数据仓库层，PDW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗（去除了杂质）后的数据。这一层的数据一般是遵循数据库第三范式的，其数据粒度通常和ODS的粒度相同。在PDW层会保存BI系统中所有的历史数据，例如保存10年的数据。</p>
<p>3）DM层：</p>
<p>为数据集市层，这层数据是面向主题来组织数据的，通常是星形或雪花结构的数据。从数据粒度来说，这层的数据是轻度汇总级的数据，已经不存在明细数据了。从数据的时间跨度来说，通常是PDW层的一部分，主要的目的是为了满足用户分析的需求，而从分析的角度来说，用户通常只需要分析近几年（如近三年的数据）的即可。从数据的广度来说，仍然覆盖了所有业务数据。</p>
<p>4）APP层：</p>
<p>为应用层，这层数据是完全为了满足具体的分析需求而构建的数据，也是星形或雪花结构的数据。从数据粒度来说是高度汇总的数据。从数据的广度来说，则并不一定会覆盖所有业务数据，而是DM层数据的一个真子集，从某种意义上来说是DM层数据的一个重复。从极端情况来说，可以为每一张报表在APP层构建一个模型来支持，达到以空间换时间的目的数据仓库的标准分层只是一个建议性质的标准，实际实施时需要根据实际情况确定数据仓库的分层，不同类型的数据也可能采取不同的分层方法。</p>
<h3 id="11-6-2-为什么要对数据仓库分层？"><a href="#11-6-2-为什么要对数据仓库分层？" class="headerlink" title="11.6.2 为什么要对数据仓库分层？"></a>11.6.2 为什么要对数据仓库分层？</h3><p>1）用空间换时间，通过大量的预处理来提升应用系统的用户体验（效率），因此数据仓库会存在大量冗余的数据。</p>
<p>2）如果不分层的话，如果源业务系统的业务规则发生变化将会影响整个数据清洗过程，工作量巨大。</p>
<p>3）通过数据分层管理可以简化数据清洗的过程，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。</p>
<h2 id="11-7-元数据介绍"><a href="#11-7-元数据介绍" class="headerlink" title="11.7 元数据介绍"></a>11.7 元数据介绍</h2><p>当需要了解某地企业及其提供的服务时，电话黄页的重要性就体现出来了。元数据（Metadata）类似于这样的电话黄页。</p>
<p>1）元数据的定义</p>
<p>  数据仓库的元数据是关于数据仓库中数据的数据。它的作用类似于数据库管理系统的数据字典，保存了逻辑数据结构、文件、地址和索引等信息。广义上讲，在数据仓库中，元数据描述了数据仓库内数据的结构和建立方法的数据。</p>
<p>   元数据是数据仓库管理系统的重要组成部分，元数据管理器是企业级数据仓库中的关键组件，贯穿数据仓库构建的整个过程，直接影响着数据仓库的构建、使用和维护。</p>
<p>（1）构建数据仓库的主要步骤之一是ETL。这时元数据将发挥重要的作用，它定义了源数据系统到数据仓库的映射、数据转换的规则、数据仓库的逻辑结构、数据更新的规则、数据导入历史记录以及装载周期等相关内容。数据抽取和转换的专家以及数据仓库管理员正是通过元数据高效地构建数据仓库。</p>
<p>（2）用户在使用数据仓库时，通过元数据访问数据，明确数据项的含义以及定制报表。</p>
<p>（3）数据仓库的规模及其复杂性离不开正确的元数据管理，包括增加或移除外部数据源，改变数据清洗方法，控制出错的查询以及安排备份等。</p>
<p>元数据可分为技术元数据和业务元数据。技术元数据为开发和管理数据仓库的IT人员使用，它描述了与数据仓库开发、管理和维护相关的数据，包括数据源信息、数据转换描述、数据仓库模型、数据清洗与更新规则、数据映射和访问权限等。而业务元数据为管理层和业务分析人员服务，从业务角度描述数据，包括商务术语、数据仓库中有什么数据、数据的位置和数据的可用性等，帮助业务人员更好地理解数据仓库中哪些数据是可用的以及如何使用。</p>
<p>由上可见，元数据不仅定义了数据仓库中数据的模式、来源、抽取和转换规则等，而且是整个数据仓库系统运行的基础，元数据把数据仓库系统中各个松散的组件联系起来，组成了一个有机的整体，如图所示</p>
<p>2）元数据的存储方式</p>
<p>   元数据有两种常见存储方式：一种是以数据集为基础，每一个数据集有对应的元数据文件，每一个元数据文件包含对应数据集的元数据内容；另一种存储方式是以数据库为基础，即元数据库。其中元数据文件由若干项组成，每一项表示元数据的一个要素，每条记录为数据集的元数据内容。上述存储方式各有优缺点，第一种存储方式的优点是调用数据时相应的元数据也作为一个独立的文件被传输，相对数据库有较强的独立性，在对元数据进行检索时可以利用数据库的功能实现，也可以把元数据文件调到其他数据库系统中操作；不足是如果每一数据集都对应一个元数据文档，在规模巨大的数据库中则会有大量的元数据文件，管理不方便。第二种存储方式下，元数据库中只有一个元数据文件，管理比较方便，添加或删除数据集，只要在该文件中添加或删除相应的记录项即可。在获取某数据集的元数据时，因为实际得到的只是关系表格数据的一条记录，所以要求用户系统可以接受这种特定形式的数据。因此推荐使用元数据库的方式。</p>
<p>   元数据库用于存储元数据，因此元数据库最好选用主流的关系数据库管理系统。元数据库还包含用于操作和查询元数据的机制。建立元数据库的主要好处是提供统一的数据结构和业务规则，易于把企业内部的多个数据集市有机地集成起来。目前，一些企业倾向建立多个数据集市，而不是一个集中的数据仓库，这时可以考虑在建立数据仓库（或数据集市）之前，先建立一个用于描述数据、服务应用集成的元数据库，做好数据仓库实施的初期支持工作，对后续开发和维护有很大的帮助。元数据库保证了数据仓库数据的一致性和准确性，为企业进行数据质量管理提供基础。</p>
<p>3）元数据的作用</p>
<p>   在数据仓库中，元数据的主要作用如下。</p>
<p>（1）描述哪些数据在数据仓库中，帮助决策分析者对数据仓库的内容定位。</p>
<p>（2）定义数据进入数据仓库的方式，作为数据汇总、映射和清洗的指南。</p>
<p>（3）记录业务事件发生而随之进行的数据抽取工作时间安排。</p>
<p>（4）记录并检测系统数据一致性的要求和执行情况。</p>
<p>（5）评估数据质量。</p>
<h2 id="11-8-星型模型和雪花模型"><a href="#11-8-星型模型和雪花模型" class="headerlink" title="11.8 星型模型和雪花模型"></a>11.8 星型模型和雪花模型</h2><p>在多维分析的商业智能解决方案中，根据事实表和维度表的关系，又可将常见的模型分为星型模型和雪花型模型。在设计逻辑型数据的模型的时候，就应考虑数据是按照星型模型还是雪花型模型进行组织。</p>
<h3 id="11-8-1-星型模型"><a href="#11-8-1-星型模型" class="headerlink" title="11.8.1 星型模型"></a>11.8.1 星型模型</h3><p>当所有维表都直接连接到“ 事实表”上时，整个图解就像星星一样，故将该模型称为星型模型。</p>
<p>  <strong>星型架构是一种非正规化的结构，多维数据集的每一个维度都直接与事实表相连接，不存在渐变维度，所以数据有一定的冗余</strong>，如在地域维度表中，存在国家A 省B的城市C以及国家A省B的城市D两条记录，那么国家A和省B的信息分别存储了两次，即存在冗余。</p>
<h3 id="11-8-2-雪花模型"><a href="#11-8-2-雪花模型" class="headerlink" title="11.8.2 雪花模型"></a>11.8.2 雪花模型</h3><p>当有一个或多个维表没有直接连接到事实表上，而是通过其他维表连接到事实表上时，其图解就像多个雪花连接在一起，故称雪花模型。雪花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的” 层次” 区域，这些被分解的表都连接到主维度表而不是事实表。如图所示，将地域维表又分解为国家，省份，城市等维表。它的优点是：<strong>通过最大限度地减少数据存储量以及联合较小的维表来改善查询性能。</strong>雪花型结构去除了数据冗余。</p>
<p><strong>星型模型因为数据的冗余所以很多统计查询不需要做外部的连接，因此一般情况下效率比雪花型模型要高。</strong>星型结构不用考虑很多正规化的因素，设计与实现都比较简单。雪花型模型由于去除了冗余，有些统计就需要通过表的联接才能产生，所以效率不一定有星型模型高。正规化也是一种比较复杂的过程，相应的数据库结构设计、数据的 ETL、以及后期的维护都要复杂一些。<strong>因此在冗余可以接受的前提下，实际运用中星型模型使用更多，也更有效率。</strong></p>
<h3 id="11-8-3-星型模型和雪花模型对比"><a href="#11-8-3-星型模型和雪花模型对比" class="headerlink" title="11.8.3 星型模型和雪花模型对比"></a>11.8.3 星型模型和雪花模型对比</h3><p>星形模型和雪花模型是数据仓库中常用到的两种方式，而它们之间的对比要从四个角度来进行讨论。</p>
<p>　　<strong>1**</strong>）数据优化**</p>
<p><strong>雪花模型使用的是规范化数据，也就是说数据在数据库内部是组织好的，以便消除冗余，因此它能够有效地减少数据量。</strong>通过引用完整性，其业务层级和维度都将存储在数据模型之中。</p>
<p>雪花模型</p>
<p><strong>相比较而言，星形模型使用的是反规范化数据。</strong>在星形模型中，维度直接指的是事实表，业务层级不会通过维度之间的参照完整性来部署。</p>
<p>星形模型</p>
<p>　　<strong>2**</strong>）业务模型**</p>
<p>主键是一个单独的唯一键(数据属性)，为特殊数据所选择。在上面的例子中，Advertiser_ID就将是一个主键。外键(参考属性)仅仅是一个表中的字段，用来匹配其他维度表中的主键。在我们所引用的例子中，Advertiser_ID将是Account_dimension的一个外键。</p>
<p>在雪花模型中，数据模型的业务层级是由一个不同维度表主键-外键的关系来代表的。而在星形模型中，所有必要的维度表在事实表中都只拥有外键。</p>
<p>　　<strong>3**</strong>）性能**</p>
<p>第三个区别在于性能的不同。<strong>雪花模型在维度表、事实表之间的连接很多，因此性能方面会比较低。</strong>举个例子，如果你想要知道Advertiser 的详细信息，雪花模型就会请求许多信息，比如Advertiser Name、ID以及那些广告主和客户表的地址需要连接起来，然后再与事实表连接。</p>
<p>而星形模型的连接就少的多，在这个模型中，如果你需要上述信息，你只要将Advertiser的维度表和事实表连接即可。</p>
<p>　　<strong>4**</strong>）<strong>**ETL</strong></p>
<p>雪花模型加载数据集市，因此ETL操作在设计上更加复杂，而且由于附属模型的限制，不能并行化。</p>
<p>星形模型加载维度表，不需要再维度之间添加附属模型，因此ETL就相对简单，而且可以实现高度的并行化。</p>
<p>　　<strong>总结</strong></p>
<p>雪花模型使得维度分析更加容易，比如“针对特定的广告主，有哪些客户或者公司是在线的?”星形模型用来做指标分析更适合，比如“给定的一个客户他们的收入是多少?”</p>
<h1 id="十二-常见错误解析"><a href="#十二-常见错误解析" class="headerlink" title="十二 常见错误解析"></a>十二 常见错误解析</h1><p>1）SecureCRT 7.3出现乱码或者删除不掉数据，免安装版的SecureCRT 卸载或者用虚拟机直接操作或者换安装版的SecureCRT </p>
<p>2）连接不上mysql数据库</p>
<p>​    （1）导错驱动包，应该把mysql-connector-java-5.1.27-bin.jar导入/opt/module/hive/lib的不是这个包。错把mysql-connector-java-5.1.27.tar.gz导入hive/lib包下。</p>
<p>​    （2）修改user表中的主机名称没有都修改为%，而是修改为localhost</p>
<p>3）hive默认的输入格式处理是CombineHiveInputFormat，会对小文件进行合并。</p>
<p>hive (default)&gt; set hive.input.format;</p>
<p>hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat</p>
<p>可以采用HiveInputFormat就会根据分区数输出相应的文件。</p>
<p>hive (default)&gt; set hive.input.format=org.apache.hadoop.hive.ql.io.HiveInputFormat;</p>
<p>4）不能执行mapreduce程序</p>
<p>​    可能是hadoop的yarn没开启。</p>
<p>5）启动mysql服务时，报MySQL server PID file could not be found! 异常。</p>
<p>​    在/var/lock/subsys/mysql路径下创建hadoop102.pid，并在文件中添加内容：4396</p>
<p>6）报service mysql status MySQL is not running, but lock file (/var/lock/subsys/mysql[失败])异常。</p>
<p>​    解决方案：在/var/lib/mysql 目录下创建： -rw-rw—-. 1 mysql mysql    5 12月 22 16:41 hadoop102.pid 文件，并修改权限为 777。</p>
<p>6）hive中文乱码 <a href="https://www.cnblogs.com/qingyunzong/p/8724155.html" target="_blank" rel="external">https://www.cnblogs.com/qingyunzong/p/8724155.html</a></p>
<h1 id="十三-好的网站"><a href="#十三-好的网站" class="headerlink" title="十三 好的网站"></a>十三 好的网站</h1><p><a href="https://www.cnblogs.com/qingyunzong/p/8710356.html#_labelTop" target="_blank" rel="external">https://www.cnblogs.com/qingyunzong/p/8710356.html#_labelTop</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>如果你感觉文章对你又些许感悟，你可以支持我！！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/wechatpay.png" alt="Jeremy Kinge WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/uploads/alipay.png" alt="Jeremy Kinge Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
	
	<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/hive/" rel="tag"><i class="fa fa-tag"></i> hive</a>
          
            <a href="/tags/数据仓库工具/" rel="tag"><i class="fa fa-tag"></i> 数据仓库工具</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/14/hadoop在使用中的常用优化手段/" rel="next" title="hadoop在使用中的常用优化手段">
                <i class="fa fa-chevron-left"></i> hadoop在使用中的常用优化手段
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/18/sqoop总结/" rel="prev" title="sqoop总结">
                sqoop总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微薄</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDUxMS83MDY1"></div>
    
  </div>


      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDUxMS83MDY1"></div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Jeremy Kinge" />
          <p class="site-author-name" itemprop="name">Jeremy Kinge</p>
           
              <p class="site-description motion-element" itemprop="description">To know everything, no words don't talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">71</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">116</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JeremyKinge" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/LJBANANABLUE?s=09" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://m.weibo.cn/u/3991058874?from=1078095010&wm=20005_0002&sourceType=qq&uid=3991058874" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/profile.php?id=100010100689349" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="StackOverflow">
                  
                    <i class="fa fa-fw fa-stack-overflow"></i>
                  
                    
                      StackOverflow
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://xiezejingzhazha.blog.163.com/" target="_blank" title="网易博客">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                    
                      网易博客
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

		<div id="music163player">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=451768026&auto=0&height=66"></iframe>
</div>
		
        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一-Hive基本概念"><span class="nav-number">1.</span> <span class="nav-text">一 Hive基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-什么是Hive"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 什么是Hive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Hive的优缺点"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Hive的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-优点"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-缺点"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Hive架构原理（图要记住）"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Hive架构原理（图要记住）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Hive和数据库比较"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 Hive和数据库比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-查询语言"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1 查询语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-数据存储位置"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2 数据存储位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-数据更新"><span class="nav-number">1.4.3.</span> <span class="nav-text">1.4.3 数据更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-4-索引"><span class="nav-number">1.4.4.</span> <span class="nav-text">1.4.4 索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-5-执行"><span class="nav-number">1.4.5.</span> <span class="nav-text">1.4.5 执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-6-执行延迟"><span class="nav-number">1.4.6.</span> <span class="nav-text">1.4.6 执行延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-7-可扩展性"><span class="nav-number">1.4.7.</span> <span class="nav-text">1.4.7 可扩展性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-8-数据规模"><span class="nav-number">1.4.8.</span> <span class="nav-text">1.4.8 数据规模</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-9-hive元数据"><span class="nav-number">1.4.9.</span> <span class="nav-text">1.4.9 hive元数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二-Hive安装环境准备"><span class="nav-number">2.</span> <span class="nav-text">二 Hive安装环境准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Hive安装地址"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 Hive安装地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Hive安装部署"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 Hive安装部署</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-将本地文件导入Hive案例"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 将本地文件导入Hive案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-遇到的问题（默认Derby数据库）"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 遇到的问题（默认Derby数据库）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-MySql安装"><span class="nav-number">2.5.</span> <span class="nav-text">2.4 MySql安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-安装包准备"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.4.1 安装包准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-安装MySql服务器（建议使用root用户进行操作-涉及到某些目录）"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.4.2 安装MySql服务器（建议使用root用户进行操作-涉及到某些目录）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-安装MySql客户端"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.4.3 安装MySql客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-MySql中user表中主机配置"><span class="nav-number">2.5.4.</span> <span class="nav-text">2.4.4 MySql中user表中主机配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-Hive元数据配置到MySql"><span class="nav-number">2.6.</span> <span class="nav-text">2.5 Hive元数据配置到MySql</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-驱动拷贝"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.5.1 驱动拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-配置Metastore到MySql"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.5.2 配置Metastore到MySql</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-多窗口启动Hive测试"><span class="nav-number">2.6.3.</span> <span class="nav-text">2.5.3 多窗口启动Hive测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-Hive常用交互命令"><span class="nav-number">2.7.</span> <span class="nav-text">2.6 Hive常用交互命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-Hive其他命令操作"><span class="nav-number">2.8.</span> <span class="nav-text">2.7 Hive其他命令操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-Hive常见属性配置（重要）"><span class="nav-number">2.9.</span> <span class="nav-text">2.8 Hive常见属性配置（重要）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-Hive数据仓库位置配置"><span class="nav-number">2.9.1.</span> <span class="nav-text">2.8.1 Hive数据仓库位置配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-2-查询后信息显示配置"><span class="nav-number">2.9.2.</span> <span class="nav-text">2.8.2 查询后信息显示配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-3-Hive运行日志信息配置"><span class="nav-number">2.9.3.</span> <span class="nav-text">2.8.3 Hive运行日志信息配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-4-参数配置方式"><span class="nav-number">2.9.4.</span> <span class="nav-text">2.8.4 参数配置方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三-Hive数据类型"><span class="nav-number">3.</span> <span class="nav-text">三 Hive数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-基本数据类型"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-集合数据类型"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 集合数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-类型转化"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 类型转化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四-DDL数据定义"><span class="nav-number">4.</span> <span class="nav-text">四 DDL数据定义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-创建数据库"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 创建数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-修改数据库（只能修改数据库描述信息，其他数据不能修改）"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 修改数据库（只能修改数据库描述信息，其他数据不能修改）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-查询数据库"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 查询数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-显示数据库"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 显示数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-查看数据库详情"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 查看数据库详情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-切换当前数据库"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3 切换当前数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-删除数据库"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 删除数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-创建表"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-管理表"><span class="nav-number">4.5.1.</span> <span class="nav-text">4.5.1 管理表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-外部表"><span class="nav-number">4.5.2.</span> <span class="nav-text">4.5.2 外部表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-分区表"><span class="nav-number">4.6.</span> <span class="nav-text">4.6 分区表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-分区表基本操作"><span class="nav-number">4.6.1.</span> <span class="nav-text">4.6.1 分区表基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-分区表注意事项"><span class="nav-number">4.6.2.</span> <span class="nav-text">4.6.2 分区表注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-修改表（不支持删除某个字段）"><span class="nav-number">4.7.</span> <span class="nav-text">4.7 修改表（不支持删除某个字段）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-1-重命名表"><span class="nav-number">4.7.1.</span> <span class="nav-text">4.7.1 重命名表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-2-增加、修改和删除表分区"><span class="nav-number">4.7.2.</span> <span class="nav-text">4.7.2 增加、修改和删除表分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-3-增加-修改-替换列信息"><span class="nav-number">4.7.3.</span> <span class="nav-text">4.7.3 增加/修改/替换列信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-删除表"><span class="nav-number">4.8.</span> <span class="nav-text">4.8 删除表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五-DML数据操作"><span class="nav-number">5.</span> <span class="nav-text">五 DML数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-数据导入"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 数据导入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-向表中装载数据（Load）"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 向表中装载数据（Load）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-通过查询语句向表中插入数据（Insert）"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 通过查询语句向表中插入数据（Insert）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-查询语句中创建表并加载数据（As-Select）"><span class="nav-number">5.1.3.</span> <span class="nav-text">5.1.3 查询语句中创建表并加载数据（As Select）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-创建表时通过Location指定加载数据路径"><span class="nav-number">5.1.4.</span> <span class="nav-text">5.1.4 创建表时通过Location指定加载数据路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-5-Import数据到指定Hive表中"><span class="nav-number">5.1.5.</span> <span class="nav-text">5.1.5 Import数据到指定Hive表中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-数据导出"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 数据导出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-Insert导出"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 Insert导出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-Hadoop命令导出到本地"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2 Hadoop命令导出到本地</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-Hive-Shell-命令导出"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3 Hive Shell 命令导出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-Export导出到HDFS上"><span class="nav-number">5.2.4.</span> <span class="nav-text">5.2.4 Export导出到HDFS上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-5-Sqoop导出"><span class="nav-number">5.2.5.</span> <span class="nav-text">5.2.5 Sqoop导出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-清除表中数据（Truncate）"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 清除表中数据（Truncate）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六-查询"><span class="nav-number">6.</span> <span class="nav-text">六 查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-基本查询（Select…From）"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 基本查询（Select…From）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-全表和特定列查询"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 全表和特定列查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-列别名"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.1.2 列别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-算术运算符"><span class="nav-number">6.1.3.</span> <span class="nav-text">6.1.3 算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-4-常用函数"><span class="nav-number">6.1.4.</span> <span class="nav-text">6.1.4 常用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-5-Limit语句"><span class="nav-number">6.1.5.</span> <span class="nav-text">6.1.5 Limit语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Where语句"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 Where语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-比较运算符（Between-In-Is-Null）"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 比较运算符（Between/In/ Is Null）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-Like和RLike"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 Like和RLike</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-逻辑运算符（And-Or-Not）"><span class="nav-number">6.2.3.</span> <span class="nav-text">6.2.3 逻辑运算符（And/Or/Not）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-分组"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 分组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-Group-By语句"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1 Group By语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-Having语句"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2 Having语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-Join语句"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 Join语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-等值Join"><span class="nav-number">6.4.1.</span> <span class="nav-text">6.4.1 等值Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-表的别名"><span class="nav-number">6.4.2.</span> <span class="nav-text">6.4.2 表的别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-内连接"><span class="nav-number">6.4.3.</span> <span class="nav-text">6.4.3 内连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-4-左外连接"><span class="nav-number">6.4.4.</span> <span class="nav-text">6.4.4 左外连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-5-右外连接"><span class="nav-number">6.4.5.</span> <span class="nav-text">6.4.5 右外连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-6-满外连接（oracle支持fulljoin语法，mysql没有该语法）"><span class="nav-number">6.4.6.</span> <span class="nav-text">6.4.6 满外连接（oracle支持fulljoin语法，mysql没有该语法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-7-多表连接"><span class="nav-number">6.4.7.</span> <span class="nav-text">6.4.7 多表连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-8-笛卡尔积"><span class="nav-number">6.4.8.</span> <span class="nav-text">6.4.8 笛卡尔积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-9-连接谓词中不支持or"><span class="nav-number">6.4.9.</span> <span class="nav-text">6.4.9 连接谓词中不支持or</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-排序"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-全局排序（Order-By）"><span class="nav-number">6.5.1.</span> <span class="nav-text">6.5.1 全局排序（Order By）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-按照别名排序"><span class="nav-number">6.5.2.</span> <span class="nav-text">6.5.2 按照别名排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-多个列排序"><span class="nav-number">6.5.3.</span> <span class="nav-text">6.5.3 多个列排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-4-每个MapReduce内部排序（Sort-By）"><span class="nav-number">6.5.4.</span> <span class="nav-text">6.5.4 每个MapReduce内部排序（Sort By）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-5-分区排序（Distribute-By）"><span class="nav-number">6.5.5.</span> <span class="nav-text">6.5.5 分区排序（Distribute By）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-6-Cluster-By"><span class="nav-number">6.5.6.</span> <span class="nav-text">6.5.6 Cluster By</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-分桶及抽样查询"><span class="nav-number">6.6.</span> <span class="nav-text">6.6 分桶及抽样查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-分桶表数据存储"><span class="nav-number">6.6.1.</span> <span class="nav-text">6.6.1 分桶表数据存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-分桶抽样查询"><span class="nav-number">6.6.2.</span> <span class="nav-text">6.6.2 分桶抽样查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3-数据块抽样"><span class="nav-number">6.6.3.</span> <span class="nav-text">6.6.3 数据块抽样</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七-函数"><span class="nav-number">7.</span> <span class="nav-text">七 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-系统自带的函数"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 系统自带的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-自定义函数"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 自定义函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-自定义UDF函数开发案例"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 自定义UDF函数开发案例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八-压缩和存储"><span class="nav-number">8.</span> <span class="nav-text">八 压缩和存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-Hadoop源码编译支持Snappy压缩"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 Hadoop源码编译支持Snappy压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-资源准备"><span class="nav-number">8.1.1.</span> <span class="nav-text">8.1.1 资源准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-jar包安装"><span class="nav-number">8.1.2.</span> <span class="nav-text">8.1.2 jar包安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-3-编译源码"><span class="nav-number">8.1.3.</span> <span class="nav-text">8.1.3 编译源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-Hadoop压缩配置"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 Hadoop压缩配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-MR支持的压缩编码"><span class="nav-number">8.2.1.</span> <span class="nav-text">8.2.1 MR支持的压缩编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-压缩参数配置"><span class="nav-number">8.2.2.</span> <span class="nav-text">8.2.2 压缩参数配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-开启Map输出阶段压缩"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 开启Map输出阶段压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-开启Reduce输出阶段压缩"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 开启Reduce输出阶段压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-文件存储格式"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 文件存储格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-1-列式存储和行式存储"><span class="nav-number">8.5.1.</span> <span class="nav-text">8.5.1 列式存储和行式存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-2-TextFile格式"><span class="nav-number">8.5.2.</span> <span class="nav-text">8.5.2 TextFile格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-3-Orc格式"><span class="nav-number">8.5.3.</span> <span class="nav-text">8.5.3 Orc格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-4-Parquet格式"><span class="nav-number">8.5.4.</span> <span class="nav-text">8.5.4 Parquet格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-5-主流文件存储格式对比实验"><span class="nav-number">8.5.5.</span> <span class="nav-text">8.5.5 主流文件存储格式对比实验</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-存储和压缩结合"><span class="nav-number">8.6.</span> <span class="nav-text">8.6 存储和压缩结合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-1-修改Hadoop集群具有Snappy压缩方式"><span class="nav-number">8.6.1.</span> <span class="nav-text">8.6.1 修改Hadoop集群具有Snappy压缩方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-2-测试存储和压缩"><span class="nav-number">8.6.2.</span> <span class="nav-text">8.6.2 测试存储和压缩</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九-企业级调优"><span class="nav-number">9.</span> <span class="nav-text">九 企业级调优</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-Fetch抓取"><span class="nav-number">9.1.</span> <span class="nav-text">9.1 Fetch抓取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-本地模式"><span class="nav-number">9.2.</span> <span class="nav-text">9.2 本地模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-表的优化（重要）"><span class="nav-number">9.3.</span> <span class="nav-text">9.3 表的优化（重要）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-1-小表、大表Join"><span class="nav-number">9.3.1.</span> <span class="nav-text">9.3.1 小表、大表Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-2-大表Join大表"><span class="nav-number">9.3.2.</span> <span class="nav-text">9.3.2 大表Join大表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-3-MapJoin"><span class="nav-number">9.3.3.</span> <span class="nav-text">9.3.3 MapJoin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-4-Group-By"><span class="nav-number">9.3.4.</span> <span class="nav-text">9.3.4 Group By</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-5-Count-Distinct-去重统计"><span class="nav-number">9.3.5.</span> <span class="nav-text">9.3.5 Count(Distinct) 去重统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-6-笛卡尔积"><span class="nav-number">9.3.6.</span> <span class="nav-text">9.3.6 笛卡尔积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-7-行列过滤"><span class="nav-number">9.3.7.</span> <span class="nav-text">9.3.7 行列过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-8-动态分区调整"><span class="nav-number">9.3.8.</span> <span class="nav-text">9.3.8 动态分区调整</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-9-分桶"><span class="nav-number">9.3.9.</span> <span class="nav-text">9.3.9 分桶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-10-分区"><span class="nav-number">9.3.10.</span> <span class="nav-text">9.3.10 分区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-数据倾斜"><span class="nav-number">9.4.</span> <span class="nav-text">9.4 数据倾斜</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-1-合理设置Map数"><span class="nav-number">9.4.1.</span> <span class="nav-text">9.4.1 合理设置Map数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-2-小文件进行合并"><span class="nav-number">9.4.2.</span> <span class="nav-text">9.4.2 小文件进行合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-3-复杂文件增加Map数"><span class="nav-number">9.4.3.</span> <span class="nav-text">9.4.3 复杂文件增加Map数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-4-合理设置Reduce数"><span class="nav-number">9.4.4.</span> <span class="nav-text">9.4.4 合理设置Reduce数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-并行执行"><span class="nav-number">9.5.</span> <span class="nav-text">9.5 并行执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-严格模式"><span class="nav-number">9.6.</span> <span class="nav-text">9.6 严格模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-7-JVM重用-重要"><span class="nav-number">9.7.</span> <span class="nav-text">9.7 JVM重用(重要)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-8-推测执行"><span class="nav-number">9.8.</span> <span class="nav-text">9.8 推测执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-9-压缩"><span class="nav-number">9.9.</span> <span class="nav-text">9.9 压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-10-执行计划（Explain）"><span class="nav-number">9.10.</span> <span class="nav-text">9.10 执行计划（Explain）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十-Hive实战"><span class="nav-number">10.</span> <span class="nav-text">十 Hive实战</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十一-数据仓库"><span class="nav-number">11.</span> <span class="nav-text">十一 数据仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-什么是数据仓库"><span class="nav-number">11.1.</span> <span class="nav-text">11.1 什么是数据仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-数据仓库能干什么？"><span class="nav-number">11.2.</span> <span class="nav-text">11.2 数据仓库能干什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-数据仓库的特点"><span class="nav-number">11.3.</span> <span class="nav-text">11.3 数据仓库的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-数据仓库发展历程"><span class="nav-number">11.4.</span> <span class="nav-text">11.4 数据仓库发展历程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-数据库与数据仓库的区别"><span class="nav-number">11.5.</span> <span class="nav-text">11.5 数据库与数据仓库的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-6-数据仓库架构分层"><span class="nav-number">11.6.</span> <span class="nav-text">11.6 数据仓库架构分层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-6-1-数据仓库架构"><span class="nav-number">11.6.1.</span> <span class="nav-text">11.6.1 数据仓库架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-6-2-为什么要对数据仓库分层？"><span class="nav-number">11.6.2.</span> <span class="nav-text">11.6.2 为什么要对数据仓库分层？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-7-元数据介绍"><span class="nav-number">11.7.</span> <span class="nav-text">11.7 元数据介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-8-星型模型和雪花模型"><span class="nav-number">11.8.</span> <span class="nav-text">11.8 星型模型和雪花模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-8-1-星型模型"><span class="nav-number">11.8.1.</span> <span class="nav-text">11.8.1 星型模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-8-2-雪花模型"><span class="nav-number">11.8.2.</span> <span class="nav-text">11.8.2 雪花模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-8-3-星型模型和雪花模型对比"><span class="nav-number">11.8.3.</span> <span class="nav-text">11.8.3 星型模型和雪花模型对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十二-常见错误解析"><span class="nav-number">12.</span> <span class="nav-text">十二 常见错误解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十三-好的网站"><span class="nav-number">13.</span> <span class="nav-text">十三 好的网站</span></a></li></ol></div>
            

          </div>
		  

		  
        </section>
      <!--/noindex-->
      

      

    </div>
	

	
  </aside>
  

  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2022 &mdash; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeremy Kinge</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">
      458.0k
    </span>
  
</div>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">
  
</div>



  <span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span class="post-meta-divider">|</span>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共458.0k字</span>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  




  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
