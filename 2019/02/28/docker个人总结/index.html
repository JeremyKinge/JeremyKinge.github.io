<!DOCTYPE html>



  




<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<script>
    (function(){
        if(''){
            if (prompt('OOPS, 主人请输入文章密码才能够观看哟') !== ''){
                alert('哎呀，密码错误哟！');
                history.back();
            }
        }
    })();
</script>


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|40:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="docker,容器," />





  <link rel="alternate" href="/atom.xml" title="King哥" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="之前学习过docker，但是很浅显的使用，概念和流程各个方面总结的不够到位，下面根据旧版本的文档，重新的梳理。 一、docker出现的契机作为开发人员，我们经常会遇到一个问题，那就是环境不统一的问题。什么意思呢？自己在本地测试的项目是运行正常的，但是打包给测试或者运维人员部署使用时，经常会出现，部署报错，运行不起来，等等问题。就算是再详细的部署文档也还是会出错。 这个时候就产生了大量沟通的成本，通">
<meta name="keywords" content="docker,容器">
<meta property="og:type" content="article">
<meta property="og:title" content="docker个人总结">
<meta property="og:url" content="http://kingge.top/2019/02/28/docker个人总结/index.html">
<meta property="og:site_name" content="King哥">
<meta property="og:description" content="之前学习过docker，但是很浅显的使用，概念和流程各个方面总结的不够到位，下面根据旧版本的文档，重新的梳理。 一、docker出现的契机作为开发人员，我们经常会遇到一个问题，那就是环境不统一的问题。什么意思呢？自己在本地测试的项目是运行正常的，但是打包给测试或者运维人员部署使用时，经常会出现，部署报错，运行不起来，等等问题。就算是再详细的部署文档也还是会出错。 这个时候就产生了大量沟通的成本，通">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image002.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image004.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image006.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image007.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image008.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image009.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image011.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image013.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image015.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image017.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image019.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image020.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image022.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image024.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image025.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image027.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image029.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image030.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image032.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image034.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image036.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image038.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image039.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image041.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image042.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image044.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image046.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image048.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image050.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image052.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image054.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image056.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image058.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image060.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image062.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image064.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image066.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image068.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image070.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image072.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image074.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image076.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image078.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image080.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image082.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image084.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image085.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image087.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image089.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image090.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image091.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image093.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image095.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image097.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image099.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image101.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image103.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image105.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image107.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image108.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image110.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image112.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image114.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image115.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image116.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image117.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image118.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image119.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image120.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image121.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image123.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image125.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image126.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image128.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image129.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image130.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image132.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image134.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image136.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image138.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image139.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image141.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image142.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image144.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image146.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image148.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image149.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image151.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image152.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image154.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image155.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image157.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image158.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image160.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image162.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image163.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image165.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image166.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image168.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image170.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image171.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image173.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image174.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image175.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image177.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image179.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image181.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image183.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image184.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image185.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image187.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image189.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image190.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image192.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image193.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image194.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image196.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image198.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image200.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image202.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image204.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image206.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image208.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image209.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image211.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image212.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image214.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image216.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image218.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image220.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image222.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image224.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image225.png">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image227.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image229.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image231.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image233.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image235.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image237.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image239.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image241.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image243.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image245.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image247.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image249.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image247.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image251.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image253.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image255.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image257.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image259.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image261.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image263.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image265.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image267.jpg">
<meta property="og:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image269.jpg">
<meta property="og:updated_time" content="2019-08-25T03:05:04.155Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="docker个人总结">
<meta name="twitter:description" content="之前学习过docker，但是很浅显的使用，概念和流程各个方面总结的不够到位，下面根据旧版本的文档，重新的梳理。 一、docker出现的契机作为开发人员，我们经常会遇到一个问题，那就是环境不统一的问题。什么意思呢？自己在本地测试的项目是运行正常的，但是打包给测试或者运维人员部署使用时，经常会出现，部署报错，运行不起来，等等问题。就算是再详细的部署文档也还是会出错。 这个时候就产生了大量沟通的成本，通">
<meta name="twitter:image" content="http://kingge.top/2019/02/28/docker个人总结/clip_image002.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://kingge.top/2019/02/28/docker个人总结/"/>





  <title>docker个人总结 | King哥</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">King哥</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">To know everything, no words don't talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-picture">
          <a href="/picture/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            照片
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kingge.top/2019/02/28/docker个人总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeremy Kinge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="King哥">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">docker个人总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-28T21:59:59+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12,460
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  48
                </span>
              
            </div>
          

          

		  
		  
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>之前学习过docker，但是很浅显的使用，概念和流程各个方面总结的不够到位，下面根据旧版本的文档，重新的梳理。</p>
<h1 id="一、docker出现的契机"><a href="#一、docker出现的契机" class="headerlink" title="一、docker出现的契机"></a>一、docker出现的契机</h1><p>作为开发人员，我们经常会遇到一个问题，那就是环境不统一的问题。什么意思呢？自己在本地测试的项目是运行正常的，但是打包给测试或者运维人员部署使用时，经常会出现，部署报错，运行不起来，等等问题。就算是再详细的部署文档也还是会出错。</p>
<p>这个时候就产生了大量沟通的成本，通常产生这些问题的原因是部署的环境并不是开发人员的那一份环境，可能是jdk版本或者tomcat版本，数据库等等环境产生的问题。所以就需要我们开发人员打包一份连同环境和配置以及项目，交付给测试或者运维。这样就能够保证项目运行环境的一致性，也容易排查问题。<strong>这个就是docker的雏形</strong></p>
<p>​       就好比我们在迁移一棵树的时候，尾部，总是会保留着一些原先的土，就是为了解决生长环境的不同额度适配问题。</p>
<p><strong>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</strong></p>
<p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。</p>
<p>​       <em>总的来说，以前我们是通过提交<strong>war</strong>包的方式，那么现在是连同<strong>war</strong></em>运行的环境<em>**一起打包给测试或者运维。</em></p>
<p><img src="/2019/02/28/docker个人总结/clip_image002.jpg" alt="graphic"></p>
<p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。<strong>透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间（类似于jvm的理念）的无缝接轨运作</strong>。</p>
<h2 id="1-1-理念"><a href="#1-1-理念" class="headerlink" title="1.1 理念"></a>1.1 理念</h2><p>Docker是基于Go语言实现的云开源项目。</p>
<p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“<strong>一次封装，到处运行</strong>”。</p>
<p><strong>Linux</strong> <strong>容器技术</strong>的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image004.jpg" alt="graphic"></p>
<p><strong>也就是说，我们可以把项目运行成功所需要的环境（redis，nginx，mysql）等等组件，通过编译打包的形式，打包成一个个的货仓。</strong></p>
<p><strong>项目部署到其他环境时（windowsàlinux）只需要运行这些货仓就可以安装这些环境，做到一次封装到处运行，解决了因为环境不同导致app部署或运行失败的问题</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image006.jpg" alt="img">docker的logo就阐述了这一理念，部署项目的时候直接搬运已经测试成功的app运行环境。</p>
<p>​       <strong>特别是在多集群的环境下，docker的作用更显而易见（避免多次安装环境）</strong></p>
<p>总的来说：<strong>解决了运行环境和配置问题软件容器（每个容器对应着一个集装箱，每个集装箱对应着项目运行所需的软件或者配置），方便做持续集成并有助于整体发布的容器虚拟化技术</strong>。</p>
<h1 id="二、docker的演化"><a href="#二、docker的演化" class="headerlink" title="二、docker的演化"></a>二、docker的演化</h1><h2 id="2-1-虚拟机技术"><a href="#2-1-虚拟机技术" class="headerlink" title="2.1 虚拟机技术"></a>2.1 虚拟机技术</h2><p><img src="/2019/02/28/docker个人总结/clip_image007.png" alt="img">一个虚拟机的结构图</p>
<p>虚拟机（virtual machine）就是<strong>带环境安装</strong>的一种解决方案。</p>
<p>带环境安装的意思是：它里面模拟了一个正常的操作系统所具备的各种环境和配置（内存、处理器、硬盘。。。。）</p>
<p><img src="/2019/02/28/docker个人总结/clip_image008.png" alt="img"></p>
<p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。  </p>
<p>​       </p>
<p>缺点：</p>
<p>\1.     启动很慢</p>
<p>\2.     资源占用多</p>
<p>\3.     冗余步骤多</p>
<p>所以docker在这之上就演化出了 <strong>容器虚拟化技术</strong></p>
<h2 id="2-2-容器虚拟化技术"><a href="#2-2-容器虚拟化技术" class="headerlink" title="2.2 容器虚拟化技术"></a>2.2 容器虚拟化技术</h2><p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：L<strong>inux</strong> <strong>容器（Linux Containers，缩写为</strong> <strong>LXC）</strong>。</p>
<p><strong>Linux</strong> <strong>容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image009.png" alt="img"></p>
<p>相比虚拟机技术的系统结构图，很明显发现，公用库api模块被移除。各个app维护自己的所依赖的api模块。好处就是，节省了资源的占用。</p>
<h2 id="2-3-总结不同"><a href="#2-3-总结不同" class="headerlink" title="2.3 总结不同"></a>2.3 总结不同</h2><p>比较了 Docker 和传统虚拟化方式的不同之处：</p>
<p>\1.     传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程</p>
<p>\2.     而容器内的应用进程<strong>直接运行于宿主的内核</strong>，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p>\3.      每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p>
<p><strong>4.</strong>     <strong>Linux虚拟机安装包可能需要4G，但是docker只需要170M。很明显这是一个很大的提升，换句话说，docker就是一个精细版的linux虚拟机</strong></p>
<h1 id="三、docker的好处"><a href="#三、docker的好处" class="headerlink" title="三、docker的好处"></a>三、docker的好处</h1><p>一次构建、随处运行</p>
<h2 id="更快速的应用交付和部署"><a href="#更快速的应用交付和部署" class="headerlink" title="更快速的应用交付和部署"></a>更快速的应用交付和部署</h2><p><img src="/2019/02/28/docker个人总结/clip_image011.jpg" alt="img"></p>
<h2 id="更便捷的升级和扩缩容"><a href="#更便捷的升级和扩缩容" class="headerlink" title="更便捷的升级和扩缩容"></a>更便捷的升级和扩缩容</h2><p><img src="/2019/02/28/docker个人总结/clip_image013.jpg" alt="img"></p>
<h2 id="更简单的系统运维"><a href="#更简单的系统运维" class="headerlink" title="更简单的系统运维"></a>更简单的系统运维</h2><p><img src="/2019/02/28/docker个人总结/clip_image015.jpg" alt="img"></p>
<h2 id="更高效的计算资源利用"><a href="#更高效的计算资源利用" class="headerlink" title="更高效的计算资源利用"></a>更高效的计算资源利用</h2><p><img src="/2019/02/28/docker个人总结/clip_image017.jpg" alt="img"></p>
<h1 id="四、安装和下载"><a href="#四、安装和下载" class="headerlink" title="四、安装和下载"></a>四、安装和下载</h1><p>docker官网：<a href="http://www.docker.com" target="_blank" rel="external">http://www.docker.com</a></p>
<p>docker中文网站： <a href="https://www.docker-cn.com/" target="_blank" rel="external">https://www.docker-cn.com/</a></p>
<p>Docker Hub官网: <a href="https://hub.docker.com/" target="_blank" rel="external">https://hub.docker.com/</a></p>
<p><code>Docker</code> 分为 <code>CE</code> 和 <code>EE</code> 两大版本。 <code>CE</code> 即社区版（免费，支持周期 <code>7</code> 个月）， <code>EE</code> 即企业版，强调安全，付费使用，支持周期 <code>24</code> 个月。下面安装的是CE版本。</p>
<h2 id="4-1-docker安装前提条件"><a href="#4-1-docker安装前提条件" class="headerlink" title="4.1 docker安装前提条件"></a>4.1 docker安装前提条件</h2><p>Docker支持以下的CentOS版本：CentOS 7 (64-bit)</p>
<p>CentOS 6.5 (64-bit) 或更高的版本</p>
<p>目前，CentOS 仅发行版本中的内核支持 Docker。</p>
<p>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。</p>
<p>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p>
<p>为了避免我们后面启动tomcat 容器做测试的时候，外部浏览器访问tomcat容器时，端口被拦截。这里先关闭虚拟机的防火墙</p>
<p>service firewalld status ；查看防火墙状态</p>
<p><img src="/2019/02/28/docker个人总结/clip_image019.jpg" alt="img"></p>
<p>service firewalld stop：关闭防火墙</p>
<h3 id="查看自己linux-内核"><a href="#查看自己linux-内核" class="headerlink" title="查看自己linux 内核"></a>查看自己linux 内核</h3><p>uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image020.png" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image022.jpg" alt="img"></p>
<h3 id="查看已安装的CentOS版本信息（CentOS6-8有，CentOS7无该命令）"><a href="#查看已安装的CentOS版本信息（CentOS6-8有，CentOS7无该命令）" class="headerlink" title="查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）"></a>查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）</h3><p><img src="/2019/02/28/docker个人总结/clip_image024.jpg" alt="img"></p>
<p>另一种方式查询</p>
<p><img src="/2019/02/28/docker个人总结/clip_image025.png" alt="img"></p>
<h2 id="4-2-docker安装"><a href="#4-2-docker安装" class="headerlink" title="4.2 docker安装"></a>4.2 docker安装</h2><p><strong>一下安装是使用yum命令进行安装，所以linux虚拟机需要能够连接互联网</strong></p>
<p><strong>官方手册：</strong></p>
<p><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#prerequisites" target="_blank" rel="external">https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#prerequisites</a></p>
<h3 id="CentOS6-8安装Docker"><a href="#CentOS6-8安装Docker" class="headerlink" title="CentOS6.8安装Docker"></a>CentOS6.8安装Docker</h3><p>\1.      yum install -y epel-release</p>
<p>  使用root用户执行改命令。</p>
<p>Docker使用EPEL发布，RHEL系的OS首先要确保已经持有EPEL仓库，否则先检查OS的版本，然后安装相应的EPEL包</p>
<p><img src="/2019/02/28/docker个人总结/clip_image027.jpg" alt="img"></p>
<p>\2.      yum install -y docker-io</p>
<p>发现这个命令在centos6.10 版本时，提示docker包找不到，于是花了另一命令：yum –y  install  docker  安装成功</p>
<p>\3.      安装后的配置文件：/etc/sysconfig/docker</p>
<p>\4.      启动Docker后台服务：service docker start</p>
<p>5.docker version验证</p>
<h3 id="CentOS7以上安装Docker（本人使用的版本）-推荐"><a href="#CentOS7以上安装Docker（本人使用的版本）-推荐" class="headerlink" title="CentOS7以上安装Docker（本人使用的版本）-推荐"></a>CentOS7以上安装Docker（本人使用的版本）-推荐</h3><p><img src="/2019/02/28/docker个人总结/clip_image029.jpg" alt="img"></p>
<p>  下面使用仓库的方式进行安装docker-ce</p>
<p>\1. cat /etc/redhat-release</p>
<p>命令查看centos版本</p>
<p><img src="/2019/02/28/docker个人总结/clip_image030.png" alt="img"></p>
<p>\2. yum安装gcc相关</p>
<p>  执行以下两条命令</p>
<p>  yum -y install gcc</p>
<p>yum -y install gcc-c++</p>
<p>3.卸载老版本（如果之前没有装过，可以忽略这一步）</p>
<p>   注意看官网的操作手册，里面有着一段命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo yum remove docker \</div><div class="line">                  docker-client \</div><div class="line">                  docker-client-latest \</div><div class="line">                  docker-common \</div><div class="line">                  docker-latest \</div><div class="line">                  docker-latest-logrotate \</div><div class="line">                  docker-logrotate \</div><div class="line">                  docker-engine</div></pre></td></tr></table></figure>
<p>   $ sudo yum remove docker \                     docker-client   \                       docker-client-latest \                     docker-common   \                     docker-latest   \                       docker-latest-logrotate \                       docker-logrotate \                     docker-engine   </p>
<p>\4. 安装需要的软件包</p>
<p>​       yum install -y yum-utils device-mapper-persistent-data lvm2</p>
<p>\5. 设置stable镜像仓库</p>
<p>执行命令：</p>
<p>​         yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="external">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p>
<p>​                注意这里使用的是阿里的镜像仓库，不要使用官网推荐的仓库</p>
<p>​          </p>
<p>   yum-config-manager –add-repo   <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="external">https://download.docker.com/linux/centos/docker-ce.repo</a>               不能使用这条命令   </p>
<p>\6. 更新yum软件包索引</p>
<p>​       yum makecache fast</p>
<p>\7. 安装DOCKER CE</p>
<p>​       yum -y install docker-ce</p>
<p>\8. 启动docker</p>
<p>​       systemctl start docker</p>
<p>\9. 测试</p>
<p>docker version  :查看docker版本</p>
<p>docker pull hello-world（从阿里云仓库中获取hello-world镜像）</p>
<p>​       docker run hello-world （要先下载hello-world镜像后才能够运行）</p>
<p><img src="/2019/02/28/docker个人总结/clip_image032.jpg" alt="img"></p>
<p>10.卸载</p>
<p>​       执行以下三条命令：</p>
<p>​       systemctl stop docker </p>
<p>​       yum -y remove docker-ce</p>
<p>​       rm -rf /var/lib/docker</p>
<h2 id="4-3阿里云镜像加速"><a href="#4-3阿里云镜像加速" class="headerlink" title="4.3阿里云镜像加速"></a>4.3阿里云镜像加速</h2><p>因为docker官网提供的获取镜像地址（hub.docker），访问速度太过缓慢，这里改换成阿里云的镜像服务。</p>
<p>\1.     登录阿里云</p>
<p><a href="https://www.aliyun.com/" target="_blank" rel="external">https://www.aliyun.com/</a> 进入管理中心</p>
<p>\2.     搜索容器镜像服务</p>
<p><img src="/2019/02/28/docker个人总结/clip_image034.jpg" alt="img"></p>
<p>可以看到镜像加速器</p>
<p><img src="/2019/02/28/docker个人总结/clip_image036.jpg" alt="img"></p>
<p>获得加速器地址连接</p>
<p>\3. 配置本机Docker运行镜像加速器</p>
<p><strong>Centos6.8版本设置：</strong></p>
<ul>
<li>vim   /etc/sysconfig/docker      将获得的自己账户下的阿里云加速地址配置进   other_args=”–registry-mirror=<a href="https://你自己的账号加速信息.mirror.aliyuncs.com" target="_blank" rel="external">https://你自己的账号加速信息.mirror.aliyuncs.com</a>“   </li>
</ul>
<p><img src="/2019/02/28/docker个人总结/clip_image038.jpg" alt="img"></p>
<p><strong>Centos7.6版本设置：</strong></p>
<p>   sudo mkdir -p /etc/docker   sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’   {     “registry-mirrors”:   [“<a href="https://sk6o0yc78m.mirror.aliyuncs.com" target="_blank" rel="external">https://sk6o0yc78m.mirror.aliyuncs.com</a>“]   }   EOF   sudo systemctl daemon-reload   sudo systemctl restart docker   </p>
<p><img src="/2019/02/28/docker个人总结/clip_image039.png" alt="img"></p>
<p>Centos7以上的配置文件时：/etc/docker/daemon.json</p>
<p>4．检查配置是否生效</p>
<p>  Centos6.8 检查命令：</p>
<p>​      启动docker，执行命令 ps –ef| grep docker</p>
<p>Centos7.6检查命令：</p>
<p><img src="/2019/02/28/docker个人总结/clip_image041.jpg" alt="img"></p>
<h2 id="4-4-设置docker开机启动"><a href="#4-4-设置docker开机启动" class="headerlink" title="4.4    设置docker开机启动"></a>4.4    设置docker开机启动</h2><p>systemctl enable docker</p>
<h1 id="五、docker组成和分析"><a href="#五、docker组成和分析" class="headerlink" title="五、docker组成和分析"></a>五、docker组成和分析</h1><h2 id="5-1-Docker组成"><a href="#5-1-Docker组成" class="headerlink" title="5.1 Docker组成"></a>5.1 Docker组成</h2><h3 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h3><p>Docker 镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image042.png" alt="graphic"></p>
<p> 一个类可以new多个对象。</p>
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h4 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h4><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p> <img src="/2019/02/28/docker个人总结/clip_image044.jpg" alt="graphic">跟花卷一样，一层一层的</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<h4 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h4><p> Docker镜像加载原理：</p>
<p>   docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 </p>
<p><img src="/2019/02/28/docker个人总结/clip_image046.jpg" alt="graphic"></p>
<p> <strong>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image048.jpg" alt="graphic"></p>
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host（宿主机）的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<h4 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h4><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载</p>
<p><img src="/2019/02/28/docker个人总结/clip_image050.jpg" alt="img"></p>
<p>有多个complete，说明有多个层次</p>
<h4 id="为什么-Docker-镜像要采用这种分层结构呢"><a href="#为什么-Docker-镜像要采用这种分层结构呢" class="headerlink" title="为什么 Docker 镜像要采用这种分层结构呢"></a>为什么 Docker 镜像要采用这种分层结构呢</h4><p>最大的一个好处就是 - 共享资源</p>
<p>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，</p>
<p>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>Docker镜像都是只读的</p>
<p>当容器启动时，一个新的可写层被加载到镜像的顶部。</p>
<p>这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<h3 id="容器（container）鲸鱼背上的集装箱"><a href="#容器（container）鲸鱼背上的集装箱" class="headerlink" title="容器（container）鲸鱼背上的集装箱"></a>容器（container）鲸鱼背上的集装箱</h3><p><strong>Docker</strong> <strong>利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。</strong></p>
<p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>
<p><strong>可以把容器看做是一个简易版的</strong> <strong>Linux</strong> <strong>环境</strong>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，<strong>唯一区别在于容器的最上面那一层是可读可写的</strong>。</p>
<p><strong>即是：容器=镜像+可读写层</strong></p>
<h3 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h3><p>仓库（Repository）是集中存放镜像文件的场所。</p>
<p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p>
<p>最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)，" target="_blank" rel="external">https://hub.docker.com/)，</a></p>
<p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要正确的理解仓储/镜像/容器这几个概念:</p>
<p> Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>\1.     image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p>
<p>\2.     一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</p>
<p>\3.     至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</p>
<p>总结：仓库存放着很多镜像，通过使用镜像可以生成多个容器</p>
<h2 id="5-2-Docker运行流程"><a href="#5-2-Docker运行流程" class="headerlink" title="5.2 Docker运行流程"></a>5.2 Docker运行流程</h2><p><img src="/2019/02/28/docker个人总结/clip_image052.png" alt="docker-framework"></p>
<p>Docker 使用 C/S 结构，即客户端/服务器体系结构。 Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。 Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 stock 或网络接口与远程 Docker 服务端进行通信。</p>
<h3 id="执行docker-run-hello-world"><a href="#执行docker-run-hello-world" class="headerlink" title="执行docker run hello-world"></a>执行docker run hello-world</h3><p>这个例子在上面我们已经使用过了，对照docker结构图我们来分析</p>
<p>Client：客户端就是我们的linux的命令窗口，也就是执行docker run hello-world的地方</p>
<p>Docker-host： docker主机，也就是执行客户端发出请求的地方，也就是我们启动的docker进程。收到一个执行hello-world容器的命令，现在本地种查找是否存在这个容器（镜像），存在则直接运行。不存在，则在Repository中取（上面我们配置了阿里云镜像仓库），pull镜像后放到本地，然后新建一个容器执行这个hello-world镜像。</p>
<p>Repository:：仓库，存放镜像的地方</p>
<p>下次执行docker run hello-world，则会从本地中拿hello-world镜像，然后新建容器执行。</p>
<p>完整流程如图：</p>
<p><img src="/2019/02/28/docker个人总结/clip_image054.jpg" alt="img"></p>
<h1 id="六、docker常用操作命令"><a href="#六、docker常用操作命令" class="headerlink" title="六、docker常用操作命令"></a>六、docker常用操作命令</h1><h2 id="6-1-帮助命令"><a href="#6-1-帮助命令" class="headerlink" title="6.1 帮助命令"></a>6.1 帮助命令</h2><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h3><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h3><p>能够查看更详细的docker信息，比docker version命令更加详细</p>
<h3 id="docker-–help"><a href="#docker-–help" class="headerlink" title="docker –help"></a>docker –help</h3><h2 id="6-2-镜像命令"><a href="#6-2-镜像命令" class="headerlink" title="6.2       镜像命令"></a>6.2       镜像命令</h2><h3 id="6-2-1-docker-images"><a href="#6-2-1-docker-images" class="headerlink" title="6.2.1 docker images"></a>6.2.1 docker images</h3><p>列出本地主机上的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image056.jpg" alt="img"></p>
<p>各个选项说明:</p>
<p>   REPOSITORY：表示镜像的仓库源   TAG：<strong>镜像 标签</strong>   IMAGE ID：镜像ID   CREATED：镜像创建时间   SIZE：镜像大小   </p>
<p> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p><strong>如果你不指定一个镜像的版本标签，例如你只使用</strong> <strong>redis，docker</strong> <strong>将默认使用</strong> <strong>redis:latest镜像</strong></p>
<p>   OPTIONS说明：   -a :列出本地所有的镜像（含中间映像层）   -q :只显示镜像ID。   –digests :显示镜像的摘要信息   –no-trunc :显示完整的镜像信息   </p>
<h3 id="6-2-2-docker-search-某个XXX镜像名字"><a href="#6-2-2-docker-search-某个XXX镜像名字" class="headerlink" title="6.2.2 docker search 某个XXX镜像名字"></a>6.2.2 docker search 某个XXX镜像名字</h3><p><strong>需要注意，查询是从网站</strong> <a href="https://hub.docker.com" target="_blank" rel="external">https://hub.docker.com</a><strong>上进行查询，拉取镜像的时候是从阿里云上拉取</strong></p>
<p>命令： docker search [OPTIONS] 镜像名字</p>
<p>OPTIONS说明：</p>
<p>–no-trunc : 显示完整的镜像描述</p>
<p>-s : 列出收藏数不小于指定值的镜像。（<strong>就是下面的STARS数</strong>）</p>
<p>–automated : 只列出 automated build类型的镜像；</p>
<p><img src="/2019/02/28/docker个人总结/clip_image058.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image060.jpg" alt="img"></p>
<h3 id="6-2-3-docker-pull-某个XXX镜像名字"><a href="#6-2-3-docker-pull-某个XXX镜像名字" class="headerlink" title="6.2.3 docker pull 某个XXX镜像名字"></a>6.2.3 docker pull 某个XXX镜像名字</h3><p>下载镜像</p>
<p>命令：ker pull 镜像名字[:TAG]  （如果不指明标签默认下载最新版本）</p>
<h3 id="6-2-4-docker-rmi-某个XXX镜像名字ID"><a href="#6-2-4-docker-rmi-某个XXX镜像名字ID" class="headerlink" title="6.2.4 docker rmi 某个XXX镜像名字ID"></a>6.2.4 docker rmi 某个XXX镜像名字ID</h3><p>删除镜像</p>
<p>删除单个：</p>
<p>docker rmi  -f 镜像ID （不指明标签默认删除latest）</p>
<p>docker rmi  -f 镜像名称 （不指明标签默认删除latest）</p>
<p>删除多个：docker rmi -f 镜像名1:TAG 镜像名2:TAG </p>
<p>删除全部：ocker rmi -f $(docker images -qa) （<strong>docker images –qa</strong> <strong>查询当前docker中所有镜像id</strong>）</p>
<h2 id="6-3容器命令"><a href="#6-3容器命令" class="headerlink" title="6.3容器命令"></a>6.3容器命令</h2><h3 id="6-3-1有镜像才能创建容器，这是根本前提-下载一个CentOS镜像演示"><a href="#6-3-1有镜像才能创建容器，这是根本前提-下载一个CentOS镜像演示" class="headerlink" title="6.3.1有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示)"></a>6.3.1有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示)</h3><p>docker pull centos</p>
<p><img src="/2019/02/28/docker个人总结/clip_image062.jpg" alt="img"></p>
<p>所以说<strong>可以把容器看做是一个简易版的</strong> <strong>Linux</strong> <strong>环境</strong></p>
<h3 id="6-3-2新建并启动容器"><a href="#6-3-2新建并启动容器" class="headerlink" title="6.3.2新建并启动容器"></a>6.3.2新建并启动容器</h3><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p> OPTIONS说明</p>
<p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号</p>
<p>–name=”容器新名字”: 为容器指定一个名称；</p>
<p>-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</p>
<p>-i：以交互模式运行容器，通常与 -t 同时使用；</p>
<p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
<p>-P: 随机端口映射；</p>
<p>-p: 指定端口映射，有以下四种格式</p>
<p>​      ip:hostPort:containerPort</p>
<p>​      ip::containerPort</p>
<p>​      hostPort:containerPort</p>
<p>​      containerPort</p>
<p>下面运行6.3.1中下载的centos</p>
<p><img src="/2019/02/28/docker个人总结/clip_image064.jpg" alt="img"></p>
<p><strong>启动交互式容器（跟下面我们所说的启动守护式容器有区别）</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image066.jpg" alt="graphic"></p>
<p>#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p>
<p><strong>docker run -it centos /bin/bash</strong> <strong>等同于</strong> <strong>docker run -it centos</strong></p>
<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p>1.从Hub上下载tomcat镜像到本地并成功运行</p>
<p>  （1）docker pull tomcat </p>
<p>  （2）docker run -it -p 8088:8080 tomcat </p>
<p>  运行tomcat，第一个端口8088表示docker对外暴露访问内部tomcat的端口，映射内部tomcat 的8080端口，什么意思呢？</p>
<p><img src="/2019/02/28/docker个人总结/clip_image068.jpg" alt="img"></p>
<p>查看运行的容器</p>
<p><img src="/2019/02/28/docker个人总结/clip_image070.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image072.jpg" alt="img"></p>
<p>访问tomcat成功，直接访问<a href="http://192.168.1.105:8080/" target="_blank" rel="external">http://49.234.188.74:8080/</a> 失败，因为我们知道，tomcat 是docker运行的一个容器，所以需要docker对外暴露后才能够访问。</p>
<p>（3）使用-P 不指名端口的方式运行tomcat</p>
<p><img src="/2019/02/28/docker个人总结/clip_image074.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image076.jpg" alt="img"></p>
<p>很明显使用大P的方式启动tomcat，docker会随机分配一个对外暴露的端口</p>
<p><img src="/2019/02/28/docker个人总结/clip_image078.jpg" alt="img"></p>
<h3 id="6-3-3列出当前所有正在运行的容器"><a href="#6-3-3列出当前所有正在运行的容器" class="headerlink" title="6.3.3列出当前所有正在运行的容器"></a>6.3.3列出当前所有正在运行的容器</h3><p>docker ps [OPTIONS]</p>
<p>OPTIONS说明（常用）：</p>
<p>-a :列出当前所有正在运行的容器+历史上运行过的</p>
<p>-l :显示最近创建的容器。</p>
<p>-n：显示最近n个创建的容器。</p>
<p>-q :静默模式，只显示容器编号。</p>
<p>–no-trunc :不截断输出。</p>
<p><strong>查看6.3.2</strong> <strong>运行的centos</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image080.jpg" alt="img"></p>
<h3 id="6-3-4退出容器"><a href="#6-3-4退出容器" class="headerlink" title="6.3.4退出容器"></a>6.3.4退出容器</h3><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h4><p>容器停止退出，销毁容器。<strong>注意，容器内的数据也会一并消失，类似java的对象，close销毁后就不会存在了。</strong></p>
<h4 id="ctrl-P-Q"><a href="#ctrl-P-Q" class="headerlink" title="ctrl+P+Q"></a>ctrl+P+Q</h4><p>容器不停止退出,回到宿主机。（<strong>那么怎么回到容器呢？-请看下面补充章节的第五小点</strong>）</p>
<h3 id="6-3-5启动容器"><a href="#6-3-5启动容器" class="headerlink" title="6.3.5启动容器"></a>6.3.5启动容器</h3><p>docker start 容器ID或者容器名 （可以启动已经关闭的容器）（docker ps –l 查看最近运行过得容器）</p>
<h3 id="6-3-6重启容器"><a href="#6-3-6重启容器" class="headerlink" title="6.3.6重启容器"></a>6.3.6重启容器</h3><p>docker restart 容器ID或者容器名</p>
<h3 id="6-3-7停止容器"><a href="#6-3-7停止容器" class="headerlink" title="6.3.7停止容器"></a>6.3.7停止容器</h3><p>docker stop 容器ID或者容器名</p>
<h3 id="6-3-8强制停止容器"><a href="#6-3-8强制停止容器" class="headerlink" title="6.3.8强制停止容器"></a>6.3.8强制停止容器</h3><p>docker kill 容器ID或者容器名</p>
<h3 id="6-3-9删除已停止的容器"><a href="#6-3-9删除已停止的容器" class="headerlink" title="6.3.9删除已停止的容器"></a>6.3.9删除已停止的容器</h3><p>docker rm 容器ID</p>
<p>一次性删除多个容器（下面两种方式）</p>
<p>docker rm -f $(docker ps -a -q)</p>
<p>docker ps -a -q | xargs docker rm</p>
<h3 id="6-3-10-迁移与备份"><a href="#6-3-10-迁移与备份" class="headerlink" title="6.3.10 迁移与备份"></a>6.3.10 迁移与备份</h3><p><img src="/2019/02/28/docker个人总结/clip_image082.jpg" alt="img"></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="启动守护式容器"><a href="#启动守护式容器" class="headerlink" title="启动守护式容器"></a>启动守护式容器</h4><p> 命令：docker run -d 容器名</p>
<p>   docker run -d centos       问题：然后docker ps -a 进行查看, <strong>会发现容器已经退出，也就是说没有刚才我们启动的容器</strong>       很重要的要说明的一点: <strong>Docker**</strong>容器后台运行<strong><strong>,</strong></strong>就必须有一个前台进程<strong>**.</strong>   <strong>容器运行的命令如果不是那些一直挂起的命令（比如运行**</strong>top<strong><strong>，</strong></strong>tail<strong>**），就是会自动退出的</strong>。       这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如   service nginx start   但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,   这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.   所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行   </p>
<h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><p>命令：docker logs -f -t –tail 容器ID</p>
<p> 参数解析：</p>
<p>*   -t 是加入时间戳</p>
<p>*   -f 跟随最新的日志打印</p>
<p>*   –tail 数字 显示最后多少条</p>
<p>例子：</p>
<p>  启动守护式容器（因为存在前台程序一直循环输出,那么他就不会退出）</p>
<p>docker run -d centos /bin/sh -c “while true;do echo hello kingge;sleep 2;done”</p>
<p><img src="/2019/02/28/docker个人总结/clip_image084.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image085.png" alt="img"></p>
<h4 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h4><p>docker top 容器ID</p>
<p><img src="/2019/02/28/docker个人总结/clip_image087.jpg" alt="img"></p>
<p>返回的信息时，上个例子中启动的守护式容器</p>
<h4 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h4><p>docker inspect 容器ID</p>
<p>返回一个json串的描述格式</p>
<p><img src="/2019/02/28/docker个人总结/clip_image089.jpg" alt="img"></p>
<h4 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h4><p><strong>回到以ctrl+p+q的方式退出的容器中</strong></p>
<p>第一种方式：</p>
<p>   使用命令：docker exec -it 容器ID bashShell （后面必须携带bash指令）</p>
<p><img src="/2019/02/28/docker个人总结/clip_image090.png" alt="img">登录操作</p>
<p>效果等同</p>
<p><img src="/2019/02/28/docker个人总结/clip_image091.png" alt="img"></p>
<p>例子2：</p>
<p><img src="/2019/02/28/docker个人总结/clip_image093.jpg" alt="img"></p>
<p><strong>打印后台启动的centos容器的根目录的消息，我们发现，他并没有进入后台的容器，只是把容器执行的指令的结果输出到宿主。所以他的功能是比docker attach指令还要强大的</strong></p>
<p>第二种方式：</p>
<p>​       docker attach 容器ID</p>
<p>两种方式的区别：</p>
<p>attach 直接进入容器启动命令的终端，不会启动新的进程</p>
<p>exec 是在容器中打开新的终端，并且可以启动新的进程</p>
<h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><p><strong>宿主机上执行</strong></p>
<p>docker cp  容器ID:容器内路径 目的主机路径</p>
<h4 id="Docker镜像commit"><a href="#Docker镜像commit" class="headerlink" title="Docker镜像commit"></a>Docker镜像commit</h4><p>\1. commit提交容器副本使之成为一个新的镜像</p>
<p>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:[标签名]</p>
<h5 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h5><p>1.删除运行的tomcat 的文档模块，然后提交为新的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image095.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image097.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image099.jpg" alt="img"></p>
<p>这个时候再来访问tomcat容器的docs文档模块，肯定是404.</p>
<p><img src="/2019/02/28/docker个人总结/clip_image101.jpg" alt="img"></p>
<p>\2. 也即当前的tomcat运行实例是一个没有文档内容的容器，以它为模板commit一个没有doc的tomcat新镜像kingge/tomcatnodoc</p>
<p><img src="/2019/02/28/docker个人总结/clip_image103.jpg" alt="img"></p>
<p><strong>注意这个标红框的镜像id必须是某一个正在运行的容器id</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image105.jpg" alt="img"></p>
<p>3.启动重新上传的tomcat</p>
<p><img src="/2019/02/28/docker个人总结/clip_image107.jpg" alt="img"></p>
<p>查看是否存在doc目录</p>
<p><img src="/2019/02/28/docker个人总结/clip_image108.png" alt="img"></p>
<p>不存在，说明这个版本就是我们亲自提交的删除文档的tomcat版本。</p>
<p><strong>这个时候可以同时启动原先的tomcat版本，查看区别。</strong></p>
<h2 id="命令图例"><a href="#命令图例" class="headerlink" title="命令图例"></a>命令图例</h2><p><img src="/2019/02/28/docker个人总结/clip_image110.jpg" alt="graphic"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image112.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image114.jpg" alt="img"></p>
<h1 id="七、Docker容器数据卷"><a href="#七、Docker容器数据卷" class="headerlink" title="七、Docker容器数据卷"></a>七、Docker容器数据卷</h1><p>生产环境中使用Docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p>
<p> 卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性.</p>
<p> 卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷.( 数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于Linux中的mount操作)</p>
<p>​       </p>
<p>特点：</p>
<p>1：数据卷可在容器之间共享或重用数据</p>
<p>2：卷中的更改可以直接生效</p>
<p>3：数据卷中的更改不会包含在镜像的更新中</p>
<p>4：数据卷的生命周期一直持续到没有容器使用它为止</p>
<p>容器中管理数据主要有两种方式：</p>
<p>\1.     <strong>数据卷（Data Volumes）</strong>：容器内数据<strong>直接映射</strong>到本地主机环境，如何在容器内创建数据卷，并且把本地的目录或文件挂载到容器内的数据卷中。</p>
<p>\2.     <strong>数据卷容器（Data Volume Containers）</strong>：使用特定容器维护数据卷。如何使用数据卷容器在容器和主机、容器和容器之间共享数据，并实现数据的备份和恢复。</p>
<h2 id="7-1-创建数据卷"><a href="#7-1-创建数据卷" class="headerlink" title="7.1 创建数据卷"></a>7.1 创建数据卷</h2><h3 id="7-1-1-第一种方式：使用命令直接添加"><a href="#7-1-1-第一种方式：使用命令直接添加" class="headerlink" title="7.1.1 第一种方式：使用命令直接添加"></a>7.1.1 第一种方式：使用命令直接添加</h3><p>命令： docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名</p>
<p>​       就是把宿主机的某个目录关联到容器中，两者数据共通（文件夹不存在时，自动创建）</p>
<p>1.使用命令创建数据卷</p>
<p><img src="/2019/02/28/docker个人总结/clip_image115.png" alt="img"></p>
<p>宿主机也创建了myHostVal目录</p>
<p><img src="/2019/02/28/docker个人总结/clip_image116.png" alt="img"></p>
<p>2.校验是否数据共通</p>
<p><img src="/2019/02/28/docker个人总结/clip_image117.png" alt="img">宿主机创建一个文本</p>
<p>查看容器是否存在hello.txt</p>
<p><img src="/2019/02/28/docker个人总结/clip_image118.png" alt="img">容器存在。</p>
<p>反之，容器创建一个文件，宿主机也会出现同样的文件。</p>
<p>尖叫提示：</p>
<p><strong>Docker挂载数据卷的默认权限是读写（rw），用户也可以通过ro指定为只读</strong></p>
<p>\3.     极端测试</p>
<p>  容器停止退出后（exit），宿主机创建或者修改文件，再重启容器（start），查看宿主机创建或者修改的文件是否有相应的变化。</p>
<p>  经测试，答案是会有相应的变化。</p>
<p>4.查看容器的内部细节</p>
<p>docker inspect 容器ID</p>
<p>   返回的json串中可以找到这样的一行描述</p>
<p><img src="/2019/02/28/docker个人总结/clip_image119.png" alt="img"></p>
<p>5.容器挂载文件夹的读写方式</p>
<p>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</p>
<p><img src="/2019/02/28/docker个人总结/clip_image120.png" alt="img"></p>
<p>经过操作我们发现，宿主机创建或者修改的文件都能够同步到容器中，但是在容器中只能够查看对应的宿主机同步过来的文件，容器中不能够新增删除修改文件，只能够查看。</p>
<p>再次使用inspect 命令查看挂载的状态</p>
<p><img src="/2019/02/28/docker个人总结/clip_image121.png" alt="img"></p>
<p>发现可读写方式变为false，只读。</p>
<h3 id="7-1-2-第二种方式：DockerFile方式添加"><a href="#7-1-2-第二种方式：DockerFile方式添加" class="headerlink" title="7.1.2 第二种方式：DockerFile方式添加"></a>7.1.2 第二种方式：DockerFile方式添加</h3><p>DockerFile就是对于一个镜像的描述文件，类似于java代码编译后形成的.class文件，他是关于一个java类的描述。</p>
<h4 id="1初探dockerfile结构"><a href="#1初探dockerfile结构" class="headerlink" title="1初探dockerfile结构"></a>1初探dockerfile结构</h4><p>打开docker hub，随便查看一个tomcat版本的dockerfile</p>
<p><img src="/2019/02/28/docker个人总结/clip_image123.jpg" alt="img"></p>
<p>打开后得到下面的代码，下面就是</p>
<p><img src="/2019/02/28/docker个人总结/clip_image125.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image126.png" alt="img"></p>
<p>这个dockerfile文件很好的阐述了tomcat镜像文件为什么这么大，而且为什么我们能够访问8080端口。</p>
<p>查看centos的dockerfile镜像描述文件</p>
<p><img src="/2019/02/28/docker个人总结/clip_image128.jpg" alt="img"></p>
<h4 id="2-创建数据卷"><a href="#2-创建数据卷" class="headerlink" title="2.创建数据卷"></a>2.创建数据卷</h4><p>可在Dockerfile中使用<strong>VOLUME</strong>指令来给镜像添加一个或多个数据卷</p>
<p>VOLUME[“/dataVolumeContainer”,”/dataVolumeContainer2”,”/dataVolumeContainer3”]</p>
<p>说明：</p>
<p>出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。</p>
<p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。（<strong>意思就是说容器中数据卷在linux01宿主机上关联的目录是myvolume1，但是如果该镜像在linux02宿主机上运行，那么容器容器启动后，可能找不到关联的myvolume1，因为你不能够保证linux02宿主机的相关目录结构是跟linux01一样的，所以使用dockerfile的方式创建数据卷的时候，单方面的指定容器中数据卷目录位置，容器启动后，会帮我们自动创建相关联的宿主机的目录</strong>）</p>
<p>   <strong>也就是说，VOLUME命令只能够单方面的在容器中创建数据卷，不能够指明对应宿主机关联的目录（但是他会自动在宿主机创建相关联的目录）</strong></p>
<p>\1.     宿主机创建dockerfile文件，依赖已经存在的centos镜像。</p>
<p>也就是说我们以现有的centos为某一层创建一个新的镜像（符合UnionFS）</p>
<p> 在宿主机创建一个文件夹，存放创建的dockerfile文件</p>
<p>​       <img src="/2019/02/28/docker个人总结/clip_image129.png" alt="img"></p>
<p> 新建的dockerfile文件dc。内容</p>
<p><img src="/2019/02/28/docker个人总结/clip_image130.png" alt="img"></p>
<p>\2.     根据dockerfile文件dc，构建新镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image132.jpg" alt="img"></p>
<p>Docker images 查看现存在的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image134.jpg" alt="img"></p>
<p>启动我们创建的centos镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image136.jpg" alt="img"></p>
<p>确实主动给我们创建了两个数据卷，那么他们关联的宿主机的目录是什么呢？</p>
<p>  使用docekr inspect命令查看</p>
<p><img src="/2019/02/28/docker个人总结/clip_image138.jpg" alt="img"></p>
<h2 id="7-2数据卷容器"><a href="#7-2数据卷容器" class="headerlink" title="7.2数据卷容器"></a>7.2数据卷容器</h2><p>使用特定容器维护数据卷。7.1中使用的数据卷的方式是宿主机直接映射到容器进行数据传输，但是如果我们想两个容器之间共享传递数据怎么办呢？</p>
<p>就需要创建数据卷容器</p>
<h3 id="7-2-1先启动一个父容器dc01"><a href="#7-2-1先启动一个父容器dc01" class="headerlink" title="7.2.1先启动一个父容器dc01"></a>7.2.1先启动一个父容器dc01</h3><p>以上一步新建的镜像kingge/centos为模板并运行容器dc01</p>
<p><img src="/2019/02/28/docker个人总结/clip_image139.png" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image141.jpg" alt="img"></p>
<p>在创建容器卷dataVolumeContainer2新增内容，touch hello1.txt</p>
<h3 id="7-2-2-创建dc02、03继承自dc01"><a href="#7-2-2-创建dc02、03继承自dc01" class="headerlink" title="7.2.2 创建dc02、03继承自dc01"></a>7.2.2 创建dc02、03继承自dc01</h3><p>使用–volumes-from关键命令</p>
<p><img src="/2019/02/28/docker个人总结/clip_image142.png" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image144.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image146.jpg" alt="img"></p>
<p>在dc02、03的dataVolumeContainer2目录下查看是否存在dc01创建的hello1txt，很明显是可以看到的。</p>
<h3 id="7-2-3测试数据共通性"><a href="#7-2-3测试数据共通性" class="headerlink" title="7.2.3测试数据共通性"></a>7.2.3测试数据共通性</h3><p>1.dc02/dc03分别在dataVolumeContainer2各自新增内容，touch hello2.txt和touch hello3.txt</p>
<p>分别查看dc01 dc02 dc03的dataVolumeContainer2目录下是否存在hello1.txt hello2.txt hello3.txt 这三个文件，答案是：<strong>都存在这三个文件</strong></p>
<p>\2. 删除dc01，dc02修改后dc03可否访问</p>
<p><img src="/2019/02/28/docker个人总结/clip_image148.jpg" alt="img"></p>
<p>答案很明显是存在的，也就是说删除dc01并不会影响dc02和dc03的数据互通</p>
<p><strong>结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</strong></p>
<h1 id="八、DockerFile解析"><a href="#八、DockerFile解析" class="headerlink" title="八、DockerFile解析"></a>八、DockerFile解析</h1><h2 id="8-1-dockerfile概念"><a href="#8-1-dockerfile概念" class="headerlink" title="8.1 dockerfile概念"></a>8.1 dockerfile概念</h2><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。通过：编写Dockerfile文件-&gt; docker build -&gt; docker run，生成一个镜像文件</p>
<p>查看centos的dockerfile镜像描述文件</p>
<p><img src="/2019/02/28/docker个人总结/clip_image149.jpg" alt="img"></p>
<p>1：每条保留字指令都必须为大写字母且后面要跟随至少一个参数</p>
<p>2：指令按照从上到下，顺序执行</p>
<p>3：#表示注释</p>
<p>4：每条指令都会创建一个新的镜像层，并对镜像进行提交</p>
<p>（1）docker从基础镜像运行一个容器（from scratch）</p>
<p>（2）执行一条指令并对容器作出修改</p>
<p>（3）执行类似docker commit的操作提交一个新的镜像层</p>
<p>（4）docker再基于刚提交的镜像运行一个新容器</p>
<p>（5）执行dockerfile中的下一条指令直到所有指令都执行完成</p>
<p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>
<p>*  Dockerfile是软件的原材料</p>
<p>*  Docker镜像是软件的交付品</p>
<p>*  Docker容器则可以认为是软件的运行态。</p>
<p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image151.jpg" alt="graphic"></p>
<p>1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</p>
<p>2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</p>
<p>3 Docker容器，容器是直接提供服务的。</p>
<p><strong>尖叫提示</strong>：Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的<img src="/2019/02/28/docker个人总结/clip_image152.png" alt="img"></p>
<h2 id="8-2-dockerfile指令（保留字指令）"><a href="#8-2-dockerfile指令（保留字指令）" class="headerlink" title="8.2 dockerfile指令（保留字指令）"></a>8.2 dockerfile指令（保留字指令）</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>​    基础镜像，当前新镜像是基于哪个镜像的</p>
<h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>​    镜像维护者的姓名和邮箱地址</p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>​    容器构建时需要运行的命令</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>​    当前容器对外暴露出的端口</p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p>
<p><img src="/2019/02/28/docker个人总结/clip_image154.jpg" alt="img"></p>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>​    用来在构建镜像过程中设置环境变量</p>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>​    将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和<strong>解压tar压缩包</strong></p>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>类似ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置，<strong>没有解压功能</strong></p>
<p>COPY src dest</p>
<p>COPY [“src”, “dest”]</p>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>​    容器数据卷，用于数据保存和持久化工作</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>​    指定一个容器启动时要运行的命令</p>
<p><strong>Dockerfile</strong> <strong>中可以有多个</strong> <strong>CMD</strong> <strong>指令，但只有最后一个生效，CMD</strong> <strong>会被</strong> <strong>docker run</strong> <strong>之后的参数替换（跟</strong>ENTRYPOINT指令的区别）</p>
<p>举个例子，查看tomcat 的dockerfile文件，我们可以发现最后是通过cmd命令启动了tomcat<img src="/2019/02/28/docker个人总结/clip_image155.png" alt="img">。那么为了证明CMD会不会被docker run后面的参数替换，请看下面例子。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image157.jpg" alt="img"></p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>​    指定一个容器启动时要运行的命令</p>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数，但是他是以追加的形式而不是覆盖</p>
<p>docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</p>
<p><img src="/2019/02/28/docker个人总结/clip_image158.png" alt="img"></p>
<p>  小总结</p>
<p><img src="/2019/02/28/docker个人总结/clip_image160.jpg" alt="graphic"></p>
<h2 id="8-3-案例"><a href="#8-3-案例" class="headerlink" title="8.3 案例"></a>8.3 案例</h2><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>需求：修改默认的centos，修改他的落脚点（默认运行centos后容器进入的根目录）和添加vim指令、ifconfig（默认centos镜像没有安装这两个组件）</p>
<p><img src="/2019/02/28/docker个人总结/clip_image162.jpg" alt="img"></p>
<p>\1.     创建dockefile镜像描述文件</p>
<p><img src="/2019/02/28/docker个人总结/clip_image163.png" alt="img"></p>
<p>内容是</p>
<p><img src="/2019/02/28/docker个人总结/clip_image165.jpg" alt="img"></p>
<p>   FROM centos   MAINTAINER kingge<a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#51;&#57;&#51;&#x32;&#49;&#x35;&#x36;&#54;&#49;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#51;&#57;&#51;&#x32;&#49;&#x35;&#x36;&#54;&#49;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;</a>       ENV MYPATH /usr/local   WORKDIR $MYPATH       RUN yum -y install vim   RUN yum -y install net-tools       EXPOSE 80       CMD echo $MYPATH   CMD echo “success————–ok”   CMD /bin/bash   </p>
<p>\2. 根据创建的Dockerfile构建镜像</p>
<p>docker build -t 新镜像名字:TAG . （注意这里还有一个点，表示当前文件夹）</p>
<p>默认去找当前目录下名字为Dockerfile的文件构建镜像。</p>
<p>也可以用这个命令指定dockerfile：</p>
<p>docker build -f /mydockerfile/Dockerfile -t kingge/mycentos:1.1 .</p>
<p><img src="/2019/02/28/docker个人总结/clip_image166.png" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image168.jpg" alt="img"></p>
<p>很明显跟原先从docker hub上拉取下来的centos多个两百多M，因为我们安装了vim和net-tools指令。</p>
<p>\3. 列出镜像的变更历史</p>
<p>​       docker history 镜像名（imagesid）</p>
<p><img src="/2019/02/28/docker个人总结/clip_image170.jpg" alt="img"></p>
<p>可以看到构建这个镜像的每一层相关的操作。</p>
<p>4.运行构建的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image171.png" alt="img"></p>
<p>可以看到容器登陆后落脚点变更为了我们设定的/usr/local，同时也支持了vim 和ifconfig命令。</p>
<p><img src="/2019/02/28/docker个人总结/clip_image173.jpg" alt="img"></p>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>通过自定义一个tomcat的方式我们来使用一些dockerfile常用的指令</p>
<h4 id="2-1-新建一个工作目录"><a href="#2-1-新建一个工作目录" class="headerlink" title="2.1 新建一个工作目录"></a>2.1 新建一个工作目录</h4><p><img src="/2019/02/28/docker个人总结/clip_image174.png" alt="img"></p>
<p>存放待传输到容器中的压缩包（测试ADD命令专用）和一个文本文件（测试COPY指令专用）</p>
<h4 id="2-2-根据原版centos新建Dockerfile文件"><a href="#2-2-根据原版centos新建Dockerfile文件" class="headerlink" title="2.2 根据原版centos新建Dockerfile文件"></a>2.2 根据原版centos新建Dockerfile文件</h4><p><img src="/2019/02/28/docker个人总结/clip_image175.png" alt="img"></p>
<p>内容是：</p>
<p>   FROM         centos   MAINTAINER      kingge<a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#51;&#x39;&#x33;&#x32;&#x31;&#x35;&#x36;&#54;&#49;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#51;&#x39;&#x33;&#x32;&#x31;&#x35;&#x36;&#54;&#49;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;</a>   #把宿主机当前上下文的hello.txt拷贝到容器/usr/local/路径下   #并重命名为helloNewName.txt   COPY hello.txt /usr/local/helloNewName.txt   #把java与tomcat添加到容器中   ADD jdk-8u144-linux-x64.tar.gz /usr/local/   ADD apache-tomcat-9.0.21.tar.gz /usr/local/   #安装vim编辑器   RUN yum -y install vim   #设置工作访问时候的WORKDIR路径，登录落脚点   ENV MYPATH /usr/local   WORKDIR $MYPATH   #配置java与tomcat环境变量   ENV JAVA_HOME /usr/local/jdk1.8.0_144   ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar   ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.21   ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.21   ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin   #容器运行时监听的端口   EXPOSE  8080   #启动时运行tomcat   # ENTRYPOINT   [“/usr/local/apache-tomcat-9.0.21/bin/startup.sh” ]   # CMD   [“/usr/local/apache-tomcat-9.0.21/bin/catalina.sh”,”run”]   CMD /usr/local/apache-tomcat-9.0.21/bin/startup.sh &amp;&amp; tail -F   /usr/local/apache-tomcat-9.0.21/bin/logs/catalina.out   </p>
<h4 id="2-3-构建"><a href="#2-3-构建" class="headerlink" title="2.3 构建"></a>2.3 构建</h4><p><img src="/2019/02/28/docker个人总结/clip_image177.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image179.jpg" alt="img"></p>
<p>构建完成</p>
<h4 id="2-4-执行（RUN）"><a href="#2-4-执行（RUN）" class="headerlink" title="2.4 执行（RUN）"></a>2.4 执行（RUN）</h4><p>   docker run -d -p 9080:8080 –name myt9 -v   /mydockerfile/mytomcat/tomcat9/project:/usr/local/apache-tomcat-9.0.21/webapps/project   -v /mydockerfile/mytomcat/tomcat9/logs/:/usr/local/apache-tomcat-9.0.21/logs   –privileged=true mytomcat921   </p>
<p>命令的意思是：后台执行tomcat镜像，docker对外暴露8080端口，外部可以通过9080端口访问docker容器的8080端口。</p>
<p><strong>–name</strong>：启动的容器重命名为myt9 </p>
<p><strong>-v</strong>：新建两个数据卷</p>
<p><strong>–privileged=true</strong>: Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied解决办法：在挂载目录后多加一个–privileged=true参数即可</p>
<p><img src="/2019/02/28/docker个人总结/clip_image181.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image183.jpg" alt="img"></p>
<p>启动成功</p>
<h4 id="2-5-验证"><a href="#2-5-验证" class="headerlink" title="2.5 验证"></a>2.5 验证</h4><p>1.首先验证两个tar包是否已经上传到容器并解压成功，hello.txt文件是否已经copy到容器、容器登录后落脚点是否是在我们设置的/usr/local</p>
<p><img src="/2019/02/28/docker个人总结/clip_image184.png" alt="img"></p>
<p>2.查看数据卷是否创建成功</p>
<p>宿主机对应数据卷创建成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image185.png" alt="img"></p>
<p>容器数据卷创建成功，project出现</p>
<p><img src="/2019/02/28/docker个人总结/clip_image187.jpg" alt="img"></p>
<p>3.校验数据卷</p>
<p><img src="/2019/02/28/docker个人总结/clip_image189.jpg" alt="img"></p>
<h4 id="2-6-部署项目"><a href="#2-6-部署项目" class="headerlink" title="2.6 部署项目"></a>2.6 部署项目</h4><p>因为我们在创建数据卷的时候：</p>
<p>/mydockerfile/mytomcat/tomcat9/project:/usr/local/apache-tomcat-9.0.21/webapps/project</p>
<p>宿主机的/tomcat9/project目录映射到了容器的webapps/project目录，那么可以利用数据卷的数据共通原理。在宿主机的project目录上传一个项目，然后重启容器，那么就可以实现项目的发布。</p>
<p>上传解压后的项目文件</p>
<p><img src="/2019/02/28/docker个人总结/clip_image190.png" alt="img"></p>
<p>很明显会自动同步到容器的webapps/project目录下</p>
<p><img src="/2019/02/28/docker个人总结/clip_image192.jpg" alt="img"></p>
<p>重启容器</p>
<p><img src="/2019/02/28/docker个人总结/clip_image193.png" alt="img"></p>
<p>访问项目</p>
<p><img src="/2019/02/28/docker个人总结/clip_image194.png" alt="img"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2019/02/28/docker个人总结/clip_image196.jpg" alt="graphic"></p>
<h1 id="九、常用插件安装"><a href="#九、常用插件安装" class="headerlink" title="九、常用插件安装"></a>九、常用插件安装</h1><p><a href="https://www.runoob.com/docker/docker-install-mysql.html" target="_blank" rel="external">https://www.runoob.com/docker/docker-install-mysql.html</a></p>
<h2 id="9-1总体步骤"><a href="#9-1总体步骤" class="headerlink" title="9.1总体步骤"></a>9.1总体步骤</h2><p>搜索镜像、拉取镜像、查看镜像、启动镜像、停止容器、移除容器</p>
<h2 id="9-2-tomcat安装"><a href="#9-2-tomcat安装" class="headerlink" title="9.2 tomcat安装"></a>9.2 tomcat安装</h2><h3 id="9-2-1-docker-hub上面查找tomcat镜像"><a href="#9-2-1-docker-hub上面查找tomcat镜像" class="headerlink" title="9.2.1 docker hub上面查找tomcat镜像"></a>9.2.1 docker hub上面查找tomcat镜像</h3><p>  docker search tomcat</p>
<p><img src="/2019/02/28/docker个人总结/clip_image198.jpg" alt="img"></p>
<p>  或者直接使用浏览器登录docker hub查找也可以</p>
<h3 id="9-2-2-从docker-hub上拉取tomcat镜像到本地"><a href="#9-2-2-从docker-hub上拉取tomcat镜像到本地" class="headerlink" title="9.2.2 从docker hub上拉取tomcat镜像到本地"></a>9.2.2 从docker hub上拉取tomcat镜像到本地</h3><p>  docker pull tomcat</p>
<h3 id="9-2-3-docker-images查看是否有拉取到的tomcat"><a href="#9-2-3-docker-images查看是否有拉取到的tomcat" class="headerlink" title="9.2.3 docker images查看是否有拉取到的tomcat"></a>9.2.3 docker images查看是否有拉取到的tomcat</h3><p><img src="/2019/02/28/docker个人总结/clip_image200.jpg" alt="img"></p>
<p>为什么拉取下来的tomcat有五百多M?上面文章已经做了解释（因为里面包含了jdk等等，这个也就是为什么我们可以直接运行tomcat镜像而不用配置jdk环境的原因）</p>
<h3 id="9-2-4-使用tomcat镜像创建容器-也叫运行镜像"><a href="#9-2-4-使用tomcat镜像创建容器-也叫运行镜像" class="headerlink" title="9.2.4 使用tomcat镜像创建容器(也叫运行镜像)"></a>9.2.4 使用tomcat镜像创建容器(也叫运行镜像)</h3><p>  docker run -it -p 8080:8080 tomcat</p>
<p>​    -p 主机端口:docker容器端口</p>
<p>​    -P 随机分配端口</p>
<p>​    i:交互</p>
<p>​    t:终端</p>
<h2 id="9-3安装mysql"><a href="#9-3安装mysql" class="headerlink" title="9.3安装mysql"></a>9.3安装mysql</h2><p><a href="https://hub.docker.com/_/mysql" target="_blank" rel="external">https://hub.docker.com/_/mysql</a>  官网文档</p>
<h3 id="9-3-1-docker-hub上面查找mysql镜像"><a href="#9-3-1-docker-hub上面查找mysql镜像" class="headerlink" title="9.3.1 docker hub上面查找mysql镜像"></a>9.3.1 docker hub上面查找mysql镜像</h3><h3 id="9-3-2-从docker-hub上-阿里云加速器-拉取mysql镜像到本地标签为5-6"><a href="#9-3-2-从docker-hub上-阿里云加速器-拉取mysql镜像到本地标签为5-6" class="headerlink" title="9.3.2 从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.6"></a>9.3.2 从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.6</h3><p><img src="/2019/02/28/docker个人总结/clip_image202.jpg" alt="img"></p>
<h3 id="9-3-3-使用mysql5-6镜像创建容器-也叫运行镜像"><a href="#9-3-3-使用mysql5-6镜像创建容器-也叫运行镜像" class="headerlink" title="9.3.3 使用mysql5.6镜像创建容器(也叫运行镜像)"></a>9.3.3 使用mysql5.6镜像创建容器(也叫运行镜像)</h3><p>   docker run -p 12345:3306 –name mysql    -v  /kingge/mysql/conf:/etc/mysql/conf.d      -v / kingge /mysql/logs:/logs    -v / kingge /mysql/data:/var/lib/mysql    -e MYSQL_ROOT_PASSWORD=123456   -d mysql:5.6   </p>
<p>   命令说明：   -p 12345:3306：将主机的12345端口映射到docker容器的3306端口。   –name mysql：运行服务名字   -v / kingge /mysql/conf:/etc/mysql/conf.d ：将主机/ kingge /mysql录下的conf/my.cnf 挂载到容器的   /etc/mysql/conf.d   -v / kingge /mysql/logs:/logs：将主机/ kingge /mysql目录下的 logs 目录挂载到容器的 /logs。   -v / kingge /mysql/data:/var/lib/mysql ：将主机/ kingge /mysql目录下的data目录挂载到容器的 /var/lib/mysql      -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。   -d mysql:5.6 : 后台程序运行mysql5.6   </p>
<p><img src="/2019/02/28/docker个人总结/clip_image204.jpg" alt="img"></p>
<p>登录测试</p>
<p>docker exec -it  954efcffa04d /bin/bash</p>
<p><img src="/2019/02/28/docker个人总结/clip_image206.jpg" alt="img"></p>
<p>成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image208.jpg" alt="img"></p>
<p>外部软件连接成功</p>
<h2 id="9-4-安装redis"><a href="#9-4-安装redis" class="headerlink" title="9.4 安装redis"></a>9.4 安装redis</h2><h3 id="9-4-1-从docker-hub上-阿里云加速器-拉取redis镜像到本地标签为3-2"><a href="#9-4-1-从docker-hub上-阿里云加速器-拉取redis镜像到本地标签为3-2" class="headerlink" title="9.4.1 从docker hub上(阿里云加速器)拉取redis镜像到本地标签为3.2"></a>9.4.1 从docker hub上(阿里云加速器)拉取redis镜像到本地标签为3.2</h3><p><img src="/2019/02/28/docker个人总结/clip_image209.png" alt="img"></p>
<h3 id="9-4-2-使用redis3-2镜像创建容器-也叫运行镜像"><a href="#9-4-2-使用redis3-2镜像创建容器-也叫运行镜像" class="headerlink" title="9.4.2 使用redis3.2镜像创建容器(也叫运行镜像)"></a>9.4.2 使用redis3.2镜像创建容器(也叫运行镜像)</h3><p>   docker run -p 6379:6379 -v   /kingge/myredis/data:/data -v   /kingge/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf  -d redis:3.2 redis-server   /usr/local/etc/redis/redis.conf –appendonly yes   </p>
<p><img src="/2019/02/28/docker个人总结/clip_image211.jpg" alt="img"></p>
<p><strong>这个时候可以直接连接redis了：</strong></p>
<p>命令：docker exec -it 运行着Rediis服务的容器ID redis-cli</p>
<p><img src="/2019/02/28/docker个人总结/clip_image212.png" alt="img"></p>
<p><strong>设置redis配置文件：</strong></p>
<p>  在主机/kingge/myredis/conf/redis.conf目录下新建redis.conf文件 vim / kingge /myredis/conf/redis.conf/redis.conf</p>
<h1 id="Accept-connections-on-the-specified-port-default-is-6379-IANA-815344-If-port-0-is-specified-Redis-will-not-listen-on-a-TCP-socket-port-6379-。。。。省略"><a href="#Accept-connections-on-the-specified-port-default-is-6379-IANA-815344-If-port-0-is-specified-Redis-will-not-listen-on-a-TCP-socket-port-6379-。。。。省略" class="headerlink" title="Accept connections on the specified port, default is 6379 (IANA   #815344).   # If port 0 is specified Redis will not listen on a TCP socket.   port 6379   。。。。省略"></a>Accept connections on the specified port, default is 6379 (IANA   #815344).   # If port 0 is specified Redis will not listen on a TCP socket.   port 6379   。。。。省略</h1><p><strong>测试持久化文件生成</strong></p>
<p><img src="/2019/02/28/docker个人总结/clip_image214.jpg" alt="img"></p>
<h1 id="十、本地镜像发布到阿里云"><a href="#十、本地镜像发布到阿里云" class="headerlink" title="十、本地镜像发布到阿里云"></a>十、本地镜像发布到阿里云</h1><p><img src="/2019/02/28/docker个人总结/clip_image216.jpg" alt="graphic"></p>
<h2 id="1-镜像生成方式"><a href="#1-镜像生成方式" class="headerlink" title="1.镜像生成方式"></a>1.镜像生成方式</h2><p>（1）使用DockerFile的方式创建镜像</p>
<p>（2）根据运行的容器创建一个新的镜像 docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]] （参见6.3章节的补充模块的Docker镜像commit）</p>
<h2 id="2-将本地镜像推送到阿里云"><a href="#2-将本地镜像推送到阿里云" class="headerlink" title="2. 将本地镜像推送到阿里云"></a>2. 将本地镜像推送到阿里云</h2><h3 id="2-1-登录阿里云，创建镜像仓库"><a href="#2-1-登录阿里云，创建镜像仓库" class="headerlink" title="2.1 登录阿里云，创建镜像仓库"></a>2.1 登录阿里云，创建镜像仓库</h3><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories" target="_blank" rel="external">https://cr.console.aliyun.com/cn-hangzhou/instances/repositories</a></p>
<p><img src="/2019/02/28/docker个人总结/clip_image218.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image220.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image222.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image224.jpg" alt="img"></p>
<h3 id="2-2-创建命名空间"><a href="#2-2-创建命名空间" class="headerlink" title="2.2 创建命名空间"></a>2.2 创建命名空间</h3><p><img src="/2019/02/28/docker个人总结/clip_image225.png" alt="img"></p>
<h3 id="2-3-点击镜像仓库的管理"><a href="#2-3-点击镜像仓库的管理" class="headerlink" title="2.3 点击镜像仓库的管理"></a>2.3 点击镜像仓库的管理</h3><p><img src="/2019/02/28/docker个人总结/clip_image227.jpg" alt="img"></p>
<p>可以获取推送镜像到阿里云仓库的地址</p>
<p><img src="/2019/02/28/docker个人总结/clip_image229.jpg" alt="img"></p>
<p>   $ sudo docker login –username=393215661@qq.com   registry.cn-hangzhou.aliyuncs.com   $ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/kingge/myrepo:[镜像版本号]   $ sudo docker push registry.cn-hangzhou.aliyuncs.com/kingge/myrepo:[镜像版本号]   </p>
<h3 id="2-4-推送镜像到阿里云"><a href="#2-4-推送镜像到阿里云" class="headerlink" title="2.4 推送镜像到阿里云"></a>2.4 推送镜像到阿里云</h3><p>首先进行登录</p>
<p><img src="/2019/02/28/docker个人总结/clip_image231.jpg" alt="img"></p>
<p>标记我们需要上传的镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image233.jpg" alt="img"></p>
<p>开始推送</p>
<p><img src="/2019/02/28/docker个人总结/clip_image235.jpg" alt="img"></p>
<p>推送成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image237.jpg" alt="img"></p>
<h3 id="2-5-查看是否推送成功"><a href="#2-5-查看是否推送成功" class="headerlink" title="2.5 查看是否推送成功"></a>2.5 查看是否推送成功</h3><p><img src="/2019/02/28/docker个人总结/clip_image239.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image241.jpg" alt="img"></p>
<h3 id="2-6-从阿里云下载我们推送的镜像"><a href="#2-6-从阿里云下载我们推送的镜像" class="headerlink" title="2.6 从阿里云下载我们推送的镜像"></a>2.6 从阿里云下载我们推送的镜像</h3><p><img src="/2019/02/28/docker个人总结/clip_image243.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image245.jpg" alt="img"></p>
<h1 id="十一、新建本地仓库"><a href="#十一、新建本地仓库" class="headerlink" title="十一、新建本地仓库"></a>十一、新建本地仓库</h1><p>   本质就是通过一个名字为registry的镜像，构建仓库</p>
<p>（1）拉取私有仓库镜像 </p>
<p>​    docker pull registry</p>
<p>（2）启动私有仓库容器</p>
<p>​    docker run -di –name=registry -p 5000:5000 registry</p>
<p>（3）打开浏览器 输入地址<a href="http://49.234.188.74:5000/v2/_catalog看到{&quot;repositories&quot;:[]}" target="_blank" rel="external">http://49.234.188.74:5000/v2/_catalog看到{&quot;repositories&quot;:[]}</a> 表示私有仓库搭建成功并且内容为空</p>
<p>或者使用crul 命令查看也可以</p>
<p><img src="/2019/02/28/docker个人总结/clip_image247.jpg" alt="img"></p>
<p>这里有个hello-world镜像，是本人之前上传的。如果没有上传过，那么这个应该返回的是{“repositories”:[]}</p>
<p>（4）修改daemon.json</p>
<p>​    vi /etc/docker/daemon.json</p>
<p>添加以下内容，保存退出。</p>
<p>{“insecure-registries”:[“49.234.188.74:5000”]} </p>
<p>例如</p>
<p><img src="/2019/02/28/docker个人总结/clip_image249.jpg" alt="img"></p>
<p>此步用于让 docker信任私有仓库地址</p>
<p>（5）重启docker 服务</p>
<p>​    systemctl restart docker</p>
<h2 id="上传镜像到本地仓库"><a href="#上传镜像到本地仓库" class="headerlink" title="上传镜像到本地仓库"></a>上传镜像到本地仓库</h2><p>（1）标记此镜像为私有仓库的镜像</p>
<p>​    docker tag hello-world 49.234.188.74:5000/ hello-world （本质就是创建一个关于hello-world的引用，镜像名字更改为hello-world 49.234.188.74:5000/hello-world ）</p>
<p>（2）再次启动私服容器</p>
<p>​    docker start registry</p>
<p>（3）上传标记的镜像</p>
<p>​    docker push 49.234.188.74:5000/ hello-world</p>
<p> (4)查看是否上传成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image247.jpg" alt="img"></p>
<h2 id="其他服务器获取上传的容器"><a href="#其他服务器获取上传的容器" class="headerlink" title="其他服务器获取上传的容器"></a>其他服务器获取上传的容器</h2><p>需求：192.168.1.105 服务器需要从 49.234.188.74 服务器创建的本地仓库获取上床的hello-world镜像</p>
<p>\1.     192.168.1.105设置可信任仓库站点</p>
<p>​    vi /etc/docker/daemon.json</p>
<p>添加以下内容，保存退出。</p>
<p>{“insecure-registries”:[“49.234.188.74:5000”]} </p>
<p><img src="/2019/02/28/docker个人总结/clip_image251.jpg" alt="img"></p>
<p><strong>如果不设置这一步，那么在从49.234.188.74服务器pull镜像的时候会报以下错误</strong></p>
<p>   默认不支持http请求的方式获取镜像</p>
<p><img src="/2019/02/28/docker个人总结/clip_image253.jpg" alt="img"></p>
<p>\2.     拉取镜像成功</p>
<p><img src="/2019/02/28/docker个人总结/clip_image255.jpg" alt="img"></p>
<h1 id="十二、使用DockerMaven插件构建项目"><a href="#十二、使用DockerMaven插件构建项目" class="headerlink" title="十二、使用DockerMaven插件构建项目"></a>十二、使用DockerMaven插件构建项目</h1><p>微服务部署有两种方法：</p>
<p>（1）手动部署：首先基于源码打包生成jar包（或war包）,将jar包（或war包）上传至虚 拟机并拷贝至JDK容器。</p>
<p>（2）通过Maven插件自动部署。</p>
<p>对于数量众多的微服务，手动部署无疑是非常麻烦的做法，并且容易出错。</p>
<h2 id="（1）修改宿主机的docker配置，让其可以远程访问"><a href="#（1）修改宿主机的docker配置，让其可以远程访问" class="headerlink" title="（1）修改宿主机的docker配置，让其可以远程访问"></a>（1）修改宿主机的docker配置，让其可以远程访问</h2><p>Vi  /lib/systemd/system/docker.service</p>
<p>其中ExecStart=后添加配置 ‐H tcp://0.0.0.0:2375 ‐H unix:///var/run/docker.sock</p>
<p><img src="/2019/02/28/docker个人总结/clip_image257.jpg" alt="img"></p>
<h2 id="（2）刷新配置，重启服务"><a href="#（2）刷新配置，重启服务" class="headerlink" title="（2）刷新配置，重启服务"></a>（2）刷新配置，重启服务</h2><p>systemctl daemon‐reload  </p>
<p>systemctl restart docker  </p>
<p>docker start registry   （这里使用的是本地仓库）</p>
<h2 id="（3）-springboot的pom文件添加插件"><a href="#（3）-springboot的pom文件添加插件" class="headerlink" title="（3） springboot的pom文件添加插件"></a>（3） springboot的pom文件添加插件</h2><p><img src="/2019/02/28/docker个人总结/clip_image259.jpg" alt="img"></p>
<p><img src="/2019/02/28/docker个人总结/clip_image261.jpg" alt="img"></p>
<p>最后执行：mvn clean package docker:build</p>
<p>即可把镜像上传到本地仓库中</p>
<p><img src="/2019/02/28/docker个人总结/clip_image263.jpg" alt="img"></p>
<p>上面的方式是构建 项目到本地仓库的方式。如果我们自己申请了阿里云仓库，那么可以使用下面的方式将项目推送到阿里云仓库中。</p>
<p>使用SpringBoot2.0+DockerFile+Maven插件构建镜像并推送到阿里云仓库</p>
<p><a href="https://blog.csdn.net/haogexiang9700/article/details/88318867" target="_blank" rel="external">https://blog.csdn.net/haogexiang9700/article/details/88318867</a></p>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><h2 id="1-启动mysql后使用外部数据库连接工具访问时，报错"><a href="#1-启动mysql后使用外部数据库连接工具访问时，报错" class="headerlink" title="1 启动mysql后使用外部数据库连接工具访问时，报错"></a>1 启动mysql后使用外部数据库连接工具访问时，报错</h2><p>错误提示 2059 - authentication plugin ‘caching_sha2_password’”</p>
<p>通过查看本人启动mysql容器，mysql的版本是：</p>
<p><img src="/2019/02/28/docker个人总结/clip_image265.jpg" alt="img"></p>
<p>经过查询得知：出现这个问题的原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password, 解决问题方法是把mysql用户登录密码加密规则还原成mysql_native_password</p>
<p>也就是数据库访问工具还是使用mysql_native_password这样的价码规则访问数据库。</p>
<p>关键的位置是在：mysql数据库中的user表</p>
<p><img src="/2019/02/28/docker个人总结/clip_image267.jpg" alt="img"></p>
<p>解决方法：</p>
<p> 通过命令行的方式登陆数据库 mysql -uroot -p密码</p>
<p>然后分别执行以下代码</p>
<p>use mysql;</p>
<p>ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘123456’;</p>
<p>ALTER USER ‘root’@’%’ IDENTIFIED WITH mysql_native_password BY ‘123456’;</p>
<p>FLUSH PRIVILEGES;</p>
<p>修改完毕</p>
<p>修改host为localhost和%(任意客户端)的密码认证方式</p>
<p>官方文档对应mysql8的更新说明</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html</a></p>
<p><img src="/2019/02/28/docker个人总结/clip_image269.jpg" alt="img"></p>
<h2 id="2-docker数据卷权限问题"><a href="#2-docker数据卷权限问题" class="headerlink" title="2.docker数据卷权限问题"></a>2.docker数据卷权限问题</h2><p>参见《持续集成和容器管理》-《额外补充》章节，启动jenkins dokcer容器时，添加数据卷权限问题。</p>
<p><a href="https://www.cnblogs.com/jackluo/p/5783116.html" target="_blank" rel="external">https://www.cnblogs.com/jackluo/p/5783116.html</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>如果你感觉文章对你又些许感悟，你可以支持我！！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/wechatpay.png" alt="Jeremy Kinge WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/uploads/alipay.png" alt="Jeremy Kinge Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
	
	<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/docker/" rel="tag"><i class="fa fa-tag"></i> docker</a>
          
            <a href="/tags/容器/" rel="tag"><i class="fa fa-tag"></i> 容器</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/30/springboot个人总结/" rel="next" title="springboot个人总结">
                <i class="fa fa-chevron-left"></i> springboot个人总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/08/持续集成技术个人总结/" rel="prev" title="持续集成技术">
                持续集成技术 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微薄</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDUxMS83MDY1"></div>
    
  </div>


      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMDUxMS83MDY1"></div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Jeremy Kinge" />
          <p class="site-author-name" itemprop="name">Jeremy Kinge</p>
           
              <p class="site-description motion-element" itemprop="description">To know everything, no words don't talk, listening to people is enough to cause alarm（知无不言，言无不尽 言者无罪，闻者足戒）</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">48</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">64</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JeremyKinge" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/LJBANANABLUE?s=09" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://m.weibo.cn/u/3991058874?from=1078095010&wm=20005_0002&sourceType=qq&uid=3991058874" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/profile.php?id=100010100689349" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="StackOverflow">
                  
                    <i class="fa fa-fw fa-stack-overflow"></i>
                  
                    
                      StackOverflow
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://xiezejingzhazha.blog.163.com/" target="_blank" title="网易博客">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                    
                      网易博客
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

		<div id="music163player">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=451768026&auto=0&height=66"></iframe>
</div>
		
        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、docker出现的契机"><span class="nav-number">1.</span> <span class="nav-text">一、docker出现的契机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-理念"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 理念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、docker的演化"><span class="nav-number">2.</span> <span class="nav-text">二、docker的演化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-虚拟机技术"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 虚拟机技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-容器虚拟化技术"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 容器虚拟化技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-总结不同"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 总结不同</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、docker的好处"><span class="nav-number">3.</span> <span class="nav-text">三、docker的好处</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#更快速的应用交付和部署"><span class="nav-number">3.1.</span> <span class="nav-text">更快速的应用交付和部署</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更便捷的升级和扩缩容"><span class="nav-number">3.2.</span> <span class="nav-text">更便捷的升级和扩缩容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更简单的系统运维"><span class="nav-number">3.3.</span> <span class="nav-text">更简单的系统运维</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更高效的计算资源利用"><span class="nav-number">3.4.</span> <span class="nav-text">更高效的计算资源利用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、安装和下载"><span class="nav-number">4.</span> <span class="nav-text">四、安装和下载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-docker安装前提条件"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 docker安装前提条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看自己linux-内核"><span class="nav-number">4.1.1.</span> <span class="nav-text">查看自己linux 内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看已安装的CentOS版本信息（CentOS6-8有，CentOS7无该命令）"><span class="nav-number">4.1.2.</span> <span class="nav-text">查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-docker安装"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 docker安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CentOS6-8安装Docker"><span class="nav-number">4.2.1.</span> <span class="nav-text">CentOS6.8安装Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CentOS7以上安装Docker（本人使用的版本）-推荐"><span class="nav-number">4.2.2.</span> <span class="nav-text">CentOS7以上安装Docker（本人使用的版本）-推荐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3阿里云镜像加速"><span class="nav-number">4.3.</span> <span class="nav-text">4.3阿里云镜像加速</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-设置docker开机启动"><span class="nav-number">4.4.</span> <span class="nav-text">4.4    设置docker开机启动</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、docker组成和分析"><span class="nav-number">5.</span> <span class="nav-text">五、docker组成和分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Docker组成"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 Docker组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像（image）"><span class="nav-number">5.1.1.</span> <span class="nav-text">镜像（image）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UnionFS（联合文件系统）"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">UnionFS（联合文件系统）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker镜像加载原理"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">Docker镜像加载原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分层的镜像"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">分层的镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么-Docker-镜像要采用这种分层结构呢"><span class="nav-number">5.1.1.4.</span> <span class="nav-text">为什么 Docker 镜像要采用这种分层结构呢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">5.1.1.5.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器（container）鲸鱼背上的集装箱"><span class="nav-number">5.1.2.</span> <span class="nav-text">容器（container）鲸鱼背上的集装箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#仓库（repository）"><span class="nav-number">5.1.3.</span> <span class="nav-text">仓库（repository）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">5.1.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Docker运行流程"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 Docker运行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#执行docker-run-hello-world"><span class="nav-number">5.2.1.</span> <span class="nav-text">执行docker run hello-world</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、docker常用操作命令"><span class="nav-number">6.</span> <span class="nav-text">六、docker常用操作命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-帮助命令"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 帮助命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-version"><span class="nav-number">6.1.1.</span> <span class="nav-text">docker version</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-info"><span class="nav-number">6.1.2.</span> <span class="nav-text">docker info</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-–help"><span class="nav-number">6.1.3.</span> <span class="nav-text">docker –help</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-镜像命令"><span class="nav-number">6.2.</span> <span class="nav-text">6.2       镜像命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-docker-images"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 docker images</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-docker-search-某个XXX镜像名字"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 docker search 某个XXX镜像名字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-docker-pull-某个XXX镜像名字"><span class="nav-number">6.2.3.</span> <span class="nav-text">6.2.3 docker pull 某个XXX镜像名字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-docker-rmi-某个XXX镜像名字ID"><span class="nav-number">6.2.4.</span> <span class="nav-text">6.2.4 docker rmi 某个XXX镜像名字ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3容器命令"><span class="nav-number">6.3.</span> <span class="nav-text">6.3容器命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1有镜像才能创建容器，这是根本前提-下载一个CentOS镜像演示"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2新建并启动容器"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2新建并启动容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例演示"><span class="nav-number">6.3.2.1.</span> <span class="nav-text">案例演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3列出当前所有正在运行的容器"><span class="nav-number">6.3.3.</span> <span class="nav-text">6.3.3列出当前所有正在运行的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-4退出容器"><span class="nav-number">6.3.4.</span> <span class="nav-text">6.3.4退出容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#exit"><span class="nav-number">6.3.4.1.</span> <span class="nav-text">exit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ctrl-P-Q"><span class="nav-number">6.3.4.2.</span> <span class="nav-text">ctrl+P+Q</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-5启动容器"><span class="nav-number">6.3.5.</span> <span class="nav-text">6.3.5启动容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-6重启容器"><span class="nav-number">6.3.6.</span> <span class="nav-text">6.3.6重启容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-7停止容器"><span class="nav-number">6.3.7.</span> <span class="nav-text">6.3.7停止容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-8强制停止容器"><span class="nav-number">6.3.8.</span> <span class="nav-text">6.3.8强制停止容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-9删除已停止的容器"><span class="nav-number">6.3.9.</span> <span class="nav-text">6.3.9删除已停止的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-10-迁移与备份"><span class="nav-number">6.3.10.</span> <span class="nav-text">6.3.10 迁移与备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#补充"><span class="nav-number">6.3.11.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启动守护式容器"><span class="nav-number">6.3.11.1.</span> <span class="nav-text">启动守护式容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看容器日志"><span class="nav-number">6.3.11.2.</span> <span class="nav-text">查看容器日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看容器内运行的进程"><span class="nav-number">6.3.11.3.</span> <span class="nav-text">查看容器内运行的进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看容器内部细节"><span class="nav-number">6.3.11.4.</span> <span class="nav-text">查看容器内部细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进入正在运行的容器并以命令行交互"><span class="nav-number">6.3.11.5.</span> <span class="nav-text">进入正在运行的容器并以命令行交互</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从容器内拷贝文件到主机上"><span class="nav-number">6.3.11.6.</span> <span class="nav-text">从容器内拷贝文件到主机上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker镜像commit"><span class="nav-number">6.3.11.7.</span> <span class="nav-text">Docker镜像commit</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#案例演示-1"><span class="nav-number">6.3.11.7.1.</span> <span class="nav-text">案例演示</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令图例"><span class="nav-number">6.4.</span> <span class="nav-text">命令图例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七、Docker容器数据卷"><span class="nav-number">7.</span> <span class="nav-text">七、Docker容器数据卷</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-创建数据卷"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 创建数据卷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-第一种方式：使用命令直接添加"><span class="nav-number">7.1.1.</span> <span class="nav-text">7.1.1 第一种方式：使用命令直接添加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-第二种方式：DockerFile方式添加"><span class="nav-number">7.1.2.</span> <span class="nav-text">7.1.2 第二种方式：DockerFile方式添加</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1初探dockerfile结构"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">1初探dockerfile结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-创建数据卷"><span class="nav-number">7.1.2.2.</span> <span class="nav-text">2.创建数据卷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2数据卷容器"><span class="nav-number">7.2.</span> <span class="nav-text">7.2数据卷容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1先启动一个父容器dc01"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.2.1先启动一个父容器dc01</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-创建dc02、03继承自dc01"><span class="nav-number">7.2.2.</span> <span class="nav-text">7.2.2 创建dc02、03继承自dc01</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3测试数据共通性"><span class="nav-number">7.2.3.</span> <span class="nav-text">7.2.3测试数据共通性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八、DockerFile解析"><span class="nav-number">8.</span> <span class="nav-text">八、DockerFile解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-dockerfile概念"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 dockerfile概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-dockerfile指令（保留字指令）"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 dockerfile指令（保留字指令）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FROM"><span class="nav-number">8.2.1.</span> <span class="nav-text">FROM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MAINTAINER"><span class="nav-number">8.2.2.</span> <span class="nav-text">MAINTAINER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RUN"><span class="nav-number">8.2.3.</span> <span class="nav-text">RUN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPOSE"><span class="nav-number">8.2.4.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WORKDIR"><span class="nav-number">8.2.5.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENV"><span class="nav-number">8.2.6.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ADD"><span class="nav-number">8.2.7.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COPY"><span class="nav-number">8.2.8.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VOLUME"><span class="nav-number">8.2.9.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMD"><span class="nav-number">8.2.10.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">8.2.11.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ONBUILD"><span class="nav-number">8.2.12.</span> <span class="nav-text">ONBUILD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-案例"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#案例一"><span class="nav-number">8.3.1.</span> <span class="nav-text">案例一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#案例2"><span class="nav-number">8.3.2.</span> <span class="nav-text">案例2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-新建一个工作目录"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">2.1 新建一个工作目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-根据原版centos新建Dockerfile文件"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">2.2 根据原版centos新建Dockerfile文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-构建"><span class="nav-number">8.3.2.3.</span> <span class="nav-text">2.3 构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-执行（RUN）"><span class="nav-number">8.3.2.4.</span> <span class="nav-text">2.4 执行（RUN）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-验证"><span class="nav-number">8.3.2.5.</span> <span class="nav-text">2.5 验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-部署项目"><span class="nav-number">8.3.2.6.</span> <span class="nav-text">2.6 部署项目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">8.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九、常用插件安装"><span class="nav-number">9.</span> <span class="nav-text">九、常用插件安装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1总体步骤"><span class="nav-number">9.1.</span> <span class="nav-text">9.1总体步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-tomcat安装"><span class="nav-number">9.2.</span> <span class="nav-text">9.2 tomcat安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1-docker-hub上面查找tomcat镜像"><span class="nav-number">9.2.1.</span> <span class="nav-text">9.2.1 docker hub上面查找tomcat镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-2-从docker-hub上拉取tomcat镜像到本地"><span class="nav-number">9.2.2.</span> <span class="nav-text">9.2.2 从docker hub上拉取tomcat镜像到本地</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-3-docker-images查看是否有拉取到的tomcat"><span class="nav-number">9.2.3.</span> <span class="nav-text">9.2.3 docker images查看是否有拉取到的tomcat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-4-使用tomcat镜像创建容器-也叫运行镜像"><span class="nav-number">9.2.4.</span> <span class="nav-text">9.2.4 使用tomcat镜像创建容器(也叫运行镜像)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3安装mysql"><span class="nav-number">9.3.</span> <span class="nav-text">9.3安装mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-1-docker-hub上面查找mysql镜像"><span class="nav-number">9.3.1.</span> <span class="nav-text">9.3.1 docker hub上面查找mysql镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-2-从docker-hub上-阿里云加速器-拉取mysql镜像到本地标签为5-6"><span class="nav-number">9.3.2.</span> <span class="nav-text">9.3.2 从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-3-使用mysql5-6镜像创建容器-也叫运行镜像"><span class="nav-number">9.3.3.</span> <span class="nav-text">9.3.3 使用mysql5.6镜像创建容器(也叫运行镜像)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-安装redis"><span class="nav-number">9.4.</span> <span class="nav-text">9.4 安装redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-1-从docker-hub上-阿里云加速器-拉取redis镜像到本地标签为3-2"><span class="nav-number">9.4.1.</span> <span class="nav-text">9.4.1 从docker hub上(阿里云加速器)拉取redis镜像到本地标签为3.2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-2-使用redis3-2镜像创建容器-也叫运行镜像"><span class="nav-number">9.4.2.</span> <span class="nav-text">9.4.2 使用redis3.2镜像创建容器(也叫运行镜像)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Accept-connections-on-the-specified-port-default-is-6379-IANA-815344-If-port-0-is-specified-Redis-will-not-listen-on-a-TCP-socket-port-6379-。。。。省略"><span class="nav-number">10.</span> <span class="nav-text">Accept connections on the specified port, default is 6379 (IANA   #815344).   # If port 0 is specified Redis will not listen on a TCP socket.   port 6379   。。。。省略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十、本地镜像发布到阿里云"><span class="nav-number">11.</span> <span class="nav-text">十、本地镜像发布到阿里云</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-镜像生成方式"><span class="nav-number">11.1.</span> <span class="nav-text">1.镜像生成方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-将本地镜像推送到阿里云"><span class="nav-number">11.2.</span> <span class="nav-text">2. 将本地镜像推送到阿里云</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-登录阿里云，创建镜像仓库"><span class="nav-number">11.2.1.</span> <span class="nav-text">2.1 登录阿里云，创建镜像仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-创建命名空间"><span class="nav-number">11.2.2.</span> <span class="nav-text">2.2 创建命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-点击镜像仓库的管理"><span class="nav-number">11.2.3.</span> <span class="nav-text">2.3 点击镜像仓库的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-推送镜像到阿里云"><span class="nav-number">11.2.4.</span> <span class="nav-text">2.4 推送镜像到阿里云</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-查看是否推送成功"><span class="nav-number">11.2.5.</span> <span class="nav-text">2.5 查看是否推送成功</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-从阿里云下载我们推送的镜像"><span class="nav-number">11.2.6.</span> <span class="nav-text">2.6 从阿里云下载我们推送的镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十一、新建本地仓库"><span class="nav-number">12.</span> <span class="nav-text">十一、新建本地仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#上传镜像到本地仓库"><span class="nav-number">12.1.</span> <span class="nav-text">上传镜像到本地仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他服务器获取上传的容器"><span class="nav-number">12.2.</span> <span class="nav-text">其他服务器获取上传的容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十二、使用DockerMaven插件构建项目"><span class="nav-number">13.</span> <span class="nav-text">十二、使用DockerMaven插件构建项目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#（1）修改宿主机的docker配置，让其可以远程访问"><span class="nav-number">13.1.</span> <span class="nav-text">（1）修改宿主机的docker配置，让其可以远程访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（2）刷新配置，重启服务"><span class="nav-number">13.2.</span> <span class="nav-text">（2）刷新配置，重启服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（3）-springboot的pom文件添加插件"><span class="nav-number">13.3.</span> <span class="nav-text">（3） springboot的pom文件添加插件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#问题总结"><span class="nav-number">14.</span> <span class="nav-text">问题总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-启动mysql后使用外部数据库连接工具访问时，报错"><span class="nav-number">14.1.</span> <span class="nav-text">1 启动mysql后使用外部数据库连接工具访问时，报错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-docker数据卷权限问题"><span class="nav-number">14.2.</span> <span class="nav-text">2.docker数据卷权限问题</span></a></li></ol></li></ol></div>
            

          </div>
		  

		  
        </section>
      <!--/noindex-->
      

      

    </div>
	

	
  </aside>
  

  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2022 &mdash; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeremy Kinge</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">
      183.6k
    </span>
  
</div>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv">
  
</div>



  <span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span class="post-meta-divider">|</span>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共183.6k字</span>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  




  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
